import {geometries} from '@jscad/modeling';
import {Ref} from '@vue/reactivity';
import jsep from 'jsep';
import mapboxgl from 'mapbox-gl';
import {
	CopyPass,
	Disposable,
	EffectComposer,
	EffectPass,
	KawaseBlurPass,
	LuminancePass,
	NormalPass,
	Pass,
	RenderPass,
} from 'postprocessing';
import {MeshBVH} from 'three-mesh-bvh';
import {EnvelopeOptions} from 'tone';
import {ToneAudioNode, ToneAudioNodeOptions} from 'tone/build/esm/core/context/ToneAudioNode';
import {Instrument} from 'tone/build/esm/instrument/Instrument';
import {Player} from 'tone/build/esm/source/buffer/Player';
import {OmniOscillatorSynthOptions} from 'tone/build/esm/source/oscillator/OscillatorInterface';
import {Source} from 'tone/build/esm/source/Source';
import {UserMedia} from 'tone/build/esm/source/UserMedia';

declare enum MOUSE {
	LEFT = 0,
	MIDDLE = 1,
	RIGHT = 2,
	ROTATE = 0,
	DOLLY = 1,
	PAN = 2,
}
declare enum TOUCH {
	ROTATE,
	PAN,
	DOLLY_PAN,
	DOLLY_ROTATE,
}
declare enum CullFace {}
declare enum ShadowMapType {}
declare enum Side {}
declare enum Blending {}
declare enum BlendingEquation {}
declare enum BlendingDstFactor {}
declare enum BlendingSrcFactor {}
declare enum DepthModes {}
declare enum Combine {}
declare enum ToneMapping {}
declare enum Mapping {}
declare enum Wrapping {}
declare enum TextureFilter {}
declare enum TextureDataType {}
declare enum PixelFormat {}
// Internal Pixel Formats
export type PixelFormatGPU =
	| 'ALPHA'
	| 'RGB'
	| 'RGBA'
	| 'LUMINANCE'
	| 'LUMINANCE_ALPHA'
	| 'RED_INTEGER'
	| 'R8'
	| 'R8_SNORM'
	| 'R8I'
	| 'R8UI'
	| 'R16I'
	| 'R16UI'
	| 'R16F'
	| 'R32I'
	| 'R32UI'
	| 'R32F'
	| 'RG8'
	| 'RG8_SNORM'
	| 'RG8I'
	| 'RG8UI'
	| 'RG16I'
	| 'RG16UI'
	| 'RG16F'
	| 'RG32I'
	| 'RG32UI'
	| 'RG32F'
	| 'RGB565'
	| 'RGB8'
	| 'RGB8_SNORM'
	| 'RGB8I'
	| 'RGB8UI'
	| 'RGB16I'
	| 'RGB16UI'
	| 'RGB16F'
	| 'RGB32I'
	| 'RGB32UI'
	| 'RGB32F'
	| 'RGB9_E5'
	| 'SRGB8'
	| 'R11F_G11F_B10F'
	| 'RGBA4'
	| 'RGBA8'
	| 'RGBA8_SNORM'
	| 'RGBA8I'
	| 'RGBA8UI'
	| 'RGBA16I'
	| 'RGBA16UI'
	| 'RGBA16F'
	| 'RGBA32I'
	| 'RGBA32UI'
	| 'RGBA32F'
	| 'RGB5_A1'
	| 'RGB10_A2'
	| 'RGB10_A2UI'
	| 'SRGB8_ALPHA8'
	| 'SRGB8'
	| 'DEPTH_COMPONENT16'
	| 'DEPTH_COMPONENT24'
	| 'DEPTH_COMPONENT32F'
	| 'DEPTH24_STENCIL8'
	| 'DEPTH32F_STENCIL8';
declare enum CompressedPixelFormat {}
declare enum AnimationActionLoopStyles {}
declare enum InterpolationModes {}
declare enum AnimationBlendMode {}
declare enum TextureEncoding {}
declare enum DepthPackingStrategies {}
declare enum NormalMapTypes {}
export type ColorSpace = NoColorSpace | SRGBColorSpace | LinearSRGBColorSpace;
export type NoColorSpace = '';
export type SRGBColorSpace = 'srgb';
export type LinearSRGBColorSpace = 'srgb-linear';
declare enum StencilOp {}
declare enum StencilFunc {}
declare enum Usage {}
declare enum GLSLVersion {}
export type BuiltinShaderAttributeName =
	| 'position'
	| 'normal'
	| 'uv'
	| 'color'
	| 'skinIndex'
	| 'skinWeight'
	| 'instanceMatrix'
	| 'morphTarget0'
	| 'morphTarget1'
	| 'morphTarget2'
	| 'morphTarget3'
	| 'morphTarget4'
	| 'morphTarget5'
	| 'morphTarget6'
	| 'morphTarget7'
	| 'morphNormal0'
	| 'morphNormal1'
	| 'morphNormal2'
	| 'morphNormal3';
declare class InterleavedBuffer {
	constructor(array: ArrayLike<number>, stride: number);
	array: ArrayLike<number>;
	stride: number;
	/**
	 * @default THREE.StaticDrawUsage
	 */
	usage: Usage;
	/**
	 * @default { offset: number; count: number }
	 */
	updateRange: {
		offset: number;
		count: number;
	};
	/**
	 * @default 0
	 */
	version: number;
	length: number;
	/**
	 * @default 0
	 */
	count: number;
	needsUpdate: boolean;
	uuid: string;
	setUsage(usage: Usage): InterleavedBuffer;
	clone(data: object): InterleavedBuffer;
	copy(source: InterleavedBuffer): this;
	copyAt(index1: number, attribute: InterleavedBufferAttribute, index2: number): InterleavedBuffer;
	set(value: ArrayLike<number>, index: number): InterleavedBuffer;
	toJSON(data: object): {
		uuid: string;
		buffer: string;
		type: string;
		stride: number;
	};
}
declare class InterleavedBufferAttribute {
	constructor(interleavedBuffer: InterleavedBuffer, itemSize: number, offset: number, normalized?: boolean);
	/**
	 * @default ''
	 */
	name: string;
	data: InterleavedBuffer;
	itemSize: number;
	offset: number;
	/**
	 * @default false
	 */
	normalized: boolean;
	get count(): number;
	get array(): ArrayLike<number>;
	set needsUpdate(value: boolean);
	readonly isInterleavedBufferAttribute: true;
	applyMatrix4(m: Matrix4): this;
	clone(data?: object): BufferAttribute;
	getX(index: number): number;
	setX(index: number, x: number): this;
	getY(index: number): number;
	setY(index: number, y: number): this;
	getZ(index: number): number;
	setZ(index: number, z: number): this;
	getW(index: number): number;
	setW(index: number, z: number): this;
	setXY(index: number, x: number, y: number): this;
	setXYZ(index: number, x: number, y: number, z: number): this;
	setXYZW(index: number, x: number, y: number, z: number, w: number): this;
	toJSON(data?: object): {
		isInterleavedBufferAttribute: true;
		itemSize: number;
		data: string;
		offset: number;
		normalized: boolean;
	};
	applyNormalMatrix(matrix: Matrix): this;
	transformDirection(matrix: Matrix): this;
}
declare class Quaternion {
	/**
	 * @param x x coordinate
	 * @param y y coordinate
	 * @param z z coordinate
	 * @param w w coordinate
	 */
	constructor(x?: number, y?: number, z?: number, w?: number);
	/**
	 * @default 0
	 */
	x: number;
	/**
	 * @default 0
	 */
	y: number;
	/**
	 * @default 0
	 */
	z: number;
	/**
	 * @default 1
	 */
	w: number;
	readonly isQuaternion: true;
	/**
	 * Sets values of this quaternion.
	 */
	set(x: number, y: number, z: number, w: number): Quaternion;
	/**
	 * Clones this quaternion.
	 */
	clone(): this;
	/**
	 * Copies values of q to this quaternion.
	 */
	copy(q: Quaternion): this;
	/**
	 * Sets this quaternion from rotation specified by Euler angles.
	 */
	setFromEuler(euler: Euler, update?: boolean): Quaternion;
	/**
	 * Sets this quaternion from rotation specified by axis and angle.
	 * Adapted from http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm.
	 * Axis have to be normalized, angle is in radians.
	 */
	setFromAxisAngle(axis: Vector3, angle: number): Quaternion;
	/**
	 * Sets this quaternion from rotation component of m. Adapted from http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm.
	 */
	setFromRotationMatrix(m: Matrix4): Quaternion;
	setFromUnitVectors(vFrom: Vector3, vTo: Vector3): Quaternion;
	angleTo(q: Quaternion): number;
	rotateTowards(q: Quaternion, step: number): Quaternion;
	identity(): Quaternion;
	/**
	 * Inverts this quaternion.
	 */
	invert(): Quaternion;
	conjugate(): Quaternion;
	dot(v: Quaternion): number;
	lengthSq(): number;
	/**
	 * Computes length of this quaternion.
	 */
	length(): number;
	/**
	 * Normalizes this quaternion.
	 */
	normalize(): Quaternion;
	/**
	 * Multiplies this quaternion by b.
	 */
	multiply(q: Quaternion): Quaternion;
	premultiply(q: Quaternion): Quaternion;
	/**
	 * Sets this quaternion to a x b
	 * Adapted from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm.
	 */
	multiplyQuaternions(a: Quaternion, b: Quaternion): Quaternion;
	slerp(qb: Quaternion, t: number): Quaternion;
	slerpQuaternions(qa: Quaternion, qb: Quaternion, t: number): Quaternion;
	equals(v: Quaternion): boolean;
	/**
	 * Sets this quaternion's x, y, z and w value from the provided array or array-like.
	 * @param array the source array or array-like.
	 * @param offset (optional) offset into the array. Default is 0.
	 */
	fromArray(array: number[] | ArrayLike<number>, offset?: number): this;
	/**
	 * Returns an array [x, y, z, w], or copies x, y, z and w into the provided array.
	 * @param array (optional) array to store the quaternion to. If this is not provided, a new array will be created.
	 * @param offset (optional) optional offset into the array.
	 * @return The created or provided array.
	 */
	toArray(array?: number[], offset?: number): number[];
	/**
	 * Copies x, y, z and w into the provided array-like.
	 * @param array array-like to store the quaternion to.
	 * @param offset (optional) optional offset into the array.
	 * @return The provided array-like.
	 */
	toArray(array: ArrayLike<number>, offset?: number): ArrayLike<number>;
	/**
	 * Sets x, y, z, w properties of this quaternion from the attribute.
	 * @param attribute the source attribute.
	 * @param index index in the attribute.
	 */
	fromBufferAttribute(attribute: BufferAttribute | InterleavedBufferAttribute, index: number): Quaternion;
	_onChange(callback: () => void): Quaternion;
	_onChangeCallback: () => void;
	static slerpFlat(
		dst: number[],
		dstOffset: number,
		src0: number[],
		srcOffset: number,
		src1: number[],
		stcOffset1: number,
		t: number
	): void;
	static multiplyQuaternionsFlat(
		dst: number[],
		dstOffset: number,
		src0: number[],
		srcOffset: number,
		src1: number[],
		stcOffset1: number
	): number[];
	/**
	 * @deprecated Use qm.slerpQuaternions( qa, qb, t ) instead..
	 */
	static slerp(qa: Quaternion, qb: Quaternion, qm: Quaternion, t: number): number;
	/**
	 * @deprecated Use {@link Vector#applyQuaternion vector.applyQuaternion( quaternion )} instead.
	 */
	multiplyVector3(v: any): any;
	random(): Quaternion;
	[Symbol.iterator](): Generator<number, void>;
}
export type EulerOrder = 'XYZ' | 'YXZ' | 'ZXY' | 'ZYX' | 'YZX' | 'XZY';
declare class Euler {
	constructor(x?: number, y?: number, z?: number, order?: EulerOrder);
	/**
	 * @default 0
	 */
	x: number;
	/**
	 * @default 0
	 */
	y: number;
	/**
	 * @default 0
	 */
	z: number;
	/**
	 * @default THREE.Euler.DEFAULT_ORDER
	 */
	order: EulerOrder;
	readonly isEuler: true;
	_onChangeCallback: () => void;
	set(x: number, y: number, z: number, order?: EulerOrder): Euler;
	clone(): this;
	copy(euler: Euler): this;
	setFromRotationMatrix(m: Matrix4, order?: EulerOrder, update?: boolean): Euler;
	setFromQuaternion(q: Quaternion, order?: EulerOrder, update?: boolean): Euler;
	setFromVector3(v: Vector3, order?: EulerOrder): Euler;
	reorder(newOrder: EulerOrder): Euler;
	equals(euler: Euler): boolean;
	fromArray(xyzo: [number, number, number, EulerOrder?, ...any[]]): Euler;
	toArray(array?: Array<number | string | undefined>, offset?: number): Array<number | string | undefined>;
	_onChange(callback: () => void): this;
	static DEFAULT_ORDER: 'XYZ';
	[Symbol.iterator](): Generator<string | number, void>;
}
declare class Layers {
	constructor();
	/**
	 * @default 1 | 0
	 */
	mask: number;
	set(channel: number): void;
	enable(channel: number): void;
	enableAll(): void;
	toggle(channel: number): void;
	disable(channel: number): void;
	disableAll(): void;
	test(layers: Layers): boolean;
	isEnabled(channel: number): boolean;
}
export interface FogBase {
	name: string;
	color: Color;
	clone(): FogBase;
	toJSON(): any;
}
declare class Fog implements FogBase {
	constructor(color: ColorRepresentation, near?: number, far?: number);
	/**
	 * @default ''
	 */
	name: string;
	/**
	 * Fog color.
	 */
	color: Color;
	/**
	 * The minimum distance to start applying fog. Objects that are less than 'near' units from the active camera won't be affected by fog.
	 * @default 1
	 */
	near: number;
	/**
	 * The maximum distance at which fog stops being calculated and applied. Objects that are more than 'far' units away from the active camera won't be affected by fog.
	 * @default 1000
	 */
	far: number;
	readonly isFog: true;
	clone(): Fog;
	toJSON(): any;
}
export type Vector2Tuple = [number, number];
/**
 * ( interface Vector<T> )
 *
 * Abstract interface of {@link https://github.com/mrdoob/three.js/blob/master/src/math/Vector2.js|Vector2},
 * {@link https://github.com/mrdoob/three.js/blob/master/src/math/Vector3.js|Vector3}
 * and {@link https://github.com/mrdoob/three.js/blob/master/src/math/Vector4.js|Vector4}.
 *
 * Currently the members of Vector is NOT type safe because it accepts different typed vectors.
 *
 * Those definitions will be changed when TypeScript innovates Generics to be type safe.
 *
 * @example
 * const v:THREE.Vector = new THREE.Vector3();
 * v.addVectors(new THREE.Vector2(0, 1), new THREE.Vector2(2, 3)); // invalid but compiled successfully
 */
export interface Vector {
	setComponent(index: number, value: number): this;
	getComponent(index: number): number;
	set(...args: number[]): this;
	setScalar(scalar: number): this;
	/**
	 * copy(v:T):T;
	 */
	copy(v: Vector): this;
	/**
	 * NOTE: The second argument is deprecated.
	 *
	 * add(v:T):T;
	 */
	add(v: Vector): this;
	/**
	 * addVectors(a:T, b:T):T;
	 */
	addVectors(a: Vector, b: Vector): this;
	addScaledVector(vector: Vector, scale: number): this;
	/**
	 * Adds the scalar value s to this vector's values.
	 */
	addScalar(scalar: number): this;
	/**
	 * sub(v:T):T;
	 */
	sub(v: Vector): this;
	/**
	 * subVectors(a:T, b:T):T;
	 */
	subVectors(a: Vector, b: Vector): this;
	/**
	 * multiplyScalar(s:number):T;
	 */
	multiplyScalar(s: number): this;
	/**
	 * divideScalar(s:number):T;
	 */
	divideScalar(s: number): this;
	/**
	 * negate():T;
	 */
	negate(): this;
	/**
	 * dot(v:T):T;
	 */
	dot(v: Vector): number;
	/**
	 * lengthSq():number;
	 */
	lengthSq(): number;
	/**
	 * length():number;
	 */
	length(): number;
	/**
	 * normalize():T;
	 */
	normalize(): this;
	/**
	 * NOTE: Vector4 doesn't have the property.
	 *
	 * distanceTo(v:T):number;
	 */
	distanceTo?(v: Vector): number;
	/**
	 * NOTE: Vector4 doesn't have the property.
	 *
	 * distanceToSquared(v:T):number;
	 */
	distanceToSquared?(v: Vector): number;
	/**
	 * setLength(l:number):T;
	 */
	setLength(l: number): this;
	/**
	 * lerp(v:T, alpha:number):T;
	 */
	lerp(v: Vector, alpha: number): this;
	/**
	 * equals(v:T):boolean;
	 */
	equals(v: Vector): boolean;
	/**
	 * clone():T;
	 */
	clone(): Vector;
}
declare class Vector2 implements Vector {
	constructor(x?: number, y?: number);
	/**
	 * @default 0
	 */
	x: number;
	/**
	 * @default 0
	 */
	y: number;
	width: number;
	height: number;
	readonly isVector2: true;
	/**
	 * Sets value of this vector.
	 */
	set(x: number, y: number): this;
	/**
	 * Sets the x and y values of this vector both equal to scalar.
	 */
	setScalar(scalar: number): this;
	/**
	 * Sets X component of this vector.
	 */
	setX(x: number): this;
	/**
	 * Sets Y component of this vector.
	 */
	setY(y: number): this;
	/**
	 * Sets a component of this vector.
	 */
	setComponent(index: number, value: number): this;
	/**
	 * Gets a component of this vector.
	 */
	getComponent(index: number): number;
	/**
	 * Returns a new Vector2 instance with the same `x` and `y` values.
	 */
	clone(): this;
	/**
	 * Copies value of v to this vector.
	 */
	copy(v: Vector2): this;
	/**
	 * Adds v to this vector.
	 */
	add(v: Vector2, w?: Vector2): this;
	/**
	 * Adds the scalar value s to this vector's x and y values.
	 */
	addScalar(s: number): this;
	/**
	 * Sets this vector to a + b.
	 */
	addVectors(a: Vector2, b: Vector2): this;
	/**
	 * Adds the multiple of v and s to this vector.
	 */
	addScaledVector(v: Vector2, s: number): this;
	/**
	 * Subtracts v from this vector.
	 */
	sub(v: Vector2): this;
	/**
	 * Subtracts s from this vector's x and y components.
	 */
	subScalar(s: number): this;
	/**
	 * Sets this vector to a - b.
	 */
	subVectors(a: Vector2, b: Vector2): this;
	/**
	 * Multiplies this vector by v.
	 */
	multiply(v: Vector2): this;
	/**
	 * Multiplies this vector by scalar s.
	 */
	multiplyScalar(scalar: number): this;
	/**
	 * Divides this vector by v.
	 */
	divide(v: Vector2): this;
	/**
	 * Divides this vector by scalar s.
	 * Set vector to ( 0, 0 ) if s == 0.
	 */
	divideScalar(s: number): this;
	/**
	 * Multiplies this vector (with an implicit 1 as the 3rd component) by m.
	 */
	applyMatrix3(m: Matrix3): this;
	/**
	 * If this vector's x or y value is greater than v's x or y value, replace that value with the corresponding min value.
	 */
	min(v: Vector2): this;
	/**
	 * If this vector's x or y value is less than v's x or y value, replace that value with the corresponding max value.
	 */
	max(v: Vector2): this;
	/**
	 * If this vector's x or y value is greater than the max vector's x or y value, it is replaced by the corresponding value.
	 * If this vector's x or y value is less than the min vector's x or y value, it is replaced by the corresponding value.
	 * @param min the minimum x and y values.
	 * @param max the maximum x and y values in the desired range.
	 */
	clamp(min: Vector2, max: Vector2): this;
	/**
	 * If this vector's x or y values are greater than the max value, they are replaced by the max value.
	 * If this vector's x or y values are less than the min value, they are replaced by the min value.
	 * @param min the minimum value the components will be clamped to.
	 * @param max the maximum value the components will be clamped to.
	 */
	clampScalar(min: number, max: number): this;
	/**
	 * If this vector's length is greater than the max value, it is replaced by the max value.
	 * If this vector's length is less than the min value, it is replaced by the min value.
	 * @param min the minimum value the length will be clamped to.
	 * @param max the maximum value the length will be clamped to.
	 */
	clampLength(min: number, max: number): this;
	/**
	 * The components of the vector are rounded down to the nearest integer value.
	 */
	floor(): this;
	/**
	 * The x and y components of the vector are rounded up to the nearest integer value.
	 */
	ceil(): this;
	/**
	 * The components of the vector are rounded to the nearest integer value.
	 */
	round(): this;
	/**
	 * The components of the vector are rounded towards zero (up if negative, down if positive) to an integer value.
	 */
	roundToZero(): this;
	/**
	 * Inverts this vector.
	 */
	negate(): this;
	/**
	 * Computes dot product of this vector and v.
	 */
	dot(v: Vector2): number;
	/**
	 * Computes cross product of this vector and v.
	 */
	cross(v: Vector2): number;
	/**
	 * Computes squared length of this vector.
	 */
	lengthSq(): number;
	/**
	 * Computes length of this vector.
	 */
	length(): number;
	/**
	 * @deprecated Use {@link Vector2#manhattanLength .manhattanLength()} instead.
	 */
	lengthManhattan(): number;
	/**
	 * Computes the Manhattan length of this vector.
	 *
	 * see {@link http://en.wikipedia.org/wiki/Taxicab_geometry|Wikipedia: Taxicab Geometry}
	 */
	manhattanLength(): number;
	/**
	 * Normalizes this vector.
	 */
	normalize(): this;
	/**
	 * computes the angle in radians with respect to the positive x-axis
	 */
	angle(): number;
	/**
	 * Computes distance of this vector to v.
	 */
	distanceTo(v: Vector2): number;
	/**
	 * Computes squared distance of this vector to v.
	 */
	distanceToSquared(v: Vector2): number;
	/**
	 * @deprecated Use {@link Vector2#manhattanDistanceTo .manhattanDistanceTo()} instead.
	 */
	distanceToManhattan(v: Vector2): number;
	/**
	 * Computes the Manhattan length (distance) from this vector to the given vector v
	 *
	 * see {@link http://en.wikipedia.org/wiki/Taxicab_geometry|Wikipedia: Taxicab Geometry}
	 */
	manhattanDistanceTo(v: Vector2): number;
	/**
	 * Normalizes this vector and multiplies it by l.
	 */
	setLength(length: number): this;
	/**
	 * Linearly interpolates between this vector and v, where alpha is the distance along the line - alpha = 0 will be this vector, and alpha = 1 will be v.
	 * @param v vector to interpolate towards.
	 * @param alpha interpolation factor in the closed interval [0, 1].
	 */
	lerp(v: Vector2, alpha: number): this;
	/**
	 * Sets this vector to be the vector linearly interpolated between v1 and v2 where alpha is the distance along the line connecting the two vectors - alpha = 0 will be v1, and alpha = 1 will be v2.
	 * @param v1 the starting vector.
	 * @param v2 vector to interpolate towards.
	 * @param alpha interpolation factor in the closed interval [0, 1].
	 */
	lerpVectors(v1: Vector2, v2: Vector2, alpha: number): this;
	/**
	 * Checks for strict equality of this vector and v.
	 */
	equals(v: Vector2): boolean;
	/**
	 * Sets this vector's x and y value from the provided array or array-like.
	 * @param array the source array or array-like.
	 * @param offset (optional) offset into the array. Default is 0.
	 */
	fromArray(array: number[] | ArrayLike<number>, offset?: number): this;
	/**
	 * Returns an array [x, y], or copies x and y into the provided array.
	 * @param array (optional) array to store the vector to. If this is not provided, a new array will be created.
	 * @param offset (optional) optional offset into the array.
	 * @return The created or provided array.
	 */
	toArray(array?: number[], offset?: number): number[];
	toArray(array?: Vector2Tuple, offset?: 0): Vector2Tuple;
	/**
	 * Copies x and y into the provided array-like.
	 * @param array array-like to store the vector to.
	 * @param offset (optional) optional offset into the array.
	 * @return The provided array-like.
	 */
	toArray(array: ArrayLike<number>, offset?: number): ArrayLike<number>;
	/**
	 * Sets this vector's x and y values from the attribute.
	 * @param attribute the source attribute.
	 * @param index index in the attribute.
	 */
	fromBufferAttribute(attribute: BufferAttribute, index: number): this;
	/**
	 * Rotates the vector around center by angle radians.
	 * @param center the point around which to rotate.
	 * @param angle the angle to rotate, in radians.
	 */
	rotateAround(center: Vector2, angle: number): this;
	/**
	 * Sets this vector's x and y from Math.random
	 */
	random(): this;
}
declare class Triangle {
	constructor(a?: Vector3, b?: Vector3, c?: Vector3);
	/**
	 * @default new THREE.Vector3()
	 */
	a: Vector3;
	/**
	 * @default new THREE.Vector3()
	 */
	b: Vector3;
	/**
	 * @default new THREE.Vector3()
	 */
	c: Vector3;
	set(a: Vector3, b: Vector3, c: Vector3): Triangle;
	setFromPointsAndIndices(points: Vector3[], i0: number, i1: number, i2: number): this;
	setFromAttributeAndIndices(
		attribute: BufferAttribute | InterleavedBufferAttribute,
		i0: number,
		i1: number,
		i2: number
	): this;
	clone(): this;
	copy(triangle: Triangle): this;
	getArea(): number;
	getMidpoint(target: Vector3): Vector3;
	getNormal(target: Vector3): Vector3;
	getPlane(target: Plane): Plane;
	getBarycoord(point: Vector3, target: Vector3): Vector3;
	getUV(point: Vector3, uv1: Vector2, uv2: Vector2, uv3: Vector2, target: Vector2): Vector2;
	containsPoint(point: Vector3): boolean;
	intersectsBox(box: Box3): boolean;
	isFrontFacing(direction: Vector3): boolean;
	closestPointToPoint(point: Vector3, target: Vector3): Vector3;
	equals(triangle: Triangle): boolean;
	static getNormal(a: Vector3, b: Vector3, c: Vector3, target: Vector3): Vector3;
	static getBarycoord(point: Vector3, a: Vector3, b: Vector3, c: Vector3, target: Vector3): Vector3;
	static containsPoint(point: Vector3, a: Vector3, b: Vector3, c: Vector3): boolean;
	static getUV(
		point: Vector3,
		p1: Vector3,
		p2: Vector3,
		p3: Vector3,
		uv1: Vector2,
		uv2: Vector2,
		uv3: Vector2,
		target: Vector2
	): Vector2;
	static isFrontFacing(a: Vector3, b: Vector3, c: Vector3, direction: Vector3): boolean;
}
declare class Box3 {
	constructor(min?: Vector3, max?: Vector3);
	/**
	 * @default new THREE.Vector3( + Infinity, + Infinity, + Infinity )
	 */
	min: Vector3;
	/**
	 * @default new THREE.Vector3( - Infinity, - Infinity, - Infinity )
	 */
	max: Vector3;
	readonly isBox3: true;
	set(min: Vector3, max: Vector3): this;
	setFromArray(array: ArrayLike<number>): this;
	setFromBufferAttribute(bufferAttribute: BufferAttribute): this;
	setFromPoints(points: Vector3[]): this;
	setFromCenterAndSize(center: Vector3, size: Vector3): this;
	setFromObject(object: Object3D, precise?: boolean): this;
	clone(): this;
	copy(box: Box3): this;
	makeEmpty(): this;
	isEmpty(): boolean;
	getCenter(target: Vector3): Vector3;
	getSize(target: Vector3): Vector3;
	expandByPoint(point: Vector3): this;
	expandByVector(vector: Vector3): this;
	expandByScalar(scalar: number): this;
	expandByObject(object: Object3D, precise?: boolean): this;
	containsPoint(point: Vector3): boolean;
	containsBox(box: Box3): boolean;
	getParameter(point: Vector3, target: Vector3): Vector3;
	intersectsBox(box: Box3): boolean;
	intersectsSphere(sphere: Sphere): boolean;
	intersectsPlane(plane: Plane): boolean;
	intersectsTriangle(triangle: Triangle): boolean;
	clampPoint(point: Vector3, target: Vector3): Vector3;
	distanceToPoint(point: Vector3): number;
	getBoundingSphere(target: Sphere): Sphere;
	intersect(box: Box3): this;
	union(box: Box3): this;
	applyMatrix4(matrix: Matrix4): this;
	translate(offset: Vector3): this;
	equals(box: Box3): boolean;
	/**
	 * @deprecated Use {@link Box3#isEmpty .isEmpty()} instead.
	 */
	empty(): any;
	/**
	 * @deprecated Use {@link Box3#intersectsBox .intersectsBox()} instead.
	 */
	isIntersectionBox(b: any): any;
	/**
	 * @deprecated Use {@link Box3#intersectsSphere .intersectsSphere()} instead.
	 */
	isIntersectionSphere(s: any): any;
}
declare class Sphere {
	constructor(center?: Vector3, radius?: number);
	/**
	 * @default new Vector3()
	 */
	center: Vector3;
	/**
	 * @default 1
	 */
	radius: number;
	set(center: Vector3, radius: number): Sphere;
	setFromPoints(points: Vector3[], optionalCenter?: Vector3): Sphere;
	clone(): this;
	copy(sphere: Sphere): this;
	expandByPoint(point: Vector3): this;
	isEmpty(): boolean;
	makeEmpty(): this;
	containsPoint(point: Vector3): boolean;
	distanceToPoint(point: Vector3): number;
	intersectsSphere(sphere: Sphere): boolean;
	intersectsBox(box: Box3): boolean;
	intersectsPlane(plane: Plane): boolean;
	clampPoint(point: Vector3, target: Vector3): Vector3;
	getBoundingBox(target: Box3): Box3;
	applyMatrix4(matrix: Matrix4): Sphere;
	translate(offset: Vector3): Sphere;
	equals(sphere: Sphere): boolean;
	union(sphere: Sphere): this;
	/**
	 * @deprecated Use {@link Sphere#isEmpty .isEmpty()} instead.
	 */
	empty(): any;
}
declare class Line3 {
	constructor(start?: Vector3, end?: Vector3);
	/**
	 * @default new THREE.Vector3()
	 */
	start: Vector3;
	/**
	 * @default new THREE.Vector3()
	 */
	end: Vector3;
	set(start?: Vector3, end?: Vector3): Line3;
	clone(): this;
	copy(line: Line3): this;
	getCenter(target: Vector3): Vector3;
	delta(target: Vector3): Vector3;
	distanceSq(): number;
	distance(): number;
	at(t: number, target: Vector3): Vector3;
	closestPointToPointParameter(point: Vector3, clampToLine?: boolean): number;
	closestPointToPoint(point: Vector3, clampToLine: boolean, target: Vector3): Vector3;
	applyMatrix4(matrix: Matrix4): Line3;
	equals(line: Line3): boolean;
}
declare class Plane {
	constructor(normal?: Vector3, constant?: number);
	/**
	 * @default new THREE.Vector3( 1, 0, 0 )
	 */
	normal: Vector3;
	/**
	 * @default 0
	 */
	constant: number;
	readonly isPlane: true;
	set(normal: Vector3, constant: number): Plane;
	setComponents(x: number, y: number, z: number, w: number): Plane;
	setFromNormalAndCoplanarPoint(normal: Vector3, point: Vector3): Plane;
	setFromCoplanarPoints(a: Vector3, b: Vector3, c: Vector3): Plane;
	clone(): this;
	copy(plane: Plane): this;
	normalize(): Plane;
	negate(): Plane;
	distanceToPoint(point: Vector3): number;
	distanceToSphere(sphere: Sphere): number;
	projectPoint(point: Vector3, target: Vector3): Vector3;
	intersectLine(line: Line3, target: Vector3): Vector3 | null;
	intersectsLine(line: Line3): boolean;
	intersectsBox(box: Box3): boolean;
	intersectsSphere(sphere: Sphere): boolean;
	coplanarPoint(target: Vector3): Vector3;
	applyMatrix4(matrix: Matrix4, optionalNormalMatrix?: Matrix3): Plane;
	translate(offset: Vector3): Plane;
	equals(plane: Plane): boolean;
	/**
	 * @deprecated Use {@link Plane#intersectsLine .intersectsLine()} instead.
	 */
	isIntersectionLine(l: any): any;
}
export interface BaseEvent {
	type: string;
}
/**
 * Event object.
 */
export interface Event extends BaseEvent {
	target?: any;
	[attachment: string]: any;
}
export type EventListener<E, T, U> = (
	event: E & {
		type: T;
	} & {
		target: U;
	}
) => void;
declare class EventDispatcher<E extends BaseEvent = Event> {
	/**
	 * Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.
	 */
	constructor();
	/**
	 * Adds a listener to an event type.
	 * @param type The type of event to listen to.
	 * @param listener The function that gets called when the event is fired.
	 */
	addEventListener<T extends E['type']>(type: T, listener: EventListener<E, T, this>): void;
	/**
	 * Checks if listener is added to an event type.
	 * @param type The type of event to listen to.
	 * @param listener The function that gets called when the event is fired.
	 */
	hasEventListener<T extends E['type']>(type: T, listener: EventListener<E, T, this>): boolean;
	/**
	 * Removes a listener from an event type.
	 * @param type The type of the listener that gets removed.
	 * @param listener The listener function that gets removed.
	 */
	removeEventListener<T extends E['type']>(type: T, listener: EventListener<E, T, this>): void;
	/**
	 * Fire an event type.
	 * @param type The type of event that gets fired.
	 */
	dispatchEvent(event: E): void;
}
// tslint:disable-next-line:interface-name
export interface IUniform<TValue = any> {
	value: TValue;
}
export interface Shader {
	uniforms: {
		[uniform: string]: IUniform;
	};
	vertexShader: string;
	fragmentShader: string;
}
export interface MaterialParameters {
	alphaTest?: number | undefined;
	alphaToCoverage?: boolean | undefined;
	blendDst?: BlendingDstFactor | undefined;
	blendDstAlpha?: number | undefined;
	blendEquation?: BlendingEquation | undefined;
	blendEquationAlpha?: number | undefined;
	blending?: Blending | undefined;
	blendSrc?: BlendingSrcFactor | BlendingDstFactor | undefined;
	blendSrcAlpha?: number | undefined;
	clipIntersection?: boolean | undefined;
	clippingPlanes?: Plane[] | undefined;
	clipShadows?: boolean | undefined;
	colorWrite?: boolean | undefined;
	defines?: any;
	depthFunc?: DepthModes | undefined;
	depthTest?: boolean | undefined;
	depthWrite?: boolean | undefined;
	name?: string | undefined;
	opacity?: number | undefined;
	polygonOffset?: boolean | undefined;
	polygonOffsetFactor?: number | undefined;
	polygonOffsetUnits?: number | undefined;
	precision?: 'highp' | 'mediump' | 'lowp' | null | undefined;
	premultipliedAlpha?: boolean | undefined;
	forceSinglePass?: boolean | undefined;
	dithering?: boolean | undefined;
	side?: Side | undefined;
	shadowSide?: Side | undefined;
	toneMapped?: boolean | undefined;
	transparent?: boolean | undefined;
	vertexColors?: boolean | undefined;
	visible?: boolean | undefined;
	format?: PixelFormat | undefined;
	stencilWrite?: boolean | undefined;
	stencilFunc?: StencilFunc | undefined;
	stencilRef?: number | undefined;
	stencilWriteMask?: number | undefined;
	stencilFuncMask?: number | undefined;
	stencilFail?: StencilOp | undefined;
	stencilZFail?: StencilOp | undefined;
	stencilZPass?: StencilOp | undefined;
	userData?: any;
}
declare class Material extends EventDispatcher {
	constructor();
	/**
	 * Sets the alpha value to be used when running an alpha test. Default is 0.
	 * @default 0
	 */
	alphaTest: number;
	/**
	 * Enables alpha to coverage. Can only be used with MSAA-enabled rendering contexts.
	 * @default false
	 */
	alphaToCoverage: boolean;
	/**
	 * Blending destination. It's one of the blending mode constants defined in Three.js. Default is {@link OneMinusSrcAlphaFactor}.
	 * @default THREE.OneMinusSrcAlphaFactor
	 */
	blendDst: BlendingDstFactor;
	/**
	 * The tranparency of the .blendDst. Default is null.
	 * @default null
	 */
	blendDstAlpha: number | null;
	/**
	 * Blending equation to use when applying blending. It's one of the constants defined in Three.js. Default is {@link AddEquation}.
	 * @default THREE.AddEquation
	 */
	blendEquation: BlendingEquation;
	/**
	 * The tranparency of the .blendEquation. Default is null.
	 * @default null
	 */
	blendEquationAlpha: number | null;
	/**
	 * Which blending to use when displaying objects with this material. Default is {@link NormalBlending}.
	 * @default THREE.NormalBlending
	 */
	blending: Blending;
	/**
	 * Blending source. It's one of the blending mode constants defined in Three.js. Default is {@link SrcAlphaFactor}.
	 * @default THREE.SrcAlphaFactor
	 */
	blendSrc: BlendingSrcFactor | BlendingDstFactor;
	/**
	 * The tranparency of the .blendSrc. Default is null.
	 * @default null
	 */
	blendSrcAlpha: number | null;
	/**
	 * Changes the behavior of clipping planes so that only their intersection is clipped, rather than their union. Default is false.
	 * @default false
	 */
	clipIntersection: boolean;
	/**
	 * User-defined clipping planes specified as THREE.Plane objects in world space.
	 * These planes apply to the objects this material is attached to.
	 * Points in space whose signed distance to the plane is negative are clipped (not rendered).
	 * See the WebGL / clipping /intersection example. Default is null.
	 * @default null
	 */
	clippingPlanes: any;
	/**
	 * Defines whether to clip shadows according to the clipping planes specified on this material. Default is false.
	 * @default false
	 */
	clipShadows: boolean;
	/**
	 * Whether to render the material's color. This can be used in conjunction with a mesh's .renderOrder property to create invisible objects that occlude other objects. Default is true.
	 * @default true
	 */
	colorWrite: boolean;
	/**
	 * Custom defines to be injected into the shader. These are passed in form of an object literal, with key/value pairs. { MY_CUSTOM_DEFINE: '' , PI2: Math.PI * 2 }.
	 * The pairs are defined in both vertex and fragment shaders. Default is undefined.
	 * @default undefined
	 */
	defines:
		| undefined
		| {
				[key: string]: any;
		  };
	/**
	 * Which depth function to use. Default is {@link LessEqualDepth}. See the depth mode constants for all possible values.
	 * @default THREE.LessEqualDepth
	 */
	depthFunc: DepthModes;
	/**
	 * Whether to have depth test enabled when rendering this material. Default is true.
	 * @default true
	 */
	depthTest: boolean;
	/**
	 * Whether rendering this material has any effect on the depth buffer. Default is true.
	 * When drawing 2D overlays it can be useful to disable the depth writing in order to layer several things together without creating z-index artifacts.
	 * @default true
	 */
	depthWrite: boolean;
	/**
	 * Unique number of this material instance.
	 */
	id: number;
	/**
	 * Whether rendering this material has any effect on the stencil buffer. Default is *false*.
	 * @default false
	 */
	stencilWrite: boolean;
	/**
	 * The stencil comparison function to use. Default is {@link AlwaysStencilFunc}. See stencil operation constants for all possible values.
	 * @default THREE.AlwaysStencilFunc
	 */
	stencilFunc: StencilFunc;
	/**
	 * The value to use when performing stencil comparisons or stencil operations. Default is *0*.
	 * @default 0
	 */
	stencilRef: number;
	/**
	 * The bit mask to use when writing to the stencil buffer. Default is *0xFF*.
	 * @default 0xff
	 */
	stencilWriteMask: number;
	/**
	 * The bit mask to use when comparing against the stencil buffer. Default is *0xFF*.
	 * @default 0xff
	 */
	stencilFuncMask: number;
	/**
	 * Which stencil operation to perform when the comparison function returns false. Default is {@link KeepStencilOp}. See the stencil operation constants for all possible values.
	 * @default THREE.KeepStencilOp
	 */
	stencilFail: StencilOp;
	/**
	 * Which stencil operation to perform when the comparison function returns true but the depth test fails.
	 * Default is {@link KeepStencilOp}.
	 * See the stencil operation constants for all possible values.
	 * @default THREE.KeepStencilOp
	 */
	stencilZFail: StencilOp;
	/**
	 * Which stencil operation to perform when the comparison function returns true and the depth test passes.
	 * Default is {@link KeepStencilOp}.
	 * See the stencil operation constants for all possible values.
	 * @default THREE.KeepStencilOp
	 */
	stencilZPass: StencilOp;
	/**
	 * Used to check whether this or derived classes are materials. Default is true.
	 * You should not change this, as it used internally for optimisation.
	 */
	readonly isMaterial: true;
	/**
	 * Material name. Default is an empty string.
	 * @default ''
	 */
	name: string;
	/**
	 * Specifies that the material needs to be updated, WebGL wise. Set it to true if you made changes that need to be reflected in WebGL.
	 * This property is automatically set to true when instancing a new material.
	 * @default false
	 */
	needsUpdate: boolean;
	/**
	 * Opacity. Default is 1.
	 * @default 1
	 */
	opacity: number;
	/**
	 * Whether to use polygon offset. Default is false. This corresponds to the POLYGON_OFFSET_FILL WebGL feature.
	 * @default false
	 */
	polygonOffset: boolean;
	/**
	 * Sets the polygon offset factor. Default is 0.
	 * @default 0
	 */
	polygonOffsetFactor: number;
	/**
	 * Sets the polygon offset units. Default is 0.
	 * @default 0
	 */
	polygonOffsetUnits: number;
	/**
	 * Override the renderer's default precision for this material. Can be "highp", "mediump" or "lowp". Defaults is null.
	 * @default null
	 */
	precision: 'highp' | 'mediump' | 'lowp' | null;
	/**
	 * Whether to premultiply the alpha (transparency) value. See WebGL / Materials / Transparency for an example of the difference. Default is false.
	 * @default false
	 */
	premultipliedAlpha: boolean;
	/**
	 * @default false
	 */
	forceSinglePass: boolean;
	/**
	 * Whether to apply dithering to the color to remove the appearance of banding. Default is false.
	 * @default false
	 */
	dithering: boolean;
	/**
	 * Defines which of the face sides will be rendered - front, back or both.
	 * Default is {@link THREE.FrontSide}. Other options are {@link THREE.BackSide} and {@link THREE.DoubleSide}.
	 *
	 * @default {@link THREE.FrontSide}
	 */
	side: Side;
	/**
	 * Defines which of the face sides will cast shadows. Default is *null*.
	 * If *null*, the value is opposite that of side, above.
	 * @default null
	 */
	shadowSide: Side | null;
	/**
	 * Defines whether this material is tone mapped according to the renderer's toneMapping setting.
	 * Default is true.
	 * @default true
	 */
	toneMapped: boolean;
	/**
	 * Defines whether this material is transparent. This has an effect on rendering as transparent objects need special treatment and are rendered after non-transparent objects.
	 * When set to true, the extent to which the material is transparent is controlled by setting it's .opacity property.
	 * Default is false.
	 * @default false
	 */
	transparent: boolean;
	/**
	 * Value is the string 'Material'. This shouldn't be changed, and can be used to find all objects of this type in a scene.
	 * @default 'Material'
	 */
	type: string;
	/**
	 * UUID of this material instance. This gets automatically assigned, so this shouldn't be edited.
	 */
	uuid: string;
	/**
	 * Defines whether vertex coloring is used. Default is false.
	 * @default false
	 */
	vertexColors: boolean;
	/**
	 * Defines whether this material is visible. Default is true.
	 * @default true
	 */
	visible: boolean;
	/**
	 * An object that can be used to store custom data about the Material. It should not hold references to functions as these will not be cloned.
	 * @default {}
	 */
	userData: any;
	/**
	 * This starts at 0 and counts how many times .needsUpdate is set to true.
	 * @default 0
	 */
	version: number;
	/**
	 * Return a new material with the same parameters as this material.
	 */
	clone(): this;
	/**
	 * Copy the parameters from the passed material into this material.
	 * @param material
	 */
	copy(material: Material): this;
	/**
	 * This disposes the material. Textures of a material don't get disposed. These needs to be disposed by {@link Texture}.
	 */
	dispose(): void;
	/**
	 * An optional callback that is executed immediately before the shader program is compiled.
	 * This function is called with the shader source code as a parameter.
	 * Useful for the modification of built-in materials.
	 * @param shader Source code of the shader
	 * @param renderer WebGLRenderer Context that is initializing the material
	 */
	onBeforeCompile(shader: Shader, renderer: WebGLRenderer): void;
	/**
	 * In case onBeforeCompile is used, this callback can be used to identify values of settings used in onBeforeCompile, so three.js can reuse a cached shader or recompile the shader as needed.
	 */
	customProgramCacheKey(): string;
	/**
	 * Sets the properties based on the values.
	 * @param values A container with parameters.
	 */
	setValues(values: MaterialParameters): void;
	/**
	 * Convert the material to three.js JSON format.
	 * @param meta Object containing metadata such as textures or images for the material.
	 */
	toJSON(meta?: any): any;
}
declare class Source {
	/**
	 * @param [data] The data definition of a texture. default is **null**.
	 */
	constructor(data: any);
	/**
	 * The actual data of a texture. The type of this property depends on the texture that uses this instance.
	 */
	data: any;
	/**
	 * Set this to **true** to trigger a data upload to the GPU next time the source is used.
	 */
	set needsUpdate(value: boolean);
	/**
	 * [UUID](http://en.wikipedia.org/wiki/Universally_unique_identifier) of this object instance.
	 * This gets automatically assigned, so this shouldn't be edited.
	 */
	uuid: string;
	/**
	 * This starts at **0** and counts how many times [property:Boolean needsUpdate] is set to **true**.
	 */
	version: number;
	/**
	 * Convert the data source to three.js [JSON Object/Scene format](https://github.com/mrdoob/three.js/wiki/JSON-Object-Scene-format-4).
	 *
	 * @param [meta] optional object containing metadata.
	 */
	toJSON(meta: any): any;
	readonly isTexture: true;
}
/** Shim for OffscreenCanvas. */
// tslint:disable-next-line:no-empty-interface
export interface OffscreenCanvas extends EventTarget {}
declare class Texture extends EventDispatcher {
	/**
	 * @param [image]
	 * @param [mapping=THREE.Texture.DEFAULT_MAPPING]
	 * @param [wrapS=THREE.ClampToEdgeWrapping]
	 * @param [wrapT=THREE.ClampToEdgeWrapping]
	 * @param [magFilter=THREE.LinearFilter]
	 * @param [minFilter=THREE.LinearMipmapLinearFilter]
	 * @param [format=THREE.RGBAFormat]
	 * @param [type=THREE.UnsignedByteType]
	 * @param [anisotropy=THREE.Texture.DEFAULT_ANISOTROPY]
	 * @param [encoding=THREE.LinearEncoding]
	 */
	constructor(
		image?: TexImageSource | OffscreenCanvas,
		mapping?: Mapping,
		wrapS?: Wrapping,
		wrapT?: Wrapping,
		magFilter?: TextureFilter,
		minFilter?: TextureFilter,
		format?: PixelFormat,
		type?: TextureDataType,
		anisotropy?: number,
		encoding?: TextureEncoding
	);
	id: number;
	uuid: string;
	/**
	 * @default ''
	 */
	name: string;
	sourceFile: string;
	/**
	 * The data definition of a texture. A reference to the data source can be shared across textures.
	 * This is often useful in context of spritesheets where multiple textures render the same data but with different texture transformations.
	 */
	source: Source;
	/**
	 * An image object, typically created using the {@link TextureLoader.load} method.
	 * This can be any image (e.g., PNG, JPG, GIF, DDS) or video (e.g., MP4, OGG/OGV) type supported by three.js.
	 *
	 * To use video as a texture you need to have a playing HTML5
	 * video element as a source for your texture image and continuously update this texture
	 * as long as video is playing - the {@link VideoTexture} class handles this automatically.
	 */
	get image(): any;
	/**
	 * An image object, typically created using the {@link TextureLoader.load} method.
	 * This can be any image (e.g., PNG, JPG, GIF, DDS) or video (e.g., MP4, OGG/OGV) type supported by three.js.
	 *
	 * To use video as a texture you need to have a playing HTML5
	 * video element as a source for your texture image and continuously update this texture
	 * as long as video is playing - the {@link VideoTexture} class handles this automatically.
	 */
	set image(data: any);
	/**
	 * @default []
	 */
	mipmaps: any[]; // ImageData[] for 2D textures and CubeTexture[] for cube textures;
	/**
	 * @default THREE.Texture.DEFAULT_MAPPING
	 */
	mapping: Mapping;
	/**
	 * @default THREE.ClampToEdgeWrapping
	 */
	wrapS: Wrapping;
	/**
	 * @default THREE.ClampToEdgeWrapping
	 */
	wrapT: Wrapping;
	/**
	 * @default THREE.LinearFilter
	 */
	magFilter: TextureFilter;
	/**
	 * @default THREE.LinearMipmapLinearFilter
	 */
	minFilter: TextureFilter;
	/**
	 * @default 1
	 */
	anisotropy: number;
	/**
	 * @default THREE.RGBAFormat
	 */
	format: PixelFormat;
	internalFormat: PixelFormatGPU | null;
	/**
	 * @default THREE.UnsignedByteType
	 */
	type: TextureDataType;
	/**
	 * @default new THREE.Matrix3()
	 */
	matrix: Matrix3;
	/**
	 * @default true
	 */
	matrixAutoUpdate: boolean;
	/**
	 * @default new THREE.Vector2( 0, 0 )
	 */
	offset: Vector2;
	/**
	 * @default new THREE.Vector2( 1, 1 )
	 */
	repeat: Vector2;
	/**
	 * @default new THREE.Vector2( 0, 0 )
	 */
	center: Vector2;
	/**
	 * @default 0
	 */
	rotation: number;
	/**
	 * @default true
	 */
	generateMipmaps: boolean;
	/**
	 * @default false
	 */
	premultiplyAlpha: boolean;
	/**
	 * @default true
	 */
	flipY: boolean;
	/**
	 * @default 4
	 */
	unpackAlignment: number;
	/**
	 * @default THREE.LinearEncoding
	 */
	encoding: TextureEncoding;
	/**
	 * @default false
	 */
	isRenderTargetTexture: boolean;
	/**
	 * @default false
	 */
	needsPMREMUpdate: boolean;
	/**
	 * An object that can be used to store custom data about the Material. It should not hold references to functions as these will not be cloned.
	 * @default {}
	 */
	userData: any;
	/**
	 * @default 0
	 */
	version: number;
	set needsUpdate(value: boolean);
	readonly isTexture: true;
	onUpdate: () => void;
	static DEFAULT_ANISOTROPY: number;
	static DEFAULT_IMAGE: any;
	static DEFAULT_MAPPING: any;
	clone(): this;
	copy(source: Texture): this;
	toJSON(meta: any): any;
	dispose(): void;
	transformUv(uv: Vector2): Vector2;
	updateMatrix(): void;
}
declare class Scene extends Object3D {
	constructor();
	type: 'Scene';
	/**
	 * A fog instance defining the type of fog that affects everything rendered in the scene. Default is null.
	 * @default null
	 */
	fog: FogBase | null;
	/**
	 * Sets the blurriness of the background. Only influences environment maps assigned to Scene.background. Valid input is a float between 0 and 1.
	 *
	 * @default 0
	 */
	backgroundBlurriness: number;
	/**
	 * Attenuates the color of the background. Only applies to background textures.
	 *
	 * @default 1
	 */
	backgroundIntensity: number;
	/**
	 * If not null, it will force everything in the scene to be rendered with that material. Default is null.
	 * @default null
	 */
	overrideMaterial: Material | null;
	/**
	 * @default null
	 */
	background: null | Color | Texture;
	/**
	 * @default null
	 */
	environment: null | Texture;
	readonly isScene: true;
	toJSON(meta?: any): any;
}
export interface WebGLCapabilitiesParameters {
	precision?: string | undefined;
	logarithmicDepthBuffer?: boolean | undefined;
}
declare class WebGLCapabilities {
	constructor(gl: WebGLRenderingContext, extensions: any, parameters: WebGLCapabilitiesParameters);
	readonly isWebGL2: boolean;
	precision: string;
	logarithmicDepthBuffer: boolean;
	maxTextures: number;
	maxVertexTextures: number;
	maxTextureSize: number;
	maxCubemapSize: number;
	maxAttributes: number;
	maxVertexUniforms: number;
	maxVaryings: number;
	maxFragmentUniforms: number;
	vertexTextures: boolean;
	floatFragmentTextures: boolean;
	floatVertexTextures: boolean;
	maxSamples: number;
	getMaxAnisotropy(): number;
	getMaxPrecision(precision: string): string;
}
declare class WebGLExtensions {
	constructor(gl: WebGLRenderingContext);
	has(name: string): boolean;
	init(capabilities: WebGLCapabilities): void;
	get(name: string): any;
}
export type Vector4Tuple = [number, number, number, number];
declare class Vector4 implements Vector {
	constructor(x?: number, y?: number, z?: number, w?: number);
	/**
	 * @default 0
	 */
	x: number;
	/**
	 * @default 0
	 */
	y: number;
	/**
	 * @default 0
	 */
	z: number;
	/**
	 * @default 0
	 */
	w: number;
	width: number;
	height: number;
	readonly isVector4: true;
	/**
	 * Sets value of this vector.
	 */
	set(x: number, y: number, z: number, w: number): this;
	/**
	 * Sets all values of this vector.
	 */
	setScalar(scalar: number): this;
	/**
	 * Sets X component of this vector.
	 */
	setX(x: number): this;
	/**
	 * Sets Y component of this vector.
	 */
	setY(y: number): this;
	/**
	 * Sets Z component of this vector.
	 */
	setZ(z: number): this;
	/**
	 * Sets w component of this vector.
	 */
	setW(w: number): this;
	setComponent(index: number, value: number): this;
	getComponent(index: number): number;
	/**
	 * Clones this vector.
	 */
	clone(): this;
	/**
	 * Copies value of v to this vector.
	 */
	copy(v: Vector4): this;
	/**
	 * Adds v to this vector.
	 */
	add(v: Vector4): this;
	addScalar(scalar: number): this;
	/**
	 * Sets this vector to a + b.
	 */
	addVectors(a: Vector4, b: Vector4): this;
	addScaledVector(v: Vector4, s: number): this;
	/**
	 * Subtracts v from this vector.
	 */
	sub(v: Vector4): this;
	subScalar(s: number): this;
	/**
	 * Sets this vector to a - b.
	 */
	subVectors(a: Vector4, b: Vector4): this;
	multiply(v: Vector4): this;
	/**
	 * Multiplies this vector by scalar s.
	 */
	multiplyScalar(s: number): this;
	applyMatrix4(m: Matrix4): this;
	/**
	 * Divides this vector by scalar s.
	 * Set vector to ( 0, 0, 0 ) if s == 0.
	 */
	divideScalar(s: number): this;
	/**
	 * http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm
	 * @param q is assumed to be normalized
	 */
	setAxisAngleFromQuaternion(q: Quaternion): this;
	/**
	 * http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm
	 * @param m assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
	 */
	setAxisAngleFromRotationMatrix(m: Matrix4): this;
	min(v: Vector4): this;
	max(v: Vector4): this;
	clamp(min: Vector4, max: Vector4): this;
	clampScalar(min: number, max: number): this;
	floor(): this;
	ceil(): this;
	round(): this;
	roundToZero(): this;
	/**
	 * Inverts this vector.
	 */
	negate(): this;
	/**
	 * Computes dot product of this vector and v.
	 */
	dot(v: Vector4): number;
	/**
	 * Computes squared length of this vector.
	 */
	lengthSq(): number;
	/**
	 * Computes length of this vector.
	 */
	length(): number;
	/**
	 * Computes the Manhattan length of this vector.
	 *
	 * see {@link http://en.wikipedia.org/wiki/Taxicab_geometry|Wikipedia: Taxicab Geometry}
	 */
	manhattanLength(): number;
	/**
	 * Normalizes this vector.
	 */
	normalize(): this;
	/**
	 * Normalizes this vector and multiplies it by l.
	 */
	setLength(length: number): this;
	/**
	 * Linearly interpolate between this vector and v with alpha factor.
	 */
	lerp(v: Vector4, alpha: number): this;
	lerpVectors(v1: Vector4, v2: Vector4, alpha: number): this;
	/**
	 * Checks for strict equality of this vector and v.
	 */
	equals(v: Vector4): boolean;
	/**
	 * Sets this vector's x, y, z and w value from the provided array or array-like.
	 * @param array the source array or array-like.
	 * @param offset (optional) offset into the array. Default is 0.
	 */
	fromArray(array: number[] | ArrayLike<number>, offset?: number): this;
	/**
	 * Returns an array [x, y, z, w], or copies x, y, z and w into the provided array.
	 * @param array (optional) array to store the vector to. If this is not provided, a new array will be created.
	 * @param offset (optional) optional offset into the array.
	 * @return The created or provided array.
	 */
	toArray(array?: number[], offset?: number): number[];
	toArray(array?: Vector4Tuple, offset?: 0): Vector4Tuple;
	/**
	 * Copies x, y, z and w into the provided array-like.
	 * @param array array-like to store the vector to.
	 * @param offset (optional) optional offset into the array-like.
	 * @return The provided array-like.
	 */
	toArray(array: ArrayLike<number>, offset?: number): ArrayLike<number>;
	fromBufferAttribute(attribute: BufferAttribute, index: number): this;
	/**
	 * Sets this vector's x, y, z and w from Math.random
	 */
	random(): this;
}
declare class WebGLColorBuffer {
	constructor();
	setMask(colorMask: boolean): void;
	setLocked(lock: boolean): void;
	setClear(r: number, g: number, b: number, a: number, premultipliedAlpha: boolean): void;
	reset(): void;
}
declare class WebGLDepthBuffer {
	constructor();
	setTest(depthTest: boolean): void;
	setMask(depthMask: boolean): void;
	setFunc(depthFunc: DepthModes): void;
	setLocked(lock: boolean): void;
	setClear(depth: number): void;
	reset(): void;
}
declare class WebGLStencilBuffer {
	constructor();
	setTest(stencilTest: boolean): void;
	setMask(stencilMask: number): void;
	setFunc(stencilFunc: number, stencilRef: number, stencilMask: number): void;
	setOp(stencilFail: number, stencilZFail: number, stencilZPass: number): void;
	setLocked(lock: boolean): void;
	setClear(stencil: number): void;
	reset(): void;
}
declare class WebGLState {
	constructor(gl: WebGLRenderingContext, extensions: WebGLExtensions, capabilities: WebGLCapabilities);
	buffers: {
		color: WebGLColorBuffer;
		depth: WebGLDepthBuffer;
		stencil: WebGLStencilBuffer;
	};
	initAttributes(): void;
	enableAttribute(attribute: number): void;
	enableAttributeAndDivisor(attribute: number, meshPerAttribute: number): void;
	disableUnusedAttributes(): void;
	vertexAttribPointer(
		index: number,
		size: number,
		type: number,
		normalized: boolean,
		stride: number,
		offset: number
	): void;
	enable(id: number): void;
	disable(id: number): void;
	bindFramebuffer(target: number, framebuffer: WebGLFramebuffer | null): void;
	bindXRFramebuffer(framebuffer: WebGLFramebuffer | null): void;
	useProgram(program: any): boolean;
	setBlending(
		blending: Blending,
		blendEquation?: BlendingEquation,
		blendSrc?: BlendingSrcFactor,
		blendDst?: BlendingDstFactor,
		blendEquationAlpha?: BlendingEquation,
		blendSrcAlpha?: BlendingSrcFactor,
		blendDstAlpha?: BlendingDstFactor,
		premultiplyAlpha?: boolean
	): void;
	setMaterial(material: Material, frontFaceCW: boolean): void;
	setFlipSided(flipSided: boolean): void;
	setCullFace(cullFace: CullFace): void;
	setLineWidth(width: number): void;
	setPolygonOffset(polygonoffset: boolean, factor?: number, units?: number): void;
	setScissorTest(scissorTest: boolean): void;
	activeTexture(webglSlot: number): void;
	bindTexture(webglType: number, webglTexture: any): void;
	unbindTexture(): void;
	// Same interface as https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/compressedTexImage2D
	compressedTexImage2D(
		target: number,
		level: number,
		internalformat: number,
		width: number,
		height: number,
		border: number,
		data: ArrayBufferView
	): void;
	// Same interface as https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/texImage2D
	texImage2D(
		target: number,
		level: number,
		internalformat: number,
		width: number,
		height: number,
		border: number,
		format: number,
		type: number,
		pixels: ArrayBufferView | null
	): void;
	texImage2D(target: number, level: number, internalformat: number, format: number, type: number, source: any): void;
	texImage3D(
		target: number,
		level: number,
		internalformat: number,
		width: number,
		height: number,
		depth: number,
		border: number,
		format: number,
		type: number,
		pixels: any
	): void;
	scissor(scissor: Vector4): void;
	viewport(viewport: Vector4): void;
	reset(): void;
}
declare class WebGLProperties {
	constructor();
	get(object: any): any;
	remove(object: any): void;
	update(object: any, key: any, value: any): any;
	dispose(): void;
}
declare class WebGLUtils {
	constructor(gl: WebGLRenderingContext | WebGL2RenderingContext, extensions: any, capabilities: any);
	convert(p: PixelFormat | CompressedPixelFormat | TextureDataType, encoding?: TextureEncoding | null): number | null;
}
declare class WebGLTextures {
	constructor(
		gl: WebGLRenderingContext,
		extensions: WebGLExtensions,
		state: WebGLState,
		properties: WebGLProperties,
		capabilities: WebGLCapabilities,
		utils: WebGLUtils,
		info: WebGLInfo
	);
	allocateTextureUnit(): void;
	resetTextureUnits(): void;
	setTexture2D(texture: any, slot: number): void;
	setTexture2DArray(texture: any, slot: number): void;
	setTexture3D(texture: any, slot: number): void;
	setTextureCube(texture: any, slot: number): void;
	setupRenderTarget(renderTarget: any): void;
	updateRenderTargetMipmap(renderTarget: any): void;
	updateMultisampleRenderTarget(renderTarget: any): void;
	safeSetTexture2D(texture: any, slot: number): void;
	safeSetTextureCube(texture: any, slot: number): void;
}
declare class WebGLUniforms {
	constructor(gl: WebGLRenderingContext, program: WebGLProgram);
	setValue(gl: WebGLRenderingContext, name: string, value: any, textures: WebGLTextures): void;
	setOptional(gl: WebGLRenderingContext, object: any, name: string): void;
	static upload(gl: WebGLRenderingContext, seq: any, values: any[], textures: WebGLTextures): void;
	static seqWithValue(seq: any, values: any[]): any[];
}
declare class WebGLProgram {
	constructor(renderer: WebGLRenderer, cacheKey: string, parameters: object);
	name: string;
	id: number;
	cacheKey: string; // unique identifier for this program, used for looking up compiled programs from cache.
	/**
	 * @default 1
	 */
	usedTimes: number;
	program: any;
	vertexShader: WebGLShader;
	fragmentShader: WebGLShader;
	/**
	 * @deprecated Use {@link WebGLProgram#getUniforms getUniforms()} instead.
	 */
	uniforms: any;
	/**
	 * @deprecated Use {@link WebGLProgram#getAttributes getAttributes()} instead.
	 */
	attributes: any;
	getUniforms(): WebGLUniforms;
	getAttributes(): any;
	destroy(): void;
}
declare class WebGLInfo {
	constructor(gl: WebGLRenderingContext);
	/**
	 * @default true
	 */
	autoReset: boolean;
	/**
	 * @default { geometries: 0, textures: 0 }
	 */
	memory: {
		geometries: number;
		textures: number;
	};
	/**
	 * @default null
	 */
	programs: WebGLProgram[] | null;
	/**
	 * @default { frame: 0, calls: 0, triangles: 0, points: 0, lines: 0 }
	 */
	render: {
		calls: number;
		frame: number;
		lines: number;
		points: number;
		triangles: number;
	};
	update(count: number, mode: number, instanceCount: number): void;
	reset(): void;
}
declare class WebGLObjects {
	constructor(gl: WebGLRenderingContext, geometries: any, attributes: any, info: any);
	update(object: any): any;
	dispose(): void;
}
declare class DepthTexture extends Texture {
	/**
	 * @param width
	 * @param height
	 * @param type
	 * @param [mapping=THREE.Texture.DEFAULT_MAPPING]
	 * @param [wrapS=THREE.ClampToEdgeWrapping]
	 * @param [wrapT=THREE.ClampToEdgeWrapping]
	 * @param [magFilter=THREE.NearestFilter]
	 * @param [minFilter=THREE.NearestFilter]
	 * @param [anisotropy=1]
	 */
	constructor(
		width: number,
		height: number,
		type?: TextureDataType,
		mapping?: Mapping,
		wrapS?: Wrapping,
		wrapT?: Wrapping,
		magFilter?: TextureFilter,
		minFilter?: TextureFilter,
		anisotropy?: number
	);
	get image(): {
		width: number;
		height: number;
	};
	set image(value: {width: number; height: number});
	/**
	 * @default false
	 */
	flipY: boolean;
	/**
	 * @default false
	 */
	generateMipmaps: boolean;
	readonly isDepthTexture: true;
}
export interface WebGLRenderTargetOptions {
	wrapS?: Wrapping | undefined;
	wrapT?: Wrapping | undefined;
	magFilter?: TextureFilter | undefined;
	minFilter?: TextureFilter | undefined;
	format?: number | undefined; // RGBAFormat;
	type?: TextureDataType | undefined; // UnsignedByteType;
	anisotropy?: number | undefined; // 1;
	depthBuffer?: boolean | undefined; // true;
	stencilBuffer?: boolean | undefined; // false;
	generateMipmaps?: boolean | undefined; // true;
	depthTexture?: DepthTexture | undefined;
	encoding?: TextureEncoding | undefined;
	/**
	 * Defines the count of MSAA samples. Can only be used with WebGL 2. Default is **0**.
	 * @default 0
	 */
	samples?: number;
}
declare class WebGLRenderTarget extends EventDispatcher {
	constructor(width?: number, height?: number, options?: WebGLRenderTargetOptions);
	width: number;
	height: number;
	depth: number;
	scissor: Vector4;
	/**
	 * @default false
	 */
	scissorTest: boolean;
	viewport: Vector4;
	texture: Texture;
	/**
	 * @default true
	 */
	depthBuffer: boolean;
	/**
	 * @default true
	 */
	stencilBuffer: boolean;
	/**
	 * @default null
	 */
	depthTexture: DepthTexture;
	/**
	 * Defines the count of MSAA samples. Can only be used with WebGL 2. Default is **0**.
	 * @default 0
	 */
	samples: number;
	readonly isWebGLRenderTarget: true;
	/**
	 * @deprecated Use {@link Texture#wrapS texture.wrapS} instead.
	 */
	wrapS: any;
	/**
	 * @deprecated Use {@link Texture#wrapT texture.wrapT} instead.
	 */
	wrapT: any;
	/**
	 * @deprecated Use {@link Texture#magFilter texture.magFilter} instead.
	 */
	magFilter: any;
	/**
	 * @deprecated Use {@link Texture#minFilter texture.minFilter} instead.
	 */
	minFilter: any;
	/**
	 * @deprecated Use {@link Texture#anisotropy texture.anisotropy} instead.
	 */
	anisotropy: any;
	/**
	 * @deprecated Use {@link Texture#offset texture.offset} instead.
	 */
	offset: any;
	/**
	 * @deprecated Use {@link Texture#repeat texture.repeat} instead.
	 */
	repeat: any;
	/**
	 * @deprecated Use {@link Texture#format texture.format} instead.
	 */
	format: any;
	/**
	 * @deprecated Use {@link Texture#type texture.type} instead.
	 */
	type: any;
	/**
	 * @deprecated Use {@link Texture#generateMipmaps texture.generateMipmaps} instead.
	 */
	generateMipmaps: any;
	setSize(width: number, height: number, depth?: number): void;
	clone(): this;
	copy(source: WebGLRenderTarget): this;
	dispose(): void;
}
declare class LightShadow {
	constructor(camera: Camera);
	camera: Camera;
	/**
	 * @default 0
	 */
	bias: number;
	/**
	 * @default 0
	 */
	normalBias: number;
	/**
	 * @default 1
	 */
	radius: number;
	/**
	 * @default 8
	 */
	blurSamples: number;
	/**
	 * @default new THREE.Vector2( 512, 512 )
	 */
	mapSize: Vector2;
	/**
	 * @default null
	 */
	map: WebGLRenderTarget;
	/**
	 * @default null
	 */
	mapPass: WebGLRenderTarget;
	/**
	 * @default new THREE.Matrix4()
	 */
	matrix: Matrix4;
	/**
	 * @default true
	 */
	autoUpdate: boolean;
	/**
	 * @default false
	 */
	needsUpdate: boolean;
	copy(source: LightShadow): this;
	clone(recursive?: boolean): this;
	toJSON(): any;
	getFrustum(): number;
	updateMatrices(light: Light, viewportIndex?: number): void;
	getViewport(viewportIndex: number): Vector4;
	getFrameExtents(): Vector2;
	dispose(): void;
}
declare class Light extends Object3D {
	constructor(hex?: number | string, intensity?: number);
	/**
	 * @default 'Light'
	 */
	type: string;
	color: Color;
	/**
	 * @default 1
	 */
	intensity: number;
	readonly isLight: true;
	shadow: LightShadow;
	/**
	 * @deprecated Use shadow.camera.fov instead.
	 */
	shadowCameraFov: any;
	/**
	 * @deprecated Use shadow.camera.left instead.
	 */
	shadowCameraLeft: any;
	/**
	 * @deprecated Use shadow.camera.right instead.
	 */
	shadowCameraRight: any;
	/**
	 * @deprecated Use shadow.camera.top instead.
	 */
	shadowCameraTop: any;
	/**
	 * @deprecated Use shadow.camera.bottom instead.
	 */
	shadowCameraBottom: any;
	/**
	 * @deprecated Use shadow.camera.near instead.
	 */
	shadowCameraNear: any;
	/**
	 * @deprecated Use shadow.camera.far instead.
	 */
	shadowCameraFar: any;
	/**
	 * @deprecated Use shadow.bias instead.
	 */
	shadowBias: any;
	/**
	 * @deprecated Use shadow.mapSize.width instead.
	 */
	shadowMapWidth: any;
	/**
	 * @deprecated Use shadow.mapSize.height instead.
	 */
	shadowMapHeight: any;
	dispose(): void;
}
declare class WebGLShadowMap {
	constructor(_renderer: WebGLRenderer, _objects: WebGLObjects, _capabilities: WebGLCapabilities);
	/**
	 * @default false
	 */
	enabled: boolean;
	/**
	 * @default true
	 */
	autoUpdate: boolean;
	/**
	 * @default false
	 */
	needsUpdate: boolean;
	/**
	 * @default THREE.PCFShadowMap
	 */
	type: ShadowMapType;
	render(shadowsArray: Light[], scene: Scene, camera: Camera): void;
	/**
	 * @deprecated Use {@link Material#shadowSide} instead.
	 */
	cullFace: any;
}
declare class Group extends Object3D {
	constructor();
	type: 'Group';
	readonly isGroup: true;
}
declare class GLBufferAttribute {
	constructor(buffer: WebGLBuffer, type: number, itemSize: number, elementSize: 1 | 2 | 4, count: number);
	/**
	 * @default ''
	 */
	name: string;
	buffer: WebGLBuffer;
	type: number;
	itemSize: number;
	elementSize: 1 | 2 | 4;
	count: number;
	version: number;
	readonly isGLBufferAttribute: true;
	set needsUpdate(value: boolean);
	setBuffer(buffer: WebGLBuffer): this;
	setType(type: number, elementSize: 1 | 2 | 4): this;
	setItemSize(itemSize: number): this;
	setCount(count: number): this;
}
declare class BufferGeometry extends EventDispatcher {
	/**
	 * This creates a new BufferGeometry. It also sets several properties to an default value.
	 */
	constructor();
	/**
	 * Unique number of this buffergeometry instance
	 */
	id: number;
	uuid: string;
	/**
	 * @default ''
	 */
	name: string;
	/**
	 * @default 'BufferGeometry'
	 */
	type: string;
	/**
	 * @default null
	 */
	index: BufferAttribute | null;
	/**
	 * @default {}
	 */
	attributes: {
		[name: string]: BufferAttribute | InterleavedBufferAttribute | GLBufferAttribute;
	};
	/**
	 * @default {}
	 */
	morphAttributes: {
		[name: string]: Array<BufferAttribute | InterleavedBufferAttribute>;
	};
	/**
	 * @default false
	 */
	morphTargetsRelative: boolean;
	/**
	 * @default []
	 */
	groups: Array<{
		start: number;
		count: number;
		materialIndex?: number | undefined;
	}>;
	/**
	 * @default null
	 */
	boundingBox: Box3 | null;
	/**
	 * @default null
	 */
	boundingSphere: Sphere | null;
	/**
	 * @default { start: 0, count: Infinity }
	 */
	drawRange: {
		start: number;
		count: number;
	};
	/**
	 * @default {}
	 */
	userData: {
		[key: string]: any;
	};
	readonly isBufferGeometry: true;
	getIndex(): BufferAttribute | null;
	setIndex(index: BufferAttribute | number[] | null): BufferGeometry;
	setAttribute(
		name: BuiltinShaderAttributeName | (string & {}),
		attribute: BufferAttribute | InterleavedBufferAttribute | GLBufferAttribute
	): BufferGeometry;
	getAttribute(
		name: BuiltinShaderAttributeName | (string & {})
	): BufferAttribute | InterleavedBufferAttribute | GLBufferAttribute;
	deleteAttribute(name: BuiltinShaderAttributeName | (string & {})): BufferGeometry;
	hasAttribute(name: BuiltinShaderAttributeName | (string & {})): boolean;
	addGroup(start: number, count: number, materialIndex?: number): void;
	clearGroups(): void;
	setDrawRange(start: number, count: number): void;
	/**
	 * Bakes matrix transform directly into vertex coordinates.
	 */
	applyMatrix4(matrix: Matrix4): BufferGeometry;
	applyQuaternion(q: Quaternion): BufferGeometry;
	rotateX(angle: number): BufferGeometry;
	rotateY(angle: number): BufferGeometry;
	rotateZ(angle: number): BufferGeometry;
	translate(x: number, y: number, z: number): BufferGeometry;
	scale(x: number, y: number, z: number): BufferGeometry;
	lookAt(v: Vector3): void;
	center(): BufferGeometry;
	setFromPoints(points: Vector3[] | Vector2[]): BufferGeometry;
	/**
	 * Computes bounding box of the geometry, updating Geometry.boundingBox attribute.
	 * Bounding boxes aren't computed by default. They need to be explicitly computed, otherwise they are null.
	 */
	computeBoundingBox(): void;
	/**
	 * Computes bounding sphere of the geometry, updating Geometry.boundingSphere attribute.
	 * Bounding spheres aren't' computed by default. They need to be explicitly computed, otherwise they are null.
	 */
	computeBoundingSphere(): void;
	/**
	 * Computes and adds tangent attribute to this geometry.
	 */
	computeTangents(): void;
	/**
	 * Computes vertex normals by averaging face normals.
	 */
	computeVertexNormals(): void;
	normalizeNormals(): void;
	toNonIndexed(): BufferGeometry;
	toJSON(): any;
	clone(): BufferGeometry;
	copy(source: BufferGeometry): this;
	/**
	 * Disposes the object from memory.
	 * You need to call this when you want the bufferGeometry removed while the application is running.
	 */
	dispose(): void;
	/**
	 * @deprecated Use {@link BufferGeometry#groups .groups} instead.
	 */
	drawcalls: any;
	/**
	 * @deprecated Use {@link BufferGeometry#groups .groups} instead.
	 */
	offsets: any;
	/**
	 * @deprecated Use {@link BufferGeometry#setIndex .setIndex()} instead.
	 */
	addIndex(index: any): void;
	/**
	 * @deprecated Use {@link BufferGeometry#addGroup .addGroup()} instead.
	 */
	addDrawCall(start: any, count: any, indexOffset?: any): void;
	/**
	 * @deprecated Use {@link BufferGeometry#clearGroups .clearGroups()} instead.
	 */
	clearDrawCalls(): void;
	/**
	 * @deprecated Use {@link BufferGeometry#setAttribute .setAttribute()} instead.
	 */
	addAttribute(name: string, attribute: BufferAttribute | InterleavedBufferAttribute): BufferGeometry;
	addAttribute(name: any, array: any, itemSize: any): any;
	/**
	 * @deprecated Use {@link BufferGeometry#deleteAttribute .deleteAttribute()} instead.
	 */
	removeAttribute(name: string): BufferGeometry;
}
export interface RenderItem {
	id: number;
	object: Object3D;
	geometry: BufferGeometry | null;
	material: Material;
	program: WebGLProgram;
	groupOrder: number;
	renderOrder: number;
	z: number;
	group: Group | null;
}
declare class WebGLRenderList {
	constructor(properties: WebGLProperties);
	/**
	 * @default []
	 */
	opaque: RenderItem[];
	/**
	 * @default []
	 */
	transparent: RenderItem[];
	/**
	 * @default []
	 */
	transmissive: RenderItem[];
	init(): void;
	push(
		object: Object3D,
		geometry: BufferGeometry | null,
		material: Material,
		groupOrder: number,
		z: number,
		group: Group | null
	): void;
	unshift(
		object: Object3D,
		geometry: BufferGeometry | null,
		material: Material,
		groupOrder: number,
		z: number,
		group: Group | null
	): void;
	sort(opaqueSort: (a: any, b: any) => number, transparentSort: (a: any, b: any) => number): void;
	finish(): void;
}
declare class WebGLRenderLists {
	constructor(properties: WebGLProperties);
	dispose(): void;
	get(scene: Scene, renderCallDepth: number): WebGLRenderList;
}
declare class WebGLMultipleRenderTargets extends EventDispatcher {
	texture: Texture[];
	readonly isWebGLMultipleRenderTargets = true;
	/**
	 * @param width The width of the render target.
	 * @param height The height of the render target.
	 * @param count The number of render targets.
	 * @param options object that holds texture parameters for an auto-generated target texture and depthBuffer/stencilBuffer booleans.
	 * For an explanation of the texture parameters see {@link Texture}.
	 */
	constructor(width?: number, height?: number, count?: number, options?: WebGLRenderTargetOptions);
	setSize(width: number, height: number, depth?: number): this;
	copy(source: WebGLMultipleRenderTargets): this;
	clone(): this;
	dispose(): void;
	// This is an available method, however it will break the code see https://github.com/mrdoob/three.js/issues/21930
	setTexture(texture: Texture): void;
}
declare class PerspectiveCamera extends Camera {
	/**
	 * @param [fov=50] Camera frustum vertical field of view. Default value is 50.
	 * @param [aspect=1] Camera frustum aspect ratio. Default value is 1.
	 * @param [near=0.1] Camera frustum near plane. Default value is 0.1.
	 * @param [far=2000] Camera frustum far plane. Default value is 2000.
	 */
	constructor(fov?: number, aspect?: number, near?: number, far?: number);
	type: 'PerspectiveCamera';
	readonly isPerspectiveCamera: true;
	/**
	 * @default 1
	 */
	zoom: number;
	/**
	 * Camera frustum vertical field of view, from bottom to top of view, in degrees.
	 * @default 50
	 */
	fov: number;
	/**
	 * Camera frustum aspect ratio, window width divided by window height.
	 * @default 1
	 */
	aspect: number;
	/**
	 * Camera frustum near plane.
	 * @default 0.1
	 */
	near: number;
	/**
	 * Camera frustum far plane.
	 * @default 2000
	 */
	far: number;
	/**
	 * @default 10
	 */
	focus: number;
	/**
	 * @default null
	 */
	view: null | {
		enabled: boolean;
		fullWidth: number;
		fullHeight: number;
		offsetX: number;
		offsetY: number;
		width: number;
		height: number;
	};
	/**
	 * @default 35
	 */
	filmGauge: number;
	/**
	 * @default 0
	 */
	filmOffset: number;
	setFocalLength(focalLength: number): void;
	getFocalLength(): number;
	getEffectiveFOV(): number;
	getFilmWidth(): number;
	getFilmHeight(): number;
	/**
	 * Sets an offset in a larger frustum. This is useful for multi-window or multi-monitor/multi-machine setups.
	 * For example, if you have 3x2 monitors and each monitor is 1920x1080 and the monitors are in grid like this:
	 *
	 * +---+---+---+
	 * | A | B | C |
	 * +---+---+---+
	 * | D | E | F |
	 * +---+---+---+
	 *
	 * then for each monitor you would call it like this:
	 *
	 * const w = 1920;
	 * const h = 1080;
	 * const fullWidth = w * 3;
	 * const fullHeight = h * 2;
	 *
	 * // A
	 * camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
	 * // B
	 * camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
	 * // C
	 * camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
	 * // D
	 * camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
	 * // E
	 * camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
	 * // F
	 * camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 1, w, h ); Note there is no reason monitors have to be the same size or in a grid.
	 *
	 * @param fullWidth full width of multiview setup
	 * @param fullHeight full height of multiview setup
	 * @param x horizontal offset of subcamera
	 * @param y vertical offset of subcamera
	 * @param width width of subcamera
	 * @param height height of subcamera
	 */
	setViewOffset(fullWidth: number, fullHeight: number, x: number, y: number, width: number, height: number): void;
	clearViewOffset(): void;
	/**
	 * Updates the camera projection matrix. Must be called after change of parameters.
	 */
	updateProjectionMatrix(): void;
	toJSON(meta?: any): any;
	/**
	 * @deprecated Use {@link PerspectiveCamera#setFocalLength .setFocalLength()} and {@link PerspectiveCamera#filmGauge .filmGauge} instead.
	 */
	setLens(focalLength: number, frameHeight?: number): void;
}
declare class ArrayCamera extends PerspectiveCamera {
	constructor(cameras?: PerspectiveCamera[]);
	/**
	 * @default []
	 */
	cameras: PerspectiveCamera[];
	readonly isArrayCamera: true;
}
declare class XRJointSpace extends Group {
	readonly jointRadius: number | undefined;
}
export type XRHandJoints = Record<XRHandJoint, XRJointSpace>;
export interface XRHandInputState {
	pinching: boolean;
}
declare class XRHandSpace extends Group {
	readonly joints: Partial<XRHandJoints>;
	readonly inputState: XRHandInputState;
}
declare class XRTargetRaySpace extends Group {
	hasLinearVelocity: boolean;
	readonly linearVelocity: Vector3;
	hasAngularVelocity: boolean;
	readonly angularVelocity: Vector3;
}
declare class XRGripSpace extends Group {
	hasLinearVelocity: boolean;
	readonly linearVelocity: Vector3;
	hasAngularVelocity: boolean;
	readonly angularVelocity: Vector3;
}
export type WebXRCamera = PerspectiveCamera & {
	viewport: Vector4;
};
export type WebXRArrayCamera = Omit<ArrayCamera, 'cameras'> & {
	cameras: [WebXRCamera, WebXRCamera];
};
declare class WebXRManager extends EventDispatcher {
	constructor(renderer: any, gl: WebGLRenderingContext);
	/**
	 * @default false
	 */
	enabled: boolean;
	/**
	 * @default false
	 */
	isPresenting: boolean;
	/**
	 * @default true
	 */
	cameraAutoUpdate: boolean;
	getController(index: number): XRTargetRaySpace;
	getControllerGrip(index: number): XRGripSpace;
	getHand(index: number): XRHandSpace;
	setFramebufferScaleFactor(value: number): void;
	setReferenceSpaceType(value: XRReferenceSpaceType): void;
	getReferenceSpace(): XRReferenceSpace | null;
	setReferenceSpace(value: XRReferenceSpace): void;
	getBaseLayer(): XRWebGLLayer | XRProjectionLayer;
	getBinding(): XRWebGLBinding;
	getFrame(): XRFrame;
	getSession(): XRSession | null;
	setSession(value: XRSession | null): Promise<void>;
	getCamera(): WebXRArrayCamera;
	updateCamera(camera: PerspectiveCamera): void;
	setAnimationLoop(callback: XRFrameRequestCallback | null): void;
	getFoveation(): number | undefined;
	setFoveation(value: number): void;
	/**
	 * Returns the set of planes detected by WebXR's plane detection API.
	 */
	getPlanes(): Set<XRPlane>;
	dispose(): void;
}
declare class Data3DTexture extends Texture {
	constructor(data: BufferSource, width: number, height: number, depth: number);
	/**
	 * @default THREE.NearestFilter
	 */
	magFilter: TextureFilter;
	/**
	 * @default THREE.NearestFilter
	 */
	minFilter: TextureFilter;
	/**
	 * @default THREE.ClampToEdgeWrapping
	 */
	wrapR: Wrapping;
	/**
	 * @default false
	 */
	flipY: boolean;
	/**
	 * @default false
	 */
	generateMipmaps: boolean;
	readonly isData3DTexture: true;
}
declare class DataArrayTexture extends Texture {
	constructor(data?: BufferSource, width?: number, height?: number, depth?: number);
	/**
	 * @default THREE.NearestFilter
	 */
	magFilter: TextureFilter;
	/**
	 * @default THREE.NearestFilter
	 */
	minFilter: TextureFilter;
	/**
	 * @default THREE.ClampToEdgeWrapping
	 */
	wrapR: boolean;
	/**
	 * @default false
	 */
	flipY: boolean;
	/**
	 * @default false
	 */
	generateMipmaps: boolean;
	readonly isDataArrayTexture: true;
}
export interface Renderer {
	domElement: HTMLCanvasElement;
	render(scene: Object3D, camera: Camera): void;
	setSize(width: number, height: number, updateStyle?: boolean): void;
}
export interface WebGLRendererParameters {
	/**
	 * A Canvas where the renderer draws its output.
	 */
	canvas?: HTMLCanvasElement | OffscreenCanvas | undefined;
	/**
	 * A WebGL Rendering Context.
	 * (https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext)
	 * Default is null
	 */
	context?: WebGLRenderingContext | undefined;
	/**
	 * shader precision. Can be "highp", "mediump" or "lowp".
	 */
	precision?: string | undefined;
	/**
	 * default is false.
	 */
	alpha?: boolean | undefined;
	/**
	 * default is true.
	 */
	premultipliedAlpha?: boolean | undefined;
	/**
	 * default is false.
	 */
	antialias?: boolean | undefined;
	/**
	 * default is true.
	 */
	stencil?: boolean | undefined;
	/**
	 * default is false.
	 */
	preserveDrawingBuffer?: boolean | undefined;
	/**
	 * Can be "high-performance", "low-power" or "default"
	 */
	powerPreference?: string | undefined;
	/**
	 * default is true.
	 */
	depth?: boolean | undefined;
	/**
	 * default is false.
	 */
	logarithmicDepthBuffer?: boolean | undefined;
	/**
	 * default is false.
	 */
	failIfMajorPerformanceCaveat?: boolean | undefined;
}
export interface WebGLDebug {
	/**
	 * Enables error checking and reporting when shader programs are being compiled.
	 */
	checkShaderErrors: boolean;
}
declare class WebGLRenderer implements Renderer {
	/**
	 * parameters is an optional object with properties defining the renderer's behaviour.
	 * The constructor also accepts no parameters at all.
	 * In all cases, it will assume sane defaults when parameters are missing.
	 */
	constructor(parameters?: WebGLRendererParameters);
	/**
	 * A Canvas where the renderer draws its output.
	 * This is automatically created by the renderer in the constructor (if not provided already); you just need to add it to your page.
	 * @default document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' )
	 */
	domElement: HTMLCanvasElement;
	/**
	 * Defines whether the renderer should automatically clear its output before rendering.
	 * @default true
	 */
	autoClear: boolean;
	/**
	 * If autoClear is true, defines whether the renderer should clear the color buffer. Default is true.
	 * @default true
	 */
	autoClearColor: boolean;
	/**
	 * If autoClear is true, defines whether the renderer should clear the depth buffer. Default is true.
	 * @default true
	 */
	autoClearDepth: boolean;
	/**
	 * If autoClear is true, defines whether the renderer should clear the stencil buffer. Default is true.
	 * @default true
	 */
	autoClearStencil: boolean;
	/**
	 * Debug configurations.
	 * @default { checkShaderErrors: true }
	 */
	debug: WebGLDebug;
	/**
	 * Defines whether the renderer should sort objects. Default is true.
	 * @default true
	 */
	sortObjects: boolean;
	/**
	 * @default []
	 */
	clippingPlanes: any[];
	/**
	 * @default false
	 */
	localClippingEnabled: boolean;
	extensions: WebGLExtensions;
	/**
	 * Default is LinearEncoding.
	 * @default THREE.LinearEncoding
	 */
	outputEncoding: TextureEncoding;
	/**
	 * @default false
	 */
	physicallyCorrectLights: boolean;
	/**
	 * @default THREE.NoToneMapping
	 */
	toneMapping: ToneMapping;
	/**
	 * @default 1
	 */
	toneMappingExposure: number;
	info: WebGLInfo;
	shadowMap: WebGLShadowMap;
	pixelRatio: number;
	capabilities: WebGLCapabilities;
	properties: WebGLProperties;
	renderLists: WebGLRenderLists;
	state: WebGLState;
	xr: WebXRManager;
	/**
	 * Return the WebGL context.
	 */
	getContext(): WebGLRenderingContext | WebGL2RenderingContext;
	getContextAttributes(): any;
	forceContextLoss(): void;
	forceContextRestore(): void;
	/**
	 * @deprecated Use {@link WebGLCapabilities#getMaxAnisotropy .capabilities.getMaxAnisotropy()} instead.
	 */
	getMaxAnisotropy(): number;
	/**
	 * @deprecated Use {@link WebGLCapabilities#precision .capabilities.precision} instead.
	 */
	getPrecision(): string;
	getPixelRatio(): number;
	setPixelRatio(value: number): void;
	getDrawingBufferSize(target: Vector2): Vector2;
	setDrawingBufferSize(width: number, height: number, pixelRatio: number): void;
	getSize(target: Vector2): Vector2;
	/**
	 * Resizes the output canvas to (width, height), and also sets the viewport to fit that size, starting in (0, 0).
	 */
	setSize(width: number, height: number, updateStyle?: boolean): void;
	getCurrentViewport(target: Vector4): Vector4;
	/**
	 * Copies the viewport into target.
	 */
	getViewport(target: Vector4): Vector4;
	/**
	 * Sets the viewport to render from (x, y) to (x + width, y + height).
	 * (x, y) is the lower-left corner of the region.
	 */
	setViewport(x: Vector4 | number, y?: number, width?: number, height?: number): void;
	/**
	 * Copies the scissor area into target.
	 */
	getScissor(target: Vector4): Vector4;
	/**
	 * Sets the scissor area from (x, y) to (x + width, y + height).
	 */
	setScissor(x: Vector4 | number, y?: number, width?: number, height?: number): void;
	/**
	 * Returns true if scissor test is enabled; returns false otherwise.
	 */
	getScissorTest(): boolean;
	/**
	 * Enable the scissor test. When this is enabled, only the pixels within the defined scissor area will be affected by further renderer actions.
	 */
	setScissorTest(enable: boolean): void;
	/**
	 * Sets the custom opaque sort function for the WebGLRenderLists. Pass null to use the default painterSortStable function.
	 */
	setOpaqueSort(method: (a: any, b: any) => number): void;
	/**
	 * Sets the custom transparent sort function for the WebGLRenderLists. Pass null to use the default reversePainterSortStable function.
	 */
	setTransparentSort(method: (a: any, b: any) => number): void;
	/**
	 * Returns a THREE.Color instance with the current clear color.
	 */
	getClearColor(target: Color): Color;
	/**
	 * Sets the clear color, using color for the color and alpha for the opacity.
	 */
	setClearColor(color: ColorRepresentation, alpha?: number): void;
	/**
	 * Returns a float with the current clear alpha. Ranges from 0 to 1.
	 */
	getClearAlpha(): number;
	setClearAlpha(alpha: number): void;
	/**
	 * Tells the renderer to clear its color, depth or stencil drawing buffer(s).
	 * Arguments default to true
	 */
	clear(color?: boolean, depth?: boolean, stencil?: boolean): void;
	clearColor(): void;
	clearDepth(): void;
	clearStencil(): void;
	clearTarget(renderTarget: WebGLRenderTarget, color: boolean, depth: boolean, stencil: boolean): void;
	/**
	 * @deprecated Use {@link WebGLState#reset .state.reset()} instead.
	 */
	resetGLState(): void;
	dispose(): void;
	renderBufferDirect(
		camera: Camera,
		scene: Scene,
		geometry: BufferGeometry,
		material: Material,
		object: Object3D,
		geometryGroup: any
	): void;
	/**
	 * A build in function that can be used instead of requestAnimationFrame. For WebXR projects this function must be used.
	 * @param callback The function will be called every available frame. If `null` is passed it will stop any already ongoing animation.
	 */
	setAnimationLoop(callback: XRFrameRequestCallback | null): void;
	/**
	 * @deprecated Use {@link WebGLRenderer#setAnimationLoop .setAnimationLoop()} instead.
	 */
	animate(callback: () => void): void;
	/**
	 * Compiles all materials in the scene with the camera. This is useful to precompile shaders before the first rendering.
	 */
	compile(scene: Object3D, camera: Camera): void;
	/**
	 * Render a scene or an object using a camera.
	 * The render is done to a previously specified {@link WebGLRenderTarget#renderTarget .renderTarget} set by calling
	 * {@link WebGLRenderer#setRenderTarget .setRenderTarget} or to the canvas as usual.
	 *
	 * By default render buffers are cleared before rendering but you can prevent this by setting the property
	 * {@link WebGLRenderer#autoClear autoClear} to false. If you want to prevent only certain buffers being cleared
	 * you can set either the {@link WebGLRenderer#autoClearColor autoClearColor},
	 * {@link WebGLRenderer#autoClearStencil autoClearStencil} or {@link WebGLRenderer#autoClearDepth autoClearDepth}
	 * properties to false. To forcibly clear one ore more buffers call {@link WebGLRenderer#clear .clear}.
	 */
	render(scene: Object3D, camera: Camera): void;
	/**
	 * Returns the current active cube face.
	 */
	getActiveCubeFace(): number;
	/**
	 * Returns the current active mipmap level.
	 */
	getActiveMipmapLevel(): number;
	/**
	 * Returns the current render target. If no render target is set, null is returned.
	 */
	getRenderTarget(): WebGLRenderTarget | null;
	/**
	 * @deprecated Use {@link WebGLRenderer#getRenderTarget .getRenderTarget()} instead.
	 */
	getCurrentRenderTarget(): WebGLRenderTarget | null;
	/**
	 * Sets the active render target.
	 *
	 * @param renderTarget The {@link WebGLRenderTarget renderTarget} that needs to be activated. When `null` is given, the canvas is set as the active render target instead.
	 * @param activeCubeFace Specifies the active cube side (PX 0, NX 1, PY 2, NY 3, PZ 4, NZ 5) of {@link WebGLCubeRenderTarget}.
	 * @param activeMipmapLevel Specifies the active mipmap level.
	 */
	setRenderTarget(
		renderTarget: WebGLRenderTarget | WebGLMultipleRenderTargets | null,
		activeCubeFace?: number,
		activeMipmapLevel?: number
	): void;
	readRenderTargetPixels(
		renderTarget: WebGLRenderTarget | WebGLMultipleRenderTargets,
		x: number,
		y: number,
		width: number,
		height: number,
		buffer: any,
		activeCubeFaceIndex?: number
	): void;
	/**
	 * Copies a region of the currently bound framebuffer into the selected mipmap level of the selected texture.
	 * This region is defined by the size of the destination texture's mip level, offset by the input position.
	 *
	 * @param position Specifies the pixel offset from which to copy out of the framebuffer.
	 * @param texture Specifies the destination texture.
	 * @param level Specifies the destination mipmap level of the texture.
	 */
	copyFramebufferToTexture(position: Vector2, texture: Texture, level?: number): void;
	/**
	 * Copies srcTexture to the specified level of dstTexture, offset by the input position.
	 *
	 * @param position Specifies the pixel offset into the dstTexture where the copy will occur.
	 * @param srcTexture Specifies the source texture.
	 * @param dstTexture Specifies the destination texture.
	 * @param level Specifies the destination mipmap level of the texture.
	 */
	copyTextureToTexture(position: Vector2, srcTexture: Texture, dstTexture: Texture, level?: number): void;
	/**
	 * Copies the pixels of a texture in the bounds sourceBox in the desination texture starting from the given position.
	 * @param sourceBox Specifies the bounds
	 * @param position Specifies the pixel offset into the dstTexture where the copy will occur.
	 * @param srcTexture Specifies the source texture.
	 * @param dstTexture Specifies the destination texture.
	 * @param level Specifies the destination mipmap level of the texture.
	 */
	copyTextureToTexture3D(
		sourceBox: Box3,
		position: Vector3,
		srcTexture: Texture,
		dstTexture: Data3DTexture | DataArrayTexture,
		level?: number
	): void;
	/**
	 * Initializes the given texture. Can be used to preload a texture rather than waiting until first render (which can cause noticeable lags due to decode and GPU upload overhead).
	 *
	 * @param texture The texture to Initialize.
	 */
	initTexture(texture: Texture): void;
	/**
	 * Can be used to reset the internal WebGL state.
	 */
	resetState(): void;
	/**
	 * @deprecated Use {@link WebGLRenderer#xr .xr} instead.
	 */
	vr: boolean;
	/**
	 * @deprecated Use {@link WebGLShadowMap#enabled .shadowMap.enabled} instead.
	 */
	shadowMapEnabled: boolean;
	/**
	 * @deprecated Use {@link WebGLShadowMap#type .shadowMap.type} instead.
	 */
	shadowMapType: ShadowMapType;
	/**
	 * @deprecated Use {@link WebGLShadowMap#cullFace .shadowMap.cullFace} instead.
	 */
	shadowMapCullFace: CullFace;
	/**
	 * @deprecated Use {@link WebGLExtensions#get .extensions.get( 'OES_texture_float' )} instead.
	 */
	supportsFloatTextures(): any;
	/**
	 * @deprecated Use {@link WebGLExtensions#get .extensions.get( 'OES_texture_half_float' )} instead.
	 */
	supportsHalfFloatTextures(): any;
	/**
	 * @deprecated Use {@link WebGLExtensions#get .extensions.get( 'OES_standard_derivatives' )} instead.
	 */
	supportsStandardDerivatives(): any;
	/**
	 * @deprecated Use {@link WebGLExtensions#get .extensions.get( 'WEBGL_compressed_texture_s3tc' )} instead.
	 */
	supportsCompressedTextureS3TC(): any;
	/**
	 * @deprecated Use {@link WebGLExtensions#get .extensions.get( 'WEBGL_compressed_texture_pvrtc' )} instead.
	 */
	supportsCompressedTexturePVRTC(): any;
	/**
	 * @deprecated Use {@link WebGLExtensions#get .extensions.get( 'EXT_blend_minmax' )} instead.
	 */
	supportsBlendMinMax(): any;
	/**
	 * @deprecated Use {@link WebGLCapabilities#vertexTextures .capabilities.vertexTextures} instead.
	 */
	supportsVertexTextures(): any;
	/**
	 * @deprecated Use {@link WebGLExtensions#get .extensions.get( 'ANGLE_instanced_arrays' )} instead.
	 */
	supportsInstancedArrays(): any;
	/**
	 * @deprecated Use {@link WebGLRenderer#setScissorTest .setScissorTest()} instead.
	 */
	enableScissorTest(boolean: any): any;
}
declare class Ray {
	constructor(origin?: Vector3, direction?: Vector3);
	/**
	 * @default new THREE.Vector3()
	 */
	origin: Vector3;
	/**
	 * @default new THREE.Vector3( 0, 0, - 1 )
	 */
	direction: Vector3;
	set(origin: Vector3, direction: Vector3): Ray;
	clone(): this;
	copy(ray: Ray): this;
	at(t: number, target: Vector3): Vector3;
	lookAt(v: Vector3): Ray;
	recast(t: number): Ray;
	closestPointToPoint(point: Vector3, target: Vector3): Vector3;
	distanceToPoint(point: Vector3): number;
	distanceSqToPoint(point: Vector3): number;
	distanceSqToSegment(
		v0: Vector3,
		v1: Vector3,
		optionalPointOnRay?: Vector3,
		optionalPointOnSegment?: Vector3
	): number;
	intersectSphere(sphere: Sphere, target: Vector3): Vector3 | null;
	intersectsSphere(sphere: Sphere): boolean;
	distanceToPlane(plane: Plane): number;
	intersectPlane(plane: Plane, target: Vector3): Vector3 | null;
	intersectsPlane(plane: Plane): boolean;
	intersectBox(box: Box3, target: Vector3): Vector3 | null;
	intersectsBox(box: Box3): boolean;
	intersectTriangle(a: Vector3, b: Vector3, c: Vector3, backfaceCulling: boolean, target: Vector3): Vector3 | null;
	applyMatrix4(matrix4: Matrix4): Ray;
	equals(ray: Ray): boolean;
	/**
	 * @deprecated Use {@link Ray#intersectsBox .intersectsBox()} instead.
	 */
	isIntersectionBox(b: any): any;
	/**
	 * @deprecated Use {@link Ray#intersectsPlane .intersectsPlane()} instead.
	 */
	isIntersectionPlane(p: any): any;
	/**
	 * @deprecated Use {@link Ray#intersectsSphere .intersectsSphere()} instead.
	 */
	isIntersectionSphere(s: any): any;
}
export interface Face {
	a: number;
	b: number;
	c: number;
	normal: Vector3;
	materialIndex: number;
}
export interface Intersection<TIntersected extends Object3D = Object3D> {
	distance: number;
	distanceToRay?: number | undefined;
	point: Vector3;
	index?: number | undefined;
	face?: Face | null | undefined;
	faceIndex?: number | undefined;
	object: TIntersected;
	uv?: Vector2 | undefined;
	uv2?: Vector2 | undefined;
	instanceId?: number | undefined;
}
export interface RaycasterParameters {
	Mesh?: any;
	Line?:
		| {
				threshold: number;
		  }
		| undefined;
	LOD?: any;
	Points?:
		| {
				threshold: number;
		  }
		| undefined;
	Sprite?: any;
}
declare class Raycaster {
	/**
	 * This creates a new raycaster object.
	 * @param origin The origin vector where the ray casts from.
	 * @param direction The direction vector that gives direction to the ray. Should be normalized.
	 * @param near All results returned are further away than near. Near can't be negative. Default value is 0.
	 * @param far All results returned are closer then far. Far can't be lower then near . Default value is Infinity.
	 */
	constructor(origin?: Vector3, direction?: Vector3, near?: number, far?: number);
	/** The Ray used for the raycasting. */
	ray: Ray;
	/**
	 * The near factor of the raycaster. This value indicates which objects can be discarded based on the
	 * distance. This value shouldn't be negative and should be smaller than the far property.
	 * @default 0
	 */
	near: number;
	/**
	 * The far factor of the raycaster. This value indicates which objects can be discarded based on the
	 * distance. This value shouldn't be negative and should be larger than the near property.
	 * @default Infinity
	 */
	far: number;
	/**
	 * The camera to use when raycasting against view-dependent objects such as billboarded objects like Sprites. This field
	 * can be set manually or is set when calling "setFromCamera".
	 */
	camera: Camera;
	/**
	 * Used by Raycaster to selectively ignore 3D objects when performing intersection tests.
	 * @default new THREE.Layers()
	 */
	layers: Layers;
	/**
	 * @default { Mesh: {}, Line: { threshold: 1 }, LOD: {}, Points: { threshold: 1 }, Sprite: {} }
	 */
	params: RaycasterParameters;
	/**
	 * Updates the ray with a new origin and direction.
	 * @param origin The origin vector where the ray casts from.
	 * @param direction The normalized direction vector that gives direction to the ray.
	 */
	set(origin: Vector3, direction: Vector3): void;
	/**
	 * Updates the ray with a new origin and direction.
	 * @param coords 2D coordinates of the mouse, in normalized device coordinates (NDC)---X and Y components should be between -1 and 1.
	 * @param camera camera from which the ray should originate
	 */
	setFromCamera(
		coords: {
			x: number;
			y: number;
		},
		camera: Camera
	): void;
	/**
	 * Checks all intersection between the ray and the object with or without the descendants. Intersections are returned sorted by distance, closest first.
	 * @param object The object to check for intersection with the ray.
	 * @param recursive If true, it also checks all descendants. Otherwise it only checks intersecton with the object. Default is true.
	 * @param optionalTarget (optional) target to set the result. Otherwise a new Array is instantiated. If set, you must clear this array prior to each call (i.e., array.length = 0;).
	 */
	intersectObject<TIntersected extends Object3D>(
		object: Object3D,
		recursive?: boolean,
		optionalTarget?: Array<Intersection<TIntersected>>
	): Array<Intersection<TIntersected>>;
	/**
	 * Checks all intersection between the ray and the objects with or without the descendants.
	 * Intersections are returned sorted by distance, closest first.
	 * Intersections are of the same form as those returned by .intersectObject.
	 * @param objects The objects to check for intersection with the ray.
	 * @param recursive If true, it also checks all descendants of the objects. Otherwise it only checks intersecton with the objects. Default is true.
	 * @param optionalTarget (optional) target to set the result. Otherwise a new Array is instantiated. If set, you must clear this array prior to each call (i.e., array.length = 0;).
	 */
	intersectObjects<TIntersected extends Object3D>(
		objects: Object3D[],
		recursive?: boolean,
		optionalTarget?: Array<Intersection<TIntersected>>
	): Array<Intersection<TIntersected>>;
}
declare abstract class Interpolant {
	constructor(parameterPositions: any, sampleValues: any, sampleSize: number, resultBuffer?: any);
	parameterPositions: any;
	sampleValues: any;
	valueSize: number;
	resultBuffer: any;
	evaluate(time: number): any;
}
declare class DiscreteInterpolant extends Interpolant {
	constructor(parameterPositions: any, samplesValues: any, sampleSize: number, resultBuffer?: any);
	interpolate_(i1: number, t0: number, t: number, t1: number): any;
}
declare class LinearInterpolant extends Interpolant {
	constructor(parameterPositions: any, samplesValues: any, sampleSize: number, resultBuffer?: any);
	interpolate_(i1: number, t0: number, t: number, t1: number): any;
}
declare class CubicInterpolant extends Interpolant {
	constructor(parameterPositions: any, samplesValues: any, sampleSize: number, resultBuffer?: any);
	interpolate_(i1: number, t0: number, t: number, t1: number): any;
}
declare class KeyframeTrack {
	/**
	 * @param name
	 * @param times
	 * @param values
	 * @param [interpolation=THREE.InterpolateLinear]
	 */
	constructor(name: string, times: ArrayLike<number>, values: ArrayLike<any>, interpolation?: InterpolationModes);
	name: string;
	times: Float32Array;
	values: Float32Array;
	ValueTypeName: string;
	TimeBufferType: Float32Array;
	ValueBufferType: Float32Array;
	/**
	 * @default THREE.InterpolateLinear
	 */
	DefaultInterpolation: InterpolationModes;
	InterpolantFactoryMethodDiscrete(result: any): DiscreteInterpolant;
	InterpolantFactoryMethodLinear(result: any): LinearInterpolant;
	InterpolantFactoryMethodSmooth(result: any): CubicInterpolant;
	setInterpolation(interpolation: InterpolationModes): KeyframeTrack;
	getInterpolation(): InterpolationModes;
	createInterpolant(): Interpolant;
	getValueSize(): number;
	shift(timeOffset: number): KeyframeTrack;
	scale(timeScale: number): KeyframeTrack;
	trim(startTime: number, endTime: number): KeyframeTrack;
	validate(): boolean;
	optimize(): KeyframeTrack;
	clone(): this;
	static toJSON(track: KeyframeTrack): any;
}
declare class Bone extends Object3D {
	constructor();
	readonly isBone: true;
	type: 'Bone';
}
export interface MorphTarget {
	name: string;
	vertices: Vector3[];
}
declare class AnimationClip {
	constructor(name?: string, duration?: number, tracks?: KeyframeTrack[], blendMode?: AnimationBlendMode);
	name: string;
	tracks: KeyframeTrack[];
	/**
	 * @default THREE.NormalAnimationBlendMode
	 */
	blendMode: AnimationBlendMode;
	/**
	 * @default -1
	 */
	duration: number;
	uuid: string;
	results: any[];
	resetDuration(): AnimationClip;
	trim(): AnimationClip;
	validate(): boolean;
	optimize(): AnimationClip;
	clone(): this;
	toJSON(clip: AnimationClip): any;
	static CreateFromMorphTargetSequence(
		name: string,
		morphTargetSequence: MorphTarget[],
		fps: number,
		noLoop: boolean
	): AnimationClip;
	static findByName(clipArray: AnimationClip[], name: string): AnimationClip;
	static CreateClipsFromMorphTargetSequences(
		morphTargets: MorphTarget[],
		fps: number,
		noLoop: boolean
	): AnimationClip[];
	static parse(json: any): AnimationClip;
	static parseAnimation(animation: any, bones: Bone[]): AnimationClip;
	static toJSON(clip: AnimationClip): any;
}
declare class Object3D<E extends BaseEvent = Event> extends EventDispatcher<E> {
	constructor();
	/**
	 * Unique number of this object instance.
	 */
	id: number;
	uuid: string;
	/**
	 * Optional name of the object (doesn't need to be unique).
	 * @default ''
	 */
	name: string;
	/**
	 * @default 'Object3D'
	 */
	type: string;
	/**
	 * Object's parent in the scene graph.
	 * @default null
	 */
	parent: Object3D | null;
	/**
	 * Array with object's children.
	 * @default []
	 */
	children: Object3D[];
	/**
	 * This is used by the {@link lookAt} method, for example, to determine the orientation of the result.
	 *
	 * Default is {@link Object3D.DEFAULT_UP} - that is, `( 0, 1, 0 )`.
	 *
	 * @default {@link Object3D.DEFAULT_UP}
	 */
	up: Vector3;
	/**
	 * Object's local position.
	 * @default new THREE.Vector3()
	 */
	readonly position: Vector3;
	/**
	 * Object's local rotation (Euler angles), in radians.
	 * @default new THREE.Euler()
	 */
	readonly rotation: Euler;
	/**
	 * Object's local rotation as a Quaternion.
	 * @default new THREE.Quaternion()
	 */
	readonly quaternion: Quaternion;
	/**
	 * Object's local scale.
	 * @default new THREE.Vector3()
	 */
	readonly scale: Vector3;
	/**
	 * @default new THREE.Matrix4()
	 */
	readonly modelViewMatrix: Matrix4;
	/**
	 * @default new THREE.Matrix3()
	 */
	readonly normalMatrix: Matrix3;
	/**
	 * Local transform.
	 * @default new THREE.Matrix4()
	 */
	matrix: Matrix4;
	/**
	 * The global transform of the object. If the Object3d has no parent, then it's identical to the local transform.
	 * @default new THREE.Matrix4()
	 */
	matrixWorld: Matrix4;
	/**
	 * When this is set, it calculates the matrix of position, (rotation or quaternion) and
	 * scale every frame and also recalculates the matrixWorld property. Default is {@link Object3D.DEFAULT_MATRIX_AUTO_UPDATE} (true).
	 */
	matrixAutoUpdate: boolean;
	/**
	 * If set, then the renderer checks every frame if the object and its children need matrix updates.
	 * When it isn't, then you have to maintain all matrices in the object and its children yourself.
	 * Default is {@link Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE} (true).
	 */
	matrixWorldAutoUpdate: boolean;
	/**
	 * When this is set, it calculates the matrixWorld in that frame and resets this property to false.
	 * @default false
	 */
	matrixWorldNeedsUpdate: boolean;
	/**
	 * @default new THREE.Layers()
	 */
	layers: Layers;
	/**
	 * Object gets rendered if true.
	 * @default true
	 */
	visible: boolean;
	/**
	 * Gets rendered into shadow map.
	 * @default false
	 */
	castShadow: boolean;
	/**
	 * Material gets baked in shadow receiving.
	 * @default false
	 */
	receiveShadow: boolean;
	/**
	 * When this is set, it checks every frame if the object is in the frustum of the camera before rendering the object.
	 * If set to false the object gets rendered every frame even if it is not in the frustum of the camera.
	 * @default true
	 */
	frustumCulled: boolean;
	/**
	 * Overrides the default rendering order of scene graph objects, from lowest to highest renderOrder.
	 * Opaque and transparent objects remain sorted independently though.
	 * When this property is set for an instance of Group, all descendants objects will be sorted and rendered together.
	 * @default 0
	 */
	renderOrder: number;
	/**
	 * Array with animation clips.
	 * @default []
	 */
	animations: AnimationClip[];
	/**
	 * An object that can be used to store custom data about the Object3d. It should not hold references to functions as these will not be cloned.
	 * @default {}
	 */
	userData: {
		[key: string]: any;
	};
	/**
	 * Custom depth material to be used when rendering to the depth map. Can only be used in context of meshes.
	 * When shadow-casting with a DirectionalLight or SpotLight, if you are (a) modifying vertex positions in
	 * the vertex shader, (b) using a displacement map, (c) using an alpha map with alphaTest, or (d) using a
	 * transparent texture with alphaTest, you must specify a customDepthMaterial for proper shadows.
	 */
	customDepthMaterial: Material;
	/**
	 * Same as customDepthMaterial, but used with PointLight.
	 */
	customDistanceMaterial: Material;
	/**
	 * Used to check whether this or derived classes are Object3Ds. Default is true.
	 * You should not change this, as it is used internally for optimisation.
	 */
	readonly isObject3D: true;
	/**
	 * Calls before rendering object
	 */
	onBeforeRender: (
		renderer: WebGLRenderer,
		scene: Scene,
		camera: Camera,
		geometry: BufferGeometry,
		material: Material,
		group: Group
	) => void;
	/**
	 * Calls after rendering object
	 */
	onAfterRender: (
		renderer: WebGLRenderer,
		scene: Scene,
		camera: Camera,
		geometry: BufferGeometry,
		material: Material,
		group: Group
	) => void;
	/**
	 * The default {@link up} direction for objects, also used as the default position for {@link DirectionalLight},
	 * {@link HemisphereLight} and {@link Spotlight} (which creates lights shining from the top down).
	 *
	 * Set to ( 0, 1, 0 ) by default.
	 */
	static DEFAULT_UP: Vector3;
	/**
	 * The default setting for {@link matrixAutoUpdate} for newly created Object3Ds.
	 */
	static DEFAULT_MATRIX_AUTO_UPDATE: boolean;
	/**
	 * The default setting for {@link matrixWorldAutoUpdate} for newly created Object3Ds.
	 */
	static DEFAULT_MATRIX_WORLD_AUTO_UPDATE: boolean;
	/**
	 * Applies the matrix transform to the object and updates the object's position, rotation and scale.
	 */
	applyMatrix4(matrix: Matrix4): void;
	/**
	 * Applies the rotation represented by the quaternion to the object.
	 */
	applyQuaternion(quaternion: Quaternion): this;
	/**
	 * axis -- A normalized vector in object space.
	 * angle -- angle in radians
	 * @param axis A normalized vector in object space.
	 * @param angle angle in radians
	 */
	setRotationFromAxisAngle(axis: Vector3, angle: number): void;
	/**
	 * Calls setRotationFromEuler(euler) on the .quaternion.
	 * @param euler Euler angle specifying rotation amount.
	 */
	setRotationFromEuler(euler: Euler): void;
	/**
	 * Calls setFromRotationMatrix(m) on the .quaternion.
	 *
	 * Note that this assumes that the upper 3x3 of m is a pure rotation matrix (i.e, unscaled).
	 * @param m rotate the quaternion by the rotation component of the matrix.
	 */
	setRotationFromMatrix(m: Matrix4): void;
	/**
	 * Copy the given quaternion into .quaternion.
	 * @param q normalized Quaternion
	 */
	setRotationFromQuaternion(q: Quaternion): void;
	/**
	 * Rotate an object along an axis in object space. The axis is assumed to be normalized.
	 * @param axis	A normalized vector in object space.
	 * @param angle	The angle in radians.
	 */
	rotateOnAxis(axis: Vector3, angle: number): this;
	/**
	 * Rotate an object along an axis in world space. The axis is assumed to be normalized. Method Assumes no rotated parent.
	 * @param axis	A normalized vector in object space.
	 * @param angle	The angle in radians.
	 */
	rotateOnWorldAxis(axis: Vector3, angle: number): this;
	/**
	 * Rotates the object around x axis in local space.
	 * @param angle the angle to rotate in radians.
	 */
	rotateX(angle: number): this;
	/**
	 * Rotates the object around y axis in local space.
	 * @param angle the angle to rotate in radians.
	 */
	rotateY(angle: number): this;
	/**
	 * Rotates the object around z axis in local space.
	 * @param angle the angle to rotate in radians.
	 */
	rotateZ(angle: number): this;
	/**
	 * Translate an object by distance along an axis in object space. The axis is assumed to be normalized.
	 * @param axis	A normalized vector in object space.
	 * @param distance	The distance to translate.
	 */
	translateOnAxis(axis: Vector3, distance: number): this;
	/**
	 * Translates object along x axis by distance.
	 * @param distance Distance.
	 */
	translateX(distance: number): this;
	/**
	 * Translates object along y axis by distance.
	 * @param distance Distance.
	 */
	translateY(distance: number): this;
	/**
	 * Translates object along z axis by distance.
	 * @param distance Distance.
	 */
	translateZ(distance: number): this;
	/**
	 * Updates the vector from local space to world space.
	 * @param vector A local vector.
	 */
	localToWorld(vector: Vector3): Vector3;
	/**
	 * Updates the vector from world space to local space.
	 * @param vector A world vector.
	 */
	worldToLocal(vector: Vector3): Vector3;
	/**
	 * Optionally, the x, y and z components of the world space position.
	 * Rotates the object to face a point in world space.
	 * This method does not support objects having non-uniformly-scaled parent(s).
	 * @param vector A world vector to look at.
	 */
	lookAt(vector: Vector3): void;
	lookAt(x: number, y: number, z: number): void;
	/**
	 * Adds object as child of this object.
	 */
	add(...object: Object3D[]): this;
	/**
	 * Removes object as child of this object.
	 */
	remove(...object: Object3D[]): this;
	/**
	 * Removes this object from its current parent.
	 */
	removeFromParent(): this;
	/**
	 * Removes all child objects.
	 */
	clear(): this;
	/**
	 * Adds object as a child of this, while maintaining the object's world transform.
	 */
	attach(object: Object3D): this;
	/**
	 * Searches through the object's children and returns the first with a matching id.
	 * @param id	Unique number of the object instance
	 */
	getObjectById(id: number): Object3D | undefined;
	/**
	 * Searches through the object's children and returns the first with a matching name.
	 * @param name	String to match to the children's Object3d.name property.
	 */
	getObjectByName(name: string): Object3D | undefined;
	/**
	 * Searches through an object and its children, starting with the object itself,
	 * and returns the first with a property that matches the value given.
	 *
	 * @param name - the property name to search for.
	 * @param value - value of the given property.
	 */
	getObjectByProperty(name: string, value: any): Object3D | undefined;
	/**
	 * Searches through an object and its children, starting with the object itself,
	 * and returns all the objects with a property that matches the value given.
	 *
	 * @param name - the property name to search for.
	 * @param value - value of the given property.
	 */
	getObjectsByProperty(name: string, value: any): Object3D[];
	getWorldPosition(target: Vector3): Vector3;
	getWorldQuaternion(target: Quaternion): Quaternion;
	getWorldScale(target: Vector3): Vector3;
	getWorldDirection(target: Vector3): Vector3;
	raycast(raycaster: Raycaster, intersects: Intersection[]): void;
	traverse(callback: (object: Object3D) => any): void;
	traverseVisible(callback: (object: Object3D) => any): void;
	traverseAncestors(callback: (object: Object3D) => any): void;
	/**
	 * Updates local transform.
	 */
	updateMatrix(): void;
	/**
	 * Updates global transform of the object and its children.
	 */
	updateMatrixWorld(force?: boolean): void;
	/**
	 * Updates the global transform of the object.
	 * @param updateParents recursively updates global transform of ancestors.
	 * @param updateChildren recursively updates global transform of descendants.
	 */
	updateWorldMatrix(updateParents: boolean, updateChildren: boolean): void;
	toJSON(meta?: {geometries: any; materials: any; textures: any; images: any}): any;
	clone(recursive?: boolean): this;
	/**
	 *
	 * @param object
	 * @param recursive
	 */
	copy(source: this, recursive?: boolean): this;
}
declare class Camera extends Object3D {
	/**
	 * This constructor sets following properties to the correct type: matrixWorldInverse, projectionMatrix and projectionMatrixInverse.
	 */
	constructor();
	/**
	 * This is the inverse of matrixWorld. MatrixWorld contains the Matrix which has the world transform of the Camera.
	 * @default new THREE.Matrix4()
	 */
	matrixWorldInverse: Matrix4;
	/**
	 * This is the matrix which contains the projection.
	 * @default new THREE.Matrix4()
	 */
	projectionMatrix: Matrix4;
	/**
	 * This is the inverse of projectionMatrix.
	 * @default new THREE.Matrix4()
	 */
	projectionMatrixInverse: Matrix4;
	readonly isCamera: true;
	getWorldDirection(target: Vector3): Vector3;
	updateMatrixWorld(force?: boolean): void;
}
declare class Spherical {
	constructor(radius?: number, phi?: number, theta?: number);
	/**
	 * @default 1
	 */
	radius: number;
	/**
	 * @default 0
	 */
	phi: number;
	/**
	 * @default 0
	 */
	theta: number;
	set(radius: number, phi: number, theta: number): this;
	clone(): this;
	copy(other: Spherical): this;
	makeSafe(): this;
	setFromVector3(v: Vector3): this;
	setFromCartesianCoords(x: number, y: number, z: number): this;
}
declare class Cylindrical {
	constructor(radius?: number, theta?: number, y?: number);
	/**
	 * @default 1
	 */
	radius: number;
	/**
	 * @default 0
	 */
	theta: number;
	/**
	 * @default 0
	 */
	y: number;
	clone(): this;
	copy(other: Cylindrical): this;
	set(radius: number, theta: number, y: number): this;
	setFromVector3(vec3: Vector3): this;
	setFromCartesianCoords(x: number, y: number, z: number): this;
}
export type Vector3Tuple = [number, number, number];
declare class Vector3 implements Vector {
	constructor(x?: number, y?: number, z?: number);
	/**
	 * @default 0
	 */
	x: number;
	/**
	 * @default 0
	 */
	y: number;
	/**
	 * @default 0
	 */
	z: number;
	readonly isVector3: true;
	/**
	 * Sets value of this vector.
	 */
	set(x: number, y: number, z: number): this;
	/**
	 * Sets all values of this vector.
	 */
	setScalar(scalar: number): this;
	/**
	 * Sets x value of this vector.
	 */
	setX(x: number): Vector3;
	/**
	 * Sets y value of this vector.
	 */
	setY(y: number): Vector3;
	/**
	 * Sets z value of this vector.
	 */
	setZ(z: number): Vector3;
	setComponent(index: number, value: number): this;
	getComponent(index: number): number;
	/**
	 * Clones this vector.
	 */
	clone(): this;
	/**
	 * Copies value of v to this vector.
	 */
	copy(v: Vector3): this;
	/**
	 * Adds v to this vector.
	 */
	add(v: Vector3): this;
	addScalar(s: number): this;
	addScaledVector(v: Vector3, s: number): this;
	/**
	 * Sets this vector to a + b.
	 */
	addVectors(a: Vector3, b: Vector3): this;
	/**
	 * Subtracts v from this vector.
	 */
	sub(a: Vector3): this;
	subScalar(s: number): this;
	/**
	 * Sets this vector to a - b.
	 */
	subVectors(a: Vector3, b: Vector3): this;
	multiply(v: Vector3): this;
	/**
	 * Multiplies this vector by scalar s.
	 */
	multiplyScalar(s: number): this;
	multiplyVectors(a: Vector3, b: Vector3): this;
	applyEuler(euler: Euler): this;
	applyAxisAngle(axis: Vector3, angle: number): this;
	applyMatrix3(m: Matrix3): this;
	applyNormalMatrix(m: Matrix3): this;
	applyMatrix4(m: Matrix4): this;
	applyQuaternion(q: Quaternion): this;
	project(camera: Camera): this;
	unproject(camera: Camera): this;
	transformDirection(m: Matrix4): this;
	divide(v: Vector3): this;
	/**
	 * Divides this vector by scalar s.
	 * Set vector to ( 0, 0, 0 ) if s == 0.
	 */
	divideScalar(s: number): this;
	min(v: Vector3): this;
	max(v: Vector3): this;
	clamp(min: Vector3, max: Vector3): this;
	clampScalar(min: number, max: number): this;
	clampLength(min: number, max: number): this;
	floor(): this;
	ceil(): this;
	round(): this;
	roundToZero(): this;
	/**
	 * Inverts this vector.
	 */
	negate(): this;
	/**
	 * Computes dot product of this vector and v.
	 */
	dot(v: Vector3): number;
	/**
	 * Computes squared length of this vector.
	 */
	lengthSq(): number;
	/**
	 * Computes length of this vector.
	 */
	length(): number;
	/**
	 * Computes Manhattan length of this vector.
	 * http://en.wikipedia.org/wiki/Taxicab_geometry
	 *
	 * @deprecated Use {@link Vector3#manhattanLength .manhattanLength()} instead.
	 */
	lengthManhattan(): number;
	/**
	 * Computes the Manhattan length of this vector.
	 *
	 * see {@link http://en.wikipedia.org/wiki/Taxicab_geometry|Wikipedia: Taxicab Geometry}
	 */
	manhattanLength(): number;
	/**
	 * Computes the Manhattan length (distance) from this vector to the given vector v
	 *
	 * see {@link http://en.wikipedia.org/wiki/Taxicab_geometry|Wikipedia: Taxicab Geometry}
	 */
	manhattanDistanceTo(v: Vector3): number;
	/**
	 * Normalizes this vector.
	 */
	normalize(): this;
	/**
	 * Normalizes this vector and multiplies it by l.
	 */
	setLength(l: number): this;
	lerp(v: Vector3, alpha: number): this;
	lerpVectors(v1: Vector3, v2: Vector3, alpha: number): this;
	/**
	 * Sets this vector to cross product of itself and v.
	 */
	cross(a: Vector3): this;
	/**
	 * Sets this vector to cross product of a and b.
	 */
	crossVectors(a: Vector3, b: Vector3): this;
	projectOnVector(v: Vector3): this;
	projectOnPlane(planeNormal: Vector3): this;
	reflect(vector: Vector3): this;
	angleTo(v: Vector3): number;
	/**
	 * Computes distance of this vector to v.
	 */
	distanceTo(v: Vector3): number;
	/**
	 * Computes squared distance of this vector to v.
	 */
	distanceToSquared(v: Vector3): number;
	/**
	 * @deprecated Use {@link Vector3#manhattanDistanceTo .manhattanDistanceTo()} instead.
	 */
	distanceToManhattan(v: Vector3): number;
	setFromSpherical(s: Spherical): this;
	setFromSphericalCoords(r: number, phi: number, theta: number): this;
	setFromCylindrical(s: Cylindrical): this;
	setFromCylindricalCoords(radius: number, theta: number, y: number): this;
	setFromMatrixPosition(m: Matrix4): this;
	setFromMatrixScale(m: Matrix4): this;
	setFromMatrixColumn(matrix: Matrix4, index: number): this;
	setFromMatrix3Column(matrix: Matrix3, index: number): this;
	/**
	 * Sets this vector's {@link x}, {@link y} and {@link z} components from the x, y, and z components of the specified {@link Euler Euler Angle}.
	 */
	setFromEuler(e: Euler): this;
	/**
	 * Checks for strict equality of this vector and v.
	 */
	equals(v: Vector3): boolean;
	/**
	 * Sets this vector's x, y and z value from the provided array or array-like.
	 * @param array the source array or array-like.
	 * @param offset (optional) offset into the array. Default is 0.
	 */
	fromArray(array: number[] | ArrayLike<number>, offset?: number): this;
	/**
	 * Returns an array [x, y, z], or copies x, y and z into the provided array.
	 * @param array (optional) array to store the vector to. If this is not provided, a new array will be created.
	 * @param offset (optional) optional offset into the array.
	 * @return The created or provided array.
	 */
	toArray(array?: number[], offset?: number): number[];
	toArray(array?: Vector3Tuple, offset?: 0): Vector3Tuple;
	/**
	 * Copies x, y and z into the provided array-like.
	 * @param array array-like to store the vector to.
	 * @param offset (optional) optional offset into the array-like.
	 * @return The provided array-like.
	 */
	toArray(array: ArrayLike<number>, offset?: number): ArrayLike<number>;
	fromBufferAttribute(attribute: BufferAttribute | InterleavedBufferAttribute, index: number): this;
	/**
	 * Sets this vector's x, y and z from Math.random
	 */
	random(): this;
	randomDirection(): this;
}
export type Matrix4Tuple = [
	number,
	number,
	number,
	number,
	number,
	number,
	number,
	number,
	number,
	number,
	number,
	number,
	number,
	number,
	number,
	number
];
declare class Matrix4 implements Matrix {
	constructor();
	/**
	 * Array with matrix values.
	 * @default [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]
	 */
	elements: number[];
	/**
	 * Sets all fields of this matrix.
	 */
	set(
		n11: number,
		n12: number,
		n13: number,
		n14: number,
		n21: number,
		n22: number,
		n23: number,
		n24: number,
		n31: number,
		n32: number,
		n33: number,
		n34: number,
		n41: number,
		n42: number,
		n43: number,
		n44: number
	): Matrix4;
	/**
	 * Resets this matrix to identity.
	 */
	identity(): Matrix4;
	clone(): Matrix4;
	copy(m: Matrix4): this;
	copyPosition(m: Matrix4): Matrix4;
	extractBasis(xAxis: Vector3, yAxis: Vector3, zAxis: Vector3): Matrix4;
	makeBasis(xAxis: Vector3, yAxis: Vector3, zAxis: Vector3): Matrix4;
	/**
	 * Copies the rotation component of the supplied matrix m into this matrix rotation component.
	 */
	extractRotation(m: Matrix4): Matrix4;
	makeRotationFromEuler(euler: Euler): Matrix4;
	makeRotationFromQuaternion(q: Quaternion): Matrix4;
	/**
	 * Constructs a rotation matrix, looking from eye towards center with defined up vector.
	 */
	lookAt(eye: Vector3, target: Vector3, up: Vector3): Matrix4;
	/**
	 * Multiplies this matrix by m.
	 */
	multiply(m: Matrix4): Matrix4;
	premultiply(m: Matrix4): Matrix4;
	/**
	 * Sets this matrix to a x b.
	 */
	multiplyMatrices(a: Matrix4, b: Matrix4): Matrix4;
	/**
	 * Sets this matrix to a x b and stores the result into the flat array r.
	 * r can be either a regular Array or a TypedArray.
	 *
	 * @deprecated This method has been removed completely.
	 */
	multiplyToArray(a: Matrix4, b: Matrix4, r: number[]): Matrix4;
	/**
	 * Multiplies this matrix by s.
	 */
	multiplyScalar(s: number): Matrix4;
	/**
	 * Computes determinant of this matrix.
	 * Based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm
	 */
	determinant(): number;
	/**
	 * Transposes this matrix.
	 */
	transpose(): Matrix4;
	/**
	 * Sets the position component for this matrix from vector v.
	 */
	setPosition(v: Vector3 | number, y?: number, z?: number): Matrix4;
	/**
	 * Inverts this matrix.
	 */
	invert(): Matrix4;
	/**
	 * Multiplies the columns of this matrix by vector v.
	 */
	scale(v: Vector3): Matrix4;
	getMaxScaleOnAxis(): number;
	/**
	 * Sets this matrix as translation transform.
	 */
	makeTranslation(x: number, y: number, z: number): Matrix4;
	/**
	 * Sets this matrix as rotation transform around x axis by theta radians.
	 *
	 * @param theta Rotation angle in radians.
	 */
	makeRotationX(theta: number): Matrix4;
	/**
	 * Sets this matrix as rotation transform around y axis by theta radians.
	 *
	 * @param theta Rotation angle in radians.
	 */
	makeRotationY(theta: number): Matrix4;
	/**
	 * Sets this matrix as rotation transform around z axis by theta radians.
	 *
	 * @param theta Rotation angle in radians.
	 */
	makeRotationZ(theta: number): Matrix4;
	/**
	 * Sets this matrix as rotation transform around axis by angle radians.
	 * Based on http://www.gamedev.net/reference/articles/article1199.asp.
	 *
	 * @param axis Rotation axis.
	 * @param theta Rotation angle in radians.
	 */
	makeRotationAxis(axis: Vector3, angle: number): Matrix4;
	/**
	 * Sets this matrix as scale transform.
	 */
	makeScale(x: number, y: number, z: number): Matrix4;
	/**
	 * Sets this matrix as shear transform.
	 */
	makeShear(xy: number, xz: number, yx: number, yz: number, zx: number, zy: number): Matrix4;
	/**
	 * Sets this matrix to the transformation composed of translation, rotation and scale.
	 */
	compose(translation: Vector3, rotation: Quaternion, scale: Vector3): Matrix4;
	/**
	 * Decomposes this matrix into it's position, quaternion and scale components.
	 */
	decompose(translation: Vector3, rotation: Quaternion, scale: Vector3): Matrix4;
	/**
	 * Creates a frustum matrix.
	 */
	makePerspective(left: number, right: number, bottom: number, top: number, near: number, far: number): Matrix4;
	/**
	 * Creates a perspective projection matrix.
	 */
	makePerspective(fov: number, aspect: number, near: number, far: number): Matrix4;
	/**
	 * Creates an orthographic projection matrix.
	 */
	makeOrthographic(left: number, right: number, top: number, bottom: number, near: number, far: number): Matrix4;
	equals(matrix: Matrix4): boolean;
	/**
	 * Sets the values of this matrix from the provided array or array-like.
	 * @param array the source array or array-like.
	 * @param offset (optional) offset into the array-like. Default is 0.
	 */
	fromArray(array: number[] | ArrayLike<number>, offset?: number): Matrix4;
	/**
	 * Returns an array with the values of this matrix, or copies them into the provided array.
	 * @param array (optional) array to store the matrix to. If this is not provided, a new array will be created.
	 * @param offset (optional) optional offset into the array.
	 * @return The created or provided array.
	 */
	toArray(array?: number[], offset?: number): number[];
	toArray(array?: Matrix4Tuple, offset?: 0): Matrix4Tuple;
	/**
	 * Copies he values of this matrix into the provided array-like.
	 * @param array array-like to store the matrix to.
	 * @param offset (optional) optional offset into the array-like.
	 * @return The provided array-like.
	 */
	toArray(array?: ArrayLike<number>, offset?: number): ArrayLike<number>;
	/**
	 * Set the upper 3x3 elements of this matrix to the values of the Matrix3 m.
	 */
	setFromMatrix3(m: Matrix3): Matrix4;
	/**
	 * @deprecated Use {@link Matrix4#copyPosition .copyPosition()} instead.
	 */
	extractPosition(m: Matrix4): Matrix4;
	/**
	 * @deprecated Use {@link Matrix4#makeRotationFromQuaternion .makeRotationFromQuaternion()} instead.
	 */
	setRotationFromQuaternion(q: Quaternion): Matrix4;
	/**
	 * @deprecated Use {@link Vector3#applyMatrix4 vector.applyMatrix4( matrix )} instead.
	 */
	multiplyVector3(v: any): any;
	/**
	 * @deprecated Use {@link Vector4#applyMatrix4 vector.applyMatrix4( matrix )} instead.
	 */
	multiplyVector4(v: any): any;
	/**
	 * @deprecated This method has been removed completely.
	 */
	multiplyVector3Array(array: number[]): number[];
	/**
	 * @deprecated Use {@link Vector3#transformDirection Vector3.transformDirection( matrix )} instead.
	 */
	rotateAxis(v: any): void;
	/**
	 * @deprecated Use {@link Vector3#applyMatrix4 vector.applyMatrix4( matrix )} instead.
	 */
	crossVector(v: any): void;
	/**
	 * @deprecated Use {@link Matrix4#toArray .toArray()} instead.
	 */
	flattenToArrayOffset(array: number[], offset: number): number[];
	/**
	 * @deprecated Use {@link Matrix4#invert .invert()} instead.
	 */
	getInverse(matrix: Matrix): Matrix;
}
export type Matrix3Tuple = [number, number, number, number, number, number, number, number, number];
/**
 * ( interface Matrix<T> )
 */
export interface Matrix {
	/**
	 * Array with matrix values.
	 */
	elements: number[];
	/**
	 * identity():T;
	 */
	identity(): Matrix;
	/**
	 * copy(m:T):T;
	 */
	copy(m: this): this;
	/**
	 * multiplyScalar(s:number):T;
	 */
	multiplyScalar(s: number): Matrix;
	determinant(): number;
	/**
	 * transpose():T;
	 */
	transpose(): Matrix;
	/**
	 * invert():T;
	 */
	invert(): Matrix;
	/**
	 * clone():T;
	 */
	clone(): Matrix;
}
declare class Matrix3 implements Matrix {
	/**
	 * Creates an identity matrix.
	 */
	constructor();
	/**
	 * Array with matrix values.
	 * @default [1, 0, 0, 0, 1, 0, 0, 0, 1]
	 */
	elements: number[];
	set(
		n11: number,
		n12: number,
		n13: number,
		n21: number,
		n22: number,
		n23: number,
		n31: number,
		n32: number,
		n33: number
	): Matrix3;
	identity(): Matrix3;
	clone(): this;
	copy(m: Matrix3): this;
	extractBasis(xAxis: Vector3, yAxis: Vector3, zAxis: Vector3): Matrix3;
	setFromMatrix4(m: Matrix4): Matrix3;
	multiplyScalar(s: number): Matrix3;
	determinant(): number;
	/**
	 * Inverts this matrix in place.
	 */
	invert(): Matrix3;
	/**
	 * Transposes this matrix in place.
	 */
	transpose(): Matrix3;
	getNormalMatrix(matrix4: Matrix4): Matrix3;
	/**
	 * Transposes this matrix into the supplied array r, and returns itself.
	 */
	transposeIntoArray(r: number[]): Matrix3;
	setUvTransform(tx: number, ty: number, sx: number, sy: number, rotation: number, cx: number, cy: number): Matrix3;
	scale(sx: number, sy: number): Matrix3;
	/**
	 * Sets this matrix as a 2D translation transform:
	 *
	 * ```
	 * 1, 0, x,
	 * 0, 1, y,
	 * 0, 0, 1
	 * ```
	 *
	 * @param x the amount to translate in the X axis.
	 * @param y the amount to translate in the Y axis.
	 */
	makeTranslation(x: number, y: number): this;
	makeTranslation(x: number, y: number): Matrix3;
	/**
	 * Sets this matrix as a 2D rotational transformation by theta radians. The resulting matrix will be:
	 *
	 * ```
	 * cos() -sin() 0
	 * sin() cos()  0
	 * 0      0       1
	 * ```
	 *
	 * @param theta Rotation angle in radians. Positive values rotate counterclockwise.
	 */
	makeRotation(theta: number): this;
	makeRotation(theta: number): Matrix3;
	/**
	 * Sets this matrix as a 2D scale transform:
	 *
	 * ```
	 * x, 0, 0,
	 * 0, y, 0,
	 * 0, 0, 1
	 * ```
	 *
	 * @param x the amount to scale in the X axis.
	 * @param y the amount to scale in the Y axis.
	 */
	makeScale(x: number, y: number): this;
	makeScale(x: number, y: number): Matrix3;
	rotate(theta: number): Matrix3;
	translate(tx: number, ty: number): Matrix3;
	equals(matrix: Matrix3): boolean;
	/**
	 * Sets the values of this matrix from the provided array or array-like.
	 * @param array the source array or array-like.
	 * @param offset (optional) offset into the array-like. Default is 0.
	 */
	fromArray(array: number[] | ArrayLike<number>, offset?: number): Matrix3;
	/**
	 * Returns an array with the values of this matrix, or copies them into the provided array.
	 * @param array (optional) array to store the matrix to. If this is not provided, a new array will be created.
	 * @param offset (optional) optional offset into the array.
	 * @return The created or provided array.
	 */
	toArray(array?: number[], offset?: number): number[];
	toArray(array?: Matrix3Tuple, offset?: 0): Matrix3Tuple;
	/**
	 * Copies he values of this matrix into the provided array-like.
	 * @param array array-like to store the matrix to.
	 * @param offset (optional) optional offset into the array-like.
	 * @return The provided array-like.
	 */
	toArray(array?: ArrayLike<number>, offset?: number): ArrayLike<number>;
	/**
	 * Multiplies this matrix by m.
	 */
	multiply(m: Matrix3): Matrix3;
	premultiply(m: Matrix3): Matrix3;
	/**
	 * Sets this matrix to a x b.
	 */
	multiplyMatrices(a: Matrix3, b: Matrix3): Matrix3;
	/**
	 * @deprecated Use {@link Vector3.applyMatrix3 vector.applyMatrix3( matrix )} instead.
	 */
	multiplyVector3(vector: Vector3): any;
	/**
	 * @deprecated This method has been removed completely.
	 */
	multiplyVector3Array(a: any): any;
	/**
	 * @deprecated Use {@link Matrix3#invert .invert()} instead.
	 */
	getInverse(matrix: Matrix4, throwOnDegenerate?: boolean): Matrix3;
	getInverse(matrix: Matrix): Matrix;
	/**
	 * @deprecated Use {@link Matrix3#toArray .toArray()} instead.
	 */
	flattenToArrayOffset(array: number[], offset: number): number[];
}
declare class BufferAttribute {
	/**
	 * @param array - Must be a TypedArray. Used to instantiate the buffer.
	 * This array should have
	 * ```
	 * itemSize * numVertices
	 * ```
	 * elements, where numVertices is the number of vertices in the associated BufferGeometry.
	 * @param itemSize - the number of values of the array that should be associated with a particular vertex.
	 * For instance, if this attribute is storing a 3-component vector (such as a position, normal, or color),
	 * then itemSize should be 3.
	 * @param normalized - (optional) Applies to integer data only.
	 * Indicates how the underlying data in the buffer maps to the values in the GLSL code.
	 * For instance, if array is an instance of UInt16Array, and normalized is true,
	 * the values 0 - +65535 in the array data will be mapped to 0.0f - +1.0f in the GLSL attribute.
	 * An Int16Array (signed) would map from -32768 - +32767 to -1.0f - +1.0f.
	 * If normalized is false, the values will be converted to floats unmodified,
	 * i.e. 32767 becomes 32767.0f.
	 */
	constructor(array: ArrayLike<number>, itemSize: number, normalized?: boolean); // array parameter should be TypedArray.
	/**
	 * @default ''
	 */
	name: string;
	array: ArrayLike<number>;
	itemSize: number;
	/**
	 * @default THREE.StaticDrawUsage
	 */
	usage: Usage;
	/**
	 * @default { offset: number; count: number }
	 */
	updateRange: {
		offset: number;
		count: number;
	};
	/**
	 * @default 0
	 */
	version: number;
	/**
	 * @default false
	 */
	normalized: boolean;
	/**
	 * @default 0
	 */
	count: number;
	set needsUpdate(value: boolean);
	readonly isBufferAttribute: true;
	onUploadCallback: () => void;
	onUpload(callback: () => void): this;
	setUsage(usage: Usage): this;
	clone(): this;
	copy(source: BufferAttribute): this;
	copyAt(index1: number, attribute: BufferAttribute, index2: number): this;
	copyArray(array: ArrayLike<number>): this;
	applyMatrix3(m: Matrix3): this;
	applyMatrix4(m: Matrix4): this;
	applyNormalMatrix(m: Matrix3): this;
	transformDirection(m: Matrix4): this;
	set(value: ArrayLike<number> | ArrayBufferView, offset?: number): this;
	getX(index: number): number;
	setX(index: number, x: number): this;
	getY(index: number): number;
	setY(index: number, y: number): this;
	getZ(index: number): number;
	setZ(index: number, z: number): this;
	getW(index: number): number;
	setW(index: number, z: number): this;
	setXY(index: number, x: number, y: number): this;
	setXYZ(index: number, x: number, y: number, z: number): this;
	setXYZW(index: number, x: number, y: number, z: number, w: number): this;
	toJSON(): {
		itemSize: number;
		type: string;
		array: number[];
		normalized: boolean;
	};
}
export interface HSL {
	h: number;
	s: number;
	l: number;
}
export interface RGB {
	r: number;
	g: number;
	b: number;
}
declare class Color {
	constructor(color?: ColorRepresentation);
	constructor(r: number, g: number, b: number);
	readonly isColor: true;
	/**
	 * Red channel value between 0 and 1. Default is 1.
	 * @default 1
	 */
	r: number;
	/**
	 * Green channel value between 0 and 1. Default is 1.
	 * @default 1
	 */
	g: number;
	/**
	 * Blue channel value between 0 and 1. Default is 1.
	 * @default 1
	 */
	b: number;
	set(color: ColorRepresentation): Color;
	setScalar(scalar: number): Color;
	setHex(hex: number, colorSpace?: ColorSpace): Color;
	/**
	 * Sets this color from RGB values.
	 * @param r Red channel value between 0 and 1.
	 * @param g Green channel value between 0 and 1.
	 * @param b Blue channel value between 0 and 1.
	 */
	setRGB(r: number, g: number, b: number, colorSpace?: ColorSpace): Color;
	/**
	 * Sets this color from HSL values.
	 * Based on MochiKit implementation by Bob Ippolito.
	 *
	 * @param h Hue channel value between 0 and 1.
	 * @param s Saturation value channel between 0 and 1.
	 * @param l Value channel value between 0 and 1.
	 */
	setHSL(h: number, s: number, l: number, colorSpace?: ColorSpace): Color;
	/**
	 * Sets this color from a CSS context style string.
	 * @param contextStyle Color in CSS context style format.
	 */
	setStyle(style: string, colorSpace?: ColorSpace): Color;
	/**
	 * Sets this color from a color name.
	 * Faster than {@link Color#setStyle .setStyle()} method if you don't need the other CSS-style formats.
	 * @param style Color name in X11 format.
	 */
	setColorName(style: string, colorSpace?: ColorSpace): Color;
	/**
	 * Clones this color.
	 */
	clone(): this;
	/**
	 * Copies given color.
	 * @param color Color to copy.
	 */
	copy(color: Color): this;
	/**
	 * Copies given color making conversion from sRGB to linear space.
	 * @param color Color to copy.
	 */
	copySRGBToLinear(color: Color): Color;
	/**
	 * Copies given color making conversion from linear to sRGB space.
	 * @param color Color to copy.
	 */
	copyLinearToSRGB(color: Color): Color;
	/**
	 * Converts this color from sRGB to linear space.
	 */
	convertSRGBToLinear(): Color;
	/**
	 * Converts this color from linear to sRGB space.
	 */
	convertLinearToSRGB(): Color;
	/**
	 * Returns the hexadecimal value of this color.
	 */
	getHex(colorSpace?: ColorSpace): number;
	/**
	 * Returns the string formated hexadecimal value of this color.
	 */
	getHexString(colorSpace?: ColorSpace): string;
	getHSL(target: HSL, colorSpace?: ColorSpace): HSL;
	getRGB(target: RGB, colorSpace?: ColorSpace): RGB;
	/**
	 * Returns the value of this color in CSS context style.
	 * Example: rgb(r, g, b)
	 */
	getStyle(colorSpace?: ColorSpace): string;
	offsetHSL(h: number, s: number, l: number): this;
	add(color: Color): this;
	addColors(color1: Color, color2: Color): this;
	addScalar(s: number): this;
	sub(color: Color): this;
	multiply(color: Color): this;
	multiplyScalar(s: number): this;
	lerp(color: Color, alpha: number): this;
	lerpColors(color1: Color, color2: Color, alpha: number): this;
	lerpHSL(color: Color, alpha: number): this;
	equals(color: Color): boolean;
	/**
	 * Sets this color's red, green and blue value from the provided array or array-like.
	 * @param array the source array or array-like.
	 * @param offset (optional) offset into the array-like. Default is 0.
	 */
	fromArray(array: number[] | ArrayLike<number>, offset?: number): this;
	/**
	 * Returns an array [red, green, blue], or copies red, green and blue into the provided array.
	 * @param array (optional) array to store the color to. If this is not provided, a new array will be created.
	 * @param offset (optional) optional offset into the array.
	 * @return The created or provided array.
	 */
	toArray(array?: number[], offset?: number): number[];
	/**
	 * Copies red, green and blue into the provided array-like.
	 * @param array array-like to store the color to.
	 * @param offset (optional) optional offset into the array-like.
	 * @return The provided array-like.
	 */
	toArray(xyz: ArrayLike<number>, offset?: number): ArrayLike<number>;
	fromBufferAttribute(attribute: BufferAttribute, index: number): this;
	[Symbol.iterator](): Generator<number, void>;
	/**
	 * List of X11 color names.
	 */
	static NAMES: Record<string, number>;
}
export type ColorRepresentation = Color | string | number;
declare class AnimationObjectGroup {
	constructor(...args: any[]);
	uuid: string;
	stats: {
		bindingsPerObject: number;
		objects: {
			total: number;
			inUse: number;
		};
	};
	readonly isAnimationObjectGroup: true;
	add(...args: any[]): void;
	remove(...args: any[]): void;
	uncache(...args: any[]): void;
}
declare class AnimationAction {
	constructor(mixer: AnimationMixer, clip: AnimationClip, localRoot?: Object3D, blendMode?: AnimationBlendMode);
	blendMode: AnimationBlendMode;
	/**
	 * @default THREE.LoopRepeat
	 */
	loop: AnimationActionLoopStyles;
	/**
	 * @default 0
	 */
	time: number;
	/**
	 * @default 1
	 */
	timeScale: number;
	/**
	 * @default 1
	 */
	weight: number;
	/**
	 * @default Infinity
	 */
	repetitions: number;
	/**
	 * @default false
	 */
	paused: boolean;
	/**
	 * @default true
	 */
	enabled: boolean;
	/**
	 * @default false
	 */
	clampWhenFinished: boolean;
	/**
	 * @default true
	 */
	zeroSlopeAtStart: boolean;
	/**
	 * @default true
	 */
	zeroSlopeAtEnd: boolean;
	play(): AnimationAction;
	stop(): AnimationAction;
	reset(): AnimationAction;
	isRunning(): boolean;
	isScheduled(): boolean;
	startAt(time: number): AnimationAction;
	setLoop(mode: AnimationActionLoopStyles, repetitions: number): AnimationAction;
	setEffectiveWeight(weight: number): AnimationAction;
	getEffectiveWeight(): number;
	fadeIn(duration: number): AnimationAction;
	fadeOut(duration: number): AnimationAction;
	crossFadeFrom(fadeOutAction: AnimationAction, duration: number, warp: boolean): AnimationAction;
	crossFadeTo(fadeInAction: AnimationAction, duration: number, warp: boolean): AnimationAction;
	stopFading(): AnimationAction;
	setEffectiveTimeScale(timeScale: number): AnimationAction;
	getEffectiveTimeScale(): number;
	setDuration(duration: number): AnimationAction;
	syncWith(action: AnimationAction): AnimationAction;
	halt(duration: number): AnimationAction;
	warp(statTimeScale: number, endTimeScale: number, duration: number): AnimationAction;
	stopWarping(): AnimationAction;
	getMixer(): AnimationMixer;
	getClip(): AnimationClip;
	getRoot(): Object3D;
}
declare class AnimationMixer extends EventDispatcher {
	constructor(root: Object3D | AnimationObjectGroup);
	/**
	 * @default 0
	 */
	time: number;
	/**
	 * @default 1.0
	 */
	timeScale: number;
	clipAction(
		clip: AnimationClip,
		root?: Object3D | AnimationObjectGroup,
		blendMode?: AnimationBlendMode
	): AnimationAction;
	existingAction(clip: AnimationClip, root?: Object3D | AnimationObjectGroup): AnimationAction | null;
	stopAllAction(): AnimationMixer;
	update(deltaTime: number): AnimationMixer;
	setTime(timeInSeconds: number): AnimationMixer;
	getRoot(): Object3D | AnimationObjectGroup;
	uncacheClip(clip: AnimationClip): void;
	uncacheRoot(root: Object3D | AnimationObjectGroup): void;
	uncacheAction(clip: AnimationClip, root?: Object3D | AnimationObjectGroup): void;
}
declare class OrthographicCamera extends Camera {
	/**
	 * @param left Camera frustum left plane.
	 * @param right Camera frustum right plane.
	 * @param top Camera frustum top plane.
	 * @param bottom Camera frustum bottom plane.
	 * @param [near=0.1] Camera frustum near plane.
	 * @param [far=2000] Camera frustum far plane.
	 */
	constructor(left?: number, right?: number, top?: number, bottom?: number, near?: number, far?: number);
	type: 'OrthographicCamera';
	readonly isOrthographicCamera: true;
	/**
	 * @default 1
	 */
	zoom: number;
	/**
	 * @default null
	 */
	view: null | {
		enabled: boolean;
		fullWidth: number;
		fullHeight: number;
		offsetX: number;
		offsetY: number;
		width: number;
		height: number;
	};
	/**
	 * Camera frustum left plane.
	 * @default -1
	 */
	left: number;
	/**
	 * Camera frustum right plane.
	 * @default 1
	 */
	right: number;
	/**
	 * Camera frustum top plane.
	 * @default 1
	 */
	top: number;
	/**
	 * Camera frustum bottom plane.
	 * @default -1
	 */
	bottom: number;
	/**
	 * Camera frustum near plane.
	 * @default 0.1
	 */
	near: number;
	/**
	 * Camera frustum far plane.
	 * @default 2000
	 */
	far: number;
	/**
	 * Updates the camera projection matrix. Must be called after change of parameters.
	 */
	updateProjectionMatrix(): void;
	setViewOffset(
		fullWidth: number,
		fullHeight: number,
		offsetX: number,
		offsetY: number,
		width: number,
		height: number
	): void;
	clearViewOffset(): void;
	toJSON(meta?: any): any;
}
declare class CubeTexture extends Texture {
	/**
	 * @param [images=[]]
	 * @param [mapping=THREE.CubeReflectionMapping]
	 * @param [wrapS=THREE.ClampToEdgeWrapping]
	 * @param [wrapT=THREE.ClampToEdgeWrapping]
	 * @param [magFilter=THREE.LinearFilter]
	 * @param [minFilter=THREE.LinearMipmapLinearFilter]
	 * @param [format=THREE.RGBAFormat]
	 * @param [type=THREE.UnsignedByteType]
	 * @param [anisotropy=1]
	 * @param [encoding=THREE.LinearEncoding]
	 */
	constructor(
		images?: any[], // HTMLImageElement or HTMLCanvasElement
		mapping?: Mapping,
		wrapS?: Wrapping,
		wrapT?: Wrapping,
		magFilter?: TextureFilter,
		minFilter?: TextureFilter,
		format?: PixelFormat,
		type?: TextureDataType,
		anisotropy?: number,
		encoding?: TextureEncoding
	);
	images: any; // returns and sets the value of Texture.image in the codde ?
	/**
	 * @default false
	 */
	flipY: boolean;
	readonly isCubeTexture: true;
}
declare class WebGLCubeRenderTarget extends WebGLRenderTarget {
	constructor(size?: number, options?: WebGLRenderTargetOptions);
	texture: CubeTexture;
	fromEquirectangularTexture(renderer: WebGLRenderer, texture: Texture): this;
	clear(renderer: WebGLRenderer, color: boolean, depth: boolean, stencil: boolean): void;
}
declare class Uniform<T = any> {
	constructor(value: T);
	/**
	 * @deprecated
	 */
	constructor(type: string, value: T);
	/**
	 * @deprecated
	 */
	type: string;
	value: T;
	/**
	 * @deprecated Use {@link Object3D#onBeforeRender object.onBeforeRender()} instead.
	 */
	dynamic: boolean;
	/**
	 * @deprecated Use {@link Object3D#onBeforeRender object.onBeforeRender()} instead.
	 */
	onUpdate(callback: () => void): Uniform<T>;
}
declare class Curve<T extends Vector> {
	/**
	 * @default 'Curve'
	 */
	type: string;
	/**
	 * This value determines the amount of divisions when calculating the cumulative segment lengths of a curve via .getLengths.
	 * To ensure precision when using methods like .getSpacedPoints, it is recommended to increase .arcLengthDivisions if the curve is very large.
	 * @default 200
	 */
	arcLengthDivisions: number;
	/**
	 * Returns a vector for point t of the curve where t is between 0 and 1
	 * getPoint(t: number, optionalTarget?: T): T;
	 */
	getPoint(t: number, optionalTarget?: T): T;
	/**
	 * Returns a vector for point at relative position in curve according to arc length
	 * getPointAt(u: number, optionalTarget?: T): T;
	 */
	getPointAt(u: number, optionalTarget?: T): T;
	/**
	 * Get sequence of points using getPoint( t )
	 * getPoints(divisions?: number): T[];
	 */
	getPoints(divisions?: number): T[];
	/**
	 * Get sequence of equi-spaced points using getPointAt( u )
	 * getSpacedPoints(divisions?: number): T[];
	 */
	getSpacedPoints(divisions?: number): T[];
	/**
	 * Get total curve arc length
	 */
	getLength(): number;
	/**
	 * Get list of cumulative segment lengths
	 */
	getLengths(divisions?: number): number[];
	/**
	 * Update the cumlative segment distance cache
	 */
	updateArcLengths(): void;
	/**
	 * Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equi distance
	 */
	getUtoTmapping(u: number, distance: number): number;
	/**
	 * Returns a unit vector tangent at t. If the subclassed curve do not implement its tangent derivation, 2 points a
	 * small delta apart will be used to find its gradient which seems to give a reasonable approximation
	 * getTangent(t: number, optionalTarget?: T): T;
	 */
	getTangent(t: number, optionalTarget?: T): T;
	/**
	 * Returns tangent at equidistance point u on the curve
	 * getTangentAt(u: number, optionalTarget?: T): T;
	 */
	getTangentAt(u: number, optionalTarget?: T): T;
	/**
	 * Generate Frenet frames of the curve
	 */
	computeFrenetFrames(
		segments: number,
		closed?: boolean
	): {
		tangents: Vector3[];
		normals: Vector3[];
		binormals: Vector3[];
	};
	clone(): this;
	copy(source: Curve<T>): this;
	toJSON(): object;
	fromJSON(json: object): this;
	/**
	 * @deprecated since r84.
	 */
	static create(constructorFunc: () => void, getPointFunc: () => void): () => void;
}
declare class CatmullRomCurve3 extends Curve<Vector3> {
	/**
	 * @param [points=[]]
	 * @param [closed=false]
	 * @param [curveType='centripetal']
	 * @param [tension=0.5]
	 */
	constructor(points?: Vector3[], closed?: boolean, curveType?: string, tension?: number);
	/**
	 * @default 'CatmullRomCurve3'
	 */
	type: string;
	/**
	 * @default []
	 */
	points: Vector3[];
}
declare class Line<
	TGeometry extends BufferGeometry = BufferGeometry,
	TMaterial extends Material | Material[] = Material | Material[]
> extends Object3D {
	constructor(geometry?: TGeometry, material?: TMaterial);
	geometry: TGeometry;
	material: TMaterial;
	type: 'Line' | 'LineLoop' | 'LineSegments' | string;
	readonly isLine: true;
	morphTargetInfluences?: number[] | undefined;
	morphTargetDictionary?:
		| {
				[key: string]: number;
		  }
		| undefined;
	computeLineDistances(): this;
	raycast(raycaster: Raycaster, intersects: Intersection[]): void;
	updateMorphTargets(): void;
}
declare class LineSegments<
	TGeometry extends BufferGeometry = BufferGeometry,
	TMaterial extends Material | Material[] = Material | Material[]
> extends Line<TGeometry, TMaterial> {
	constructor(geometry?: TGeometry, material?: TMaterial);
	/**
	 * @default 'LineSegments'
	 */
	type: 'LineSegments' | string;
	readonly isLineSegments: true;
}
declare class PointLightShadow extends LightShadow {
	camera: PerspectiveCamera;
}
declare class PointLight extends Light {
	constructor(color?: ColorRepresentation, intensity?: number, distance?: number, decay?: number);
	/**
	 * @default 'PointLight'
	 */
	type: string;
	/**
	 * Light's intensity.
	 * @default 2
	 */
	intensity: number;
	/**
	 * If non-zero, light will attenuate linearly from maximum intensity at light position down to zero at distance.
	 * @default 0
	 */
	distance: number;
	/**
	 * If set to `true` light will cast dynamic shadows.
	 * **Warning**: This is expensive and requires tweaking to get shadows looking right.
	 * See the {@link PointLightShadow} for details.
	 * The default is `false`.
	 */
	castShadow: boolean;
	/**
	 * @default 1
	 */
	decay: number;
	/**
	 * @default new THREE.PointLightShadow()
	 */
	shadow: PointLightShadow;
	power: number;
}
declare class HemisphereLight extends Light {
	/**
	 * @param skyColor
	 * @param groundColor
	 * @param [intensity=1]
	 */
	constructor(skyColor?: ColorRepresentation, groundColor?: ColorRepresentation, intensity?: number);
	/**
	 * @default 'HemisphereLight'
	 */
	type: string;
	/**
	 * This is set equal to {@link Object3D.DEFAULT_UP} (0, 1, 0), so that the light shines from the top down.
	 *
	 * @default {@link Object3D.DEFAULT_UP}
	 */
	position: Vector3;
	groundColor: Color;
	readonly isHemisphereLight: true;
}
/**
 * parameters is an object with one or more properties defining the material's appearance.
 */
export interface MeshBasicMaterialParameters extends MaterialParameters {
	color?: ColorRepresentation | undefined;
	opacity?: number | undefined;
	map?: Texture | null | undefined;
	lightMap?: Texture | null;
	lightMapIntensity?: number | undefined;
	aoMap?: Texture | null | undefined;
	aoMapIntensity?: number | undefined;
	specularMap?: Texture | null | undefined;
	alphaMap?: Texture | null | undefined;
	fog?: boolean | undefined;
	envMap?: Texture | null | undefined;
	combine?: Combine | undefined;
	reflectivity?: number | undefined;
	refractionRatio?: number | undefined;
	wireframe?: boolean | undefined;
	wireframeLinewidth?: number | undefined;
	wireframeLinecap?: string | undefined;
	wireframeLinejoin?: string | undefined;
}
declare class MeshBasicMaterial extends Material {
	constructor(parameters?: MeshBasicMaterialParameters);
	/**
	 * @default 'MeshBasicMaterial'
	 */
	type: string;
	/**
	 * @default new THREE.Color( 0xffffff )
	 */
	color: Color;
	/**
	 * @default null
	 */
	map: Texture | null;
	/**
	 * @default null
	 */
	lightMap: Texture | null;
	/**
	 * @default 1
	 */
	lightMapIntensity: number;
	/**
	 * @default null
	 */
	aoMap: Texture | null;
	/**
	 * @default 1
	 */
	aoMapIntensity: number;
	/**
	 * @default null
	 */
	specularMap: Texture | null;
	/**
	 * @default null
	 */
	alphaMap: Texture | null;
	/**
	 * @default null
	 */
	envMap: Texture | null;
	/**
	 * @default THREE.MultiplyOperation
	 */
	combine: Combine;
	/**
	 * @default 1
	 */
	reflectivity: number;
	/**
	 * @default 0.98
	 */
	refractionRatio: number;
	/**
	 * @default false
	 */
	wireframe: boolean;
	/**
	 * @default 1
	 */
	wireframeLinewidth: number;
	/**
	 * @default 'round'
	 */
	wireframeLinecap: string;
	/**
	 * @default 'round'
	 */
	wireframeLinejoin: string;
	/**
	 * Whether the material is affected by fog. Default is true.
	 * @default fog
	 */
	fog: boolean;
	setValues(parameters: MeshBasicMaterialParameters): void;
}
declare class DirectionalLightShadow extends LightShadow {
	camera: OrthographicCamera;
	readonly isDirectionalLightShadow: true;
}
declare class DirectionalLight extends Light {
	constructor(color?: ColorRepresentation, intensity?: number);
	/**
	 * @default 'DirectionalLight'
	 */
	type: string;
	/**
	 * This is set equal to {@link Object3D.DEFAULT_UP} (0, 1, 0), so that the light shines from the top down.
	 *
	 * @default {@link Object3D.DEFAULT_UP}
	 */
	readonly position: Vector3;
	/**
	 * Target used for shadow camera orientation.
	 * @default new THREE.Object3D()
	 */
	target: Object3D;
	/**
	 * Light's intensity.
	 * @default 1
	 */
	intensity: number;
	/**
	 * @default new THREE.DirectionalLightShadow()
	 */
	shadow: DirectionalLightShadow;
	readonly isDirectionalLight: true;
}
declare class Mesh<
	TGeometry extends BufferGeometry = BufferGeometry,
	TMaterial extends Material | Material[] = Material | Material[]
> extends Object3D {
	constructor(geometry?: TGeometry, material?: TMaterial);
	geometry: TGeometry;
	material: TMaterial;
	morphTargetInfluences?: number[] | undefined;
	morphTargetDictionary?:
		| {
				[key: string]: number;
		  }
		| undefined;
	readonly isMesh: true;
	type: string;
	updateMorphTargets(): void;
	/**
	 * Get the local-space position of the vertex at the given index,
	 * taking into account the current animation state of both morph targets and skinning.
	 */
	getVertexPosition(index: number, target: Vector3): Vector3;
	raycast(raycaster: Raycaster, intersects: Intersection[]): void;
}
declare class SpotLightShadow extends LightShadow {
	camera: PerspectiveCamera;
	readonly isSpotLightShadow: true;
	/**
	 * @default 1
	 */
	focus: number;
}
declare class SpotLight extends Light {
	constructor(
		color?: ColorRepresentation,
		intensity?: number,
		distance?: number,
		angle?: number,
		penumbra?: number,
		decay?: number
	);
	/**
	 * @default 'SpotLight'
	 */
	type: string;
	/**
	 * This is set equal to {@link Object3D.DEFAULT_UP} (0, 1, 0), so that the light shines from the top down.
	 *
	 * @default {@link Object3D.DEFAULT_UP}
	 */
	position: Vector3;
	/**
	 * Spotlight focus points at target.position.
	 * @default new THREE.Object3D()
	 */
	target: Object3D;
	/**
	 * Light's intensity.
	 * @default 2
	 */
	intensity: number;
	/**
	 * If non-zero, light will attenuate linearly from maximum intensity at light position down to zero at distance.
	 * @default 0
	 */
	distance: number;
	/**
	 * Maximum extent of the spotlight, in radians, from its direction.
	 * @default Math.PI / 3.
	 */
	angle: number;
	/**
	 * @default 1
	 */
	decay: number;
	/**
	 * @default new THREE.SpotLightShadow()
	 */
	shadow: SpotLightShadow;
	power: number;
	/**
	 * @default 0
	 */
	penumbra: number;
	/**
	 * @default null
	 */
	map: Texture | null;
	readonly isSpotLight: true;
}
declare class RectAreaLight extends Light {
	constructor(color?: ColorRepresentation, intensity?: number, width?: number, height?: number);
	/**
	 * @default 'RectAreaLight'
	 */
	type: string;
	/**
	 * @default 10
	 */
	width: number;
	/**
	 * @default 10
	 */
	height: number;
	/**
	 * @default 1
	 */
	intensity: number;
	power: number;
	readonly isRectAreaLight: true;
}
declare class AmbientLight extends Light {
	/**
	 * This creates a Ambientlight with a color.
	 * @param color Numeric value of the RGB component of the color or a Color instance.
	 * @param [intensity=1]
	 */
	constructor(color?: ColorRepresentation, intensity?: number);
	/**
	 * @default 'AmbientLight'
	 */
	type: string;
	readonly isAmbientLight: true;
}
declare class SphericalHarmonics3 {
	constructor();
	/**
	 * @default [new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3(),
	 * new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3()]
	 */
	coefficients: Vector3[];
	readonly isSphericalHarmonics3: true;
	set(coefficients: Vector3[]): SphericalHarmonics3;
	zero(): SphericalHarmonics3;
	add(sh: SphericalHarmonics3): SphericalHarmonics3;
	addScaledSH(sh: SphericalHarmonics3, s: number): SphericalHarmonics3;
	scale(s: number): SphericalHarmonics3;
	lerp(sh: SphericalHarmonics3, alpha: number): SphericalHarmonics3;
	equals(sh: SphericalHarmonics3): boolean;
	copy(sh: SphericalHarmonics3): SphericalHarmonics3;
	clone(): this;
	/**
	 * Sets the values of this spherical harmonics from the provided array or array-like.
	 * @param array the source array or array-like.
	 * @param offset (optional) offset into the array. Default is 0.
	 */
	fromArray(array: number[] | ArrayLike<number>, offset?: number): this;
	/**
	 * Returns an array with the values of this spherical harmonics, or copies them into the provided array.
	 * @param array (optional) array to store the spherical harmonics to. If this is not provided, a new array will be created.
	 * @param offset (optional) optional offset into the array.
	 * @return The created or provided array.
	 */
	toArray(array?: number[], offset?: number): number[];
	/**
	 * Returns an array with the values of this spherical harmonics, or copies them into the provided array-like.
	 * @param array array-like to store the spherical harmonics to.
	 * @param offset (optional) optional offset into the array-like.
	 * @return The provided array-like.
	 */
	toArray(array: ArrayLike<number>, offset?: number): ArrayLike<number>;
	getAt(normal: Vector3, target: Vector3): Vector3;
	getIrradianceAt(normal: Vector3, target: Vector3): Vector3;
	static getBasisAt(normal: Vector3, shBasis: number[]): void;
}
declare class LightProbe extends Light {
	constructor(sh?: SphericalHarmonics3, intensity?: number);
	/**
	 * @default 'LightProbe'
	 */
	type: string;
	readonly isLightProbe: true;
	/**
	 * @default new THREE.SphericalHarmonics3()
	 */
	sh: SphericalHarmonics3;
	fromJSON(json: object): LightProbe;
}
declare class Loader {
	constructor(manager?: LoadingManager);
	/**
	 * @default 'anonymous'
	 */
	crossOrigin: string;
	/**
	 * @default: false
	 */
	withCredentials: boolean;
	/**
	 * @default ''
	 */
	path: string;
	/**
	 * @default ''
	 */
	resourcePath: string;
	manager: LoadingManager;
	/**
	 * @default {}
	 */
	requestHeader: {
		[header: string]: string;
	};
	/*
	load(): void;
	loadAsync(): Promise<unknown>;
	parse(): void;
	*/
	setCrossOrigin(crossOrigin: string): this;
	setWithCredentials(value: boolean): this;
	setPath(path: string): this;
	setResourcePath(resourcePath: string): this;
	setRequestHeader(requestHeader: {[header: string]: string}): this;
}
declare class LoadingManager {
	constructor(
		onLoad?: () => void,
		onProgress?: (url: string, loaded: number, total: number) => void,
		onError?: (url: string) => void
	);
	/**
	 * Will be called when loading of an item starts.
	 * @param url The url of the item that started loading.
	 * @param loaded The number of items already loaded so far.
	 * @param total The total amount of items to be loaded.
	 */
	onStart?: ((url: string, loaded: number, total: number) => void) | undefined;
	/**
	 * Will be called when all items finish loading.
	 * The default is a function with empty body.
	 */
	onLoad: () => void;
	/**
	 * Will be called for each loaded item.
	 * The default is a function with empty body.
	 * @param url The url of the item just loaded.
	 * @param loaded The number of items already loaded so far.
	 * @param total The total amount of items to be loaded.
	 */
	onProgress: (url: string, loaded: number, total: number) => void;
	/**
	 * Will be called when item loading fails.
	 * The default is a function with empty body.
	 * @param url The url of the item that errored.
	 */
	onError: (url: string) => void;
	/**
	 * If provided, the callback will be passed each resource URL before a request is sent.
	 * The callback may return the original URL, or a new URL to override loading behavior.
	 * This behavior can be used to load assets from .ZIP files, drag-and-drop APIs, and Data URIs.
	 * @param callback URL modifier callback. Called with url argument, and must return resolvedURL.
	 */
	setURLModifier(callback?: (url: string) => string): this;
	/**
	 * Given a URL, uses the URL modifier callback (if any) and returns a resolved URL.
	 * If no URL modifier is set, returns the original URL.
	 * @param url the url to load
	 */
	resolveURL(url: string): string;
	itemStart(url: string): void;
	itemEnd(url: string): void;
	itemError(url: string): void;
	// handlers
	addHandler(regex: RegExp, loader: Loader): this;
	removeHandler(regex: RegExp): this;
	getHandler(file: string): Loader | null;
}
declare class CompressedTexture extends Texture {
	/**
	 * @param mipmaps
	 * @param width
	 * @param height
	 * @param [format=THREE.RGBAFormat]
	 * @param [type=THREE.UnsignedByteType]
	 * @param [mapping=THREE.Texture.DEFAULT_MAPPING]
	 * @param [wrapS=THREE.ClampToEdgeWrapping]
	 * @param [wrapT=THREE.ClampToEdgeWrapping]
	 * @param [magFilter=THREE.LinearFilter]
	 * @param [minFilter=THREE.LinearMipmapLinearFilter]
	 * @param [anisotropy=1]
	 * @param [encoding=THREE.LinearEncoding]
	 */
	constructor(
		mipmaps: ImageData[],
		width: number,
		height: number,
		format?: CompressedPixelFormat,
		type?: TextureDataType,
		mapping?: Mapping,
		wrapS?: Wrapping,
		wrapT?: Wrapping,
		magFilter?: TextureFilter,
		minFilter?: TextureFilter,
		anisotropy?: number,
		encoding?: TextureEncoding
	);
	get image(): {
		width: number;
		height: number;
	};
	set image(value: {width: number; height: number});
	mipmaps: ImageData[];
	/**
	 * @default false
	 */
	flipY: boolean;
	/**
	 * @default false
	 */
	generateMipmaps: boolean;
	readonly isCompressedTexture: true;
}
declare class CompressedTextureLoader extends Loader {
	constructor(manager?: LoadingManager);
	load(
		url: string,
		onLoad: (texture: CompressedTexture) => void,
		onProgress?: (event: ProgressEvent) => void,
		onError?: (event: ErrorEvent) => void
	): CompressedTexture;
	loadAsync(url: string, onProgress?: (event: ProgressEvent) => void): Promise<CompressedTexture>;
}
declare class DataTexture extends Texture {
	/**
	 * @param data
	 * @param width
	 * @param height
	 * @param [format=THREE.RGBAFormat]
	 * @param [type=THREE.UnsignedByteType]
	 * @param [mapping=THREE.Texture.DEFAULT_MAPPING]
	 * @param [wrapS=THREE.ClampToEdgeWrapping]
	 * @param [wrapT=THREE.ClampToEdgeWrapping]
	 * @param [magFilter=THREE.NearestFilter]
	 * @param [minFilter=THREE.NearestFilter]
	 * @param [anisotropy=1]
	 * @param [encoding=THREE.LinearEncoding]
	 */
	constructor(
		data?: BufferSource | null,
		width?: number,
		height?: number,
		format?: PixelFormat,
		type?: TextureDataType,
		mapping?: Mapping,
		wrapS?: Wrapping,
		wrapT?: Wrapping,
		magFilter?: TextureFilter,
		minFilter?: TextureFilter,
		anisotropy?: number,
		encoding?: TextureEncoding
	);
	get image(): ImageData;
	set image(value: ImageData);
	/**
	 * @default false
	 */
	flipY: boolean;
	/**
	 * @default false
	 */
	generateMipmaps: boolean;
	/**
	 * @default 1
	 */
	unpackAlignment: number;
	/**
	 * @default THREE.DepthFormat
	 */
	format: PixelFormat;
	readonly isDataTexture: true;
}
declare class TextureLoader extends Loader {
	constructor(manager?: LoadingManager);
	load(
		url: string,
		onLoad?: (texture: Texture) => void,
		onProgress?: (event: ProgressEvent) => void,
		onError?: (event: ErrorEvent) => void
	): Texture;
	loadAsync(url: string, onProgress?: (event: ProgressEvent) => void): Promise<Texture>;
}
declare class ImageBitmapLoader extends Loader {
	constructor(manager?: LoadingManager);
	/**
	 * @default { premultiplyAlpha: 'none' }
	 */
	options: undefined | object;
	readonly isImageBitmapLoader: true;
	setOptions(options: object): ImageBitmapLoader;
	load(
		url: string,
		onLoad?: (response: ImageBitmap) => void,
		onProgress?: (request: ProgressEvent) => void,
		onError?: (event: ErrorEvent) => void
	): any;
	loadAsync(url: string, onProgress?: (event: ProgressEvent) => void): Promise<ImageBitmap>;
}
declare class FileLoader extends Loader {
	constructor(manager?: LoadingManager);
	mimeType: undefined | MimeType;
	responseType: undefined | string;
	load(
		url: string,
		onLoad?: (response: string | ArrayBuffer) => void,
		onProgress?: (request: ProgressEvent) => void,
		onError?: (event: ErrorEvent) => void
	): any;
	loadAsync(url: string, onProgress?: (event: ProgressEvent) => void): Promise<string | ArrayBuffer>;
	setMimeType(mimeType: MimeType): FileLoader;
	setResponseType(responseType: string): FileLoader;
}
export interface ShadowMaterialParameters extends MaterialParameters {
	color?: ColorRepresentation | undefined;
	fog?: boolean | undefined;
}
declare class ShadowMaterial extends Material {
	constructor(parameters?: ShadowMaterialParameters);
	/**
	 * @default 'ShadowMaterial'
	 */
	type: string;
	/**
	 * @default new THREE.Color( 0x000000 )
	 */
	color: Color;
	/**
	 * @default true
	 */
	transparent: boolean;
	/**
	 * Whether the material is affected by fog. Default is true.
	 * @default fog
	 */
	fog: boolean;
}
export interface ShaderMaterialParameters extends MaterialParameters {
	uniforms?:
		| {
				[uniform: string]: IUniform;
		  }
		| undefined;
	vertexShader?: string | undefined;
	fragmentShader?: string | undefined;
	linewidth?: number | undefined;
	wireframe?: boolean | undefined;
	wireframeLinewidth?: number | undefined;
	lights?: boolean | undefined;
	clipping?: boolean | undefined;
	fog?: boolean | undefined;
	extensions?:
		| {
				derivatives?: boolean | undefined;
				fragDepth?: boolean | undefined;
				drawBuffers?: boolean | undefined;
				shaderTextureLOD?: boolean | undefined;
		  }
		| undefined;
	glslVersion?: GLSLVersion | undefined;
}
declare class ShaderMaterial extends Material {
	constructor(parameters?: ShaderMaterialParameters);
	/**
	 * @default 'ShaderMaterial'
	 */
	type: string;
	/**
	 * @default {}
	 */
	defines: {
		[key: string]: any;
	};
	/**
	 * @default {}
	 */
	uniforms: {
		[uniform: string]: IUniform;
	};
	vertexShader: string;
	fragmentShader: string;
	/**
	 * @default 1
	 */
	linewidth: number;
	/**
	 * @default false
	 */
	wireframe: boolean;
	/**
	 * @default 1
	 */
	wireframeLinewidth: number;
	/**
	 * @default false
	 */
	fog: boolean;
	/**
	 * @default false
	 */
	lights: boolean;
	/**
	 * @default false
	 */
	clipping: boolean;
	/**
	 * @deprecated Use {@link ShaderMaterial#extensions.derivatives extensions.derivatives} instead.
	 */
	derivatives: any;
	/**
	 * @default { derivatives: false, fragDepth: false, drawBuffers: false, shaderTextureLOD: false }
	 */
	extensions: {
		derivatives: boolean;
		fragDepth: boolean;
		drawBuffers: boolean;
		shaderTextureLOD: boolean;
	};
	/**
	 * @default { 'color': [ 1, 1, 1 ], 'uv': [ 0, 0 ], 'uv2': [ 0, 0 ] }
	 */
	defaultAttributeValues: any;
	/**
	 * @default undefined
	 */
	index0AttributeName: string | undefined;
	/**
	 * @default false
	 */
	uniformsNeedUpdate: boolean;
	/**
	 * @default null
	 */
	glslVersion: GLSLVersion | null;
	isShaderMaterial: boolean;
	setValues(parameters: ShaderMaterialParameters): void;
	toJSON(meta: any): any;
}
export interface PointsMaterialParameters extends MaterialParameters {
	color?: ColorRepresentation | undefined;
	map?: Texture | null | undefined;
	alphaMap?: Texture | null | undefined;
	size?: number | undefined;
	sizeAttenuation?: boolean | undefined;
	fog?: boolean | undefined;
}
declare class PointsMaterial extends Material {
	constructor(parameters?: PointsMaterialParameters);
	/**
	 * @default 'PointsMaterial'
	 */
	type: string;
	/**
	 * @default new THREE.Color( 0xffffff )
	 */
	color: Color;
	/**
	 * @default null
	 */
	map: Texture | null;
	/**
	 * @default null
	 */
	alphaMap: Texture | null;
	/**
	 * @default 1
	 */
	size: number;
	/**
	 * @default true
	 */
	sizeAttenuation: boolean;
	/**
	 * Whether the material is affected by fog. Default is true.
	 * @default fog
	 */
	fog: boolean;
	setValues(parameters: PointsMaterialParameters): void;
}
export interface MeshStandardMaterialParameters extends MaterialParameters {
	color?: ColorRepresentation | undefined;
	roughness?: number | undefined;
	metalness?: number | undefined;
	map?: Texture | null | undefined;
	lightMap?: Texture | null | undefined;
	lightMapIntensity?: number | undefined;
	aoMap?: Texture | null | undefined;
	aoMapIntensity?: number | undefined;
	emissive?: ColorRepresentation | undefined;
	emissiveIntensity?: number | undefined;
	emissiveMap?: Texture | null | undefined;
	bumpMap?: Texture | null | undefined;
	bumpScale?: number | undefined;
	normalMap?: Texture | null | undefined;
	normalMapType?: NormalMapTypes | undefined;
	normalScale?: Vector2 | undefined;
	displacementMap?: Texture | null | undefined;
	displacementScale?: number | undefined;
	displacementBias?: number | undefined;
	roughnessMap?: Texture | null | undefined;
	metalnessMap?: Texture | null | undefined;
	alphaMap?: Texture | null | undefined;
	envMap?: Texture | null | undefined;
	envMapIntensity?: number | undefined;
	wireframe?: boolean | undefined;
	wireframeLinewidth?: number | undefined;
	fog?: boolean | undefined;
	flatShading?: boolean | undefined;
}
declare class MeshStandardMaterial extends Material {
	constructor(parameters?: MeshStandardMaterialParameters);
	/**
	 * @default 'MeshStandardMaterial'
	 */
	type: string;
	/**
	 * @default { 'STANDARD': '' }
	 */
	defines: {
		[key: string]: any;
	};
	/**
	 * @default new THREE.Color( 0xffffff )
	 */
	color: Color;
	/**
	 * @default 1
	 */
	roughness: number;
	/**
	 * @default 0
	 */
	metalness: number;
	/**
	 * @default null
	 */
	map: Texture | null;
	/**
	 * @default null
	 */
	lightMap: Texture | null;
	/**
	 * @default 1
	 */
	lightMapIntensity: number;
	/**
	 * @default null
	 */
	aoMap: Texture | null;
	/**
	 * @default 1
	 */
	aoMapIntensity: number;
	/**
	 * @default new THREE.Color( 0x000000 )
	 */
	emissive: Color;
	/**
	 * @default 1
	 */
	emissiveIntensity: number;
	/**
	 * @default null
	 */
	emissiveMap: Texture | null;
	/**
	 * @default null
	 */
	bumpMap: Texture | null;
	/**
	 * @default 1
	 */
	bumpScale: number;
	/**
	 * @default null
	 */
	normalMap: Texture | null;
	/**
	 * @default THREE.TangentSpaceNormalMap
	 */
	normalMapType: NormalMapTypes;
	/**
	 * @default new THREE.Vector2( 1, 1 )
	 */
	normalScale: Vector2;
	/**
	 * @default null
	 */
	displacementMap: Texture | null;
	/**
	 * @default 1
	 */
	displacementScale: number;
	/**
	 * @default 0
	 */
	displacementBias: number;
	/**
	 * @default null
	 */
	roughnessMap: Texture | null;
	/**
	 * @default null
	 */
	metalnessMap: Texture | null;
	/**
	 * @default null
	 */
	alphaMap: Texture | null;
	/**
	 * @default null
	 */
	envMap: Texture | null;
	/**
	 * @default 1
	 */
	envMapIntensity: number;
	/**
	 * @default false
	 */
	wireframe: boolean;
	/**
	 * @default 1
	 */
	wireframeLinewidth: number;
	/**
	 * @default 'round'
	 */
	wireframeLinecap: string;
	/**
	 * @default 'round'
	 */
	wireframeLinejoin: string;
	/**
	 * Define whether the material is rendered with flat shading. Default is false.
	 * @default false
	 */
	flatShading: boolean;
	/**
	 * Whether the material is affected by fog. Default is true.
	 * @default fog
	 */
	fog: boolean;
	isMeshStandardMaterial: boolean;
	setValues(parameters: MeshStandardMaterialParameters): void;
}
export interface MeshPhysicalMaterialParameters extends MeshStandardMaterialParameters {
	clearcoat?: number | undefined;
	clearcoatMap?: Texture | null | undefined;
	clearcoatRoughness?: number | undefined;
	clearcoatRoughnessMap?: Texture | null | undefined;
	clearcoatNormalScale?: Vector2 | undefined;
	clearcoatNormalMap?: Texture | null | undefined;
	reflectivity?: number | undefined;
	ior?: number | undefined;
	sheen?: number | undefined;
	sheenColor?: Color | undefined;
	sheenRoughness?: number | undefined;
	transmission?: number | undefined;
	transmissionMap?: Texture | null | undefined;
	attenuationDistance?: number | undefined;
	attenuationColor?: Color | undefined;
	specularIntensity?: number | undefined;
	specularColor?: Color | undefined;
	specularIntensityMap?: Texture | null | undefined;
	specularColorMap?: Texture | null | undefined;
}
declare class MeshPhysicalMaterial extends MeshStandardMaterial {
	constructor(parameters?: MeshPhysicalMaterialParameters);
	/**
	 * @default 'MeshPhysicalMaterial'
	 */
	type: string;
	/**
	 * @default { 'STANDARD': '', 'PHYSICAL': '' }
	 */
	defines: {
		[key: string]: any;
	};
	/**
	 * @default 0
	 */
	clearcoat: number;
	/**
	 * @default null
	 */
	clearcoatMap: Texture | null;
	/**
	 * @default 0
	 */
	clearcoatRoughness: number;
	/**
	 * @default null
	 */
	clearcoatRoughnessMap: Texture | null;
	/**
	 * @default new THREE.Vector2( 1, 1 )
	 */
	clearcoatNormalScale: Vector2;
	/**
	 * @default null
	 */
	clearcoatNormalMap: Texture | null;
	/**
	 * @default 0.5
	 */
	reflectivity: number;
	/**
	 * @default 1.5
	 */
	ior: number;
	/**
	 * @default 0.0
	 */
	sheen: number;
	/**
	 * @default Color( 0x000000 )
	 */
	sheenColor: Color;
	/**
	 * @default null
	 */
	sheenColorMap: Texture | null;
	/**
	 * @default 1.0
	 */
	sheenRoughness: number;
	/**
	 * @default null
	 */
	sheenRoughnessMap: Texture | null;
	/**
	 * @default 0
	 */
	transmission: number;
	/**
	 * @default null
	 */
	transmissionMap: Texture | null;
	/**
	 * @default 0.01
	 */
	thickness: number;
	/**
	 * @default null
	 */
	thicknessMap: Texture | null;
	/**
	 * @default 0.0
	 */
	attenuationDistance: number;
	/**
	 * @default Color( 1, 1, 1 )
	 */
	attenuationColor: Color;
	/**
	 * @default 1.0
	 */
	specularIntensity: number;
	/**
	 * @default Color(1, 1, 1)
	 */
	specularColor: Color;
	/**
	 * @default null
	 */
	specularIntensityMap: Texture | null;
	/**
	 * @default null
	 */
	specularColorMap: Texture | null;
	/**
	 * @default null
	 */
	iridescenceMap: Texture | null;
	/**
	 * @default 1.3
	 */
	iridescenceIOR: number;
	/**
	 * @default 0
	 */
	iridescence: number;
	/**
	 * @default [100, 400]
	 */
	iridescenceThicknessRange: number[];
	/**
	 * @default null
	 */
	iridescenceThicknessMap: Texture | null;
}
export interface MeshPhongMaterialParameters extends MaterialParameters {
	/** geometry color in hexadecimal. Default is 0xffffff. */
	color?: ColorRepresentation | undefined;
	specular?: ColorRepresentation | undefined;
	shininess?: number | undefined;
	opacity?: number | undefined;
	map?: Texture | null | undefined;
	lightMap?: Texture | null | undefined;
	lightMapIntensity?: number | undefined;
	aoMap?: Texture | null | undefined;
	aoMapIntensity?: number | undefined;
	emissive?: ColorRepresentation | undefined;
	emissiveIntensity?: number | undefined;
	emissiveMap?: Texture | null | undefined;
	bumpMap?: Texture | null | undefined;
	bumpScale?: number | undefined;
	normalMap?: Texture | null | undefined;
	normalMapType?: NormalMapTypes | undefined;
	normalScale?: Vector2 | undefined;
	displacementMap?: Texture | null | undefined;
	displacementScale?: number | undefined;
	displacementBias?: number | undefined;
	specularMap?: Texture | null | undefined;
	alphaMap?: Texture | null | undefined;
	envMap?: Texture | null | undefined;
	combine?: Combine | undefined;
	reflectivity?: number | undefined;
	refractionRatio?: number | undefined;
	wireframe?: boolean | undefined;
	wireframeLinewidth?: number | undefined;
	wireframeLinecap?: string | undefined;
	wireframeLinejoin?: string | undefined;
	fog?: boolean | undefined;
	flatShading?: boolean | undefined;
}
declare class MeshPhongMaterial extends Material {
	constructor(parameters?: MeshPhongMaterialParameters);
	/**
	 * @default 'MeshNormalMaterial'
	 */
	type: string;
	/**
	 * @default new THREE.Color( 0xffffff )
	 */
	color: Color;
	/**
	 * @default new THREE.Color( 0x111111 )
	 */
	specular: Color;
	/**
	 * @default 30
	 */
	shininess: number;
	/**
	 * @default null
	 */
	map: Texture | null;
	/**
	 * @default null
	 */
	lightMap: Texture | null;
	/**
	 * @default null
	 */
	lightMapIntensity: number;
	/**
	 * @default null
	 */
	aoMap: Texture | null;
	/**
	 * @default null
	 */
	aoMapIntensity: number;
	/**
	 * @default new THREE.Color( 0x000000 )
	 */
	emissive: Color;
	/**
	 * @default 1
	 */
	emissiveIntensity: number;
	/**
	 * @default null
	 */
	emissiveMap: Texture | null;
	/**
	 * @default null
	 */
	bumpMap: Texture | null;
	/**
	 * @default 1
	 */
	bumpScale: number;
	/**
	 * @default null
	 */
	normalMap: Texture | null;
	/**
	 * @default THREE.TangentSpaceNormalMap
	 */
	normalMapType: NormalMapTypes;
	/**
	 * @default new Vector2( 1, 1 )
	 */
	normalScale: Vector2;
	/**
	 * @default null
	 */
	displacementMap: Texture | null;
	/**
	 * @default 1
	 */
	displacementScale: number;
	/**
	 * @default 0
	 */
	displacementBias: number;
	/**
	 * @default null
	 */
	specularMap: Texture | null;
	/**
	 * @default null
	 */
	alphaMap: Texture | null;
	/**
	 * @default null
	 */
	envMap: Texture | null;
	/**
	 * @default THREE.MultiplyOperation
	 */
	combine: Combine;
	/**
	 * @default 1
	 */
	reflectivity: number;
	/**
	 * @default 0.98
	 */
	refractionRatio: number;
	/**
	 * @default false
	 */
	wireframe: boolean;
	/**
	 * @default 1
	 */
	wireframeLinewidth: number;
	/**
	 * @default 'round'
	 */
	wireframeLinecap: string;
	/**
	 * @default 'round'
	 */
	wireframeLinejoin: string;
	/**
	 * Define whether the material is rendered with flat shading. Default is false.
	 * @default false
	 */
	flatShading: boolean;
	/**
	 * @deprecated Use {@link MeshStandardMaterial THREE.MeshStandardMaterial} instead.
	 */
	metal: boolean;
	/**
	 * Whether the material is affected by fog. Default is true.
	 * @default fog
	 */
	fog: boolean;
	setValues(parameters: MeshPhongMaterialParameters): void;
}
export interface MeshToonMaterialParameters extends MaterialParameters {
	/** geometry color in hexadecimal. Default is 0xffffff. */
	color?: ColorRepresentation | undefined;
	opacity?: number | undefined;
	gradientMap?: Texture | null | undefined;
	map?: Texture | null | undefined;
	lightMap?: Texture | null | undefined;
	lightMapIntensity?: number | undefined;
	aoMap?: Texture | null | undefined;
	aoMapIntensity?: number | undefined;
	emissive?: ColorRepresentation | undefined;
	emissiveIntensity?: number | undefined;
	emissiveMap?: Texture | null | undefined;
	bumpMap?: Texture | null | undefined;
	bumpScale?: number | undefined;
	normalMap?: Texture | null | undefined;
	normalMapType?: NormalMapTypes | undefined;
	normalScale?: Vector2 | undefined;
	displacementMap?: Texture | null | undefined;
	displacementScale?: number | undefined;
	displacementBias?: number | undefined;
	alphaMap?: Texture | null | undefined;
	wireframe?: boolean | undefined;
	wireframeLinewidth?: number | undefined;
	wireframeLinecap?: string | undefined;
	wireframeLinejoin?: string | undefined;
	fog?: boolean | undefined;
}
declare class MeshToonMaterial extends Material {
	constructor(parameters?: MeshToonMaterialParameters);
	/**
	 * @default 'MeshToonMaterial'
	 */
	type: string;
	/**
	 * @default { 'TOON': '' }
	 */
	defines: {
		[key: string]: any;
	};
	/**
	 * @default new THREE.Color( 0xffffff )
	 */
	color: Color;
	/**
	 * @default null
	 */
	gradientMap: Texture | null;
	/**
	 * @default null
	 */
	map: Texture | null;
	/**
	 * @default null
	 */
	lightMap: Texture | null;
	/**
	 * @default 1
	 */
	lightMapIntensity: number;
	/**
	 * @default null
	 */
	aoMap: Texture | null;
	/**
	 * @default 1
	 */
	aoMapIntensity: number;
	/**
	 * @default new THREE.Color( 0x000000 )
	 */
	emissive: Color;
	/**
	 * @default 1
	 */
	emissiveIntensity: number;
	/**
	 * @default null
	 */
	emissiveMap: Texture | null;
	/**
	 * @default null
	 */
	bumpMap: Texture | null;
	/**
	 * @default 1
	 */
	bumpScale: number;
	/**
	 * @default null
	 */
	normalMap: Texture | null;
	/**
	 * @default THREE.TangentSpaceNormalMap
	 */
	normalMapType: NormalMapTypes;
	/**
	 * @default new THREE.Vector2( 1, 1 )
	 */
	normalScale: Vector2;
	/**
	 * @default null
	 */
	displacementMap: Texture | null;
	/**
	 * @default 1
	 */
	displacementScale: number;
	/**
	 * @default 0
	 */
	displacementBias: number;
	/**
	 * @default null
	 */
	alphaMap: Texture | null;
	/**
	 * @default false
	 */
	wireframe: boolean;
	/**
	 * @default 1
	 */
	wireframeLinewidth: number;
	/**
	 * @default 'round'
	 */
	wireframeLinecap: string;
	/**
	 * @default 'round'
	 */
	wireframeLinejoin: string;
	/**
	 * Whether the material is affected by fog. Default is true.
	 * @default fog
	 */
	fog: boolean;
	setValues(parameters: MeshToonMaterialParameters): void;
}
export interface MeshNormalMaterialParameters extends MaterialParameters {
	bumpMap?: Texture | null | undefined;
	bumpScale?: number | undefined;
	normalMap?: Texture | null | undefined;
	normalMapType?: NormalMapTypes | undefined;
	normalScale?: Vector2 | undefined;
	displacementMap?: Texture | null | undefined;
	displacementScale?: number | undefined;
	displacementBias?: number | undefined;
	wireframe?: boolean | undefined;
	wireframeLinewidth?: number | undefined;
	flatShading?: boolean | undefined;
}
declare class MeshNormalMaterial extends Material {
	constructor(parameters?: MeshNormalMaterialParameters);
	/**
	 * @default 'MeshNormalMaterial'
	 */
	type: string;
	/**
	 * @default null
	 */
	bumpMap: Texture | null;
	/**
	 * @default 1
	 */
	bumpScale: number;
	/**
	 * @default null
	 */
	normalMap: Texture | null;
	/**
	 * @default THREE.TangentSpaceNormalMap
	 */
	normalMapType: NormalMapTypes;
	/**
	 * @default new THREE.Vector2( 1, 1 )
	 */
	normalScale: Vector2;
	/**
	 * @default null
	 */
	displacementMap: Texture | null;
	/**
	 * @default 1
	 */
	displacementScale: number;
	/**
	 * @default 0
	 */
	displacementBias: number;
	/**
	 * @default false
	 */
	wireframe: boolean;
	/**
	 * @default 1
	 */
	wireframeLinewidth: number;
	/**
	 * Define whether the material is rendered with flat shading. Default is false.
	 * @default false
	 */
	flatShading: boolean;
	setValues(parameters: MeshNormalMaterialParameters): void;
}
export interface MeshLambertMaterialParameters extends MaterialParameters {
	bumpMap?: Texture | undefined;
	bumpScale?: number | undefined;
	color?: ColorRepresentation | undefined;
	displacementMap?: Texture | undefined;
	displacementScale?: number | undefined;
	displacementBias?: number | undefined;
	emissive?: ColorRepresentation | undefined;
	emissiveIntensity?: number | undefined;
	emissiveMap?: Texture | null | undefined;
	flatShading?: boolean | undefined;
	map?: Texture | null | undefined;
	lightMap?: Texture | null | undefined;
	lightMapIntensity?: number | undefined;
	normalMap?: Texture | undefined;
	normalScale?: Vector2 | undefined;
	aoMap?: Texture | null | undefined;
	aoMapIntensity?: number | undefined;
	specularMap?: Texture | null | undefined;
	alphaMap?: Texture | null | undefined;
	envMap?: Texture | null | undefined;
	combine?: Combine | undefined;
	reflectivity?: number | undefined;
	refractionRatio?: number | undefined;
	wireframe?: boolean | undefined;
	wireframeLinewidth?: number | undefined;
	wireframeLinecap?: string | undefined;
	wireframeLinejoin?: string | undefined;
	fog?: boolean | undefined;
}
declare class MeshLambertMaterial extends Material {
	constructor(parameters?: MeshLambertMaterialParameters);
	/**
	 * @default 'MeshLambertMaterial'
	 */
	type: string;
	/**
	 * @default new THREE.Color( 0xffffff )
	 */
	color: Color;
	/**
	 * @default null
	 */
	bumpMap: Texture | null;
	/**
	 * @default 1
	 */
	bumpScale: number;
	/**
	 * @default null
	 */
	displacementMap: Texture | null;
	/**
	 * @default 1
	 */
	displacementScale: number;
	/**
	 * @default 0
	 */
	displacementBias: number;
	/**
	 * @default new THREE.Color( 0x000000 )
	 */
	emissive: Color;
	/**
	 * @default 1
	 */
	emissiveIntensity: number;
	/**
	 * @default null
	 */
	emissiveMap: Texture | null;
	/**
	 * @default false
	 */
	flatShading: boolean;
	/**
	 * @default null
	 */
	map: Texture | null;
	/**
	 * @default null
	 */
	lightMap: Texture | null;
	/**
	 * @default 1
	 */
	lightMapIntensity: number;
	/**
	 * @default null
	 */
	normalMap: Texture | null;
	normalMapType: NormalMapTypes;
	/**
	 * @default new THREE.Vector2( 1, 1 )
	 */
	normalScale: Vector2;
	/**
	 * @default null
	 */
	aoMap: Texture | null;
	/**
	 * @default 1
	 */
	aoMapIntensity: number;
	/**
	 * @default null
	 */
	specularMap: Texture | null;
	/**
	 * @default null
	 */
	alphaMap: Texture | null;
	/**
	 * @default null
	 */
	envMap: Texture | null;
	/**
	 * @default THREE.MultiplyOperation
	 */
	combine: Combine;
	/**
	 * @default 1
	 */
	reflectivity: number;
	/**
	 * @default 0.98
	 */
	refractionRatio: number;
	/**
	 * @default false
	 */
	wireframe: boolean;
	/**
	 * @default 1
	 */
	wireframeLinewidth: number;
	/**
	 * @default 'round'
	 */
	wireframeLinecap: string;
	/**
	 * @default 'round'
	 */
	wireframeLinejoin: string;
	/**
	 * Whether the material is affected by fog. Default is true.
	 * @default fog
	 */
	fog: boolean;
	setValues(parameters: MeshLambertMaterialParameters): void;
}
export interface MeshDepthMaterialParameters extends MaterialParameters {
	map?: Texture | null | undefined;
	alphaMap?: Texture | null | undefined;
	depthPacking?: DepthPackingStrategies | undefined;
	displacementMap?: Texture | null | undefined;
	displacementScale?: number | undefined;
	displacementBias?: number | undefined;
	wireframe?: boolean | undefined;
	wireframeLinewidth?: number | undefined;
}
declare class MeshDepthMaterial extends Material {
	constructor(parameters?: MeshDepthMaterialParameters);
	/**
	 * @default 'MeshDepthMaterial'
	 */
	type: string;
	/**
	 * @default null
	 */
	map: Texture | null;
	/**
	 * @default null
	 */
	alphaMap: Texture | null;
	/**
	 * @default THREE.BasicDepthPacking
	 */
	depthPacking: DepthPackingStrategies;
	/**
	 * @default null
	 */
	displacementMap: Texture | null;
	/**
	 * @default 1
	 */
	displacementScale: number;
	/**
	 * @default 0
	 */
	displacementBias: number;
	/**
	 * @default false
	 */
	wireframe: boolean;
	/**
	 * @default 1
	 */
	wireframeLinewidth: number;
	/**
	 * @default false
	 */
	fog: boolean;
	setValues(parameters: MeshDepthMaterialParameters): void;
}
export interface MeshDistanceMaterialParameters extends MaterialParameters {
	map?: Texture | null | undefined;
	alphaMap?: Texture | null | undefined;
	displacementMap?: Texture | null | undefined;
	displacementScale?: number | undefined;
	displacementBias?: number | undefined;
	farDistance?: number | undefined;
	nearDistance?: number | undefined;
	referencePosition?: Vector3 | undefined;
}
declare class MeshDistanceMaterial extends Material {
	constructor(parameters?: MeshDistanceMaterialParameters);
	/**
	 * @default 'MeshDistanceMaterial'
	 */
	type: string;
	/**
	 * @default null
	 */
	map: Texture | null;
	/**
	 * @default null
	 */
	alphaMap: Texture | null;
	/**
	 * @default null
	 */
	displacementMap: Texture | null;
	/**
	 * @default 1
	 */
	displacementScale: number;
	/**
	 * @default 0
	 */
	displacementBias: number;
	/**
	 * @default 1000
	 */
	farDistance: number;
	/**
	 * @default 1
	 */
	nearDistance: number;
	/**
	 * @default new THREE.Vector3()
	 */
	referencePosition: Vector3;
	/**
	 * @default false
	 */
	fog: boolean;
	setValues(parameters: MeshDistanceMaterialParameters): void;
}
export interface MeshMatcapMaterialParameters extends MaterialParameters {
	color?: ColorRepresentation | undefined;
	matcap?: Texture | null | undefined;
	map?: Texture | null | undefined;
	bumpMap?: Texture | null | undefined;
	bumpScale?: number | undefined;
	normalMap?: Texture | null | undefined;
	normalMapType?: NormalMapTypes | undefined;
	normalScale?: Vector2 | undefined;
	displacementMap?: Texture | null | undefined;
	displacementScale?: number | undefined;
	displacementBias?: number | undefined;
	alphaMap?: Texture | null | undefined;
	fog?: boolean | undefined;
	flatShading?: boolean | undefined;
}
declare class MeshMatcapMaterial extends Material {
	constructor(parameters?: MeshMatcapMaterialParameters);
	/**
	 * @default 'MeshMatcapMaterial'
	 */
	type: string;
	/**
	 * @default { 'MATCAP': '' }
	 */
	defines: {
		[key: string]: any;
	};
	/**
	 * @default new THREE.Color( 0xffffff )
	 */
	color: Color;
	/**
	 * @default null
	 */
	matcap: Texture | null;
	/**
	 * @default null
	 */
	map: Texture | null;
	/**
	 * @default null
	 */
	bumpMap: Texture | null;
	/**
	 * @default 1
	 */
	bumpScale: number;
	/**
	 * @default null
	 */
	normalMap: Texture | null;
	/**
	 * @default THREE.TangentSpaceNormalMap
	 */
	normalMapType: NormalMapTypes;
	/**
	 * @default new Vector2( 1, 1 )
	 */
	normalScale: Vector2;
	/**
	 * @default null
	 */
	displacementMap: Texture | null;
	/**
	 * @default 1
	 */
	displacementScale: number;
	/**
	 * @default 0
	 */
	displacementBias: number;
	/**
	 * @default null
	 */
	alphaMap: Texture | null;
	/**
	 * Define whether the material is rendered with flat shading. Default is false.
	 * @default false
	 */
	flatShading: boolean;
	/**
	 * Whether the material is affected by fog. Default is true.
	 * @default fog
	 */
	fog: boolean;
	setValues(parameters: MeshMatcapMaterialParameters): void;
}
export interface LineBasicMaterialParameters extends MaterialParameters {
	color?: ColorRepresentation | undefined;
	fog?: boolean | undefined;
	linewidth?: number | undefined;
	linecap?: string | undefined;
	linejoin?: string | undefined;
}
declare class LineBasicMaterial extends Material {
	constructor(parameters?: LineBasicMaterialParameters);
	/**
	 * @default 'LineBasicMaterial'
	 */
	type: string;
	/**
	 * @default 0xffffff
	 */
	color: Color;
	/**
	 * Whether the material is affected by fog. Default is true.
	 * @default true
	 */
	fog: boolean;
	/**
	 * @default 1
	 */
	linewidth: number;
	/**
	 * @default 'round'
	 */
	linecap: string;
	/**
	 * @default 'round'
	 */
	linejoin: string;
	setValues(parameters: LineBasicMaterialParameters): void;
}
declare class LOD extends Object3D {
	constructor();
	type: 'LOD';
	/**
	 *
	 * An array of level objects
	 *
	 * Each level is an object with the following properties:
	 *
	 * - object - The Object3D to display at this level.
	 * - distance - The distance at which to display this level of detail.
	 * - hysteresis - Threshold used to avoid flickering at LOD boundaries, as a fraction of distance.
	 */
	levels: Array<{
		distance: number;
		hysteresis: number;
		object: Object3D;
	}>;
	autoUpdate: boolean;
	readonly isLOD: true;
	/**
	 * Adds a mesh that will display at a certain distance and greater. Typically the further away the distance, the lower the detail on the mesh.
	 *
	 * @param object The Object3D to display at this level.
	 * @param distance The distance at which to display this level of detail. Default 0.0.
	 * @param hysteresis Threshold used to avoid flickering at LOD boundaries, as a fraction of distance. Default 0.0.
	 */
	addLevel(object: Object3D, distance?: number, hysteresis?: number): this;
	getCurrentLevel(): number;
	getObjectForDistance(distance: number): Object3D | null;
	raycast(raycaster: Raycaster, intersects: Intersection[]): void;
	update(camera: Camera): void;
	toJSON(meta: any): any;
	// TODO: Remove this
	/**
	 * @deprecated Use {@link LOD#levels .levels} instead.
	 */
	objects: any[];
}
declare class Skeleton {
	constructor(bones: Bone[], boneInverses?: Matrix4[]);
	uuid: string;
	bones: Bone[];
	boneInverses: Matrix4[];
	boneMatrices: Float32Array;
	boneTexture: null | DataTexture;
	boneTextureSize: number;
	frame: number;
	init(): void;
	calculateInverses(): void;
	computeBoneTexture(): this;
	pose(): void;
	update(): void;
	clone(): Skeleton;
	getBoneByName(name: string): undefined | Bone;
	dispose(): void;
	/**
	 * @deprecated This property has been removed completely.
	 */
	useVertexTexture: boolean;
}
declare class SkinnedMesh<
	TGeometry extends BufferGeometry = BufferGeometry,
	TMaterial extends Material | Material[] = Material | Material[]
> extends Mesh<TGeometry, TMaterial> {
	constructor(geometry?: TGeometry, material?: TMaterial, useVertexTexture?: boolean);
	bindMode: string;
	bindMatrix: Matrix4;
	bindMatrixInverse: Matrix4;
	skeleton: Skeleton;
	readonly isSkinnedMesh: true;
	bind(skeleton: Skeleton, bindMatrix?: Matrix4): void;
	pose(): void;
	normalizeSkinWeights(): void;
	updateMatrixWorld(force?: boolean): void;
	boneTransform(index: number, target: Vector3): Vector3;
}
declare class Points<
	TGeometry extends BufferGeometry = BufferGeometry,
	TMaterial extends Material | Material[] = Material | Material[]
> extends Object3D {
	/**
	 * @param geometry An instance of BufferGeometry.
	 * @param material An instance of Material (optional).
	 */
	constructor(geometry?: TGeometry, material?: TMaterial);
	type: 'Points';
	morphTargetInfluences?: number[] | undefined;
	morphTargetDictionary?:
		| {
				[key: string]: number;
		  }
		| undefined;
	readonly isPoints: true;
	/**
	 * An instance of BufferGeometry, where each vertex designates the position of a particle in the system.
	 */
	geometry: TGeometry;
	/**
	 * An instance of Material, defining the object's appearance. Default is a PointsMaterial with randomised colour.
	 */
	material: TMaterial;
	raycast(raycaster: Raycaster, intersects: Intersection[]): void;
	updateMorphTargets(): void;
}
declare class WebGLArrayRenderTarget extends WebGLRenderTarget {
	/**
	 * Creates a new WebGLArrayRenderTarget.
	 *
	 * @param width the width of the render target, in pixels.
	 * @param height the height of the render target, in pixels.
	 * @param depth the depth/layer count of the render target.
	 */
	constructor(width?: number, height?: number, depth?: number);
	/**
	 * The depth of the render target.
	 */
	depth: number;
	/**
	 * The texture property is overwritten with an instance of {@link DataArrayTexture}.
	 */
	texture: DataArrayTexture;
	readonly isWebGLArrayRenderTarget: true;
}
declare class FogExp2 implements FogBase {
	constructor(hex: number | string, density?: number);
	/**
	 * @default ''
	 */
	name: string;
	color: Color;
	/**
	 * Defines how fast the fog will grow dense.
	 * @default 0.00025
	 */
	density: number;
	readonly isFogExp2: true;
	clone(): FogExp2;
	toJSON(): any;
}
declare class ActorManualTriggersController {
	protected actorsManager: ActorsManager;
	private _scene;
	constructor(actorsManager: ActorsManager);
	runTriggerFromFunctionNode(node: ActorBuilderNode, methodName: string): void;
}
declare enum JsType {
	ATTRIBUTE = 'attribute',
	CURSOR = 'cursor',
	GLOBALS = 'globals',
	ON_CHILD_ATTRIBUTE_UPDATE = 'onChildAttributeUpdate',
	ON_KEY = 'onKey',
	ON_KEYDOWN = 'onKeydown',
	ON_KEYPRESS = 'onKeypress',
	ON_KEYUP = 'onKeyup',
	ON_MAPBOX_CAMERA_MOVE = 'onMapboxCameraMove',
	ON_MAPBOX_CAMERA_MOVE_START = 'onMapboxCameraMoveStart',
	ON_MAPBOX_CAMERA_MOVE_END = 'onMapboxCameraMoveEnd',
	ON_OBJECT_ATTRIBUTE_UPDATE = 'onObjectAttributeUpdate',
	ON_OBJECT_CLICK = 'onObjectClick',
	ON_OBJECT_DISPATCH_EVENT = 'onObjectDispatchEvent',
	ON_OBJECT_HOVER = 'onObjectHover',
	ON_OBJECT_POINTERDOWN = 'onObjectPointerdown',
	ON_OBJECT_POINTERUP = 'onObjectPointerup',
	ON_POINTERDOWN = 'onPointerdown',
	ON_POINTERUP = 'onPointerup',
	ON_SCENE_PAUSE = 'onScenePause',
	ON_SCENE_PLAY = 'onScenePlay',
	ON_SCENE_RESET = 'onSceneReset',
	ON_MANUAL_TRIGGER = 'onManualTrigger',
	ON_TICK = 'onTick',
	ON_PERFORMANCE_CHANGE = 'onPerformanceChange',
	ON_VIDEO_EVENT = 'onVideoEvent',
	ON_WEBXR_CONTROLLER_EVENT = 'onWebXRControllerEvent',
	OUTPUT = 'output',
	PARAM = 'param',
	RAY_FROM_CURSOR = 'rayFromCursor',
	RAY_FROM_CAMERA = 'rayFromCamera',
	SET_OBJECT_LOOK_AT = 'setObjectLookAt',
	SET_OBJECT_POSITION = 'setObjectPosition',
	SET_OBJECT_ROTATION = 'setObjectRotation',
	SET_PHYSICS_RBD_POSITION = 'setPhysicsRBDPosition',
	SET_PLAYER_INPUT = 'setPlayerInput',
}
declare enum CoreEventEmitter {
	CANVAS = 'canvas',
	DOCUMENT = 'document',
}
declare enum PointerEventType {
	click = 'click',
	pointerdown = 'pointerdown',
	pointermove = 'pointermove',
	pointerup = 'pointerup',
}
declare enum KeyboardEventType {
	keydown = 'keydown',
	keypress = 'keypress',
	keyup = 'keyup',
}
declare enum WindowEventType {
	resize = 'resize',
}
declare enum DragEventType {
	dragover = 'dragover',
}
declare enum MouseEventType {
	auxclick = 'auxclick',
	click = 'click',
	contextmenu = 'contextmenu',
	dblclick = 'dblclick',
	mousedown = 'mousedown',
	mouseenter = 'mouseenter',
	mouseleave = 'mouseleave',
	mousemove = 'mousemove',
	mouseover = 'mouseover',
	mouseout = 'mouseout',
	mouseup = 'mouseup',
	pointerlockchange = 'pointerlockchange',
	pointerlockerror = 'pointerlockerror',
	select = 'select',
	wheel = 'wheel',
}
declare enum TouchEventType {
	touchstart = 'touchstart',
	touchmove = 'touchmove',
	touchend = 'touchend',
}
export declare type EventType =
	| PointerEventType
	| MouseEventType
	| KeyboardEventType
	| WindowEventType
	| DragEventType
	| KeyboardEventType
	| TouchEventType;
export interface EventData {
	type: EventType;
	emitter: CoreEventEmitter;
}
declare class CallbacksTriggerController {
	private _graph;
	private _queue;
	private _blockLevel;
	constructor(_graph: CoreGraph);
	block(): void;
	unblock(): void;
	blocked(): boolean;
	enqueue(node: CoreGraphNode, originalTriggerGraphNode?: CoreGraphNode): void;
	private _processQueue;
	private _processItem;
}
export declare type CoreGraphNodeId = number;
declare class CoreGraph {
	private _nextId;
	private _scene;
	private _successors;
	private _predecessors;
	private _nodesById;
	private _nodesCount;
	readonly callbacksTriggerController: CallbacksTriggerController;
	private _debugging;
	private _addedNodesDuringDebugging;
	startDebugging(): void;
	stopDebugging(): void;
	printDebug(): void;
	setScene(scene: PolyScene): void;
	scene(): PolyScene | undefined;
	nextId(): CoreGraphNodeId;
	nodesFromIds(ids: number[]): CoreGraphNode[];
	nodeFromId(id: number): CoreGraphNode | undefined;
	hasNode(node: CoreGraphNode): boolean;
	addNode(node: CoreGraphNode): void;
	removeNode(node: CoreGraphNode): void;
	nodesCount(): number;
	connect(src: CoreGraphNode, dest: CoreGraphNode, checkCycle?: boolean): boolean;
	disconnect(src: CoreGraphNode, dest: CoreGraphNode): void;
	disconnectPredecessors(node: CoreGraphNode): void;
	disconnectSuccessors(node: CoreGraphNode): void;
	predecessorIds(id: CoreGraphNodeId): CoreGraphNodeId[];
	predecessors(node: CoreGraphNode): CoreGraphNode[];
	successorIds(id: CoreGraphNodeId): CoreGraphNodeId[];
	successors(node: CoreGraphNode): CoreGraphNode[];
	private _boundPredecessorIds;
	private _boundSuccessorIds;
	allPredecessorIds(node: CoreGraphNode): CoreGraphNodeId[];
	allSuccessorIds(node: CoreGraphNode): CoreGraphNodeId[];
	allPredecessors(node: CoreGraphNode): CoreGraphNode[];
	allSuccessors(node: CoreGraphNode): CoreGraphNode[];
	private _createConnection;
	private _removeConnection;
	private _hasPredecessor;
}
export declare type PostDirtyHook = (caller?: CoreGraphNode) => void;
declare class DirtyController {
	private node;
	_dirtyCount: number;
	_dirty: boolean;
	_dirtyTimestamp: number | undefined;
	_cachedSuccessors: CoreGraphNode[] | undefined;
	_forbiddenTriggerNodeIds: Set<CoreGraphNodeId> | undefined;
	_postDirtyHooks: PostDirtyHook[] | undefined;
	_postDirtyHookNames: string[] | undefined;
	constructor(node: CoreGraphNode);
	dispose(): void;
	isDirty(): boolean;
	dirtyTimestamp(): number | undefined;
	dirtyCount(): number;
	addPostDirtyHook(name: string, method: PostDirtyHook): void;
	removePostDirtyHook(name: string): void;
	hasHook(name: string): boolean;
	removeDirtyState(): void;
	setForbiddenTriggerNodes(nodes: CoreGraphNode[]): void;
	isForbiddenTriggerNodeId(nodeId: CoreGraphNodeId): boolean;
	setDirty(original_trigger_graph_node?: CoreGraphNode | null, propagate?: boolean): void;
	runPostDirtyHooks(original_trigger_graph_node?: CoreGraphNode): void;
	setSuccessorsDirty(original_trigger_graph_node?: CoreGraphNode): void;
	clearSuccessorsCache(): void;
	clearSuccessorsCacheWithPredecessors(): void;
}
declare class CoreGraphNode {
	protected _scene: PolyScene;
	protected _name: string;
	private _graph;
	private _graphNodeId;
	private _dirtyController;
	constructor(_scene: PolyScene, _name: string);
	disposed: boolean;
	dispose(): void;
	/**
	 * returns the name
	 *
	 */
	name(): string;
	setName(name: string): void;
	/**
	 * returns the scene
	 *
	 */
	scene(): PolyScene;
	/**
	 * returns the id, which is unique for the scene
	 *
	 */
	graphNodeId(): CoreGraphNodeId;
	get dirtyController(): DirtyController;
	/**
	 * makes the graphNode dirty, which in turns makes its dependencies dirty
	 *
	 */
	setDirty(trigger?: CoreGraphNode | null): void;
	/**
	 * makes dependencies dirty
	 *
	 */
	setSuccessorsDirty(trigger?: CoreGraphNode): void;
	/**
	 * removes the dirty state
	 *
	 */
	removeDirtyState(): void;
	isDirty(): boolean;
	/**
	 * adds a callback that gets run when the graphNode is dirty
	 *
	 */
	addPostDirtyHook(name: string, callback: PostDirtyHook): void;
	removePostDirtyHook(name: string): void;
	graphRemove(): void;
	addGraphInput(src: CoreGraphNode, checkCycle?: boolean): boolean;
	removeGraphInput(src: CoreGraphNode): void;
	graphDisconnectPredecessors(): void;
	graphDisconnectSuccessors(): void;
	graphPredecessorIds(): CoreGraphNodeId[];
	graphPredecessors(): CoreGraphNode[];
	graphSuccessors(): CoreGraphNode[];
	graphAllPredecessors(): CoreGraphNode[];
	graphAllSuccessors(): CoreGraphNode[];
}
export declare type onTimeTickHook = (delta: number) => void;
export declare type onPlayingStateChangeCallback = () => void;
export interface TimeControllerUpdateTimeOptions {
	updateClockDelta?: boolean;
}
export declare type onTimeTickCallbacksMap = Map<string, onTimeTickHook>;
declare class TimeController {
	private scene;
	static START_FRAME: Readonly<number>;
	private _frame;
	private _timeUniform;
	private _timeDeltaUniform;
	private _graphNode;
	private _realtimeState;
	private _maxFrame;
	private _maxFrameLocked;
	private _playing;
	private _clock;
	constructor(scene: PolyScene);
	get graphNode(): CoreGraphNode;
	updateClockDelta(): number;
	delta(): number;
	setDelta(delta: number): number;
	frame(): number;
	timeUniform(): import('@vue/reactivity').Ref<number>;
	timeDeltaUniform(): import('@vue/reactivity').Ref<number>;
	time(): number;
	maxFrame(): number;
	maxFrameLocked(): boolean;
	realtimeState(): boolean;
	setMaxFrame(maxFrame: number): void;
	setMaxFrameLocked(state: boolean): void;
	setRealtimeState(state: boolean): void;
	setTime(time: number, updateFrame?: boolean): void;
	setFrame(frame: number, updateTime?: boolean): void;
	setFrameToStart(): void;
	incrementTimeIfPlaying(options?: TimeControllerUpdateTimeOptions): void;
	incrementTime(options?: TimeControllerUpdateTimeOptions): void;
	private _ensureFrameWithinBounds;
	playing(): boolean;
	pause(): void;
	play(): void;
	togglePlayPause(): void;
	private _onBeforeTickCallbacksMap;
	private _onAfterTickCallbacksMap;
	private _onPlayingStateChangeCallbacksMap;
	private _onBeforeTickCallbacks;
	private _onAfterTickCallbacks;
	private _onPlayingStateChangeCallbacks;
	registerOnBeforeTick(callbackName: string, callback: onTimeTickHook): void;
	unRegisterOnBeforeTick(callbackName: string): void;
	registeredBeforeTickCallbacks(): Map<any, any>;
	registerOnAfterTick(callbackName: string, callback: onTimeTickHook): void;
	unRegisterOnAfterTick(callbackName: string): void;
	registeredAfterTickCallbacks(): onTimeTickCallbacksMap;
	onPlayingStateChange(callback: onPlayingStateChangeCallback): void;
	removeOnPlayingStateChange(callback: onPlayingStateChangeCallback): void;
	private _updateOnPlayingStateChangeCallbacks;
	private _registerCallback;
	private _unregisterCallback;
	private _updateCallbacks;
}
export declare type TriggerCallback = () => void;
export declare type EvaluatorKeyboardMethod = JsType.ON_KEY | JsType.ON_KEYDOWN | JsType.ON_KEYPRESS | JsType.ON_KEYUP;
export declare type EvaluatorPointerMethod = 'onClick' | 'onPointermove' | JsType.ON_POINTERDOWN | JsType.ON_POINTERUP;
export declare type EvaluatorMethodName =
	| JsType.ON_KEY
	| JsType.ON_KEYDOWN
	| JsType.ON_KEYPRESS
	| JsType.ON_KEYUP
	| JsType.ON_MAPBOX_CAMERA_MOVE
	| JsType.ON_MAPBOX_CAMERA_MOVE_START
	| JsType.ON_MAPBOX_CAMERA_MOVE_END
	| JsType.ON_OBJECT_ATTRIBUTE_UPDATE
	| 'onClick'
	| JsType.ON_OBJECT_DISPATCH_EVENT
	| JsType.ON_PERFORMANCE_CHANGE
	| JsType.ON_POINTERDOWN
	| 'onPointermove'
	| JsType.ON_POINTERUP
	| JsType.ON_SCENE_PAUSE
	| JsType.ON_SCENE_PLAY
	| JsType.ON_SCENE_RESET
	| JsType.ON_TICK
	| JsType.ON_VIDEO_EVENT
	| JsType.ON_WEBXR_CONTROLLER_EVENT;
export interface EvaluatorEventData extends EventData {
	jsType: JsType;
}
export declare type OnDisposeCallback = () => void;
declare class ActorEvaluator {
	readonly node: ActorBuilderNode;
	readonly object3D: Object3D;
	protected scene: PolyScene;
	protected timeController: TimeController;
	private _watchStopHandles;
	constructor(node: ActorBuilderNode, object3D: Object3D);
	onKey?: TriggerCallback;
	onKeydown?: TriggerCallback;
	onKeypress?: TriggerCallback;
	onKeyup?: TriggerCallback;
	onPlayerEvent?: TriggerCallback;
	onMapboxCameraMove?: TriggerCallback;
	onMapboxCameraMoveStart?: TriggerCallback;
	onMapboxCameraMoveEnd?: TriggerCallback;
	onObjectAttributeUpdate?: TriggerCallback;
	onObjectClick?: TriggerCallback;
	onObjectDispatchEvent?: TriggerCallback;
	onObjectHover?: TriggerCallback;
	onObjectPointerdown?: TriggerCallback;
	onObjectPointerup?: TriggerCallback;
	onPerformanceChange?: TriggerCallback;
	onPointerdown?: TriggerCallback;
	onPointerup?: TriggerCallback;
	onScenePause?: TriggerCallback;
	onScenePlay?: TriggerCallback;
	onSceneReset?: TriggerCallback;
	onTick?: TriggerCallback;
	onVideoEvent?: TriggerCallback;
	onWebXRControllerEvent?: TriggerCallback;
	_onDisposeCallbacks?: OnDisposeCallback[];
	onDispose(callback: OnDisposeCallback): void;
	dispose(): void;
}
export declare type GeneratorFunction = (object3D: Object3D) => ActorEvaluator;
export declare type EvaluatorCallback = (evaluator: ActorEvaluator) => void;
declare class ActorEvaluatorGenerator {
	private _func;
	constructor(_func: GeneratorFunction);
	private _evaluatorByObject;
	eventDatas?: Set<EvaluatorEventData>;
	private _createEvaluator;
	findOrCreateEvaluator(object3D: Object3D): ActorEvaluator;
	traverseEvaluator(callback: EvaluatorCallback): void;
	dispose(): void;
}
declare class ActorKeyboardEventsController {
	protected actorsManager: ActorsManager;
	protected _scene: PolyScene;
	private _triggeredEvaluatorGeneratorsByMethodName;
	constructor(actorsManager: ActorsManager);
	addTriggeredEvaluators(
		evaluatorGenerators: Set<ActorEvaluatorGenerator>,
		methodName: EvaluatorKeyboardMethod
	): void;
	runTriggers(): void;
}
declare class ActorPointerEventsController {
	protected actorsManager: ActorsManager;
	protected _scene: PolyScene;
	private _triggeredEvaluatorGeneratorsByMethodName;
	constructor(actorsManager: ActorsManager);
	addTriggeredEvaluators(evaluatorGenerators: Set<ActorEvaluatorGenerator>, methodName: EvaluatorPointerMethod): void;
	runTriggers(): void;
}
export interface Vector2Like {
	x: number;
	y: number;
}
export interface Vector3Like {
	x: number;
	y: number;
	z: number;
}
export interface Vector4Like {
	x: number;
	y: number;
	z: number;
	w: number;
}
export interface ColorLike {
	r: number;
	g: number;
	b: number;
}
export declare type StringOrNumber = string | number;
export declare type Boolean2 = [boolean, boolean];
export declare type Number2 = [number, number];
export declare type Number3 = [number, number, number];
export declare type Number4 = [number, number, number, number];
export declare type Number16 = [
	number,
	number,
	number,
	number,
	number,
	number,
	number,
	number,
	number,
	number,
	number,
	number,
	number,
	number,
	number,
	number
];
export declare type StringOrNumber2 = [StringOrNumber, StringOrNumber];
export declare type StringOrNumber3 = [StringOrNumber, StringOrNumber, StringOrNumber];
export declare type StringOrNumber4 = [StringOrNumber, StringOrNumber, StringOrNumber, StringOrNumber];
export declare type NumericAttribValueAsArray = Number2 | Number3 | Number4;
export declare type NumericAttribValueAsVectorLike = Vector2Like | Vector3Like | Vector4Like | ColorLike;
export declare type NumericAttribValue = number | NumericAttribValueAsVectorLike | NumericAttribValueAsArray;
export declare type AttribValue = string | NumericAttribValue | boolean;
export declare type Constructor<T = {}> = new (...args: any[]) => T;
export interface PolyDictionary<T> {
	[Key: string]: T;
}
export declare type valueof<T> = T[keyof T];
export interface NodeUIDataJson {
	x: number;
	y: number;
	comment?: string;
}
declare class UIData {
	private node;
	private _position;
	protected _width: number;
	private _color;
	private _layoutVertical;
	private _comment;
	private _json;
	constructor(node: BaseNodeType, x?: number, y?: number);
	dispose(): void;
	setComment(comment: string | undefined): void;
	comment(): string | undefined;
	setColor(color: Color): void;
	color(): Color;
	setLayoutHorizontal(): void;
	isLayoutVertical(): boolean;
	copy(ui_data: UIData): void;
	position(): Vector2;
	setPosition(newPosition: Vector2 | number, y?: number): this;
	translate(offset: Vector2, snap?: boolean): this;
	toJSON(): NodeUIDataJson;
}
export declare type FlagHookCallback = () => void;
declare class BaseFlag {
	protected node: BaseNodeType;
	protected _state: boolean;
	protected _hooks: FlagHookCallback[] | null;
	constructor(node: BaseNodeType);
	onUpdate(hook: FlagHookCallback): void;
	protected _onUpdate(): void;
	set(newState: boolean): void;
	active(): boolean;
	toggle(): void;
	private runHooks;
}
declare class BypassFlag extends BaseFlag {
	protected _state: boolean;
	protected _onUpdate(): void;
}
declare class DisplayFlag extends BaseFlag {
	protected _onUpdate(): void;
}
declare class OptimizeFlag extends BaseFlag {
	protected _state: boolean;
	protected _onUpdate(): void;
}
declare class FlagsController {
	readonly node: BaseNodeType;
	readonly bypass: DisplayFlag | undefined;
	readonly display: BypassFlag | undefined;
	readonly optimize: OptimizeFlag | undefined;
	constructor(node: BaseNodeType);
	hasDisplay(): boolean;
	hasBypass(): boolean;
	hasOptimize(): boolean;
}
declare const FlagsControllerD_base: {
	new (...args: any[]): {
		readonly node: BaseNodeType;
		display: DisplayFlag;
		hasDisplay(): boolean;
	};
} & typeof FlagsController;
declare class FlagsControllerD extends FlagsControllerD_base {}
declare const FlagsControllerB_base: {
	new (...args: any[]): {
		readonly node: BaseNodeType;
		readonly bypass: BypassFlag;
		hasBypass(): boolean;
	};
} & typeof FlagsController;
declare class FlagsControllerB extends FlagsControllerB_base {}
declare const FlagsControllerDB_base: {
	new (...args: any[]): {
		readonly node: BaseNodeType;
		readonly bypass: BypassFlag;
		hasBypass(): boolean;
	};
} & {
	new (...args: any[]): {
		readonly node: BaseNodeType;
		display: DisplayFlag;
		hasDisplay(): boolean;
	};
} & typeof FlagsController;
declare class FlagsControllerDB extends FlagsControllerDB_base {}
declare const FlagsControllerBO_base: {
	new (...args: any[]): {
		readonly node: BaseNodeType;
		readonly optimize: OptimizeFlag;
		hasOptimize(): boolean;
	};
} & {
	new (...args: any[]): {
		readonly node: BaseNodeType;
		readonly bypass: BypassFlag;
		hasBypass(): boolean;
	};
} & typeof FlagsController;
declare class FlagsControllerBO extends FlagsControllerBO_base {}
declare const FlagsControllerDBO_base: {
	new (...args: any[]): {
		readonly node: BaseNodeType;
		readonly optimize: OptimizeFlag;
		hasOptimize(): boolean;
	};
} & {
	new (...args: any[]): {
		readonly node: BaseNodeType;
		readonly bypass: BypassFlag;
		hasBypass(): boolean;
	};
} & {
	new (...args: any[]): {
		readonly node: BaseNodeType;
		display: DisplayFlag;
		hasDisplay(): boolean;
	};
} & typeof FlagsController;
declare class FlagsControllerDBO extends FlagsControllerDBO_base {}
declare enum ParamType {
	BOOLEAN = 'boolean',
	BUTTON = 'button',
	COLOR = 'color',
	FLOAT = 'float',
	FOLDER = 'folder',
	INTEGER = 'integer',
	PARAM_PATH = 'param_path',
	NODE_PATH = 'node_path',
	RAMP = 'ramp',
	STRING = 'string',
	VECTOR2 = 'vector2',
	VECTOR3 = 'vector3',
	VECTOR4 = 'vector4',
}
declare abstract class CoreEntity {
	protected _index: number;
	constructor(_index: number);
	index(): number;
	abstract setAttribValue(attribName: string, attribValue: NumericAttribValue | string): void;
	abstract attribValue(attribName: string, target?: Vector2 | Vector3 | Vector4): AttribValue | undefined;
	abstract stringAttribValue(attribName: string): string | undefined;
	abstract position(target: Vector3): void;
}
export declare type CoreEntitySelectionState = Map<CoreEntity, boolean>;
export declare type CadGeometry = gp_Pnt2d | Geom2d_Curve | TopoDS_Vertex | TopoDS_Edge | TopoDS_Wire | TopoDS_Shape;
declare enum CadGeometryType {
	POINT_2D = 'CADPoint2D',
	CURVE_2D = 'CADCurve2D',
	VERTEX = 'CADVertex',
	EDGE = 'CADEdge',
	WIRE = 'CADWire',
	FACE = 'CADFace',
	SHELL = 'CADShell',
	SOLID = 'CADSolid',
	COMPSOLID = 'CADCompsolid',
	COMPOUND = 'CADCompound',
}
export declare type CadGeometryTypeShape =
	| CadGeometryType.VERTEX
	| CadGeometryType.EDGE
	| CadGeometryType.WIRE
	| CadGeometryType.FACE
	| CadGeometryType.SHELL
	| CadGeometryType.SOLID
	| CadGeometryType.COMPSOLID
	| CadGeometryType.COMPOUND;
export interface CadTypeMap {
	[CadGeometryType.POINT_2D]: gp_Pnt2d;
	[CadGeometryType.CURVE_2D]: Geom2d_Curve;
	[CadGeometryType.VERTEX]: TopoDS_Vertex;
	[CadGeometryType.EDGE]: TopoDS_Edge;
	[CadGeometryType.WIRE]: TopoDS_Wire;
	[CadGeometryType.FACE]: TopoDS_Face;
	[CadGeometryType.SHELL]: TopoDS_Shell;
	[CadGeometryType.SOLID]: TopoDS_Solid;
	[CadGeometryType.COMPSOLID]: TopoDS_CompSolid;
	[CadGeometryType.COMPOUND]: TopoDS_Compound;
}
export interface CachedCADTesselationParams {
	linearTolerance: number;
	angularTolerance: number;
	curveAbscissa: number;
	curveTolerance: number;
}
export interface CachedCADOBJTesselationParams {
	CADLinearTolerance: number;
	CADAngularTolerance: number;
	CADCurveAbscissa: number;
	CADCurveTolerance: number;
}
export interface CADTesselationParams extends CachedCADTesselationParams {
	wireframe: boolean;
	displayMeshes: boolean;
	displayEdges: boolean;
	meshesColor: Color;
	edgesColor: Color;
}
export interface CADOBJTesselationParams extends CachedCADOBJTesselationParams {
	CADWireframe: boolean;
	CADDisplayMeshes: boolean;
	CADDisplayEdges: boolean;
	CADMeshesColor: Color;
	CADEdgesColor: Color;
}
export declare type CsgGeometry = geometries.path2.Path2 | geometries.geom2.Geom2 | geometries.geom3.Geom3;
declare enum CsgGeometryType {
	PATH2 = 'CSGPath2',
	GEOM2 = 'CSGGeom2',
	GEOM3 = 'CSGGeom3',
}
export interface CsgTypeMap {
	[CsgGeometryType.PATH2]: geometries.path2.Path2;
	[CsgGeometryType.GEOM2]: geometries.geom2.Geom2;
	[CsgGeometryType.GEOM3]: geometries.geom3.Geom3;
}
export interface CSGTesselationParams {
	facetAngle: number;
	wireframe: boolean;
	meshesColor: Color;
	linesColor: Color;
}
export interface CSGOBJTesselationParams {
	CSGFacetAngle: number;
	CSGWireframe: boolean;
	CSGMeshesColor: Color;
	CSGLinesColor: Color;
}
export declare type SDFGeometry = Manifold;
export interface SDFOBJTesselationParams {
	SDFFacetAngle: number;
	SDFMeshesColor: Color;
	SDFWireframe: boolean;
}
declare enum CoreObjectType {
	THREEJS = 'Object3D',
	CAD = 'CADObject',
	CSG = 'CSGObject',
	SDF = 'SDFObject',
}
export interface ObjectGeometryMap {
	[CoreObjectType.THREEJS]: BufferGeometry;
	[CoreObjectType.CAD]: CadGeometry;
	[CoreObjectType.CSG]: CsgGeometry;
	[CoreObjectType.SDF]: SDFGeometry;
}
export interface ObjectContent<T extends CoreObjectType> {
	type: string;
	geometry?: ObjectGeometryMap[T];
	userData: {
		[key: string]: any;
	};
	name: string;
	visible: boolean;
	castShadow: boolean;
	receiveShadow: boolean;
	renderOrder: number;
	frustumCulled: boolean;
	matrixAutoUpdate: boolean;
	material?: Material | Material[];
	clone: () => ObjectContent<T>;
	dispose?: () => void;
	traverse(callback: (object: ObjectContent<T>) => any): void;
	applyMatrix4(matrix: Matrix4): void;
}
export interface MergeCompactOptions {
	objects: ObjectContent<CoreObjectType>[];
	mergedObjects: ObjectContent<CoreObjectType>[];
	material?: Material;
	objectType: string;
	onError: (message: string) => void;
}
declare enum GroupOperation {
	SET = 'replace existing',
	UNION = 'add to existing',
	SUBTRACT = 'subtract from existing',
	INTERSECT = 'intersect with existing',
}
export interface GroupData {
	name: string;
	entitiesCount: number;
}
export declare type GroupsDataForType = GroupData[];
export declare type GroupCollectionData = Record<string, GroupsDataForType>;
declare enum EntityGroupType {
	POINT = 'point',
	OBJECT = 'object',
	EDGE = 'edge',
	FACE = 'face',
}
export interface UpdateGroupOptions {
	type: EntityGroupType;
	groupName: string;
	operation: GroupOperation;
	invert: boolean;
}
export declare type GroupsDictionary = Record<string, Record<string, number[]>>;
declare class EntityGroupCollection {
	private _object;
	constructor(_object: ObjectContent<CoreObjectType>);
	attributesDictionary(): GroupsDictionary;
	static attributesDictionary<T extends CoreObjectType>(object: ObjectContent<T>): GroupsDictionary;
	private static _createAttributesDictionaryIfNone;
	findOrCreateGroup(type: EntityGroupType, groupName: string): number[];
	deleteGroup(type: EntityGroupType, groupName: string): void;
	static data<T extends CoreObjectType>(object: ObjectContent<T>): GroupCollectionData;
	indicesSet(type: EntityGroupType, groupName: string, target: Set<number>): void;
	private selectedIndices;
	updateGroup(options: UpdateGroupOptions, selectionStates: CoreEntitySelectionState): void;
}
declare enum ObjectType {
	AMBIENT_LIGHT = 'AmbientLight',
	AREA_LIGHT = 'AreaLight',
	DIRECTIONAL_LIGHT = 'DirectionalLight',
	GROUP = 'Group',
	HEMISPHERE_LIGHT = 'HemisphereLight',
	LIGHT_PROBE = 'LightProbe',
	LINE_SEGMENTS = 'LineSegments',
	LOD = 'LOD',
	MESH = 'Mesh',
	OBJECT3D = 'Object3D',
	ORTHOGRAPHIC_CAMERA = 'OrthographicCamera',
	PERSPECTIVE_CAMERA = 'PerspectiveCamera',
	POINT_LIGHT = 'PointLight',
	POINTS = 'Points',
	SCENE = 'Scene',
	SPOT_LIGHT = 'SpotLight',
}
export interface ObjectByObjectType {
	[ObjectType.AMBIENT_LIGHT]: AmbientLight;
	[ObjectType.AREA_LIGHT]: RectAreaLight;
	[ObjectType.DIRECTIONAL_LIGHT]: DirectionalLight;
	[ObjectType.GROUP]: Group;
	[ObjectType.HEMISPHERE_LIGHT]: HemisphereLight;
	[ObjectType.LIGHT_PROBE]: LightProbe;
	[ObjectType.LINE_SEGMENTS]: LineSegments;
	[ObjectType.LOD]: LOD;
	[ObjectType.MESH]: Mesh;
	[ObjectType.OBJECT3D]: Object3D;
	[ObjectType.POINT_LIGHT]: PointLight;
	[ObjectType.POINTS]: Points;
	[ObjectType.ORTHOGRAPHIC_CAMERA]: OrthographicCamera;
	[ObjectType.PERSPECTIVE_CAMERA]: PerspectiveCamera;
	[ObjectType.SCENE]: Scene;
	[ObjectType.SPOT_LIGHT]: SpotLight;
}
export interface ObjectData {
	type: ObjectType;
	name: string | null;
	childrenCount: number;
	pointsCount: number;
	groupData: GroupCollectionData;
}
declare enum AttribClass {
	VERTEX = 'vertex',
	OBJECT = 'object',
	CORE_GROUP = 'container',
}
declare enum AttribType {
	NUMERIC = 'numeric',
	STRING = 'string',
}
declare enum AttribSize {
	FLOAT = 1,
	VECTOR2 = 2,
	VECTOR3 = 3,
	VECTOR4 = 4,
}
declare enum TransformTargetType {
	OBJECT = 'object',
	GEOMETRY = 'geometry',
}
export interface SetParamsFromMatrixOptions {
	scale?: boolean;
}
declare enum ObjectTransformSpace {
	PARENT = 'parent',
	LOCAL = 'local',
}
export declare type AttributeDictionary = PolyDictionary<AttribValue>;
declare abstract class BaseCoreObject<T extends CoreObjectType> extends CoreEntity {
	protected _object: ObjectContent<T>;
	constructor(_object: ObjectContent<T>, index: number);
	dispose(): void;
	object(): ObjectContent<T>;
	geometry(): ObjectGeometryMap[T] | null;
	static setAttribute<T extends CoreObjectType>(
		object: ObjectContent<T>,
		attribName: string,
		value: AttribValue
	): void;
	static addAttribute<T extends CoreObjectType>(
		object: ObjectContent<T>,
		attribName: string,
		value: AttribValue
	): void;
	addAttribute(name: string, value: AttribValue): void;
	addNumericAttrib(name: string, value: NumericAttribValue): void;
	setAttribValue(name: string, value: AttribValue): void;
	protected static _attributesDictionary<T extends CoreObjectType>(object: ObjectContent<T>): AttributeDictionary;
	static attributesDictionaryEntry<T extends CoreObjectType>(
		object: ObjectContent<T>,
		attribName: string,
		defaultValue?: AttribValue
	): AttribValue;
	private static _createAttributesDictionaryIfNone;
	private _attributesDictionary;
	attributeNames(): string[];
	static attribNames<T extends CoreObjectType>(object: ObjectContent<T>): string[];
	attribNames(): string[];
	static objectsAttribNames<T extends CoreObjectType>(objects: ObjectContent<T>[]): string[];
	static coreObjectsAttribNames<T extends CoreObjectType>(coreObjects: BaseCoreObject<T>[]): string[];
	hasAttrib(attribName: string): boolean;
	static hasAttrib<T extends CoreObjectType>(object: ObjectContent<T>, attribName: string): boolean;
	renameAttrib(old_name: string, new_name: string): void;
	static renameAttrib<T extends CoreObjectType>(object: ObjectContent<T>, old_name: string, new_name: string): void;
	deleteAttribute(name: string): void;
	static deleteAttribute<T extends CoreObjectType>(object: ObjectContent<T>, attribName: string): void;
	static position(object: ObjectContent<CoreObjectType>, target: Vector3): void;
	position(target: Vector3): void;
	boundingBox(target: Box3): void;
	geometryBoundingBox(target: Box3): void;
	boundingSphere(target: Sphere): void;
	geometryBoundingSphere(target: Sphere): void;
	static attribValue<T extends CoreObjectType>(
		object: ObjectContent<T>,
		attribName: string,
		index?: number,
		target?: Color | Vector2 | Vector3 | Vector4
	): AttribValue | undefined;
	static stringAttribValue<T extends CoreObjectType>(
		object: ObjectContent<T>,
		attribName: string,
		index?: number
	): string | undefined;
	attribValue(attribName: string, target?: Vector2 | Vector3 | Vector4): AttribValue | undefined;
	stringAttribValue(name: string): string | undefined;
	name(): string;
	humanType(): string;
	attribTypes(): PolyDictionary<AttribType>;
	static attribType<T extends CoreObjectType>(object: ObjectContent<T>, attribName: string): AttribType;
	attribType(attribName: string): AttribType;
	static coreObjectAttributeTypesByName<T extends CoreObjectType>(
		coreObjects: BaseCoreObject<T>[]
	): PolyDictionary<AttribType[]>;
	attribSizes(): PolyDictionary<AttribSize>;
	static attribSize<T extends CoreObjectType>(object: ObjectContent<T>, attribName: string): AttribSize | null;
	attribSize(attribName: string): AttribSize | null;
	static coreObjectsAttribSizesByName<T extends CoreObjectType>(
		coreObjects: BaseCoreObject<T>[]
	): PolyDictionary<AttribSize[]>;
	clone(): BaseCoreObject<T>;
	static clone<T extends CoreObjectType>(srcObject: ObjectContent<T>): ObjectContent<T>;
	static applyMatrix(
		object: ObjectContent<CoreObjectType>,
		matrix: Matrix4,
		transformTargetType: TransformTargetType,
		transformSpace: ObjectTransformSpace
	): void;
	static mergeCompact(options: MergeCompactOptions): void;
	groupCollection(): EntityGroupCollection;
}
declare class CorePoint extends CoreEntity {
	private _coreGeometry;
	_geometry: BufferGeometry;
	_position: Vector3 | undefined;
	_normal: Vector3 | undefined;
	constructor(_coreGeometry: CoreGeometry, _index: number);
	applyMatrix4(matrix: Matrix4): void;
	coreGeometry(): CoreGeometry;
	geometry(): BufferGeometry;
	attribSize(name: string): number;
	hasAttrib(name: string): boolean;
	static attribValue(
		geometry: BufferGeometry,
		index: number,
		attribName: string,
		target?: Vector2 | Vector3 | Vector4
	): AttribValue;
	attribValue(attribName: string, target?: Vector2 | Vector3 | Vector4): AttribValue;
	attribValueNumber(name: string): number;
	attribValueVector2(name: string, target: Vector2): Vector2;
	attribValueVector3(name: string, target: Vector3): Vector3;
	attribValueVector4(name: string, target: Vector4): Vector4;
	static indexedAttribValue(geometry: BufferGeometry, index: number, attribName: string): string;
	indexedAttribValue(name: string): string;
	stringAttribValue(name: string): string;
	static attribValueIndex(geometry: BufferGeometry, index: number, attribName: string): number;
	attribValueIndex(attribName: string): number;
	isAttribIndexed(name: string): boolean;
	position(): Vector3;
	getPosition(target: Vector3): Vector3;
	setPosition(new_position: Vector3): void;
	normal(): Vector3;
	getNormal(target: Vector3): Vector3;
	setNormal(new_normal: Vector3): void;
	setAttribValue(attribName: string, value: NumericAttribValue | string): void;
	setAttribValueFromNumber(attribName: string, value: number): void;
	setAttribValueFromVector2(attribName: string, value: Vector2): void;
	setAttribValueFromVector3(attribName: string, value: Vector3): void;
	setAttribValueFromVector4(attribName: string, value: Vector4): void;
	setAttribIndex(name: string, new_value_index: number): number;
}
export interface FaceLike {
	a: number;
	b: number;
	c: number;
}
export declare type CorePointArray3 = [CorePoint, CorePoint, CorePoint];
export declare type Vector3Array2 = [Vector3, Vector3];
export declare type Vector3Array3 = [Vector3, Vector3, Vector3];
declare class CoreFace {
	private _coreGeometry;
	private _index;
	_geometry: BufferGeometry;
	_points: CorePointArray3 | undefined;
	_triangle: Triangle | undefined;
	_positions: Vector3Array3 | undefined;
	_deltas: Vector3Array2 | undefined;
	constructor(_coreGeometry: CoreGeometry, _index: number);
	index(): number;
	points(): CorePointArray3;
	applyMatrix4(matrix: Matrix4): void;
	private _get_points;
	positions(): Vector3Array3;
	private _getPositions;
	triangle(): Triangle;
	private _get_triangle;
	deltas(): Vector3Array2;
	private _getDeltas;
	area(): number;
	center(target: Vector3): Vector3;
	randomPosition(seed: number): Vector3;
	attribValueAtPosition(attrib_name: string, position: Vector3): number | Vector2Like | Vector3Like | undefined;
	static interpolatedValue(
		geometry: BufferGeometry,
		face: FaceLike,
		intersectPoint: Vector3,
		attrib: BufferAttribute
	): number | Vector3 | null;
}
declare class CoreAttributeData {
	private _size;
	private _type;
	constructor(_size: number, _type: AttribType);
	size(): number;
	type(): AttribType;
	static from_value(attrib_value: any): CoreAttributeData;
}
declare class CoreGeometry {
	private _geometry;
	_bounding_box: Box3 | undefined;
	constructor(_geometry: BufferGeometry);
	dispose(): void;
	geometry(): BufferGeometry;
	uuid(): string;
	boundingBox(): Box3 | undefined;
	private _create_bounding_box;
	markAsInstance(): void;
	static markedAsInstance(geometry: BufferGeometry): boolean;
	markedAsInstance(): boolean;
	positionAttribName(): string;
	computeVertexNormals(): void;
	static userDataAttribs(geometry: BufferGeometry): any;
	userDataAttribs(): any;
	indexedAttributeNames(): string[];
	static userDataAttrib(geometry: BufferGeometry, attribName: string): any;
	userDataAttrib(name: string): any;
	static isAttribIndexed(geometry: BufferGeometry, attribName: string): boolean;
	isAttribIndexed(name: string): boolean;
	static hasAttrib(geometry: BufferGeometry, attribName: string): boolean;
	hasAttrib(attribName: string): boolean;
	markAttribAsNeedsUpdate(attribName: string): void;
	attribType(name: string): AttribType;
	static attribNames(geometry: BufferGeometry): string[];
	attribNames(): string[];
	static attribNamesMatchingMask(geometry: BufferGeometry, masksString: GroupString): string[];
	attribNamesMatchingMask(masksString: GroupString): string[];
	attribSizes(): PolyDictionary<AttribSize>;
	static attribSize(geometry: BufferGeometry, attribName: string): number;
	attribSize(attribName: string): number;
	setIndexedAttributeValues(name: string, values: string[]): void;
	setIndexedAttribute(name: string, values: string[], indices: number[]): void;
	addNumericAttrib(name: string, size?: number, default_value?: NumericAttribValue): void;
	initPositionAttribute(points_count: number, default_value?: Vector3): BufferGeometry;
	addAttribute(name: string, attrib_data: CoreAttributeData): void;
	renameAttrib(old_name: string, new_name: string): BufferGeometry;
	deleteAttribute(name: string): BufferGeometry;
	clone(): BufferGeometry;
	static clone(srcGeometry: BufferGeometry): BufferGeometry;
	pointsCount(): number;
	static pointsCount(geometry: BufferGeometry): number;
	points(): CorePoint[];
	pointsFromGeometry(): CorePoint[];
	segments(): number[][];
	faces(): CoreFace[];
	facesFromGeometry(): CoreFace[];
}
declare class CoreObject extends BaseCoreObject<CoreObjectType.THREEJS> {
	protected _object: Object3D;
	constructor(_object: Object3D, index: number);
	humanType(): string;
	object(): Object3D<Event>;
	geometry(): BufferGeometry | null;
	coreGeometry(): CoreGeometry | null;
	points(): CorePoint[];
	pointsFromGroup(group: GroupString): CorePoint[];
	addNumericVertexAttrib(name: string, size: number, defaultValue: NumericAttribValue): void;
	static position(object: Object3D, target: Vector3): void;
	boundingBox(target: Box3): void;
	geometryBoundingBox(target: Box3): void;
	boundingSphere(target: Sphere): void;
	computeVertexNormals(): void;
	static clone(srcObject: Object3D): Object3D<Event>;
	static parallelTraverse(a: Object3D, b: Object3D, callback: (a: Object3D, b: Object3D) => void): void;
	static applyMatrix(
		object: Object3D,
		matrix: Matrix4,
		transformTargetType: TransformTargetType,
		transformSpace: ObjectTransformSpace
	): void;
	static mergeCompact(options: MergeCompactOptions): void;
}
declare class TypedSopNode<K extends NodeParamsConfig> extends TypedNode<NodeContext.SOP, K> {
	static context(): NodeContext;
	readonly flags: FlagsControllerDBO;
	dataType(): string;
	static displayedInputNames(): string[];
	initializeBaseNode(): void;
	setCoreGroup(coreGroup: CoreGroup): void;
	setObject(object: ObjectContent<CoreObjectType>): void;
	setObjects(objects: ObjectContent<CoreObjectType>[]): void;
	setGeometry(geometry: BufferGeometry, type?: ObjectType): void;
	setGeometries(geometries: BufferGeometry[], type?: ObjectType): void;
	protected _setContainerObjects(objects: ObjectContent<CoreObjectType>[]): void;
	static createObject<OT extends ObjectType>(
		geometry: BufferGeometry,
		type: OT,
		material?: Material
	): ObjectByObjectType[OT];
	createObject<OT extends ObjectType>(
		geometry: BufferGeometry,
		type: OT,
		material?: Material
	): ObjectByObjectType[OT];
	static createIndexIfNone(geometry: BufferGeometry): void;
	protected _createIndexIfNone(geometry: BufferGeometry): void;
}
export declare type BaseSopNodeType = TypedSopNode<NodeParamsConfig>;
declare class CadObject<T extends CadGeometryType> implements ObjectContent<CoreObjectType.CAD> {
	private _geometry;
	private _type;
	visible: boolean;
	get geometry(): CadGeometry;
	get type(): T;
	userData: {};
	name: string;
	castShadow: boolean;
	receiveShadow: boolean;
	renderOrder: number;
	frustumCulled: boolean;
	matrixAutoUpdate: boolean;
	material: Material | undefined;
	constructor(_geometry: CadTypeMap[T], _type: T);
	setGeometry<TE extends CadGeometryType>(geometry: CadTypeMap[TE], type: TE): void;
	private _validate;
	cadGeometry(): CadTypeMap[T];
	dispose(): void;
	applyMatrix4(matrix: Matrix4): void;
	traverse(callback: (object: CadObject<T>) => any): void;
	clone(): CadObject<T>;
	toObject3D(
		tesselationParams: CADTesselationParams,
		displayNode: BaseSopNodeType
	): Object3D | Object3D[] | undefined;
	static toObject3D<T extends CadGeometryType>(
		cadObject: CadObject<T>,
		type: T,
		tesselationParams: CADTesselationParams,
		displayNode: BaseSopNodeType
	): Object3D | Object3D[] | undefined;
	boundingBox(target: Box3): void;
}
declare class CsgObject<T extends CsgGeometryType> implements ObjectContent<CoreObjectType.CSG> {
	private _geometry;
	visible: boolean;
	get geometry(): CsgGeometry;
	get type(): T;
	userData: {};
	name: string;
	castShadow: boolean;
	receiveShadow: boolean;
	renderOrder: number;
	frustumCulled: boolean;
	matrixAutoUpdate: boolean;
	material: Material | undefined;
	private _type;
	constructor(_geometry: CsgTypeMap[T]);
	setGeometry<TE extends CsgGeometryType>(geometry: CsgTypeMap[TE]): void;
	private _validate;
	csgGeometry(): CsgTypeMap[T];
	dispose(): void;
	applyMatrix4(matrix: Matrix4): void;
	traverse(callback: (object: CsgObject<T>) => any): void;
	clone(): CsgObject<T>;
	toObject3D(tesselationParams: CSGTesselationParams): Object3D | Object3D[] | undefined;
	static toObject3D<T extends CsgGeometryType>(
		csgObject: CsgObject<T>,
		type: T,
		tesselationParams: CSGTesselationParams
	): Object3D | Object3D[] | undefined;
	boundingBox(target: Box3): void;
	boundingSphere(target: Sphere): void;
}
export declare type GroupString = string;
export interface Object3DWithGeometry extends Object3D {
	geometry: BufferGeometry;
}
declare class CoreGroup extends CoreEntity {
	private _timestamp;
	private _allObjects;
	constructor();
	dispose(): void;
	timestamp(): number | undefined;
	touch(): void;
	resetBoundingBox(): void;
	clone(): CoreGroup;
	setAllObjects(objects: ObjectContent<CoreObjectType>[]): void;
	allObjects(): ObjectContent<CoreObjectType>[];
	allCoreObjects(): BaseCoreObject<CoreObjectType>[];
	cadObjects(): CadObject<CadGeometryType>[] | undefined;
	cadObjectsWithShape(): CadObject<CadGeometryTypeShape>[] | undefined;
	cadCoreObjects(): BaseCoreObject<CoreObjectType>[] | undefined;
	csgObjects(): CsgObject<CsgGeometryType>[] | undefined;
	csgCoreObjects(): BaseCoreObject<CoreObjectType>[] | undefined;
	threejsObjects(): Object3D[];
	threejsObjectsWithGeo(): Object3DWithGeometry[];
	threejsCoreObjects(): CoreObject[];
	geometries(): BufferGeometry[];
	coreGeometries(): CoreGeometry[];
	static geometryFromObject(object: Object3D): BufferGeometry | null;
	faces(): CoreFace[];
	points(): CorePoint[];
	pointsCount(): number;
	totalPointsCount(): number;
	pointsFromGroup(group: GroupString): CorePoint[];
	static _fromObjects(objects: Object3D[]): CoreGroup;
	objectsData(): ObjectData[];
	boundingBox(target: Box3): void;
	hasAttrib(name: string): boolean;
	geoAttribType(name: string): AttribType | null;
	objectAttribTypesByName(): PolyDictionary<AttribType[]>;
	renameAttrib(old_name: string, new_name: string, attribClass: AttribClass): void;
	geoAttribNames(): string[];
	objectAttribNames(): string[];
	geoAttribNamesMatchingMask(masksString: GroupString): string[];
	objectAttribNamesMatchingMask(masksString: GroupString): string[];
	attribNamesMatchingMask(masksString: GroupString): string[];
	geoAttribSizes(): PolyDictionary<AttribSize>;
	objectAttribSizesByName(): PolyDictionary<AttribSize[]>;
	geoAttribSize(attrib_name: string): number;
	addGeoNumericVertexAttrib(name: string, size: number, defaultValue: NumericAttribValue): void;
	private _attributes;
	addAttribute(attribName: string, attribValue: AttribValue): void;
	deleteAttribute(name: string): void;
	attribValue(attribName: string): AttribValue;
	attribNames(): string[];
	attribType(name: string): AttribType;
	attribSizes(): PolyDictionary<AttribSize>;
	attribSize(name: string): AttribSize | null;
	private _attributesDictionary;
	private _createAttributesDictionaryIfNone;
	setAttribValue(attribName: string, attribValue: NumericAttribValue | string): void;
	stringAttribValue(attribName: string): string | undefined;
	position(target: Vector3): void;
}
declare class ParsedTree {
	node: jsep.Expression | undefined;
	error_message: string | undefined;
	constructor();
	parseExpression(string: string): void;
	parseExpressionForStringParam(string: string): void;
	static stringValueElements(v: string): string[];
	private reset;
}
declare abstract class BaseTraverser {
	param: BaseParamType;
	_error_message: string | undefined;
	constructor(param: BaseParamType);
	protected clear_error(): void;
	protected set_error(message: string): void;
	protected _set_error_from_error_bound: (error: Error | string) => void;
	private _set_error_from_error;
	is_errored(): boolean;
	error_message(): string | undefined;
	reset(): void;
	traverse_node(node: jsep.Expression): string | undefined;
	protected traverse_BinaryExpression(node: jsep.BinaryExpression): string;
	protected traverse_MemberExpression(node: jsep.MemberExpression): string;
	protected traverse_ConditionalExpression(node: jsep.ConditionalExpression): string;
	protected traverse_Compound(node: jsep.Compound): string;
	protected traverse_Literal(node: jsep.Literal): string;
	protected abstract traverse_Identifier(node: jsep.Identifier): string | undefined;
	protected abstract traverse_CallExpression(node: jsep.CallExpression): string | undefined;
	protected abstract traverse_UnaryExpression(node: jsep.UnaryExpression): string;
}
export declare type NodeOrParam = BaseNodeType | BaseParamType;
declare class DecomposedPath {
	private _index;
	private _path_elements;
	private _named_nodes;
	private _graph_node_ids;
	private _node_element_by_graph_node_id;
	constructor();
	reset(): void;
	add_node(name: string, node: NodeOrParam): void;
	add_path_element(path_element: string): void;
	named_graph_nodes(): (NodeOrParam | null)[];
	named_nodes(): BaseNodeType[];
	update_from_name_change(node: NodeOrParam): void;
	to_path(): string;
}
declare namespace gsap.core {
	// Added to TypeScript 3.5
	type Omit<T, K extends keyof any> = Pick<T, Exclude<keyof T, K>>;
	class Animation {
		static readonly version: string;
		data: any;
		readonly parent: Timeline | null;
		readonly scrollTrigger?: ScrollTrigger;
		constructor(vars?: object, time?: number);
		/**
		 * Sets the delay before the start of the animation.
		 *
		 * ```js
		 * anim.delay(1);
		 * ```
		 *
		 * @param {number} value
		 * @returns {Animation} The animation
		 * @memberof Animation
		 * @link https://greensock.com/docs/v3/GSAP/Tween/delay()
		 */
		delay(value: number): this;
		/**
		 * Gets the delay before the start of the animation.
		 *
		 * ```js
		 * anim.delay();
		 * ```
		 *
		 * @returns {number} The delay value
		 * @memberof Animation
		 * @link https://greensock.com/docs/v3/GSAP/Tween/delay()
		 */
		delay(): number;
		/**
		 * Sets the duration of the animation.
		 *
		 * ```js
		 * anim.duration(1);
		 * ```
		 *
		 * @param {number} value
		 * @returns {Animation} The animation
		 * @memberof Animation
		 * @link https://greensock.com/docs/v3/GSAP/Tween/duration()
		 */
		duration(value: number): this;
		/**
		 * Gets the duration of the animation.
		 *
		 * ```js
		 * anim.duration();
		 * ```
		 *
		 * @returns {number} The duration
		 * @memberof Animation
		 * @link https://greensock.com/docs/v3/GSAP/Tween/duration()
		 */
		duration(): number;
		/**
		 * Returns the time at which the animation will finish according to the parent timeline's local time.
		 *
		 * ```js
		 * anim.endTime() // the time, e.g. something like 17.854
		 * ```
		 *
		 * @returns {number} The end time
		 * @memberof Animation
		 * @link https://greensock.com/docs/v3/GSAP/Tween/endTime()
		 */
		endTime(includeRepeats?: boolean): number;
		/**
		 * Sets a callback of the animation.
		 *
		 * ```js
		 * anim.eventCallback("onComplete", myCompleteCallback);
		 * ```
		 *
		 * @param {CallbackType} type
		 * @param {Callback | null} callback
		 * @param {any[]} [params]
		 * @param {object} [scope]
		 * @returns {Animation} The animation
		 * @memberof Animation
		 * @link https://greensock.com/docs/v3/GSAP/Tween/eventCallback()
		 */
		eventCallback(type: CallbackType, callback: Callback | null, params?: any[], scope?: object): this;
		/**
		 * Gets the requested callback function of the animation.
		 *
		 * ```js
		 * anim.eventCallback("onComplete"); // function or undefined
		 * ```
		 *
		 * @param {CallbackType} type
		 * @returns {Callback} The callback
		 * @memberof Animation
		 * @link https://greensock.com/docs/v3/GSAP/Tween/eventCallback()
		 */
		eventCallback(type: CallbackType): Callback;
		/**
		 * Forces new starting & ending values based on the current state.
		 *
		 * ```js
		 * anim.invalidate();
		 * ```
		 *
		 * @returns {Animation} The animation
		 * @memberof Animation
		 * @link https://greensock.com/docs/v3/GSAP/Tween/invalidate()
		 */
		invalidate(): this;
		/**
		 * Returns true or false based on the active state of the animation.
		 * Being active means that the virtual playhead is actively moving across this instance's time span and it is not paused, nor are any of its ancestor timelines.
		 *
		 * ```js
		 * anim.isActive();
		 * ```
		 *
		 * @returns {boolean} The active state
		 * @memberof Animation
		 * @link https://greensock.com/docs/v3/GSAP/Tween/isActive()
		 */
		isActive(): boolean;
		/**
		 * Sets the current iteration of the animation.
		 *
		 * ```js
		 * anim.iteration(1); // set the state back to the start in this case
		 * ```
		 *
		 * @param {number} value
		 * @param {boolean} [suppressEvents]
		 * @returns {Animation} The tween
		 * @memberof Animation
		 * @link https://greensock.com/docs/v3/GSAP/Tween/iteration()
		 */
		iteration(value: number, suppressEvents?: boolean): this;
		/**
		 * Gets the current iteration of the animation.
		 *
		 * ```js
		 * anim.iteration();  // getter
		 * ```
		 *
		 * @returns {number} The iteration
		 * @memberof Animation
		 * @link https://greensock.com/docs/v3/GSAP/Tween/iteration()
		 */
		iteration(): number;
		/**
		 * Kills the animation entirely.
		 * To kill means to immediately stop the animation, remove it from its parent timeline, and release it for garbage collection.
		 *
		 * ```js
		 * anim.kill();
		 * ```
		 *
		 * @returns {Animation} The animation
		 * @memberof Animation
		 * @link https://greensock.com/docs/v3/GSAP/Tween/kill()
		 */
		kill(): this;
		/**
		 * Pauses the animation, optionally at the given time.
		 *
		 * ```js
		 * anim.pause();    // pause immediately
		 * anim.pause(1.5); // pause but seek to this time in the animation
		 * ```
		 *
		 * @param {number} [atTime]
		 * @param {boolean} [suppressEvents]
		 * @returns {Animation} The animation
		 * @memberof Animation
		 * @link https://greensock.com/docs/v3/GSAP/Tween/pause()
		 */
		pause(atTime?: number | string, suppressEvents?: boolean): this;
		/**
		 * Sets the paused state of the animation.
		 *
		 * ```js
		 * anim.paused(true); // pause immediately
		 * ```
		 *
		 * @param {boolean} value
		 * @returns {Animation} The animation
		 * @memberof Animation
		 * @link https://greensock.com/docs/v3/GSAP/Tween/paused()
		 */
		paused(value: boolean): this;
		/**
		 * Gets the paused state of the animation.
		 *
		 * ```js
		 * anim.paused(); // returns true or false
		 * ```
		 *
		 * @returns {boolean} The paused state
		 * @memberof Animation
		 * @link https://greensock.com/docs/v3/GSAP/Tween/paused()
		 */
		paused(): boolean;
		/**
		 * Plays the animation, optionally from the given start time.
		 *
		 * ```js
		 * anim.play(true); // play from current point
		 * anim.play(1.5);  // play from the 1.5 second mark
		 * ```
		 *
		 * @param {number} [from]
		 * @param {boolean} [suppressEvents]
		 * @returns {Animation} The animation
		 * @memberof Animation
		 * @link https://greensock.com/docs/v3/GSAP/Tween/play()
		 */
		play(from?: number | string | null, suppressEvents?: boolean): this;
		/**
		 * Sets the progress of the animation (between 0 and 1).
		 *
		 * ```js
		 * anim.progress(0.5); // go to the half way point
		 * ```
		 *
		 * @param {number} value
		 * @param {boolean} [suppressEvents]
		 * @returns {Animation} The animation
		 * @memberof Animation
		 * @link https://greensock.com/docs/v3/GSAP/Tween/progress()
		 */
		progress(value: number, suppressEvents?: boolean): this;
		/**
		 * Gets the progress of the animation.
		 *
		 * ```js
		 * anim.progress(); // returns the progress like 0.5
		 * ```
		 *
		 * @returns {number} The progress
		 * @memberof Animation
		 * @link https://greensock.com/docs/v3/GSAP/Tween/progress()
		 */
		progress(): number;
		rawTime(wrapRepeats?: boolean): number;
		/**
		 * Forces things to render at a certain time WITHOUT adjusting the animation's position in its parent timeline
		 *
		 * ```js
		 * anim.render(1);
		 * ```
		 *
		 * @param {number} totalTime
		 * @param {boolean} [suppressEvents]
		 * @param {boolean} [force]
		 * @returns {Animation} The animation
		 * @memberof Animation
		 */
		render(totalTime: number, suppressEvents?: boolean, force?: boolean): this;
		/**
		 * Sets the number of repeats of the animation.
		 *
		 * ```js
		 * anim.repeat(1); // sets repeat to 1 for a total iteration count of 2
		 * ```
		 *
		 * @param {number} [value]
		 * @returns {Animation} The animation
		 * @memberof Animation
		 */
		repeat(value: number): this;
		/**
		 * Gets the number of repeats of the animation.
		 *
		 * ```js
		 * anim.repeat();
		 * ```
		 *
		 * @returns {number} The repeat value
		 * @memberof Animation
		 */
		repeat(): number;
		/**
		 * Sets the repeat delay (time between iterations) of the animation.
		 *
		 * ```js
		 * anim.repeatDelay(1);
		 * ```
		 *
		 * @param {number} [value]
		 * @returns {Animation} The animation
		 * @memberof Animation
		 */
		repeatDelay(value: number): this;
		/**
		 * Gets the repeat delay (time between iterations) of the animation.
		 *
		 * ```js
		 * anim.repeatDelay();
		 * ```
		 *
		 * @returns {number} The repeatDelay value
		 * @memberof Animation
		 */
		repeatDelay(): number;
		/**
		 * Begins playing the animation forward from the beginning, optionally including the starting delay.
		 *
		 * ```js
		 * anim.restart();     // repeats the animation NOT including the starting delay
		 * anim.restart(true); // repeats the animation including the starting delay
		 * ```
		 *
		 * @param {number} [includeDelay]
		 * @param {boolean} [suppressEvents]
		 * @returns {Animation} The animation
		 * @memberof Animation
		 * @link https://greensock.com/docs/v3/GSAP/Tween/restart()
		 */
		restart(includeDelay?: boolean, suppressEvents?: boolean): this;
		/**
		 * Continues a paused animation in the direction it was headed (forwards or reverse), optionally from the given time.
		 *
		 * ```js
		 * anim.resume();  // continues the animation
		 * anim.resume(1); // continues the animation from the 1 second mark
		 * ```
		 *
		 * @param {number} [from]
		 * @param {boolean} [suppressEvents]
		 * @returns {Animation} The animation
		 * @memberof Animation
		 * @link https://greensock.com/docs/v3/GSAP/Tween/resume()
		 */
		resume(from?: number | string, suppressEvents?: boolean): this;
		/**
		 * Plays an animation in the reverse direction, optionally from the given time.
		 *
		 * ```js
		 * anim.reverse();  // plays the animation in reverse
		 * anim.reverse(1); // plays the animation in reverse from the 1 second mark
		 * ```
		 *
		 * @param {number} [from]
		 * @param {boolean} [suppressEvents]
		 * @returns {Animation} The animation
		 * @memberof Animation
		 * @link https://greensock.com/docs/v3/GSAP/Tween/reverse()
		 */
		reverse(from?: number | string, suppressEvents?: boolean): this;
		/**
		 * Sets the reversed state of the animation.
		 *
		 * ```js
		 * anim.reversed(true); // plays the animation in reverse
		 * ```
		 *
		 * @param {boolean} value
		 * @returns {Animation} The animation
		 * @memberof Animation
		 * @link https://greensock.com/docs/v3/GSAP/Tween/reversed()
		 */
		reversed(value: boolean): this;
		/**
		 * Gets the reversed state of the animation.
		 *
		 * ```js
		 * anim.reversed(); // true or false
		 * ```
		 *
		 * @returns {boolean} The reversed state
		 * @memberof Animation
		 * @link https://greensock.com/docs/v3/GSAP/Tween/reversed()
		 */
		reversed(): boolean;
		/**
		 * Reverts the animation, returning the targets to their pre-animation state including the removal of inline styles added by the animation.
		 *
		 * ```js
		 * anim.revert();
		 * ```
		 *
		 * @param {object} [config]
		 * @returns {Animation} The animation
		 * @memberof Animation
		 * @link https://greensock.com/docs/v3/GSAP/Tween/revert()
		 */
		revert(config?: object): this;
		/**
		 * Sets the start time of the animation in reference to its parent timeline (not including any delay).
		 *
		 * ```js
		 * anim.startTime(1); // plays the animation at the 1 second mark of the parent timeline
		 * ```
		 *
		 * @param {number} value
		 * @returns {Animation} The animation
		 * @memberof Animation
		 * @link https://greensock.com/docs/v3/GSAP/Tween/startTime()
		 */
		startTime(value: number): this;
		/**
		 * Gets the start time of the animation in reference to its parent timeline (not including any delay).
		 *
		 * ```js
		 * anim.startTime(); // the current start time, something like 1.0
		 * ```
		 *
		 * @returns {Animation} The animation
		 * @memberof Animation
		 * @link https://greensock.com/docs/v3/GSAP/Tween/startTime()
		 */
		startTime(): number;
		/**
		 * Sets the current time of the given animation using a time or a label.
		 *
		 * ```js
		 * anim.seek(1); // moves the playhead to the 1 second mark
		 * ```
		 *
		 * @param {number| string} time
		 * @param {boolean} [suppressEvents]
		 * @returns {Animation} The animation
		 * @memberof Animation
		 */
		seek(time: number | string, suppressEvents?: boolean): this;
		/**
		 * Returns a promise for the given animation.
		 *
		 * ```js
		 * anim.then(yourFunction).then(...);
		 * ```
		 *
		 * @param {Function} [onFulfilled]
		 * @returns {Promise} A promise for the completion of the animation
		 * @memberof Animation
		 * @link https://greensock.com/docs/v3/GSAP/Tween/then()
		 */
		then(onFulfilled?: (result: Omit<this, 'then'>) => any): Promise<this>;
		/**
		 * Sets the current time of the given animation.
		 *
		 * ```js
		 * anim.time(1); // moves the playhead to the 1 second mark
		 * ```
		 *
		 * @param {number} value
		 * @param {boolean} [suppressEvents]
		 * @returns {Animation} The animation
		 * @memberof Animation
		 * @link https://greensock.com/docs/v3/GSAP/Tween/time()
		 */
		time(value: number, suppressEvents?: boolean): this;
		/**
		 * Gets the current time of the given animation.
		 *
		 * ```js
		 * anim.time(); // the current time, e.g. something like 1.0
		 * ```
		 *
		 * @returns {number} The current time
		 * @memberof Animation
		 * @link https://greensock.com/docs/v3/GSAP/Tween/time()
		 */
		time(): number;
		/**
		 * Sets the time scale of the given animation.
		 *
		 * ```js
		 * anim.timeScale(2.0); // makes the animation go at twice the normal speed
		 * ```
		 *
		 * @param {number} value
		 * @returns {Animation} The animation
		 * @memberof Animation
		 * @link https://greensock.com/docs/v3/GSAP/Tween/timeScale()
		 */
		timeScale(value: number): this;
		/**
		 * Gets the time scale of the given animation.
		 *
		 * ```js
		 * anim.timeScale(); // the
		 * ```
		 *
		 * @returns {Animation} The animation
		 * @memberof Animation
		 * @link https://greensock.com/docs/v3/GSAP/Tween/timeScale()
		 */
		timeScale(): number;
		/**
		 * Sets the total duration (including repeats) of the given animation by time scaling the animation.
		 *
		 * ```js
		 * anim.totalDuration(8);
		 * ```
		 *
		 * @param {number} value
		 * @returns {Animation} The animation
		 * @memberof Animation
		 * @link https://greensock.com/docs/v3/GSAP/Tween/totalDuration()
		 */
		totalDuration(value: number): this;
		/**
		 * Gets the total duration (including repeats) of the given animation.
		 *
		 * ```js
		 * anim.totalDuration(); // the total duration, e.g. something like 5.7
		 * ```
		 *
		 * @returns {number} The total duration
		 * @memberof Animation
		 * @link https://greensock.com/docs/v3/GSAP/Tween/totalDuration()
		 */
		totalDuration(): number;
		/**
		 * Sets the total progress (including repeats) of the given animation.
		 *
		 * ```js
		 * anim.totalProgress(0.5); // move the playhead to half way through the animation (including repeats)
		 * ```
		 *
		 * @param {number} value
		 * @param {boolean} suppressEvents
		 * @returns {Animation} The animation
		 * @memberof Animation
		 * @link https://greensock.com/docs/v3/GSAP/Tween/totalProgress()
		 */
		totalProgress(value: number, suppressEvents?: boolean): this;
		/**
		 * Gets the total progress (including repeats) of the given animation.
		 *
		 * ```js
		 * anim.totalProgress(); // the total progress, e.g. something like 0.5
		 * ```
		 *
		 * @returns {number} The total progress
		 * @memberof Animation
		 * @link https://greensock.com/docs/v3/GSAP/Tween/totalProgress()
		 */
		totalProgress(): number;
		/**
		 * Sets the total time (meaning where the playhead is, including repeats) of the given animation.
		 *
		 * ```js
		 * anim.totalTime(5.7); // move the playhead to the 5.7 mark of the animation (including repeats)
		 * ```
		 *
		 * @param {number} value
		 * @param {boolean} [suppressEvents]
		 * @returns {Animation} The animation
		 * @memberof Animation
		 * @link https://greensock.com/docs/v3/GSAP/Tween/totalTime()
		 */
		totalTime(value: number, suppressEvents?: boolean): this;
		/**
		 * Gets the total time (meaning where the playhead is, including repeats) of the given animation.
		 *
		 * ```js
		 * anim.totalTime(); // the total time, e.g. something like 5.7
		 * ```
		 *
		 * @returns {number} The total time
		 * @memberof Animation
		 * @link https://greensock.com/docs/v3/GSAP/Tween/totalTime()
		 */
		totalTime(): number;
		/**
		 * Sets the yoyo value of the given animation.
		 * Setting yoyo to true means that each time the animation repeats it should switch its direction (forwards or reverse).
		 *
		 * ```js
		 * anim.yoyo(true);
		 * ```
		 *
		 * @param {boolean} value
		 * @returns {Animation} The animation
		 * @memberof Animation
		 * @link https://greensock.com/docs/v3/GSAP/Tween/yoyo()
		 */
		yoyo(value: boolean): this;
		/**
		 * Gets the yoyo value of the given animation.
		 * If yoyo is true that means that each time the animation repeats it should switch its direction (forwards or reverse).
		 *
		 * ```js
		 * anim.yoyo(); // true or false
		 * ```
		 *
		 * @returns {boolean} The yoyo value
		 * @memberof Animation
		 * @link https://greensock.com/docs/v3/GSAP/Tween/yoyo()
		 */
		yoyo(): boolean;
	}
}
declare namespace gsap {
	// GSAP specific
	interface CSSProperties {
		[key: string]: any;
		alpha: TweenValue;
		autoAlpha: TweenValue;
		rotate: TweenValue;
		rotateX: TweenValue;
		rotateY: TweenValue;
		rotateZ: TweenValue;
		rotation: TweenValue;
		rotationX: TweenValue;
		rotationY: TweenValue;
		rotationZ: TweenValue;
		scale: TweenValue;
		scaleX: TweenValue;
		scaleY: TweenValue;
		skew: TweenValue;
		skewX: TweenValue;
		skewY: TweenValue;
		smoothOrigin: BooleanValue;
		svgOrigin: TweenValue;
		translateX: TweenValue;
		translateY: TweenValue;
		translateZ: TweenValue;
		x: TweenValue;
		xPercent: TweenValue;
		y: TweenValue;
		yPercent: TweenValue;
		z: TweenValue;
	}
	interface CSSProperties {
		alignContent: TweenValue;
		alignItems: TweenValue;
		alignSelf: TweenValue;
		alignmentBaseline: TweenValue;
		animation: TweenValue;
		animationDelay: TweenValue;
		animationDirection: TweenValue;
		animationDuration: TweenValue;
		animationFillMode: TweenValue;
		animationIterationCount: TweenValue;
		animationName: TweenValue;
		animationPlayState: TweenValue;
		animationTimingFunction: TweenValue;
		backfaceVisibility: TweenValue;
		background: TweenValue;
		backgroundAttachment: TweenValue;
		backgroundClip: TweenValue;
		backgroundColor: TweenValue;
		backgroundImage: TweenValue;
		backgroundOrigin: TweenValue;
		backgroundPosition: TweenValue;
		backgroundPositionX: TweenValue;
		backgroundPositionY: TweenValue;
		backgroundRepeat: TweenValue;
		backgroundSize: TweenValue;
		baselineShift: TweenValue;
		border: TweenValue;
		borderBottom: TweenValue;
		borderBottomColor: TweenValue;
		borderBottomLeftRadius: TweenValue;
		borderBottomRightRadius: TweenValue;
		borderBottomStyle: TweenValue;
		borderBottomWidth: TweenValue;
		borderCollapse: TweenValue;
		borderColor: TweenValue;
		borderImage: TweenValue;
		borderImageOutset: TweenValue;
		borderImageRepeat: TweenValue;
		borderImageSlice: TweenValue;
		borderImageSource: TweenValue;
		borderImageWidth: TweenValue;
		borderLeft: TweenValue;
		borderLeftColor: TweenValue;
		borderLeftStyle: TweenValue;
		borderLeftWidth: TweenValue;
		borderRadius: TweenValue;
		borderRight: TweenValue;
		borderRightColor: TweenValue;
		borderRightStyle: TweenValue;
		borderRightWidth: TweenValue;
		borderSpacing: TweenValue;
		borderStyle: TweenValue;
		borderTop: TweenValue;
		borderTopColor: TweenValue;
		borderTopLeftRadius: TweenValue;
		borderTopRightRadius: TweenValue;
		borderTopStyle: TweenValue;
		borderTopWidth: TweenValue;
		borderWidth: TweenValue;
		bottom: TweenValue;
		boxShadow: TweenValue;
		boxSizing: TweenValue;
		breakAfter: TweenValue;
		breakBefore: TweenValue;
		breakInside: TweenValue;
		captionSide: TweenValue;
		caretColor: TweenValue;
		clear: TweenValue;
		clip: TweenValue;
		clipPath: TweenValue;
		clipRule: TweenValue;
		color: TweenValue;
		colorInterpolationFilters: TweenValue;
		columnCount: TweenValue;
		columnFill: TweenValue;
		columnGap: TweenValue;
		columnRule: TweenValue;
		columnRuleColor: TweenValue;
		columnRuleStyle: TweenValue;
		columnRuleWidth: TweenValue;
		columnSpan: TweenValue;
		columnWidth: TweenValue;
		columns: TweenValue;
		content: TweenValue;
		counterIncrement: TweenValue;
		counterReset: TweenValue;
		cssFloat: TweenValue;
		cssText: TweenValue;
		cursor: TweenValue;
		direction: TweenValue;
		display: TweenValue;
		dominantBaseline: TweenValue;
		emptyCells: TweenValue;
		enableBackground: TweenValue;
		fill: TweenValue;
		fillOpacity: TweenValue;
		fillRule: TweenValue;
		filter: TweenValue;
		flex: TweenValue;
		flexBasis: TweenValue;
		flexDirection: TweenValue;
		flexFlow: TweenValue;
		flexGrow: TweenValue;
		flexShrink: TweenValue;
		flexWrap: TweenValue;
		floodColor: TweenValue;
		floodOpacity: TweenValue;
		font: TweenValue;
		fontFamily: TweenValue;
		fontFeatureSettings: TweenValue;
		fontKerning: TweenValue;
		fontSize: TweenValue;
		fontSizeAdjust: TweenValue;
		fontStretch: TweenValue;
		fontStyle: TweenValue;
		fontSynthesis: TweenValue;
		fontVariant: TweenValue;
		fontVariantCaps: TweenValue;
		fontVariantEastAsian: TweenValue;
		fontVariantLigatures: TweenValue;
		fontVariantNumeric: TweenValue;
		fontVariantPosition: TweenValue;
		fontWeight: TweenValue;
		gap: TweenValue;
		glyphOrientationHorizontal: TweenValue;
		glyphOrientationVertical: TweenValue;
		grid: TweenValue;
		gridArea: TweenValue;
		gridAutoColumns: TweenValue;
		gridAutoFlow: TweenValue;
		gridAutoRows: TweenValue;
		gridColumn: TweenValue;
		gridColumnEnd: TweenValue;
		gridColumnGap: TweenValue;
		gridColumnStart: TweenValue;
		gridGap: TweenValue;
		gridRow: TweenValue;
		gridRowEnd: TweenValue;
		gridRowGap: TweenValue;
		gridRowStart: TweenValue;
		gridTemplate: TweenValue;
		gridTemplateAreas: TweenValue;
		gridTemplateColumns: TweenValue;
		gridTemplateRows: TweenValue;
		height: TweenValue;
		hyphens: TweenValue;
		imageOrientation: TweenValue;
		imageRendering: TweenValue;
		imeMode: TweenValue;
		justifyContent: TweenValue;
		justifyItems: TweenValue;
		justifySelf: TweenValue;
		kerning: TweenValue;
		layoutGrid: TweenValue;
		layoutGridChar: TweenValue;
		layoutGridLine: TweenValue;
		layoutGridMode: TweenValue;
		layoutGridType: TweenValue;
		left: TweenValue;
		letterSpacing: TweenValue;
		lightingColor: TweenValue;
		lineBreak: TweenValue;
		lineHeight: TweenValue;
		listStyle: TweenValue;
		listStyleImage: TweenValue;
		listStylePosition: TweenValue;
		listStyleType: TweenValue;
		margin: TweenValue;
		marginBottom: TweenValue;
		marginLeft: TweenValue;
		marginRight: TweenValue;
		marginTop: TweenValue;
		marker: TweenValue;
		markerEnd: TweenValue;
		markerMid: TweenValue;
		markerStart: TweenValue;
		mask: TweenValue;
		maskComposite: TweenValue;
		maskImage: TweenValue;
		maskPosition: TweenValue;
		maskRepeat: TweenValue;
		maskSize: TweenValue;
		maskType: TweenValue;
		maxHeight: TweenValue;
		maxWidth: TweenValue;
		minHeight: TweenValue;
		minWidth: TweenValue;
		msContentZoomChaining: TweenValue;
		msContentZoomLimit: TweenValue;
		msContentZoomLimitMax: any;
		msContentZoomLimitMin: any;
		msContentZoomSnap: TweenValue;
		msContentZoomSnapPoints: TweenValue;
		msContentZoomSnapType: TweenValue;
		msContentZooming: TweenValue;
		msFlowFrom: TweenValue;
		msFlowInto: TweenValue;
		msFontFeatureSettings: TweenValue;
		msGridColumn: any;
		msGridColumnAlign: TweenValue;
		msGridColumnSpan: any;
		msGridColumns: TweenValue;
		msGridRow: any;
		msGridRowAlign: TweenValue;
		msGridRowSpan: any;
		msGridRows: TweenValue;
		msHighContrastAdjust: TweenValue;
		msHyphenateLimitChars: TweenValue;
		msHyphenateLimitLines: any;
		msHyphenateLimitZone: any;
		msHyphens: TweenValue;
		msImeAlign: TweenValue;
		msOverflowStyle: TweenValue;
		msScrollChaining: TweenValue;
		msScrollLimit: TweenValue;
		msScrollLimitXMax: any;
		msScrollLimitXMin: any;
		msScrollLimitYMax: any;
		msScrollLimitYMin: any;
		msScrollRails: TweenValue;
		msScrollSnapPointsX: TweenValue;
		msScrollSnapPointsY: TweenValue;
		msScrollSnapType: TweenValue;
		msScrollSnapX: TweenValue;
		msScrollSnapY: TweenValue;
		msScrollTranslation: TweenValue;
		msTextCombineHorizontal: TweenValue;
		msTextSizeAdjust: any;
		msTouchAction: TweenValue;
		msTouchSelect: TweenValue;
		msUserSelect: TweenValue;
		msWrapFlow: TweenValue;
		msWrapMargin: any;
		msWrapThrough: TweenValue;
		objectFit: TweenValue;
		objectPosition: TweenValue;
		opacity: TweenValue;
		order: TweenValue;
		orphans: TweenValue;
		outline: TweenValue;
		outlineColor: TweenValue;
		outlineOffset: TweenValue;
		outlineStyle: TweenValue;
		outlineWidth: TweenValue;
		overflow: TweenValue;
		overflowAnchor: TweenValue;
		overflowWrap: TweenValue;
		overflowX: TweenValue;
		overflowY: TweenValue;
		padding: TweenValue;
		paddingBottom: TweenValue;
		paddingLeft: TweenValue;
		paddingRight: TweenValue;
		paddingTop: TweenValue;
		pageBreakAfter: TweenValue;
		pageBreakBefore: TweenValue;
		pageBreakInside: TweenValue;
		penAction: TweenValue;
		perspective: TweenValue;
		perspectiveOrigin: TweenValue;
		placeContent: TweenValue;
		placeItems: TweenValue;
		placeSelf: TweenValue;
		pointerEvents: TweenValue;
		position: TweenValue;
		quotes: TweenValue;
		resize: TweenValue;
		right: TweenValue;
		rotate: TweenValue;
		rowGap: TweenValue;
		rubyAlign: TweenValue;
		rubyOverhang: TweenValue;
		rubyPosition: TweenValue;
		scale: TweenValue;
		scrollBehavior: TweenValue;
		stopColor: TweenValue;
		stopOpacity: TweenValue;
		stroke: TweenValue;
		strokeDasharray: TweenValue;
		strokeDashoffset: TweenValue;
		strokeLinecap: TweenValue;
		strokeLinejoin: TweenValue;
		strokeMiterlimit: TweenValue;
		strokeOpacity: TweenValue;
		strokeWidth: TweenValue;
		tabSize: TweenValue;
		tableLayout: TweenValue;
		textAlign: TweenValue;
		textAlignLast: TweenValue;
		textAnchor: TweenValue;
		textCombineUpright: TweenValue;
		textDecoration: TweenValue;
		textDecorationColor: TweenValue;
		textDecorationLine: TweenValue;
		textDecorationStyle: TweenValue;
		textEmphasis: TweenValue;
		textEmphasisColor: TweenValue;
		textEmphasisPosition: TweenValue;
		textEmphasisStyle: TweenValue;
		textIndent: TweenValue;
		textJustify: TweenValue;
		textKashida: TweenValue;
		textKashidaSpace: TweenValue;
		textOrientation: TweenValue;
		textOverflow: TweenValue;
		textShadow: TweenValue;
		textTransform: TweenValue;
		textUnderlinePosition: TweenValue;
		top: TweenValue;
		touchAction: TweenValue;
		transform: TweenValue;
		transformBox: TweenValue;
		transformOrigin: TweenValue;
		transformStyle: TweenValue;
		transition: TweenValue;
		transitionDelay: TweenValue;
		transitionDuration: TweenValue;
		transitionProperty: TweenValue;
		transitionTimingFunction: TweenValue;
		translate: TweenValue;
		unicodeBidi: TweenValue;
		userSelect: TweenValue;
		verticalAlign: TweenValue;
		visibility: TweenValue;
		/** @deprecated */
		webkitAlignContent: TweenValue;
		/** @deprecated */
		webkitAlignItems: TweenValue;
		/** @deprecated */
		webkitAlignSelf: TweenValue;
		/** @deprecated */
		webkitAnimation: TweenValue;
		/** @deprecated */
		webkitAnimationDelay: TweenValue;
		/** @deprecated */
		webkitAnimationDirection: TweenValue;
		/** @deprecated */
		webkitAnimationDuration: TweenValue;
		/** @deprecated */
		webkitAnimationFillMode: TweenValue;
		/** @deprecated */
		webkitAnimationIterationCount: TweenValue;
		/** @deprecated */
		webkitAnimationName: TweenValue;
		/** @deprecated */
		webkitAnimationPlayState: TweenValue;
		/** @deprecated */
		webkitAnimationTimingFunction: TweenValue;
		/** @deprecated */
		webkitAppearance: TweenValue;
		/** @deprecated */
		webkitBackfaceVisibility: TweenValue;
		/** @deprecated */
		webkitBackgroundClip: TweenValue;
		/** @deprecated */
		webkitBackgroundOrigin: TweenValue;
		/** @deprecated */
		webkitBackgroundSize: TweenValue;
		/** @deprecated */
		webkitBorderBottomLeftRadius: TweenValue;
		/** @deprecated */
		webkitBorderBottomRightRadius: TweenValue;
		webkitBorderImage: TweenValue;
		/** @deprecated */
		webkitBorderRadius: TweenValue;
		/** @deprecated */
		webkitBorderTopLeftRadius: TweenValue;
		/** @deprecated */
		webkitBorderTopRightRadius: TweenValue;
		/** @deprecated */
		webkitBoxAlign: TweenValue;
		webkitBoxDirection: TweenValue;
		/** @deprecated */
		webkitBoxFlex: TweenValue;
		/** @deprecated */
		webkitBoxOrdinalGroup: TweenValue;
		webkitBoxOrient: TweenValue;
		/** @deprecated */
		webkitBoxPack: TweenValue;
		/** @deprecated */
		webkitBoxShadow: TweenValue;
		/** @deprecated */
		webkitBoxSizing: TweenValue;
		webkitColumnBreakAfter: TweenValue;
		webkitColumnBreakBefore: TweenValue;
		webkitColumnBreakInside: TweenValue;
		webkitColumnCount: any;
		webkitColumnGap: any;
		webkitColumnRule: TweenValue;
		webkitColumnRuleColor: any;
		webkitColumnRuleStyle: TweenValue;
		webkitColumnRuleWidth: any;
		webkitColumnSpan: TweenValue;
		webkitColumnWidth: any;
		webkitColumns: TweenValue;
		/** @deprecated */
		webkitFilter: TweenValue;
		/** @deprecated */
		webkitFlex: TweenValue;
		/** @deprecated */
		webkitFlexBasis: TweenValue;
		/** @deprecated */
		webkitFlexDirection: TweenValue;
		/** @deprecated */
		webkitFlexFlow: TweenValue;
		/** @deprecated */
		webkitFlexGrow: TweenValue;
		/** @deprecated */
		webkitFlexShrink: TweenValue;
		/** @deprecated */
		webkitFlexWrap: TweenValue;
		/** @deprecated */
		webkitJustifyContent: TweenValue;
		webkitLineClamp: TweenValue;
		/** @deprecated */
		webkitMask: TweenValue;
		/** @deprecated */
		webkitMaskBoxImage: TweenValue;
		/** @deprecated */
		webkitMaskBoxImageOutset: TweenValue;
		/** @deprecated */
		webkitMaskBoxImageRepeat: TweenValue;
		/** @deprecated */
		webkitMaskBoxImageSlice: TweenValue;
		/** @deprecated */
		webkitMaskBoxImageSource: TweenValue;
		/** @deprecated */
		webkitMaskBoxImageWidth: TweenValue;
		/** @deprecated */
		webkitMaskClip: TweenValue;
		/** @deprecated */
		webkitMaskComposite: TweenValue;
		/** @deprecated */
		webkitMaskImage: TweenValue;
		/** @deprecated */
		webkitMaskOrigin: TweenValue;
		/** @deprecated */
		webkitMaskPosition: TweenValue;
		/** @deprecated */
		webkitMaskRepeat: TweenValue;
		/** @deprecated */
		webkitMaskSize: TweenValue;
		/** @deprecated */
		webkitOrder: TweenValue;
		/** @deprecated */
		webkitPerspective: TweenValue;
		/** @deprecated */
		webkitPerspectiveOrigin: TweenValue;
		webkitTapHighlightColor: TweenValue;
		/** @deprecated */
		webkitTextFillColor: TweenValue;
		/** @deprecated */
		webkitTextSizeAdjust: TweenValue;
		/** @deprecated */
		webkitTextStroke: TweenValue;
		/** @deprecated */
		webkitTextStrokeColor: TweenValue;
		/** @deprecated */
		webkitTextStrokeWidth: TweenValue;
		/** @deprecated */
		webkitTransform: TweenValue;
		/** @deprecated */
		webkitTransformOrigin: TweenValue;
		/** @deprecated */
		webkitTransformStyle: TweenValue;
		/** @deprecated */
		webkitTransition: TweenValue;
		/** @deprecated */
		webkitTransitionDelay: TweenValue;
		/** @deprecated */
		webkitTransitionDuration: TweenValue;
		/** @deprecated */
		webkitTransitionProperty: TweenValue;
		/** @deprecated */
		webkitTransitionTimingFunction: TweenValue;
		webkitUserModify: TweenValue;
		webkitUserSelect: TweenValue;
		webkitWritingMode: TweenValue;
		whiteSpace: TweenValue;
		widows: TweenValue;
		width: TweenValue;
		willChange: TweenValue;
		wordBreak: TweenValue;
		wordSpacing: TweenValue;
		wordWrap: TweenValue;
		writingMode: TweenValue;
		zIndex: TweenValue;
		zoom: TweenValue;
	}
	interface CSSVars extends Partial<CSSProperties> {}
	interface TweenVars extends CSSVars {
		css?: CSSVars;
	}
	// TODO: Add types
	interface GSCache {
		[key: string]: any;
	}
}
declare namespace gsap.plugins {
	interface CSSPlugin extends Plugin {}
	interface CSSPluginClass extends CSSPlugin {
		new (): PluginScope & CSSPlugin;
		prototype: PluginScope & CSSPlugin;
	}
	const css: CSSPluginClass;
}
export interface Element {
	_gsap: gsap.GSCache;
}
declare namespace gsap {
	interface TweenVars {
		cssRule?: object; // TODO make more specific
	}
}
declare namespace gsap.plugins {
	interface CSSRulePlugin extends Plugin {
		/**
		 * Gets the style sheet object associated with a particular selector.
		 *
		 * ```js
		 * var rule = CSSRulePlugin.getRule(".myClass::before");
		 * // Then do what you want with it, such as:
		 * gsap.to(rule, { duration: 3, cssRule: { color: "#0000FF" } });
		 * ```
		 *
		 * @param {string} selector
		 * @returns {CSSRule} The CSSRule
		 * @memberof CSSRulePlugin
		 * @link https://greensock.com/docs/v3/Plugins/CSSRulePlugin
		 */
		getRule(selector: string): CSSRule;
	}
	interface CSSRulePluginClass extends CSSRulePlugin {
		new (): PluginScope & CSSRulePlugin;
		prototype: PluginScope & CSSRulePlugin;
	}
	const cssRule: CSSRulePluginClass;
}
declare class Draggable {
	static version: string;
	static zIndex: number;
	readonly autoScroll: number;
	readonly deltaX: number;
	readonly deltaY: number;
	readonly endRotation: number;
	readonly endX: number;
	readonly endY: number;
	readonly isDragging: boolean;
	readonly isPressed: boolean;
	readonly isThrowing: boolean;
	readonly lockAxis: boolean;
	readonly maxRotation: number;
	readonly maxX: number;
	readonly maxY: number;
	readonly minX: number;
	readonly minY: number;
	readonly minRotation: number;
	readonly pointerEvent: TouchEvent | PointerEvent;
	readonly pointerX: number;
	readonly pointerY: number;
	readonly rotation: number;
	readonly scrollProxy: any; // TODO: Create interface
	readonly startX: number;
	readonly startY: number;
	readonly target: HTMLElement | SVGElement;
	readonly tween: gsap.core.Tween;
	readonly vars: Draggable.Vars;
	readonly x: number;
	readonly y: number;
	constructor(target: gsap.DOMTarget, vars?: Draggable.Vars);
	/**
	 * A more flexible way to create Draggable instances than the constructor.
	 *
	 * ```js
	 * Draggable.create(".myClass", {type: "x,y"});
	 * ```
	 *
	 * @param {gsap.DOMTarget} target
	 * @param {Draggable.Vars} [vars]
	 * @returns {Draggable[]} Array of Draggables
	 * @memberof Draggable
	 * @link https://greensock.com/docs/v3/Plugins/Draggable/static.create()
	 */
	static create(target: gsap.DOMTarget, vars?: Draggable.Vars): Draggable[];
	/**
	 * Get the Draggable instance that's associated with a particular DOM element.
	 *
	 * ```js
	 * var draggable = Draggable.get("#myId");
	 * ```
	 *
	 * @param {gsap.DOMTarget} target
	 * @returns {Draggable} The Draggable
	 * @memberof Draggable
	 * @link https://greensock.com/docs/v3/Plugins/Draggable/static.get()
	 */
	static get(target: gsap.DOMTarget): Draggable;
	/**
	 * Test whether or not the target element overlaps with a particular element or the mouse position, optionally including a threshold.
	 *
	 * ```js
	 * Draggable.hitTest(element1, element2, 20)
	 * ```
	 *
	 * @param {Draggable.TestObject} testObject1
	 * @param {Draggable.TestObject} testObject2
	 * @param {number | string} [threshold]
	 * @returns {boolean} If the hit threshhold is met or not
	 * @memberof Draggable
	 * @link https://greensock.com/docs/v3/Plugins/Draggable/static.hitTest()
	 */
	static hitTest(
		testObject1: Draggable.TestObject,
		testObject2: Draggable.TestObject,
		threshold?: number | string
	): boolean;
	/**
	 * Returns the time (in seconds) that has elapsed since the last drag ended.
	 *
	 * ```js
	 * Draggable.timeSinceDrag();
	 * ```
	 *
	 * @returns {number} The time since the last drag ended
	 * @memberof Draggable
	 * @link https://greensock.com/docs/v3/Plugins/Draggable/static.timeSinceDrag()
	 */
	static timeSinceDrag(): number;
	/**
	 * Registers a function that should be called each time a particular type of event occurs.
	 *
	 * ```js
	 * draggable.addEventListener("press", myPressFunction);
	 * ```
	 *
	 * @param {Draggable.CallbackType} type
	 * @param {gsap.Callback} callback
	 * @memberof Draggable
	 * @link https://greensock.com/docs/v3/Plugins/Draggable/addEventListener()
	 */
	addEventListener(type: Draggable.CallbackType, callback: gsap.Callback): void;
	/**
	 * Registers a function that should be called each time a particular type of event occurs.
	 *
	 * ```js
	 * draggable.applyBounds("#dragContainer");
	 * draggable.applyBounds({top: 100, left: 0, width: 1000, height: 800});
	 * draggable.applyBounds({minX: 10, maxX: 300, minY: 50, maxY: 500});
	 * draggable.applyBounds({minRotation: 0, maxRotation: 270});
	 * ```
	 *
	 * @param {gsap.DOMTarget | Draggable.BoundsMinMax | Draggable.BoundsRectangle | Draggable.BoundsRotation} bounds
	 * @memberof Draggable
	 * @link https://greensock.com/docs/v3/Plugins/Draggable/applyBounds()
	 */
	applyBounds(
		bounds: gsap.DOMTarget | Draggable.BoundsMinMax | Draggable.BoundsRectangle | Draggable.BoundsRotation
	): void;
	/**
	 * Disables the Draggable instance so that it cannot be dragged anymore.
	 *
	 * ```js
	 * draggable.disable();
	 * ```
	 *
	 * @param {string | object} [type]
	 * @returns {Draggable} The Draggable instance
	 * @memberof Draggable
	 * @link https://greensock.com/docs/v3/Plugins/Draggable/disable()
	 */
	disable(type?: string | object): this;
	dispatchEvent(type: Draggable.CallbackType): boolean;
	/**
	 * Enables the Draggable instance so that it can be dragged.
	 *
	 * ```js
	 * draggable.enable();
	 * ```
	 *
	 * @param {string | object} [type]
	 * @returns {Draggable} The Draggable instance
	 * @memberof Draggable
	 * @link https://greensock.com/docs/v3/Plugins/Draggable/enable()
	 */
	enable(type?: string | object): this;
	/**
	 * Sets the enabled state of the Draggable.
	 *
	 * ```js
	 * draggable.enabled(true);
	 * ```
	 *
	 * @param {boolean} value
	 * @returns {Draggable} The Draggable
	 * @memberof Draggable
	 * @link https://greensock.com/docs/v3/Plugins/Draggable/enabled()
	 */
	enabled(value: boolean): this;
	/**
	 * Gets the enabled state of the Draggable.
	 *
	 * ```js
	 * draggable.enabled();
	 * ```
	 *
	 * @returns {boolean} The enabled state
	 * @memberof Draggable
	 * @link https://greensock.com/docs/v3/Plugins/Draggable/enabled()
	 */
	enabled(): boolean;
	/**
	 * Force the Draggable to immediately stop interactively dragging.
	 * You must pass it the original mouse or touch event that initiated the stop.
	 *
	 * ```js
	 * draggable.endDrag(e);
	 * ```
	 *
	 * @param {Event} event
	 * @memberof Draggable
	 * @link https://greensock.com/docs/v3/Plugins/Draggable/endDrag()
	 */
	endDrag(event: Event): void;
	/**
	 * Returns the direction, velocity, or proximity to another object.
	 *
	 * ```js
	 * draggable.getDirection("start");
	 * draggable.getDirection("velocity");
	 * draggable.getDirection(refElem);
	 * ```
	 *
	 * @param {"start" | "velocity" | gsap.DOMTarget} from
	 * @returns {Draggable.Direction} The direction
	 * @memberof Draggable
	 * @link https://greensock.com/docs/v3/Plugins/Draggable/getDirection()
	 */
	getDirection(from: 'start' | 'velocity' | gsap.DOMTarget): Draggable.Direction;
	/**
	 * Test whether or not the target element overlaps with a particular element or the mouse position, optionally including a threshold.
	 *
	 * ```js
	 * draggable.hitTest(otherElem, 20);
	 * ```
	 *
	 * @param {Draggable.TestObject} testObject
	 * @param {number | string} [threshold]
	 * @returns {boolean} If the hit threshhold is met or not
	 * @memberof Draggable
	 * @link https://greensock.com/docs/v3/Plugins/Draggable/static.hitTest()
	 */
	hitTest(testObject: Draggable.TestObject, threshold?: number | string): boolean;
	/**
	 * Disables the Draggable instance and frees it for garbage collection
	 * so that it cannot be dragged anymore.
	 *
	 * ```js
	 * draggable.kill();
	 * ```
	 *
	 * @returns {Draggable} The Draggable instance
	 * @memberof Draggable
	 * @link https://greensock.com/docs/v3/Plugins/Draggable/kill()
	 */
	kill(): this;
	removeEventListener(type: Draggable.CallbackType, callback: gsap.Callback): void;
	/**
	 * Force the Draggable to start interactively dragging.
	 * You must pass it the original mouse or touch event that initiated the start.
	 *
	 * ```js
	 * draggable.startDrag(e);
	 * ```
	 *
	 * @param {Event} event
	 * @param {boolean} align
	 * @memberof Draggable
	 * @link https://greensock.com/docs/v3/Plugins/Draggable/startDrag()
	 */
	startDrag(event: Event, align?: boolean): void;
	/**
	 * Returns the time (in seconds) that has elapsed since the last drag ended.
	 *
	 * ```js
	 * draggable.timeSinceDrag();
	 * ```
	 *
	 * @returns {number} The time since the last drag ended
	 * @memberof Draggable
	 * @link https://greensock.com/docs/v3/Plugins/Draggable/static.timeSinceDrag()
	 */
	timeSinceDrag(): number;
	/**
	 * Updates the Draggable's x/y properties to reflect the target element's current position.
	 *
	 * ```js
	 * Draggable.update();
	 * ```
	 *
	 * @param {boolean} [applyBounds]
	 * @param {boolean} [sticky]
	 * @returns {Draggable} The Draggable instance
	 * @memberof Draggable
	 * @link https://greensock.com/docs/v3/Plugins/Draggable/update()
	 */
	update(applyBounds?: boolean, sticky?: boolean): this;
}
declare namespace Draggable {
	type CallbackType =
		| 'click'
		| 'drag'
		| 'dragend'
		| 'dragstart'
		| 'move'
		| 'press'
		| 'release'
		| 'throwcomplete'
		| 'throwupdate';
	type Direction = 'down' | 'left' | 'left-down' | 'left-up' | 'up' | 'right' | 'right-down' | 'right-up';
	type DraggableType =
		| 'left'
		| 'left,top'
		| 'rotation'
		| 'scroll'
		| 'scrollLeft'
		| 'scrollTop'
		| 'top'
		| 'top,left'
		| 'x'
		| 'x,y'
		| 'y'
		| 'y,x';
	type SnapValue = number[] | ((value: number) => number);
	type TestObject = gsap.DOMTarget | Event | Rectangle;
	interface BoundsMinMax {
		minX?: number;
		minY?: number;
		maxX?: number;
		maxY?: number;
	}
	interface BoundsRectangle {
		height?: number;
		left?: number;
		top?: number;
		width?: number;
	}
	interface BoundsRotation {
		minRotation?: number;
		maxRotation?: number;
	}
	interface Rectangle {
		bottom: number;
		left: number;
		right: number;
		top: number;
	}
	interface SnapObject {
		left?: SnapValue;
		points?: gsap.Point2D[] | ((point: gsap.Point2D) => gsap.Point2D);
		radius?: number;
		rotation?: SnapValue;
		top?: SnapValue;
		x?: SnapValue;
		y?: SnapValue;
	}
	interface Vars {
		[key: string]: any;
		activeCursor?: string;
		allowContextMenu?: boolean;
		allowEventDefault?: boolean;
		allowNativeTouchScrolling?: boolean;
		autoScroll?: number;
		bounds?: gsap.DOMTarget | BoundsMinMax | BoundsRectangle | BoundsRotation;
		callbackScope?: object;
		clickableTest?: (this: Draggable, element: HTMLElement | SVGElement) => void;
		cursor?: string;
		dragClickables?: boolean;
		dragResistance?: number;
		edgeResistance?: number;
		force3D?: 'auto' | boolean;
		inertia?: boolean | gsap.InertiaVars;
		liveSnap?: boolean | SnapValue | SnapObject;
		lockAxis?: boolean;
		maxDuration?: number;
		minDuration?: number;
		minimumMovement?: number;
		onClick?: gsap.Callback;
		onClickParams?: any[];
		onDrag?: gsap.Callback;
		onDragParams?: any[];
		onDragStart?: gsap.Callback;
		onDragStartParams?: any[];
		onDragEnd?: gsap.Callback;
		onDragEndParams?: any[];
		onLockAxis?: (this: Draggable, event: Event) => void;
		onMove?: gsap.Callback;
		onMoveParams?: any[];
		onPress?: gsap.Callback;
		onPressParams?: any[];
		onPressInit?: gsap.Callback;
		onPressInitParams?: any[];
		onRelease?: gsap.Callback;
		onReleaseParams?: any[];
		onThrowComplete?: gsap.Callback;
		onThrowCompleteParams?: any[];
		onThrowUpdate?: gsap.Callback;
		onThrowUpdateParams?: any[];
		overshootTolerance?: number;
		resistance?: number;
		snap?: SnapValue | SnapObject;
		throwProps?: boolean | gsap.InertiaVars;
		throwResistance?: number;
		trigger?: gsap.DOMTarget;
		type?: DraggableType;
		zIndexBoost?: boolean;
	}
}
declare namespace gsap {
	type DrawSVGTarget = string | SVGPrimitive | SVGPathElement;
	interface TweenVars {
		drawSVG?: number | BooleanValue | DrawSVGTarget;
	}
}
declare namespace gsap.plugins {
	interface DrawSVGPlugin extends Plugin {
		/**
		 * Get the length of an SVG element's stroke.
		 *
		 * ```js
		 * DrawSVGPlugin.getLength(element);
		 * ```
		 *
		 * @param {DrawSVGTarget} element
		 * @returns {number} The stroke length
		 * @memberof DrawSVGPlugin
		 * @link https://greensock.com/docs/v3/Plugins/DrawSVGPlugin/static.getLength()
		 */
		getLength(element: DrawSVGTarget): number;
		/**
		 * Get the current position of the DrawSVG in array form.
		 *
		 * ```js
		 * DrawSVGPlugin.getPosition(element);
		 * ```
		 *
		 * @param {DrawSVGTarget} element
		 * @returns {number[]} The position array
		 * @memberof DrawSVGPlugin
		 * @link https://greensock.com/docs/v3/Plugins/DrawSVGPlugin/static.getPosition()
		 */
		getPosition(element: DrawSVGTarget): number[];
	}
	interface DrawSVGPluginClass extends DrawSVGPlugin {
		new (): PluginScope & DrawSVGPlugin;
		prototype: PluginScope & DrawSVGPlugin;
	}
	const drawSVG: DrawSVGPluginClass;
}
declare namespace gsap {
	interface EaseFunction {
		(progress: number): number;
	}
	interface Ease {
		easeIn: EaseFunction;
		easeOut: EaseFunction;
		easeInOut: EaseFunction;
	}
	interface BackConfig extends EaseFunction {
		config(overshoot: number): EaseFunction;
	}
	interface Back {
		easeIn: BackConfig;
		easeOut: BackConfig;
		easeInOut: BackConfig;
	}
	interface EasePack {
		SlowMo: gsap.SlowMo;
		ExpoScaleEase: gsap.ExpoScaleEase;
		RoughEase: gsap.RoughEase;
	}
	interface ElasticConfig extends EaseFunction {
		config(amplitude: number, period?: number): EaseFunction;
	}
	interface Elastic {
		easeIn: ElasticConfig;
		easeOut: ElasticConfig;
		easeInOut: ElasticConfig;
	}
	interface ExpoScaleEase {
		config(startingScale: number, endingScale: number, ease?: string | EaseFunction): EaseFunction;
	}
	interface Linear extends Ease {
		easeNone: EaseFunction;
	}
	interface RoughEaseVars {
		clamp?: boolean;
		points?: number;
		randomize?: boolean;
		strength?: number;
		taper?: 'in' | 'out' | 'both' | 'none';
		template?: string | EaseFunction;
	}
	interface RoughEaseEase extends EaseFunction {
		config: RoughEaseConfig;
	}
	interface RoughEaseConfig extends EaseFunction {
		(config?: RoughEaseVars): EaseFunction;
	}
	interface RoughEase extends EaseFunction {
		config: RoughEaseConfig;
		ease: RoughEaseEase;
	}
	interface SlowMoEase extends EaseFunction {
		config: SlowMoConfig;
	}
	interface SlowMoConfig extends EaseFunction {
		(linearRatio: number, power?: number, yoyoMode?: boolean): EaseFunction;
	}
	interface SlowMo extends EaseFunction {
		config: SlowMoConfig;
		ease: SlowMoEase;
	}
	interface SteppedEase {
		config(steps: number): EaseFunction;
	}
}
declare namespace EaselPlugin {
	interface Vars {
		[key: string]: any;
	}
}
declare namespace gsap {
	interface TweenVars {
		easel?: EaselPlugin.Vars;
	}
}
declare namespace gsap.plugins {
	interface EaselPlugin extends Plugin {}
	interface EaselPluginClass extends EaselPlugin {
		new (): PluginScope & EaselPlugin;
		prototype: PluginScope & EaselPlugin;
	}
	const easel: EaselPluginClass;
}
declare const EaselPlugin: gsap.plugins.EaselPlugin;
declare class Flip {
	static readonly version: string;
	/**
	 * Gets the FlipBatch associated with the provided id ("default" by default); if one hasn't be created/registered yet, a new one is returned and registered.
	 *
	 * ```js
	 * let batch = Flip.batch("id");
	 * ```
	 *
	 * @static
	 * @param {string} [id]
	 * @returns {FlipBatch} the FlipBatch (if one isn't registered, a new one is created/registered and returned)
	 * @memberof Flip
	 * @link https://greensock.com/docs/v3/Plugins/Flip/static.batch()
	 */
	static batch(id?: string): FlipBatch;
	/**
	 * Gets the matrix to convert points from one element's local coordinates into a
	 * different element's local coordinate system.
	 *
	 * ```js
	 * Flip.convertCoordinates(fromElement, toElement);
	 * ```
	 *
	 * @static
	 * @param {Element} fromElement
	 * @param {Element} toElement
	 * @returns {gsap.plugins.Matrix2D} A matrix to convert from one element's coordinate system to another's
	 * @memberof Flip
	 */
	static convertCoordinates(fromElement: Element, toElement: Element): gsap.plugins.Matrix2D;
	/**
	 * Converts a point from one element's local coordinates into a
	 * different element's local coordinate system.
	 *
	 * ```js
	 * Flip.convertCoordinates(fromElement, toElement, point);
	 * ```
	 *
	 * @static
	 * @param {Element} fromElement
	 * @param {Element} toElement
	 * @param {gsap.Point2D} point
	 * @returns {gsap.Point2D} A point to convert from one element's coordinate system to another's
	 * @memberof Flip
	 */
	static convertCoordinates(fromElement: Element, toElement: Element, point: gsap.Point2D): gsap.Point2D;
	/**
	 * Changes the x/y/rotation/skewX transforms (and width/height or scaleX/scaleY) to fit one element exactly into the the position/size/rotation of another element.
	 *
	 * ```js
	 * Flip.fit("#el1", "#el2", {
	 *   scale: true,
	 *   absolute: true,
	 *   duration: 1,
	 *   ease: "power2"
	 * });
	 * ```
	 *
	 * @static
	 * @param {gsap.DOMTarget} fromElement
	 * @param {(gsap.DOMTarget | Flip.FlipState)} toElement
	 * @param {Flip.FitVars} [vars]
	 * @returns {(gsap.core.Tween | object | null)}
	 * @memberof Flip
	 */
	static fit(
		fromElement: gsap.DOMTarget,
		toElement: gsap.DOMTarget | Flip.FlipState,
		vars?: Flip.FitVars
	): gsap.core.Tween | object | null;
	/**
	 * Animates the targets from the provided state to their current state (position/size).
	 *
	 * ```js
	 * Flip.from(state, {
	 *   duration: 1,
	 *   ease: "power1.inOut",
	 *   stagger: 0.1,
	 *   onComplete: () => console.log("done")
	 * });
	 * ```
	 *
	 * @static
	 * @param {Flip.FlipState} state
	 * @param {Flip.FromToVars} [vars]
	 * @returns {gsap.core.Timeline} Flip timeline
	 * @memberof Flip
	 * @link https://greensock.com/docs/v3/Plugins/Flip/static.from()
	 */
	static from(state: Flip.FlipState, vars?: Flip.FromToVars): gsap.core.Timeline;
	/**
	 * Captures information about the current state of the targets so that they can be flipped later.
	 *
	 * ```js
	 * let state = Flip.getState(".my-class, .another-class", {props: "backgroundColor,color", simple: true});
	 * ```
	 *
	 * @static
	 * @param {gsap.DOMTarget} targets
	 * @param {(Flip.FlipStateVars | string)} [vars]
	 * @returns {Flip.FlipState} The resulting state object
	 * @memberof Flip
	 * @link https://greensock.com/docs/v3/Plugins/Flip/static.getState()
	 */
	static getState(targets: gsap.DOMTarget, vars?: Flip.FlipStateVars | string): Flip.FlipState;
	/**
	 * Gets the timeline for the most recently-created flip animation associated with the provided element
	 *
	 * ```js
	 * let tl = Flip.getByTarget("#elementID");
	 * ```
	 *
	 * @static
	 * @param {Element | string} target
	 * @returns {core.Timeline | null} The timeline for the most recently-created flip animation associated with the provided element
	 * @memberof Flip
	 */
	static getByTarget(target: Element | string): gsap.core.Timeline | null;
	/**
	 * Determines whether or not a particular element is actively flipping (has an active flip animation)
	 *
	 * ```js
	 * if (!Flip.isFlipping("#elementID")) {
	 *   // do stuff
	 * }
	 * ```
	 *
	 * @static
	 * @param {gsap.DOMTarget} target
	 * @returns {boolean} whether or not the target element is actively flipping
	 * @memberof Flip
	 * @link https://greensock.com/docs/v3/Plugins/Flip/static.isFlipping()
	 */
	static isFlipping(target: gsap.DOMTarget): boolean;
	/**
	 * Immediately kills any Flip animations that are running on the target(s) provided, completing them as well (unless "complete" parameter is explicitly false).
	 *
	 * ```js
	 * Flip.killFlipsOf(".box");
	 * ```
	 *
	 * @static
	 * @param {gsap.DOMTarget} targets
	 * @param {boolean} complete
	 * @memberof Flip
	 * @link https://greensock.com/docs/v3/Plugins/Flip/static.killFlipsOf()
	 */
	static killFlipsOf(targets: gsap.DOMTarget, complete?: boolean): void;
	/**
	 * Sets all of the provided target elements to position: absolute while retaining their current positioning.
	 *
	 * ```js
	 * Flip.makeAbsolute(".my-class");
	 * ```
	 *
	 * @static
	 * @param {Element | string | null | ArrayLike<Element | string>} targets
	 * @returns {Element[]} An Array containing the Elements that were affected
	 * @memberof Flip
	 * @link https://greensock.com/docs/v3/Plugins/Flip/static.makeAbsolute()
	 */
	static makeAbsolute(targets: gsap.DOMTarget | Flip.FlipState[]): Element[];
	/**
	 * Animates the targets from the current state to the provided state.
	 *
	 * ```js
	 * Flip.to(state, {
	 *   duration: 1,
	 *   ease: "power1.inOut",
	 *   stagger: 0.1,
	 *   onComplete: () => console.log("done")
	 * });
	 * ```
	 *
	 * @static
	 * @param {Flip.FlipState} state
	 * @param {Flip.FromToVars} [vars]
	 * @returns {gsap.core.Timeline} Flip timeline
	 * @memberof Flip
	 * @link https://greensock.com/docs/v3/Plugins/Flip/static.to()
	 */
	static to(state: Flip.FlipState, vars?: Flip.FromToVars): gsap.core.Timeline;
	/**
	 * Registers Flip with gsap
	 *
	 * @static
	 * @param {typeof gsap} core
	 * @memberof Flip
	 */
	static register(core: typeof gsap): void;
}
declare namespace Flip {
	type OverrideProps<M, N> = {
		[P in keyof M]: P extends keyof N ? N[P] : M[P];
	};
	type EnterOrLeaveCallback = (elements: Element[]) => any;
	type SpinFunction = (index: number, element: Element, targets: Element[]) => number;
	type LoadStateFunction = (load: Function) => any;
	type BatchActionFunction = (self: FlipBatchAction) => any;
	interface TweenVarOverrides {
		scale?: boolean;
	}
	interface AnimationVars extends OverrideProps<gsap.TweenVars, TweenVarOverrides> {
		absolute?: boolean | gsap.DOMTarget;
		simple?: boolean;
		props?: string;
	}
	interface FlipStateVars {
		simple?: boolean;
		props?: string;
	}
	interface StateCompare {
		changed: Element[];
		unchanged: Element[];
		enter: Element[];
		leave: Element[];
	}
	interface FromToVars extends AnimationVars {
		absoluteOnLeave?: boolean;
		prune?: boolean;
		fade?: boolean;
		nested?: boolean;
		onEnter?: EnterOrLeaveCallback;
		onLeave?: EnterOrLeaveCallback;
		spin?: number | boolean | SpinFunction;
		targets?: gsap.DOMTarget;
		toggleClass?: string;
		zIndex?: number;
	}
	interface FitReturnVars {
		width?: number;
		height?: number;
		rotation: number;
		scaleX?: number;
		scaleY?: number;
		skewX: number;
		x: number;
		y: number;
		[key: string]: any;
	}
	interface FitVars extends AnimationVars {
		fitChild?: gsap.DOMTarget;
		getVars?: boolean;
	}
	interface BatchActionConfig {
		getState?: BatchActionFunction;
		loadState?: LoadStateFunction;
		setState?: BatchActionFunction;
		animate?: BatchActionFunction;
		onEnter?: EnterOrLeaveCallback;
		onLeave?: EnterOrLeaveCallback;
		onStart?: BatchActionFunction;
		onComplete?: BatchActionFunction;
		once?: boolean;
	}
	class ElementState {
		readonly bounds: DOMRect;
		readonly cache: object;
		readonly display: string;
		readonly element: Element;
		readonly getProp: Function;
		readonly height: number;
		readonly id: string;
		readonly isVisible: boolean;
		readonly matrix: gsap.plugins.Matrix2D;
		readonly opacity: number;
		readonly parent: Element | null;
		readonly position: string;
		readonly rotation: number;
		readonly scaleX: number;
		readonly scaleY: number;
		readonly simple: boolean;
		readonly skewX: number;
		readonly width: number;
		readonly x: number;
		readonly y: number;
		isDifferent(elState: ElementState): boolean;
	}
	class FlipState {
		readonly alt: object;
		readonly elementStates: ElementState[];
		readonly idLookup: object;
		readonly props: string | null;
		readonly simple: boolean;
		readonly targets: Element[];
		add(state: FlipState): FlipState;
		clear(): FlipState;
		compare(state: FlipState): StateCompare;
		update(soft?: boolean): FlipState;
		fit(state: FlipState, scale?: boolean, nested?: boolean): this;
		recordInlineStyles(): void;
		interrupt(soft?: boolean): void;
		getProperty(element: string | Element, property: string): any;
		getElementState(element: Element): ElementState;
		makeAbsolute(): Element[];
	}
}
declare class FlipBatchAction {
	readonly batch: FlipBatch;
	readonly state: any;
	readonly states: Flip.FlipState[];
	readonly timeline: gsap.core.Timeline;
	readonly targets: any;
	readonly vars: Flip.BatchActionConfig;
	/**
	 * Searches the state objects that were captured inside the action's getState() on its most recent call, and returns the first one it finds that matches the provided data-flip-id value.
	 *
	 * ```js
	 * let state = action.getStateById("box1");
	 * ```
	 * @param {string} id
	 * @memberof FlipBatchAction
	 */
	getStateById(id: string): Flip.FlipState | null;
	/**
	 * Kills the batch action, removing it from its batch.
	 *
	 * @memberof FlipBatchAction
	 */
	kill(): FlipBatchAction;
}
declare class FlipBatch {
	readonly actions: FlipBatchAction[];
	readonly state: Flip.FlipState;
	readonly timeline: gsap.core.Timeline;
	readonly id: string;
	data: any;
	/**
	 * Adds a Flip action to the batch so that MULTIPLE Flips can be combined and run each of their steps together (getState(), loadState(), setState(), animate())
	 *
	 * ```js
	 * batch.add({
	 *     getState: self => Flip.getState(targets),
	 *     loadState: done => done(),
	 *     setState: self => app.classList.toggle("active"),
	 *     animate: self => {
	 *       Flip.from(self.state, {ease: "power1.inOut"});
	 *     },
	 *     onStart: startCallback,
	 *     onComplete: completeCallback,
	 *     onEnter: elements => console.log("entering", elements),
	 *     onLeave: elements => console.log("leaving", elements),
	 *     once: true
	 * });
	 * ```
	 *
	 * @param {BatchActionConfig | Function} config
	 * @returns {FlipBatchAction} A FlipBatchAction
	 * @memberof FlipBatch
	 */
	add(config: Flip.BatchActionConfig | Function): FlipBatchAction;
	/**
	 * Flushes the batch.state (merged) object and removes all actions (unless stateOnly parameter is true)
	 *
	 * ```js
	 * batch.clear(true);
	 * ```
	 *
	 * @param {boolean} stateOnly
	 * @returns {FlipBatch} self
	 * @memberof FlipBatch
	 */
	clear(stateOnly?: boolean): FlipBatch;
	/**
	 * Calls getState() on all actions in this batch (any that are defined at least), optionally merging the results into batch.state
	 *
	 * ```js
	 * batch.getState(true);
	 * ```
	 *
	 * @param {boolean} merge (false by default)
	 * @returns {FlipBatch} self
	 * @memberof FlipBatch
	 */
	getState(merge?: boolean): FlipBatch;
	/**
	 * Searches the state objects that were captured inside ANY of this batch actions' most recent getState() call, and returns the first one it finds that matches the provided data-flip-id value.
	 *
	 * ```js
	 * let state = batch.getStateById("box1");
	 * ```
	 * @param {string} id
	 * @memberof FlipBatch
	 */
	getStateById(id: string): Flip.FlipState | null;
	/**
	 * Kills the batch, unregistering it internally and making it available for garbage collection. Also clears all actions and flushes the batch.state (merged) object.
	 *
	 * @memberof FlipBatch
	 */
	kill(): FlipBatchAction;
	/**
	 * Removes a particular action from the batch.
	 *
	 * ```js
	 * batch.remove(action);
	 * ```
	 *
	 * @param {FlipBatchAction} action
	 * @returns {FlipBatch} self
	 * @memberof FlipBatch
	 */
	remove(action: FlipBatchAction): FlipBatch;
	/**
	 * Executes all actions in the batch in the proper order: getState() (unless skipGetState is true), loadState(), setState(), and animate()
	 *
	 * ```js
	 * batch.run(true);
	 * ```
	 *
	 * @param {boolean} skipGetState
	 * @param {boolean} merge
	 * @returns {FlipBatch} self
	 * @memberof FlipBatch
	 */
	run(skipGetState?: boolean, merge?: boolean): FlipBatch;
}
declare namespace gsap {
	/**
	 * @deprecated since 3.7.0
	 * @see Flip.ElementState
	 */
	type ElementState = any;
	/**
	 * @deprecated since 3.7.0
	 * @see Flip.EnterOrLeaveCallback
	 */
	type EnterOrLeaveCallback = Flip.EnterOrLeaveCallback;
	/**
	 * @deprecated since 3.7.0
	 * @see Flip.FitVars
	 */
	type FitVars = Flip.FitVars;
	/**
	 * @deprecated since 3.7.0
	 * @see Flip.FitReturnVars
	 */
	type FitReturnVars = Flip.FitReturnVars;
	/**
	 * @deprecated since 3.7.0
	 * @see Flip
	 */
	type Flip = any;
	/**
	 * @deprecated since 3.7.0
	 * @see Flip.FlipState
	 */
	type FlipState = any;
	/**
	 * @deprecated since 3.7.0
	 * @see Flip.FlipStateVars
	 */
	type FlipStateVars = Flip.FlipStateVars;
	/**
	 * @deprecated since 3.7.0
	 * @see Flip.FromToVars
	 */
	type FlipToFromVars = Flip.FromToVars;
	/**
	 * @deprecated since 3.7.0
	 * @see Flip.SpinFunction
	 */
	type SpinFunction = Flip.SpinFunction;
}
declare class GSDevTools {
	constructor(target: gsap.DOMTarget, vars?: GSDevTools.Vars);
	/**
	 * Create a GSDevTools instance.
	 *
	 * ```js
	 * GSDevTools.create({animation: tl});
	 * ```
	 *
	 * @param {GSDevTools.Vars} vars
	 * @returns {GSDevTools} The GSDevTools instance
	 * @memberof GSDevTools
	 * @link https://greensock.com/docs/v3/Plugins/GSDevTools/static.create()
	 */
	static create(vars?: GSDevTools.Vars): GSDevTools;
	/**
	 * Returns the GSDevTools instance associated with the provided id.
	 *
	 * ```js
	 * GSDevTools.getById("my-id");
	 * ```
	 *
	 * @param {string} id
	 * @returns {GSDevTools} The GSDevTools instance
	 * @memberof GSDevTools
	 * @link https://greensock.com/docs/v3/Plugins/GSDevTools/static.getById()
	 */
	static getById(id: string): GSDevTools | null;
	/**
	 * Kills a GSDevTools instance
	 *
	 * ```js
	 * tool.kill();
	 * ```
	 *
	 * @memberof GSDevTools
	 * @link https://greensock.com/docs/v3/Plugins/GSDevTools/kill()
	 */
	kill(): void;
}
declare namespace GSDevTools {
	interface Vars {
		[key: string]: any;
		animation?: string | gsap.core.Animation;
		container?: string | Element;
		css?: object | string;
		globalSync?: boolean;
		hideGlobalTimeline?: boolean;
		id?: string;
		inTime?: number | string;
		keyboard?: boolean;
		loop?: boolean;
		minimal?: boolean;
		outTime?: number | string;
		paused?: boolean;
		persist?: boolean;
		timeScale?: number;
		visibility?: string;
	}
}
declare namespace gsap {
	type PluginInit = (
		this: PluginScope,
		target: object,
		endValue: any,
		tween: core.Tween,
		index: number,
		targets: object[]
	) => void;
	type PluginRender = (this: PropTween, progress: number, data: PluginScope) => void;
	type PluginKill = (this: PluginScope) => void;
	interface PluginAliases {
		[key: string]: string;
	}
	// TODO: Incomplete
	interface PropTween {
		_next: PropTween;
		_prev: PropTween;
		d: PluginScope;
		r: PluginRender;
		t: object;
		modifier(...args: any[]): any; // TODO: Add signature
	}
	interface PluginScope {
		[key: string]: any;
		_props: string[];
		_pt: PropTween;
		add(...args: any[]): PropTween; // TODO: Add signature
		name: string;
		init: PluginInit;
		kill: PluginKill;
		render: PluginRender;
	}
	interface PluginStatic {
		[key: string]: any;
		targetTest(...args: any[]): any; // TODO: Add signature
		get(target: object, prop: string): any; // TODO: Add signature
		getSetter(...args: any[]): any; // TODO: Add signature
		aliases: PluginAliases;
		register(core: typeof gsap): void;
	}
	interface Plugin extends Partial<PluginStatic> {
		name: string;
		init: PluginInit;
		kill?: PluginKill;
		render?: PluginRender;
	}
	interface AttrVars {
		[key: string]: ArrayValue | TweenValue;
	}
	interface ModifiersVars {
		[key: string]: (value: any, target: any) => any;
	}
	interface SnapVars {
		[key: string]:
			| number
			| number[]
			| {
					values: number[];
					radius?: number;
			  };
	}
	interface TweenVars {
		attr?: AttrVars;
		modifiers?: ModifiersVars;
		snap?: string | SnapVars;
	}
}
declare namespace gsap.plugins {
	interface AttrPlugin extends Plugin {}
	interface ModifiersPlugin extends Plugin {}
	interface SnapPlugin extends Plugin {}
	interface AttrPluginClass extends AttrPlugin {
		new (): PluginScope & AttrPlugin;
		prototype: PluginScope & AttrPlugin;
	}
	interface ModifiersPluginClass extends ModifiersPlugin {
		new (): PluginScope & ModifiersPlugin;
		prototype: PluginScope & ModifiersPlugin;
	}
	interface SnapPluginClass extends SnapPlugin {
		new (): PluginScope & SnapPlugin;
		prototype: PluginScope & SnapPlugin;
	}
	const attr: AttrPluginClass;
	const modifiers: ModifiersPluginClass;
	const snap: SnapPluginClass;
	// Data types shared between plugins
	type RawPath = number[][];
	type Matrix2D = {
		a: number;
		b: number;
		c: number;
		d: number;
		e: number;
		f: number;
	};
}
declare namespace gsap.utils {
	interface DistributeConfig {
		amount?: number;
		axis?: 'x' | 'y';
		base?: number;
		each?: number;
		ease?: string | EaseFunction;
		from?: 'start' | 'center' | 'end' | 'edges' | 'random' | number | [number, number];
		grid?: 'auto' | [number, number];
	}
	interface SnapNumberConfig {
		increment?: number;
		values?: number[];
		radius: number;
	}
	interface SnapPoint2DConfig {
		values: Point2D[];
		radius: number;
	}
	interface SelectorFunc {
		<K extends keyof HTMLElementTagNameMap>(selectorText: string): Array<HTMLElementTagNameMap[K]>;
		<K extends keyof SVGElementTagNameMap>(selectorText: string): Array<SVGElementTagNameMap[K]>;
		<E extends Element = Element>(selectorText: string): Array<E>;
	}
	/**
	 * Prefixes the provided CSS property if necessary. Returns null if the property isn't supported at all.
	 *
	 * ```js
	 * // The following may return "filter", "WebkitFilter", or "MozFilter" depending on the browser
	 * let filterProperty = gsap.utils.checkPrefix("filter");
	 * ```
	 *
	 * @param {string} property
	 * @returns {string | null} The appropriately prefixed property
	 * @memberof gsap.utils
	 */
	function checkPrefix(property: string): string;
	/**
	 * Clamps a number between a given minimum and maximum.
	 *
	 * ```js
	 * gsap.utils.clamp(0, 100, 105); // returns 100
	 *
	 * const clamper = gsap.utils.clamp(0, 100); // no value = reusable function
	 * console.log(clamper(105)); // returns 100
	 * ```
	 *
	 * @param {number} minimum
	 * @param {number} maximum
	 * @param {number} [valueToClamp]
	 * @returns {number | Function} The clamped number or function to clamp to given range
	 * @memberof gsap.utils
	 */
	function clamp(minimum: number, maximum: number, valueToClamp: number): number;
	function clamp(minimum: number, maximum: number): (valueToClamp: number) => number;
	/**
	 * Returns a function to distribute an array of values based on the inputs that you give it.
	 *
	 * ```js
	 * gsap.utils.distribute({
	 *   base: 50,
	 *   amount: 100,
	 *   from: "center",
	 *   grid: "auto",
	 *   axis: "y",
	 *   ease: "power1.inOut"
	 * });
	 * ```
	 *
	 * @param {DistributeConfig} config
	 * @returns {FunctionBasedValue<number>} The clamped number or function to clamp to given range
	 * @memberof gsap.utils
	 */
	function distribute(config: DistributeConfig): FunctionBasedValue<number>;
	/**
	 * Returns unit of a given string where the number comes first, then the unit.
	 *
	 * ```js
	 * gsap.utils.getUnit("50%"); // "%"
	 * ```
	 *
	 * @param {string} value
	 * @returns {string} The unit
	 * @memberof gsap.utils
	 */
	function getUnit(value: string): string;
	/**
	 * Linearly interpolates between any two values of a similar type.
	 *
	 * ```js
	 * gsap.utils.interpolate(0, 500, 0.5); // 250
	 *
	 * const interp = gsap.utils.interpolate(0, 100); // no value = reusable function
	 * console.log( interp(0.5) ); // 50
	 * ```
	 *
	 * @param {T} startValue
	 * @param {T} endValue
	 * @param {number} [number]
	 * @returns {T | Function<number>} The interpolated value or interpolate function
	 * @memberof gsap.utils
	 */
	function interpolate<T>(startValue: T, endValue: T, progress: number): T;
	function interpolate<T>(startValue: T, endValue: T): (progress: number) => T;
	/**
	 * Linearly interpolates between any two values of a similar type.
	 *
	 * ```js
	 * gsap.utils.interpolate([100, 50, 500], 0.5); // 50
	 *
	 * c interp = gsap.utils.interpolate([100, 50, 500]); // no value = reusable function
	 * console.log( interp(0.5) ); // 50
	 * ```
	 *
	 * @param {T[]} array
	 * @param {number} progress
	 * @returns {T | Function} The interpolated value or interpolate function
	 * @memberof gsap.utils
	 */
	function interpolate<T>(array: T[], progress: number): T;
	function interpolate<T>(array: T[]): (progress: number) => T;
	/**
	 * Maps a number's relative placement within one range to the equivalent position in another range.
	 *
	 * ```js
	 * gsap.utils.mapRange(-10, 10, 100, 200, 0); // 150
	 *
	 * const mapper = gsap.utils.mapRange(0, 100, 0, 250); // no value = reusable function
	 * console.log( mapper(50) ); // 250
	 * ```
	 *
	 * @param {number} inMin
	 * @param {number} inMax
	 * @param {number} outMin
	 * @param {number} outMax
	 * @param {number} [value]
	 * @returns {number | Function} The mapped value or map function
	 * @memberof gsap.utils
	 */
	function mapRange(inMin: number, inMax: number, outMin: number, outMax: number, value: number): number;
	function mapRange(inMin: number, inMax: number, outMin: number, outMax: number): (value: number) => number;
	/**
	 * Maps a value within a provided range to the corresponding position in the range between 0 and 1.
	 *
	 * ```js
	 * gsap.utils.normalize(-10, 10, 0); // 0.5
	 *
	 * const clamper = gsap.utils.normalize(0, 100); // no value = reusable function
	 * console.log( clamper(50) ); // 0.5
	 * ```
	 *
	 * @param {number} inMin
	 * @param {number} inMax
	 * @param {number} [value]
	 * @returns {number | Function} The normalized value or normalizer function
	 * @memberof gsap.utils
	 */
	function normalize(inMin: number, inMax: number, value: number): number;
	function normalize(inMin: number, inMax: number): (value: number) => number;
	/**
	 * Strings together multiple function calls, passing the result from one to the next.
	 * You can pass in as many function references as you'd like!
	 *
	 * ```js
	 * const transfrom = gsap.utils.pipe(func1, func2, func3); // reusable function
	 * const output = transform(input);
	 * ```
	 *
	 * @param {Function} ab
	 * @param {Function} bc
	 * @param {Function} [cd]
	 * @returns {Function} The function that pipes values from function to function given
	 * @memberof gsap.utils
	 */
	function pipe<A extends Array<unknown>, B>(ab: (...a: A) => B): (...a: A) => B;
	function pipe<A extends Array<unknown>, B, C>(ab: (...a: A) => B, bc: (b: B) => C): (...a: A) => C;
	function pipe<A extends Array<unknown>, B, C, D>(
		ab: (...a: A) => B,
		bc: (b: B) => C,
		cd: (c: C) => D
	): (...a: A) => D;
	function pipe<A extends Array<unknown>, B, C, D, E>(
		ab: (...a: A) => B,
		bc: (b: B) => C,
		cd: (c: C) => D,
		de: (d: D) => E
	): (...a: A) => E;
	function pipe<A extends Array<unknown>, B, C, D, E, F>(
		ab: (...a: A) => B,
		bc: (b: B) => C,
		cd: (c: C) => D,
		de: (d: D) => E,
		ef: (e: E) => F
	): (...a: A) => F;
	function pipe<A extends Array<unknown>, B, C, D, E, F, G>(
		ab: (...a: A) => B,
		bc: (b: B) => C,
		cd: (c: C) => D,
		de: (d: D) => E,
		ef: (e: E) => F,
		fg: (f: F) => G
	): (...a: A) => G;
	function pipe<A extends Array<unknown>, B, C, D, E, F, G, H>(
		ab: (...a: A) => B,
		bc: (b: B) => C,
		cd: (c: C) => D,
		de: (d: D) => E,
		ef: (e: E) => F,
		fg: (f: F) => G,
		gh: (g: G) => H
	): (...a: A) => H;
	function pipe<A extends Array<unknown>, B, C, D, E, F, G, H, I>(
		ab: (...a: A) => B,
		bc: (b: B) => C,
		cd: (c: C) => D,
		de: (d: D) => E,
		ef: (e: E) => F,
		fg: (f: F) => G,
		gh: (g: G) => H,
		hi: (h: H) => I
	): (...a: A) => I;
	function pipe<A extends Array<unknown>, B, C, D, E, F, G, H, I, J>(
		ab: (...a: A) => B,
		bc: (b: B) => C,
		cd: (c: C) => D,
		de: (d: D) => E,
		ef: (e: E) => F,
		fg: (f: F) => G,
		gh: (g: G) => H,
		hi: (h: H) => I,
		ij: (i: I) => J
	): (...a: A) => J;
	/**
	 * Get a random number within a range, optionally rounding to an increment you provide.
	 *
	 * ```js
	 * gsap.utils.random(-100, 100);
	 * gsap.utils.random(0, 500, 5); // snapped to the nearest value of 5
	 *
	 * const random = gsap.utils.random(-200, 500, 10, true); // reusable function
	 * console.log( random() );
	 * ```
	 *
	 * @param {number} minValue
	 * @param {number} maxValue
	 * @param {number} [snapIncrement]
	 * @param {boolean} [returnFunction]
	 * @returns {number | Function} The random number or random number generator function
	 * @memberof gsap.utils
	 */
	function random(minValue: number, maxValue: number, snapIncrement?: number): number;
	function random<T extends boolean>(
		minValue: number,
		maxValue: number,
		returnFunction?: T
	): T extends true ? () => number : number;
	function random<T extends boolean>(
		minValue: number,
		maxValue: number,
		snapIncrement: number,
		returnFunction?: T
	): T extends true ? () => number : number;
	/**
	 * Get a random random element in an array.
	 *
	 * ```js
	 * gsap.utils.random(["red", "blue", "green"]); //"red", "blue", or "green"
	 *
	 * const random = gsap.utils.random([0, 100, 200], true);
	 * console.log( random() ); // 0, 100, or 200 (randomly selected)
	 * ```
	 *
	 * @param {T[]} array
	 * @param {boolean} [returnFunction]
	 * @returns {number | Function} The random number or random number generator function
	 * @memberof gsap.utils
	 */
	function random<T>(array: T[]): T;
	function random<T, U extends boolean>(array: T[], returnFunction?: U): U extends true ? () => T : T;
	/**
	 * Returns a selector function that is scoped to a particular Element.
	 *
	 * ```js
	 * const q = gsap.utils.selector("#id");
	 * const q = gsap.utils.selector(myElement);
	 * gsap.to(q(".class"), {x: 100});
	 * ```
	 *
	 * @param {Element | object | string} scope
	 * @returns {SelectorFunc} A selector function
	 * @memberof gsap.utils
	 */
	function selector(scope: Element | object | string | null): SelectorFunc;
	/**
	 * Takes an array and randomly shuffles it, returning the same (but shuffled) array.
	 *
	 * ```js
	 * gsap.utils.shuffle(array);
	 * ```
	 *
	 * @param {T[]} array
	 * @returns {T[]} The same shuffled array
	 * @memberof gsap.utils
	 */
	function shuffle<T>(array: T[]): T[];
	/**
	 * Snaps a value to the nearest increment of the number provided.
	 * Or snaps to a value in the given array.
	 * Or snaps to a value within the given radius (if an object is provided).
	 * Or returns a function that does the above (if the second value is not provided).
	 *
	 * ```js
	 * gsap.utils.snap(10, 23.5); // 20
	 * gsap.utils.snap([100, 50, 500], 65); // 50
	 * gsap.utils.snap({values:[0, 100, 300], radius:20}, 30.5); // 30.5
	 * gsap.utils.snap({increment:500, radius:150}, 310); // 310
	 *
	 * const snap = gsap.utils.snap(5); // no value = reusable function
	 * console.log( snap(0.5) ); // 0
	 * ```
	 *
	 * @param {SnapNumberConfig} snapConfig
	 * @param {number} [valueToSnap]
	 * @returns {number | Function} The snapped number or snap function
	 * @memberof gsap.utils
	 */
	function snap(snapConfig: number | number[] | SnapNumberConfig, valueToSnap: number): number;
	function snap(snapConfig: number | number[] | SnapNumberConfig): (valueToSnap: number) => number;
	/**
	 * Snaps a value if within the given radius of a points (objects with "x" and "y" properties).
	 * Or returns a function that does the above (if the second value is not provided).
	 *
	 * ```js
	 *
	 * gsap.utils.snap({values:[0, 100, 300], radius:20}, 85); // 100
	 *
	 * const snap = gsap.utils.snap({values:[{x:0, y:0}, {x:10, y:10}, {x:20, y:20}], radius:5}); // no value = reusable function
	 * console.log( snap({x:8, y:8}) ); // {x:10, y:10}
	 * ```
	 *
	 * @param {SnapPoint2DConfig} snapConfig
	 * @param {number} [valueToSnap]
	 * @returns {Point2D | Function} The snapped number or snap function
	 * @memberof gsap.utils
	 */
	function snap(snapConfig: SnapPoint2DConfig, valueToSnap: Point2D): Point2D;
	function snap(snapConfig: SnapPoint2DConfig): (valueToSnap: Point2D) => Point2D;
	/**
	 * Converts a string-based color value into an array consisting of RGB(A) or HSL values.
	 *
	 * ```js
	 * gsap.utils.splitColor("red"); // [255, 0, 0]
	 * gsap.utils.splitColor("rgba(204, 153, 51, 0.5)"); // [204, 153, 51, 0.5]
	 *
	 * gsap.utils.splitColor("#6fb936", true); // [94, 55, 47] - HSL value
	 * ```
	 *
	 * @param {string} color
	 * @param {boolean} [hsl]
	 * @returns {[number, number, number] | [number, number, number, number]} The converted color array
	 * @memberof gsap.utils
	 */
	function splitColor(color: string, hsl?: boolean): [number, number, number] | [number, number, number, number];
	/**
	 * Converts almost anything into a flat Array.
	 *
	 * ```js
	 * const targets = gsap.utils.toArray(".class");
	 * const targets = gsap.utils.toArray(myElement);
	 * const targets = gsap.utils.toArray($(".class"));
	 * const targets = gsap.utils.toArray([".class1", ".class2"]);
	 * ```
	 *
	 * @param {string | object | Element | null} value
	 * @param {object} [scope]
	 * @param {boolean} [leaveStrings]
	 * @returns {T[]} The converted Array
	 * @memberof gsap.utils
	 */
	function toArray<T>(value: string | object | Element | null, scope?: object | null, leaveStrings?: boolean): T[];
	/**
	 * Ensures that a specific unit gets applied.
	 *
	 * ```js
	 * const clamp = gsap.utils.unitize( gsap.utils.clamp(0, 100), "px");
	 * clamp(132); // "100px"
	 *
	 * gsap.to(".class", {
	 *   x: 1000,
	 *   modifiers: {
	 *     x: gsap.utils.unitize( gsap.utils.wrap(0, window.innerWidth), "px")
	 *   }
	 * });
	 * ```
	 *
	 * @param {Function} fn
	 * @param {string} [unit]
	 * @returns {string} The value with unit added
	 * @memberof gsap.utils
	 */
	function unitize<T extends Array<unknown>>(fn: (...args: T) => unknown, unit?: string): (...args: T) => string;
	/**
	 * Returns the next number in a range after the given index, jumping to the start after the end has been reached.
	 *
	 * ```js
	 * let color = gsap.utils.wrap(["red", "green", "yellow"], 5); // "yellow"
	 *
	 * let wrapper = gsap.utils.wrap(["red", "green", "yellow"]); // no value = reusable function
	 * let color = wrapper(5) // "yellow"
	 * ```
	 *
	 * @param {number} value1
	 * @param {number} value2
	 * @param {number} [index]
	 * @returns {string} The wrapped value or wrap function
	 * @memberof gsap.utils
	 */
	function wrap(value1: number, value2: number, index: number): number;
	function wrap(value1: number, value2: number): (index: number) => number;
	/**
	 * Returns the next item in an array after the given index, jumping to the start after the end has been reached.
	 *
	 * ```js
	 * let color = gsap.utils.wrap(["red", "green", "yellow"], 5); // "yellow"
	 *
	 * let wrapper = gsap.utils.wrap(["red", "green", "yellow"]); // no value = reusable function
	 * let color = wrapper(5) // "yellow"
	 * ```
	 *
	 * @param {T[]} values
	 * @param {number} [index]
	 * @returns {string} The wrapper value or wrap function
	 * @memberof gsap.utils
	 */
	function wrap<T>(values: T[], index: number): T;
	function wrap<T>(values: T[]): (index: number) => T;
	/**
	 * Returns the next number in a range after the given index, wrapping backwards towards the start after the end has been reached.
	 *
	 * ```js
	 * let color = gsap.utils.wrap(["red", "green", "yellow"], 5); // "yellow"
	 *
	 * let wrapper = gsap.utils.wrap(["red", "green", "yellow"]); // no value = reusable function
	 * let color = wrapper(5) // "yellow"
	 * ```
	 *
	 * @param {number} value1
	 * @param {number} value2
	 * @param {number} [index]
	 * @returns {string} The wrapped value or wrap function
	 * @memberof gsap.utils
	 */
	function wrapYoyo(value1: number, value2: number, index: number): number;
	function wrapYoyo(value1: number, value2: number): (index: number) => number;
	/**
	 * Returns the next item in an array after the given index, wrapping backwards towards the start after the end has been reached.
	 *
	 * ```js
	 * let color = gsap.utils.wrap(["red", "green", "yellow"], 5); // "yellow"
	 *
	 * let wrapper = gsap.utils.wrap(["red", "green", "yellow"]); // no value = reusable function
	 * let color = wrapper(5) // "yellow"
	 * ```
	 *
	 * @param {T[]} values
	 * @param {number} [index]
	 * @returns {string} The wrapper value or wrap function
	 * @memberof gsap.utils
	 */
	function wrapYoyo<T>(values: T[], index: number): T;
	function wrapYoyo<T>(values: T[]): (index: number) => T;
}
declare namespace gsap {
	type InertiaEndFunction<T> = (value: T) => T;
	interface InertiaDuration {
		min?: number;
		max?: number;
		overshoot?: number;
	}
	interface InertiaLinkedProps {
		[key: string]: number;
	}
	interface InertiaObject {
		min?: number;
		max?: number;
		end?: number | number[] | InertiaEndFunction<any>;
		// end?: number | number[] | InertiaEndFunction<number> | InertiaEndFunction<InertiaLinkedProps>;
		velocity?: number | 'auto';
	}
	type InertiaVars = {
		duration?: number | InertiaDuration;
		linkedProps?: string;
		resistance?: number;
	} & {
		[key: string]: TweenValue | InertiaObject;
	};
	interface TweenVars {
		inertia?: InertiaVars;
	}
}
declare namespace gsap.plugins {
	interface InertiaPlugin extends Plugin, VelocityTrackerStatic {
		// TODO add missing methods
		// TODO improve docs on site as well
		/**
		 * Returns the current velocity of the given property and target object (only works if you started tracking the property using the InertiaPlugin.track() method).
		 *
		 * ```js
		 * InertiaPlugin.getVelocity(obj, "x,y");
		 * ```
		 *
		 * @param {Element} target
		 * @param {string} props
		 * @returns {number} The current velocity
		 * @memberof InertiaPlugin
		 * @link https://greensock.com/docs/v3/Plugins/InertiaPlugin/static.getVelocity()
		 */
		getVelocity(target: Element, props: string): number;
	}
	interface InertiaPluginClass extends InertiaPlugin {
		new (): PluginScope & InertiaPlugin;
		prototype: PluginScope & InertiaPlugin;
	}
	const inertia: InertiaPluginClass;
}
declare namespace gsap {
	interface TweenVars {
		morphSVG?: SVGPathValue | gsap.plugins.MorphSVGVars;
	}
}
declare namespace gsap.plugins {
	interface MorphSVGPlugin extends Plugin {
		defaultRender?: Function;
		defaultType?: String;
		defaultUpdateTarget?: Boolean;
		/**
		 * Converts SVG shapes into <path>s.
		 *
		 * ```js
		 * MorphSVGPlugin.convertToPath("circle");
		 * ```
		 *
		 * @param {DOMTarget} shape
		 * @param {boolean} [swap]
		 * @returns {SVGPathElement[]} The converted paths
		 * @memberof MorphSVGPlugin
		 * @link https://greensock.com/docs/v3/Plugins/MorphSVGPlugin/static.convertToPath()
		 */
		convertToPath(shape: string | SVGPrimitive | (string | SVGPrimitive)[], swap?: boolean): SVGPathElement[];
		/**
		 * Returns a RawPath associated with whatever is passed in (path data string, selector text, <path> element, or a RawPath)
		 *
		 * ```js
		 * MorphSVGPlugin.getRawPath("#my-path");
		 * ```
		 *
		 * @param {SVGPathValue} path
		 * @returns {array} The RawPath
		 * @memberof MorphSVGPlugin
		 * @link https://greensock.com/docs/v3/Plugins/MorphSVGPlugin/static.getRawPath()
		 */
		getRawPath(path: SVGPathValue): string[];
		/**
		 * Accepts two strings representing SVG path data and matches the number of points between them, returning an Array with the edited path data strings [shape1, shape2].
		 *
		 * ```js
		 * MorphSVGPlugin.normalizeStrings(shape1, shape2, {map: "complexity"});
		 * ```
		 *
		 * @param {string} shape1
		 * @param {string} shape2
		 * @param {NormalizeVars} config
		 * @returns {string[]} An Array containing the converted string data with matching numbers of points, like [shape1, shape2]
		 * @memberof MorphSVGPlugin
		 * @link https://greensock.com/docs/v3/Plugins/MorphSVGPlugin/static.normalizeStrings()
		 */
		normalizeStrings(shape1: string, shape2: string, config?: NormalizeVars): string[];
		/**
		 * Converts a RawPath into a string of path data.
		 *
		 * ```js
		 * MorphSVGPlugin.rawPathToString(myRawPath);
		 * ```
		 *
		 * @param {RawPath} rawPath
		 * @returns {string} The converted path data
		 * @memberof MorphSVGPlugin
		 * @link https://greensock.com/docs/v3/Plugins/MorphSVGPlugin/static.rawPathToString()
		 */
		rawPathToString(rawPath: RawPath): string;
		/**
		 * Converts a string of path data into a RawPath.
		 *
		 * ```js
		 * MorphSVGPlugin.stringToRawPath("M0,0 C100,20 300,50 400,0...");
		 * ```
		 *
		 * @param {string} data
		 * @returns {RawPath} The converted RawPath
		 * @memberof MorphSVGPlugin
		 * @link https://greensock.com/docs/v3/Plugins/MorphSVGPlugin/static.stringToRawPath()
		 */
		stringToRawPath(data: string): RawPath;
	}
	interface NormalizeVars {
		shapeIndex?: number | 'auto' | number[];
		map?: 'complexity' | 'position' | 'size';
	}
	interface MorphSVGPluginClass extends MorphSVGPlugin {
		new (): PluginScope & MorphSVGPlugin;
		prototype: PluginScope & MorphSVGPlugin;
	}
	interface MorphSVGVars {
		shape: SVGPathValue;
		type?: 'rotational' | 'linear';
		origin?: string;
		shapeIndex?: number | 'auto' | number[];
		precompile?: 'log' | string[];
		map?: 'size' | 'position' | 'complexity';
		render?: Function;
		updateTarget?: boolean;
	}
	const morphSVG: MorphSVGPluginClass;
}
declare namespace gsap {
	interface PathObject {
		[propName: string]: number;
	}
	interface TweenVars {
		motionPath?: SVGPathValue | TweenValue | Point2D[] | PathObject[] | MotionPath.Vars;
	}
}
declare namespace gsap.plugins {
	interface ArrayToRawPathObject {
		curviness?: number;
		relative?: boolean;
		type?: string;
		x?: string;
		y?: string;
	}
	interface getRelativePositionObject extends gsap.Point2D {
		angle: number;
	}
	interface MotionPathPlugin extends Plugin {
		/**
		 * Takes an array of coordinates and plots a curve through them.
		 *
		 * ```js
		 * MotionPathPlugin.arrayToRawPath(anchors, {curviness:0.5})
		 * ```
		 *
		 * @param {Point2D[]} values
		 * @param {ArrayToRawPathObject} vars
		 * @returns {RawPath} The converted rawPath
		 * @memberof MotionPathPlugin
		 * @link https://greensock.com/docs/v3/Plugins/MotionPathPlugin/static.arrayToRawPath()
		 */
		arrayToRawPath(values: Point2D[], vars?: ArrayToRawPathObject): RawPath;
		/**
		 * Measures the path and caches the values on the RawPath itself for fast and accurate subsequent processing.
		 *
		 * ```js
		 * MotionPathPlugin.cacheRawPathMeasurements(rawPath);
		 * ```
		 *
		 * @param {RawPath} rawPath
		 * @param {number} resolution
		 * @returns {RawPath} the RawPath that was passed in
		 * @memberof MotionPathPlugin
		 */
		cacheRawPathMeasurements(rawPath: RawPath, resolution?: number): RawPath;
		/**
		 * Gets the matrix to convert points from one element's local coordinates into a
		 * different element's local coordinate system.
		 *
		 * ```js
		 * MotionPathPlugin.convertCoordinates(fromElement, toElement);
		 * ```
		 *
		 * @param {Element} fromElement
		 * @param {Element} toElement
		 * @returns {Matrix2D} A matrix to convert from one element's coordinate system to another's
		 * @memberof MotionPathPlugin
		 * @link https://greensock.com/docs/v3/Plugins/MotionPathPlugin/static.convertCoordinates()
		 */
		convertCoordinates(fromElement: Element, toElement: Element): Matrix2D;
		/**
		 * Converts a point from one element's local coordinates into a
		 * different element's local coordinate system.
		 *
		 * ```js
		 * MotionPathPlugin.convertCoordinates(fromElement, toElement, point);
		 * ```
		 *
		 * @param {Element} fromElement
		 * @param {Element} toElement
		 * @param {Point2D} point
		 * @returns {Point2D} the converted point
		 * @memberof MotionPathPlugin
		 * @link https://greensock.com/docs/v3/Plugins/MotionPathPlugin/static.convertCoordinates()
		 */
		convertCoordinates(fromElement: Element, toElement: Element, point: Point2D): Point2D;
		/**
		 * Converts SVG shapes into <path>s.
		 *
		 * ```js
		 * MotionPathPlugin.convertToPath("circle");
		 * ```
		 *
		 * @param {DOMTarget} shape
		 * @param {boolean} [swap]
		 * @returns {SVGPathElement[]} The converted paths
		 * @memberof MotionPathPlugin
		 * @link https://greensock.com/docs/v3/Plugins/MotionPathPlugin/static.convertToPath()
		 */
		convertToPath(shape: SVGPathTarget, swap?: boolean): SVGPathElement[];
		/**
		 * Gets the matrix to convert points from one element's local coordinates into a
		 * different element's local coordinate system.
		 *
		 * ```js
		 * MotionPathPlugin.getAlignMatrix(fromElement, toElement);
		 * ```
		 *
		 * @param {Element} fromElement
		 * @param {Element} toElement
		 * @param {number[] | Point2D} [fromOrigin]
		 * @param {number[] | Point2D | "auto"} [toOrigin]
		 * @returns {Matrix2D} A matrix to convert from one element's coordinate system to another's
		 * @memberof MotionPathPlugin
		 * @link https://greensock.com/docs/v3/Plugins/MotionPathPlugin/static.getAlignMatrix()
		 */
		getAlignMatrix(
			fromElement: Element,
			toElement: Element,
			fromOrigin?: number[] | Point2D,
			toOrigin?: number[] | Point2D | 'auto'
		): Matrix2D;
		/**
		 * Gets the Matrix2D that would be used to convert the element's local coordinate
		 * space into the global coordinate space.
		 *
		 * ```js
		 * MotionPathPlugin.getGlobalMatrix(element);
		 * ```
		 *
		 * @param {Element} element
		 * @param {Boolean} [inverse]
		 * @param {Boolean} [adjustGOffset]
		 * @returns {Matrix2D} A matrix to convert from one element's coordinate system to another's
		 * @memberof MotionPathPlugin
		 * @link https://greensock.com/docs/v3/Plugins/MotionPathPlugin/static.getGlobalMatrix()
		 */
		getGlobalMatrix(element: Element, inverse?: boolean, adjustGOffset?: boolean): Matrix2D;
		/**
		 * Calculates the x/y position (and optionally the angle) corresponding to a
		 * particular progress value along the RawPath.
		 *
		 * ```js
		 * MotionPathPlugin.getPositionOnPath(rawPath, 0.5);
		 * ```
		 *
		 * @param {RawPath} rawPath
		 * @param {Number} progress
		 * @param {Boolean} [includeAngle]
		 * @returns {Matrix2D} A matrix to convert from one element's coordinate system to another's
		 * @memberof MotionPathPlugin
		 * @link https://greensock.com/docs/v3/Plugins/MotionPathPlugin/static.getPositionOnPath()
		 */
		getPositionOnPath(
			rawPath: RawPath,
			progress: number,
			includeAngle?: boolean
		): Point2D | getRelativePositionObject;
		/**
		 * Gets the RawPath for the provided element or raw SVG <path> data.
		 *
		 * ```js
		 * MotionPathPlugin.getRawPath(element);
		 * ```
		 *
		 * @param {DOMTarget} value
		 * @returns {RawPath} The rawPath
		 * @memberof MotionPathPlugin
		 * @link https://greensock.com/docs/v3/Plugins/MotionPathPlugin/static.getRawPath()
		 */
		getRawPath(value: SVGPathValue): RawPath;
		/**
		 * Gets the x and y distances between two elements regardless of nested transforms.
		 *
		 * ```js
		 * MotionPathPlugin.getRelativePosition(dot, inner, [0.5, 0.5], [0.5, 0.5]);
		 * ```
		 *
		 * @param {Element} fromElement
		 * @param {Element} toElement
		 * @param {number[] | Point2D[]} [fromOrigin]
		 * @param {number[] | Point2D[] | "auto"} [toOrigin]
		 * @returns {Point2D} The x and y between the references given
		 * @memberof MotionPathPlugin
		 * @link https://greensock.com/docs/v3/Plugins/MotionPathPlugin/static.getRelativePosition()
		 */
		getRelativePosition(
			fromElement: Element,
			toElement: Element,
			fromOrigin?: number[] | Point2D,
			toOrigin?: number[] | Point2D | 'auto'
		): Point2D;
		/**
		 * Gets the x and y distances between two elements regardless of nested transforms.
		 *
		 * ```js
		 * MotionPathPlugin.pointsToSegment([0,0, 10,10, ...], 0.5);
		 * ```
		 *
		 * @param {number[]} points
		 * @param {number} [curviness]
		 * @returns {number[]} Cubic Bezier data in alternating x, y, x, y format
		 * @memberof MotionPathPlugin
		 * @link https://greensock.com/docs/v3/Plugins/MotionPathPlugin/static.pointsToSegment()
		 */
		pointsToSegment(points: number[], curviness?: number): number[];
		/**
		 * Converts a RawPath to a path string.
		 *
		 * ```js
		 * MotionPathPlugin.rawPathToString(rawPath);
		 * ```
		 *
		 * @param {RawPath} rawPath
		 * @returns {string} The converted path
		 * @memberof MotionPathPlugin
		 * @link https://greensock.com/docs/v3/Plugins/MotionPathPlugin/static.rawPathToString()
		 */
		rawPathToString(rawPath: RawPath): string;
		/**
		 * Slices a RawPath into a smaller RawPath.
		 *
		 * ```js
		 * MotionPathPlugin.sliceRawPath(rawPath, 0, 3);
		 * ```
		 *
		 * @param {RawPath} rawPath
		 * @param {number} start
		 * @param {number} end
		 * @returns {RawPath} The sliced RawPath
		 * @memberof MotionPathPlugin
		 * @link https://greensock.com/docs/v3/Plugins/MotionPathPlugin/static.sliceRawPath()
		 */
		sliceRawPath(rawPath: RawPath, start: number, end: number): RawPath;
		/**
		 * Converts a string of path data into a rawPath.
		 *
		 * ```js
		 * MotionPathPlugin.stringToRawPath("M0,0 C100,20 300,50 400,0...");
		 * ```
		 *
		 * @param {string} data
		 * @returns {RawPath} The converted RawPath
		 * @memberof MotionPathPlugin
		 * @link https://greensock.com/docs/v3/Plugins/MotionPathPlugin/static.stringToRawPath()
		 */
		stringToRawPath(data: string): RawPath;
	}
	interface MotionPathPluginClass extends MotionPathPlugin {
		new (): PluginScope & MotionPathPlugin;
		prototype: PluginScope & MotionPathPlugin;
	}
	const motionPath: MotionPathPluginClass;
}
declare namespace MotionPath {
	interface Vars {
		align?: string | Element;
		alignOrigin?: number[];
		autoRotate?: boolean | number;
		curviness?: number;
		end?: number;
		offsetX?: number;
		offsetY?: number;
		path?: gsap.SVGPathValue | gsap.TweenValue | gsap.Point2D[] | gsap.PathObject[];
		relative?: boolean;
		resolution?: number;
		start?: number;
		type?: string;
		useRadians?: boolean;
		fromCurrent?: boolean;
	}
}
declare class MotionPathHelper {
	constructor(target: gsap.DOMTarget, vars?: MotionPathHelper.Vars);
	/**
	 * Kills the MotionPathHelper instance, removing the editing elements from the DOM.
	 *
	 * ```js
	 * myHelper.kill();
	 * ```
	 *
	 * @memberof MotionPathHelper
	 * @link https://greensock.com/docs/v3/Plugins/MotionPathHelper/kill()
	 */
	kill(): void;
	/**
	 * Create a MotionPathHelper instance.
	 *
	 * ```js
	 * MotionPathHelper.create(".myClass");
	 * ```
	 *
	 * @param {gsap.DOMTarget} target
	 * @param {MotionPathHelper.Vars} [vars]
	 * @returns {MotionPathHelper} The MotionPathHelper instance
	 * @memberof MotionPathHelper
	 * @link https://greensock.com/docs/v3/Plugins/MotionPathHelper
	 */
	static create(target: gsap.DOMTarget, vars?: MotionPathHelper.Vars): MotionPathHelper;
	/**
	 * Makes an SVG <path> editable in the browser.
	 *
	 * ```js
	 * MotionPathHelper.editPath(".myClass", {
	 *     onPress: () => console.log("press"),
	 *     onRelease: () => console.log("release"),
	 *     onUpdate: () => console.log("update")
	 * });
	 * ```
	 *
	 * @param {gsap.DOMTarget} target
	 * @param {MotionPathHelper.EditPathVars} [vars]
	 * @returns {object} A PathEditor instance
	 * @memberof MotionPathHelper
	 * @link https://greensock.com/docs/v3/Plugins/MotionPathHelper/static.editPath()
	 */
	static editPath(target: gsap.DOMTarget, vars?: MotionPathHelper.EditPathVars): MotionPathHelper;
}
declare namespace MotionPathHelper {
	interface Vars {
		[key: string]: any;
		ease?: string | gsap.EaseFunction;
		end?: number;
		duration?: number;
		path?: gsap.DOMTarget;
		pathColor?: gsap.TweenValue;
		pathWidth?: number;
		pathOpacity?: number;
		selected?: boolean;
		start?: number;
	}
	interface EditPathVars {
		[key: string]: any;
		anchorSnap?: Function;
		callbackScope?: object;
		draggable?: boolean;
		handleSize?: number;
		handleSnap?: Function;
		onDeleteAnchor?: Function;
		onPress?: Function;
		onRelease?: Function;
		onUpdate?: Function;
		selected?: boolean;
	}
}
declare class Observer {
	static readonly isTouch: number;
	static readonly eventTypes: string[];
	static readonly version: string;
	readonly deltaX: number;
	readonly deltaY: number;
	readonly event: Event;
	readonly isDragging: boolean;
	readonly isEnabled: boolean;
	readonly isPressed: boolean;
	readonly startX?: number;
	readonly startY?: number;
	readonly target: Element;
	readonly vars: Observer.ObserverVars;
	readonly velocityX: number;
	readonly velocityY: number;
	readonly x?: number;
	readonly y?: number;
	readonly axis?: string | null;
	/**
	 * Creates a new Observer
	 *
	 * ```js
	 * Observer.create({
	 *   target: "#id",
	 *   onUp: () => console.log("up"),
	 *   onDown: () => console.log("down"),
	 *   onPress: () => console.log("press")
	 * });
	 * ```
	 *
	 * @static
	 * @param {Observer.ObserverVars} vars
	 * @returns {Observer} The Observer
	 * @memberof Observer
	 * @link https://greensock.com/docs/v3/Plugins/Observer/static.create()
	 */
	static create(vars: Observer.ObserverVars): Observer;
	/**
	 * Gets all Observers (that haven't been killed)
	 *
	 * ```js
	 * Observer.getAll().forEach(o => o.kill());
	 * ```
	 *
	 * @static
	 * @returns {Observer[]} An Array of Observers
	 * @memberof Observer
	 * @link https://greensock.com/docs/v3/Plugins/Observer/static.getAll()
	 */
	static getAll(): Observer[];
	/**
	 * Gets the observer with the id provided.
	 *
	 * ```js
	 * let o = Observer.getById("my-id");
	 * ```
	 *
	 * @static
	 * @param {string} id
	 * @returns {Observer | undefined} The Observer with the supplied id (if one exists)
	 * @memberof Observer
	 * @link https://greensock.com/docs/v3/Plugins/Observer/static.getAll()
	 */
	static getById(id: string): Observer | undefined;
	/**
	 * Disables a Observer instance.
	 *
	 * ```js
	 * observer.disable();
	 * ```
	 */
	disable(): void;
	/**
	 * Re-enables a disabled Observer instance.
	 *
	 * ```js
	 * observer.enable();
	 * ```
	 */
	enable(): this;
	/**
	 * Kills a Observer instance (same as disabling, but typically permanent).
	 *
	 * ```js
	 * observer.kill();
	 * ```
	 */
	kill(): void;
	/**
	 * Gets the horizontal scroll position of the target (typically scrollLeft).
	 *
	 * ```js
	 * observer.scrollX();
	 * ```
	 *
	 * @returns {number} The horizontal scroll position of the target
	 */
	scrollX(): number;
	/**
	 * Sets the horizontal scroll position of the target (typically scrollTop).
	 *
	 * ```js
	 * observer.scrollX(100);
	 * ```
	 *
	 * @param {number} position
	 */
	scrollX(position: number): void;
	/**
	 * Gets the vertical scroll position of the target (typically scrollTop).
	 *
	 * ```js
	 * observer.scrollY();
	 * ```
	 *
	 * @returns {number} The vertical scroll position of the target
	 */
	scrollY(): number;
	/**
	 * Sets the vertical scroll position of the target (typically scrollTop).
	 *
	 * ```js
	 * observer.scrollY(100);
	 * ```
	 *
	 * @param {number} position
	 */
	scrollY(position: number): void;
}
declare namespace Observer {
	type ObserverCallback = (self: Observer) => any;
	type IgnoreCheckCallback = (event: Event, isTouchOrPointer: boolean) => boolean;
	interface ObserverVars {
		allowClicks?: boolean;
		capture?: boolean;
		debounce?: boolean;
		dragMinimum?: number;
		event?: Event;
		id?: string;
		ignore?: gsap.DOMTarget;
		ignoreCheck?: IgnoreCheckCallback;
		lineHeight?: number;
		lockAxis?: boolean;
		onLockAxis?: ObserverCallback;
		onDown?: ObserverCallback;
		onUp?: ObserverCallback;
		onLeft?: ObserverCallback;
		onRight?: ObserverCallback;
		onDisable?: ObserverCallback;
		onDrag?: ObserverCallback;
		onDragStart?: ObserverCallback;
		onDragEnd?: ObserverCallback;
		onEnable?: ObserverCallback;
		onHover?: ObserverCallback;
		onHoverEnd?: ObserverCallback;
		onToggleY?: ObserverCallback;
		onToggleX?: ObserverCallback;
		onChangeX?: ObserverCallback;
		onChangeY?: ObserverCallback;
		onChange?: ObserverCallback;
		onClick?: ObserverCallback;
		onPress?: ObserverCallback;
		onRelease?: ObserverCallback;
		onMove?: ObserverCallback;
		onWheel?: ObserverCallback;
		onStop?: ObserverCallback;
		onStopDelay?: number;
		preventDefault?: boolean;
		target?: gsap.DOMTarget | Window | Document;
		tolerance?: number;
		type?: string;
		wheelSpeed?: number;
	}
}
declare namespace Physics2DPlugin {
	interface Vars {
		acceleration?: gsap.TweenValue;
		accelerationAngle?: gsap.TweenValue;
		angle?: gsap.TweenValue;
		friction?: gsap.TweenValue;
		gravity?: gsap.TweenValue;
		velocity?: gsap.TweenValue;
		xProp?: string;
		yProp?: string;
	}
}
declare namespace gsap {
	interface TweenVars {
		physics2D?: Physics2DPlugin.Vars;
	}
}
declare namespace gsap.plugins {
	interface Physics2DPlugin extends Plugin {}
	interface Physics2DPluginClass extends Physics2DPlugin {
		new (): PluginScope & Physics2DPlugin;
		prototype: PluginScope & Physics2DPlugin;
	}
	const physics2D: Physics2DPluginClass;
}
declare const Physics2DPlugin: gsap.plugins.Physics2DPlugin;
declare namespace PhysicsPropsPlugin {
	interface Vars {
		[key: string]: Values;
	}
	interface Values {
		acceleration?: gsap.TweenValue;
		friction?: gsap.TweenValue;
		velocity?: gsap.TweenValue;
	}
}
declare namespace gsap {
	interface TweenVars {
		physicsProps?: PhysicsPropsPlugin.Vars;
	}
}
declare namespace gsap.plugins {
	interface PhysicsPropsPlugin extends Plugin {}
	interface PhysicsPropsPluginClass extends PhysicsPropsPlugin {
		new (): PluginScope & PhysicsPropsPlugin;
		prototype: PluginScope & PhysicsPropsPlugin;
	}
	const physicsProps: PhysicsPropsPluginClass;
}
declare const PhysicsPropsPlugin: gsap.plugins.PhysicsPropsPlugin;
declare namespace PixiPlugin {
	interface PixiMatrix {
		a: number;
		b: number;
		c: number;
		d: number;
		tx: number;
		ty: number;
		array?: number[];
	}
	interface Vars {
		[key: string]: any;
		alpha?: number | string;
		anchor?: number;
		anchorX?: number | string;
		anchorY?: number | string;
		angle?: number | string;
		autoAlpha?: number;
		blur?: number;
		blurX?: number;
		blurY?: number;
		blurPadding?: number;
		brightness?: number;
		colorize?: string | number;
		colorizeAmount?: number;
		colorMatrixFilter?: object; // TODO
		combineCMF?: boolean;
		contrast?: number;
		fillColor?: string | number;
		height?: number | string;
		hue?: number;
		lineColor?: string | number;
		matrix?: PixiMatrix;
		pivot?: number;
		pivotX?: number | string;
		pivotY?: number | string;
		position?: number | string;
		positionX?: number | string;
		positionY?: number | string;
		resolution?: number;
		rotation?: number | string;
		saturation?: number;
		scale?: number | string;
		scaleX?: number | string;
		scaleY?: number | string;
		skew?: number | string;
		skewX?: number | string;
		skewY?: number | string;
		tilePosition?: number;
		tilePositionX?: number | string;
		tilePositionY?: number | string;
		tileScale?: number;
		tileScaleX?: number | string;
		tileScaleY?: number | string;
		tileX?: number | string;
		tileY?: number | string;
		tint?: string | number;
		width?: number | string;
		x?: number | string;
		y?: number | string;
		zIndex?: number | string;
	}
}
declare namespace gsap {
	interface TweenVars {
		pixi?: PixiPlugin.Vars;
	}
}
declare namespace gsap.plugins {
	interface PixiPlugin extends Plugin {
		/**
		 * Registers the main PIXI library object with the PixiPlugin so that it can find the
		 * necessary classes/objects. You only need to register it once.
		 *
		 * ```js
		 * PixiPlugin.registerPIXI(PIXI);
		 * ```
		 *
		 * @param {object} pixi
		 * @memberof PixiPlugin
		 * @link https://greensock.com/docs/v3/Plugins/PixiPlugin/static.registerPIXI()
		 */
		registerPIXI(pixi: object): void;
	}
	interface PixiPluginClass extends PixiPlugin {
		new (): PluginScope & PixiPlugin;
		prototype: PluginScope & PixiPlugin;
	}
	const pixi: PixiPluginClass;
}
declare const PixiPlugin: gsap.plugins.PixiPlugin;
declare namespace ScrambleTextPlugin {
	interface Vars {
		text: string;
		chars?: string;
		speed?: number;
		delimiter?: string;
		tweenLength?: boolean;
		newClass?: string;
		oldClass?: string;
		revealDelay?: number;
		rightToLeft?: boolean;
	}
}
declare namespace gsap {
	interface TweenVars {
		scrambleText?: string | ScrambleTextPlugin.Vars;
	}
}
declare namespace gsap.plugins {
	interface ScrambleTextPlugin extends Plugin {}
	interface ScrambleTextPluginClass extends ScrambleTextPlugin {
		new (): PluginScope & ScrambleTextPlugin;
		prototype: PluginScope & ScrambleTextPlugin;
	}
	const scrambleText: ScrambleTextPluginClass;
}
declare const ScrambleTextPlugin: gsap.plugins.ScrambleTextPlugin;
declare namespace ScrollToPlugin {
	interface Vars {
		x?: number | string | Element;
		y?: number | string | Element;
		offsetX?: number;
		offsetY?: number;
		autoKill?: boolean;
		onAutoKill?: Function;
	}
}
declare namespace gsap {
	interface TweenVars {
		scrollTo?: number | string | Element | Function | ScrollToPlugin.Vars;
	}
}
declare namespace gsap.plugins {
	interface ScrollToPlugin extends Plugin {}
	interface ScrollToPluginClass extends ScrollToPlugin {
		new (): PluginScope & ScrollToPlugin;
		prototype: PluginScope & ScrollToPlugin;
	}
	const scrollTo: ScrollToPluginClass;
}
declare const ScrollToPlugin: gsap.plugins.ScrollToPlugin;
declare namespace gsap {
	interface AnimationVars {
		scrollTrigger?: gsap.DOMTarget | ScrollTrigger.Vars;
	}
}
declare class ScrollTrigger {
	static readonly version: string;
	static readonly isTouch: number;
	readonly animation?: gsap.core.Animation | undefined;
	readonly callbackAnimation?: gsap.core.Animation | undefined;
	readonly direction: number;
	readonly end: number;
	readonly isActive: boolean;
	readonly pin?: Element;
	readonly progress: number;
	readonly scroller: Element | Window;
	readonly start: number;
	readonly trigger?: Element;
	readonly vars: ScrollTrigger.Vars;
	/**
	 * Creates an instance of ScrollTrigger.
	 * @param {ScrollTrigger.StaticVars} vars
	 * @param {gsap.core.Animation} [animation]
	 * @memberof ScrollTrigger
	 */
	constructor(vars: ScrollTrigger.StaticVars, animation?: gsap.core.Animation);
	/**
	 * Attach a new event listener to a ScrollTrigger event.
	 *
	 * ```js
	 * ScrollTrigger.addEventListener("scrollStart", myFunc);
	 * ```
	 *
	 * @static
	 * @param {"scrollStart" | "scrollEnd" | "refreshInit" | "refresh"} event
	 * @param {gsap.Callback} callback
	 * @memberof ScrollTrigger
	 * @link https://greensock.com/docs/v3/Plugins/ScrollTrigger/static.addEventListener()
	 */
	static addEventListener(
		event: 'scrollStart' | 'scrollEnd' | 'refreshInit' | 'refresh' | 'matchMedia',
		callback: gsap.Callback
	): void;
	/**
	 * Creates a coordinated group of ScrollTriggers (one for each target element) that batch their callbacks within a certain interval
	 *
	 * ```js
	 * ScrollTrigger.batch(".class", {
	 *   interval: 0.1,
	 *   batchMax: 3,
	 *   onEnter: (elements, triggers) => gsap.to(elements, {opacity: 1, stagger: 0.15, overwrite: true}),
	 *   onLeave: (elements, triggers) => gsap.set(elements, {opacity: 0, overwrite: true}),
	 *   onEnterBack: (elements, triggers) => gsap.to(elements, {opacity: 1, stagger: 0.15, overwrite: true}),
	 *   onLeaveBack: (elements, triggers) => gsap.set(elements, {opacity: 0, overwrite: true})
	 * });
	 * ```
	 *
	 * @static
	 * @param {gsap.DOMTarget} targets
	 * @param {ScrollTrigger.BatchVars} vars
	 * @returns {ScrollTriggerInstance[]} An Array of the resulting ScrollTrigger instances
	 * @memberof ScrollTrigger
	 * @link https://greensock.com/docs/v3/Plugins/ScrollTrigger/static.batch()
	 */
	static batch(targets: gsap.DOMTarget, vars: ScrollTrigger.BatchVars): ScrollTrigger[];
	/**
	 * Un-registers .matchMedia() break points (or just one).
	 *
	 * ```js
	 * ScrollTrigger.clearMatchMedia();
	 * ```
	 *
	 * @static
	 * @param {string} [name]
	 * @memberof ScrollTrigger
	 * @link https://greensock.com/docs/v3/Plugins/ScrollTrigger/static.clearMatchMedia()
	 */
	static clearMatchMedia(name?: string): void;
	/**
	 * Clears any recorded scroll position data.
	 *
	 * ```js
	 * ScrollTrigger.clearScrollMemory();
	 * ```
	 *
	 * @static
	 * @memberof ScrollTrigger
	 * @link https://greensock.com/docs/v3/Plugins/ScrollTrigger/static.clearScrollMemory()
	 */
	static clearScrollMemory(): void;
	/**
	 * Configure ScrollTrigger
	 *
	 * ```js
	 * ScrollTrigger.config({
	 *   limitCallbacks: true,
	 *   autoRefreshEvents: "resize,load,visibilitychange,DOMContentLoaded"
	 * });
	 * ```
	 *
	 * @static
	 * @param {ScrollTrigger.ConfigVars} vars
	 * @memberof ScrollTrigger
	 * @link https://greensock.com/docs/v3/Plugins/ScrollTrigger/static.config()
	 */
	static config(vars: ScrollTrigger.ConfigVars): void;
	/**
	 * Create scroll triggers that aren't directly connected to a tween or timeline.
	 *
	 * ```js
	 * ScrollTrigger.create({
	 *   trigger: "#id",
	 *   start: "top top",
	 *   end: "bottom 50%+=100px"
	 * });
	 * ```
	 *
	 * @static
	 * @param {ScrollTrigger.StaticVars} vars
	 * @returns {ScrollTrigger} The ScrollTrigger
	 * @memberof ScrollTrigger
	 * @link https://greensock.com/docs/v3/Plugins/ScrollTrigger/static.create()
	 */
	static create(vars: ScrollTrigger.StaticVars): ScrollTrigger;
	/**
	 * Set the default values that apply to every ScrollTrigger upon creation.
	 *
	 * ```js
	 * ScrollTrigger.defaults({
	 *   toggleActions: "restart pause resume none",
	 *   markers: {startColor: "white", endColor: "white", fontSize: "18px", indent: 10}
	 * });
	 * ```
	 *
	 * @static
	 * @param {ScrollTrigger.StaticVars} vars
	 * @returns {ScrollTrigger.StaticVars} The config object
	 * @memberof ScrollTrigger
	 * @link https://greensock.com/docs/v3/Plugins/ScrollTrigger/static.defaults()
	 */
	static defaults(vars: ScrollTrigger.StaticVars): ScrollTrigger.StaticVars;
	/**
	 * Returns all ScrollTriggers that exist.
	 *
	 * ```js
	 * ScrollTrigger.getAll("myID");
	 * ```
	 *
	 * @static
	 * @returns {ScrollTrigger[]} The ScrollTrigger
	 * @memberof ScrollTrigger
	 * @link https://greensock.com/docs/v3/Plugins/ScrollTrigger/static.getAll()
	 */
	static getAll(): ScrollTrigger[];
	/**
	 * Disables ALL ScrollTrigger functionality.
	 *
	 * ```js
	 * ScrollTrigger.disable();
	 * ```
	 * @static
	 * @param {boolean} reset
	 * @param {boolean} kill
	 * @memberof ScrollTrigger
	 * @link https://greensock.com/docs/v3/Plugins/ScrollTrigger/static.disable()
	 */
	static disable(reset?: boolean, kill?: boolean): void;
	/**
	 * Enables all ScrollTrigger functionality again after ScrollTrigger.disable() was called.
	 *
	 * ```js
	 * ScrollTrigger.enable();
	 * ```
	 * @static
	 * @memberof ScrollTrigger
	 * @link https://greensock.com/docs/v3/Plugins/ScrollTrigger/static.enable()
	 */
	static enable(): void;
	/**
	 * Returns the ScrollTrigger that was assigned the corresponding id.
	 *
	 * ```js
	 * ScrollTrigger.getById("myID");
	 * ```
	 *
	 * @static
	 * @param {string} id
	 * @returns {ScrollTriggerInstance} The ScrollTrigger
	 * @memberof ScrollTrigger
	 * @link https://greensock.com/docs/v3/Plugins/ScrollTrigger/static.getById()
	 */
	static getById(id: string): ScrollTrigger | undefined;
	/**
	 * Returns a function to control the scroll position of a particular element
	 *
	 * ```js
	 * let setScroll = ScrollTrigger.getScrollFunc(window);
	 * setScroll(250);
	 * ```
	 *
	 * @static
	 * @param {(gsap.DOMTarget | Window)} element
	 * @param {boolean} [horizontal]
	 * @returns {ScrollTrigger.ScrollFunc}
	 * @memberof ScrollTrigger
	 */
	static getScrollFunc(element: gsap.DOMTarget | Window, horizontal?: boolean): ScrollTrigger.ScrollFunc;
	/**
	 * Checks if the element is in the viewport.
	 *
	 * ```js
	 * if (ScrollTrigger.isInViewport(element, 0.2)) {...};
	 * ```
	 *
	 * @static
	 * @param {Element | string} element
	 * @param {number} [ratio]
	 * @param {boolean} [horizontal]
	 * @returns {boolean} Boolean
	 * @memberof ScrollTrigger
	 * @link https://greensock.com/docs/v3/Plugins/ScrollTrigger/static.isInViewport()
	 */
	static isInViewport(element: Element | string, ratio?: number, horizontal?: boolean): boolean;
	/**
	 * Find out if a ScrollTrigger-related scroller is currently scrolling.
	 *
	 * ```js
	 * ScrollTrigger.isScrolling();
	 * ```
	 *
	 * @static
	 * @returns {boolean} Whether or not any scroller is scrolling
	 * @memberof ScrollTrigger
	 * @link https://greensock.com/docs/v3/Plugins/ScrollTrigger/static.isScrolling()
	 */
	static isScrolling(): boolean;
	/**
	 * Kills all ScrollTriggers (except the main ScrollSmoother one, if it exists)
	 *
	 * ```js
	 * ScrollTrigger.killAll();
	 * ```
	 *
	 * @static
	 * @param {boolean} [allowListeners]
	 * @memberof ScrollTrigger
	 * @link https://greensock.com/docs/v3/Plugins/ScrollTrigger/static.killAll()
	 */
	static killAll(allowListeners?: boolean): void;
	/**
	 * Set up ScrollTriggers that only apply to certain viewport sizes using media queries. Deprecated in favor of gsap.matchMedia() in version 3.11.0+
	 *
	 * ```js
	 * ScrollTrigger.matchMedia({
	 *   "(min-width: 800px)": function() { },
	 *   "(max-width: 799px)": function() { },
	 *   "all": function() { }
	 * });
	 * ```
	 * @deprecated
	 * @static
	 * @param {ScrollTrigger.MatchMediaObject} vars
	 * @memberof ScrollTrigger
	 * @link https://greensock.com/docs/v3/Plugins/ScrollTrigger/static.matchMedia()
	 */
	static matchMedia(vars: ScrollTrigger.MatchMediaObject): void;
	/**
	 * Get the maximum scroll value for any given element.
	 *
	 * ```js
	 * ScrollTrigger.maxScroll(window);
	 * ```
	 *
	 * @static
	 * @param {(HTMLElement | Window)} target
	 * @param {boolean} [horizontal]
	 * @returns {number} The max distance the element can scroll
	 * @memberof ScrollTrigger
	 * @link https://greensock.com/docs/v3/Plugins/ScrollTrigger/static.maxScroll()
	 */
	static maxScroll(target: HTMLElement | Window, horizontal?: boolean): number;
	/**
	 * Forces scrolling to be done on the JavaScript thread, ensuring it is synchronized and the address bar doesn't show/hide on [most] mobile devices.
	 *
	 * ```js
	 * ScrollTrigger.normalizeScroll(true);
	 * ```
	 * @static
	 * @param {boolean | ScrollTrigger.NormalizeVars | Observer} enable
	 * @returns {Observer | undefined} a new Observer instance (if true) or undefined (if false)
	 * @memberof ScrollTrigger
	 * @link https://greensock.com/docs/v3/Plugins/ScrollTrigger/static.normalizeScroll()
	 */
	static normalizeScroll(enable?: boolean | ScrollTrigger.NormalizeVars | Observer): Observer | undefined;
	/**
	 * Returns the Observer instance that is currently normalizing scroll behavior (if one exists).
	 *
	 * ```js
	 * let normalizer = ScrollTrigger.normalizeScroll();
	 * ```
	 * @static
	 * @returns {Observer | undefined} the Observer instance normalizing scroll (if one exists) or undefined (if false)
	 * @memberof ScrollTrigger
	 * @link https://greensock.com/docs/v3/Plugins/ScrollTrigger/static.normalizeScroll()
	 */
	static normalizeScroll(): Observer | undefined;
	/**
	 * Creates an Observer that senses "scroll-like" behavior like a mouse wheel spin, finger swipe on a touch device, scrollbar drag or even a press/drag of the pointer.
	 *
	 * ```js
	 * ScrollTrigger.observe({
	 *     target: ".box",
	 *     onUp: self => console.log("up", self.deltaY),
	 *     onDown: self => console.log("down", self.deltaY)
	 * });
	 * ```
	 * @static
	 * @param {Observer.ObserverVars} vars
	 * @returns {Observer} a new Observer instance
	 * @memberof ScrollTrigger
	 * @link https://greensock.com/docs/v3/Plugins/ScrollTrigger/static.observe()
	 */
	static observe(vars: Observer.ObserverVars): Observer;
	/**
	 * Returns the position of the Element in the viewport as a normalized value (0-1) where 0 is top/left and 1 is bottom/right.
	 *
	 * ```js
	 * if (ScrollTrigger.positionInViewport(element, "top")) {...};
	 * ```
	 *
	 * @static
	 * @param {Element | string} element
	 * @param {number} [referencePoint] - a number in pixels from top, percent like "20%" from top or keyword like "top"/"center"/"bottom"
	 * @param {boolean} [horizontal]
	 * @returns {number} normalized value (0-1) where 0 is top/left and 1 is bottom/right
	 * @memberof ScrollTrigger
	 * @link https://greensock.com/docs/v3/Plugins/ScrollTrigger/static.positionInViewport()
	 */
	static positionInViewport(
		element: Element | string,
		referencePoint?: string | number,
		horizontal?: boolean
	): number;
	/**
	 * Recalculates the positioning of all of the ScrollTriggers on the page.
	 *
	 * ```js
	 * ScrollTrigger.refresh();
	 * ```
	 *
	 * @static
	 * @param {boolean} [safe]
	 * @memberof ScrollTrigger
	 * @link https://greensock.com/docs/v3/Plugins/ScrollTrigger/static.refresh()
	 */
	static refresh(safe?: boolean): void;
	/**
	 * Registers ScrollTrigger with gsap
	 *
	 * @static
	 * @param {typeof gsap} core
	 * @memberof ScrollTrigger
	 */
	static register(core: typeof gsap): void;
	/**
	 * Removes an event listener for a ScrollTrigger event.
	 *
	 * ```js
	 * ScrollTrigger.removeEventListener("scrollStart", myFunc);
	 * ```
	 *
	 * @static
	 * @param {"scrollStart" | "scrollEnd" | "refreshInit" | "refresh" | "matchMedia"} event
	 * @param {gsap.Callback} callback
	 * @memberof ScrollTrigger
	 * @link https://greensock.com/docs/v3/Plugins/ScrollTrigger/static.removeEventListener()
	 */
	static removeEventListener(
		event: 'scrollStart' | 'scrollEnd' | 'refreshInit' | 'refresh' | 'matchMedia',
		callback: gsap.Callback
	): void;
	/**
	 * Records the current inline CSS styles for the given element(s) so they can be reverted later.
	 *
	 * ```js
	 * ScrollTrigger.saveStyles(".panel, #logo");
	 * ```
	 *
	 * @static
	 * @param {gsap.DOMTarget} targets
	 * @memberof ScrollTrigger
	 * @link https://greensock.com/docs/v3/Plugins/ScrollTrigger/static.targets()
	 */
	static saveStyles(targets: gsap.DOMTarget): void;
	/**
	 * Sets up proxy methods for a particular scroller so that you can do advanced effects like integrate with a 3rd party smooth scrolling library.
	 *
	 * ```js
	 * ScrollTrigger.scrollerProxy(".container", {
	 *   scrollTop(value) {
	 *     return arguments.length ? locoScroll.scrollTo(value, 0, 0) : locoScroll.scroll.instance.scroll.y;
	 *   },
	 *   getBoundingClientRect() {
	 *     return {top: 0, left: 0, width: window.innerWidth, height: window.innerHeight};
	 *   },
	 *   pinType: document.querySelector(".container").style.transform ? "transform" : "fixed"
	 * });
	 * ```
	 *
	 * @static
	 * @param {gsap.DOMTarget} scroller
	 * @param {ScrollTrigger.ScrollerProxyVars} vars
	 * @memberof ScrollTrigger
	 * @link https://greensock.com/docs/v3/Plugins/ScrollTrigger/static.scrollerProxy()
	 */
	static scrollerProxy(scroller: gsap.DOMTarget, vars?: ScrollTrigger.ScrollerProxyVars): void;
	/**
	 * Returns a function that will snap in a given direction where 1 is positive and -1 is negative. It will accept an increment or Array of numbers
	 *
	 * ```js
	 * let snap = ScrollTrigger.snapDirectional(5);
	 * snap(2, 1); // 5
	 * snap(8, -1); // 5
	 * snap(51, 1) // 55
	 * ```
	 *
	 * @static
	 * @param {number | number[]} incrementOrArray
	 * @memberof ScrollTrigger
	 * @link https://greensock.com/docs/v3/Plugins/ScrollTrigger/static.snapDirectional()
	 */
	static snapDirectional(incrementOrArray: number | number[]): ScrollTrigger.SnapDirectionalFunc;
	/**
	 * Sorts the internal Array of ScrollTriggers by "refreshPriority" first, then by their "start" positions (or by a custom function you provide).
	 *
	 * ```js
	 * ScrollTrigger.sort();
	 * ```
	 *
	 * @static
	 * @param {Function} [func]
	 * @memberof ScrollTrigger
	 * @link https://greensock.com/docs/v3/Plugins/ScrollTrigger/static.sort()
	 */
	static sort(func?: Function): ScrollTrigger[];
	/**
	 * Checks where the scrollbar is and updates all ScrollTrigger instances' progress and direction values accordingly, controls the animation (if necessary) and fires the appropriate callbacks.
	 *
	 * ```js
	 * ScrollTrigger.update();
	 * ```
	 *
	 * @memberof ScrollTrigger
	 * @link https://greensock.com/docs/v3/Plugins/ScrollTrigger/static.update()
	 */
	static update(): void;
	/**
	 * Stops all of the ScrollTrigger's callbacks and removes any added markup and padding caused by pinning.
	 *
	 * ```js
	 * scrollTrigger.disable();
	 * scrollTrigger.disable(true);
	 * ```
	 *
	 * @param {boolean} [revert]
	 * @param {boolean} [allowAnimation]
	 * @memberof ScrollTrigger
	 * @link https://greensock.com/docs/v3/Plugins/ScrollTrigger/disable()
	 */
	disable(revert?: boolean, allowAnimation?: boolean): void;
	/**
	 * Re-enables a disabled ScrollTrigger instance.
	 *
	 * ```js
	 * scrollTrigger.enable();
	 * ```
	 * @param {boolean} [reset]
	 * @param {boolean} [refresh]
	 * @memberof ScrollTrigger
	 * @link https://greensock.com/docs/v3/Plugins/ScrollTrigger/enable()
	 */
	enable(reset?: boolean, refresh?: boolean): void;
	/**
	 * Forces any associated animation (including the callbackAnimation) to its natural end state immediately which is progress(1) if
	 * direction is 1 (forward) and progress(0) if direction is -1 (backward).
	 *
	 * ```js
	 * preventOverlaps: self => self.getTrailing().forEach(t => t.endAnimation());
	 * ```
	 *
	 * @memberof ScrollTrigger
	 * @link https://greensock.com/docs/v3/Plugins/ScrollTrigger/endAnimation()
	 */
	endAnimation(): void;
	/**
	 * Gets the scrub tween associated with the ScrollTrigger instance (if scrub was defined), or getTween(true) will get the snap tween (assuming snap was defined).
	 *
	 * ```js
	 * let scrub = scrollTrigger.getTween();
	 * scrub.progress(1); // immediately finish the scrub
	 * ```
	 *
	 * @param {boolean} [snap]
	 * @memberof ScrollTrigger
	 * @link https://greensock.com/docs/v3/Plugins/ScrollTrigger/getTween()
	 */
	getTween(snap?: boolean): gsap.core.Tween;
	/**
	 * Returns an Array of all ScrollTriggers that precede this one in the updating order according to the current scroll direction.
	 *
	 * ```js
	 * preventOverlaps: self => self.getTrailing().forEach(t => t.endAnimation());
	 * ```
	 *
	 * @param {string | boolean} [name] optional preventOverlaps name to filter
	 * @memberof ScrollTrigger
	 * @link https://greensock.com/docs/v3/Plugins/ScrollTrigger/getTrailing()
	 */
	getTrailing(name?: string | boolean | null): ScrollTrigger[];
	/**
	 * Gets the current velocity of the element's scroll on which the ScrollTrigger is attached to (in pixels per second).
	 *
	 * ```js
	 * scrollTrigger.getVelocity();
	 * ```
	 *
	 * @memberof ScrollTrigger
	 * @link https://greensock.com/docs/v3/Plugins/ScrollTrigger/getVelocity()
	 */
	getVelocity(): number;
	/**
	 * Removes all added markup, stops all callbacks, and frees it for GC.
	 *
	 * ```js
	 * scrollTrigger.kill();
	 * ```
	 *
	 * @param {boolean} [reset]
	 * @param {boolean} [allowAnimation]
	 * @memberof ScrollTrigger
	 * @link https://greensock.com/docs/v3/Plugins/ScrollTrigger/kill()
	 */
	kill(reset?: boolean, allowAnimation?: boolean): void;
	/**
	 * Converts a timeline's label to the associated scroll position (in px)
	 *
	 * ```js
	 * scrollTrigger.labelToScroll("label-1");
	 * ```
	 *
	 * @param {string} label
	 * @returns {number} The associated scroll position
	 * @memberof ScrollTrigger
	 * @link https://greensock.com/docs/v3/Plugins/ScrollTrigger/labelToScroll()
	 */
	labelToScroll(label: string): number;
	/**
	 * Gets the ScrollTrigger instance that's immediately after this one in the refresh order (if any)
	 *
	 * ```js
	 * scrollTrigger.next();
	 * ```
	 *
	 * @memberof ScrollTrigger
	 * @returns {ScrollTrigger | undefined} The next ScrollTrigger (if one exists)
	 * @link https://greensock.com/docs/v3/Plugins/ScrollTrigger/next()
	 */
	next(): ScrollTrigger | undefined;
	/**
	 * Gets the ScrollTrigger instance that's immediately before this one in the refresh order (if any)
	 *
	 * ```js
	 * scrollTrigger.previous();
	 * ```
	 *
	 * @memberof ScrollTrigger
	 * @link https://greensock.com/docs/v3/Plugins/ScrollTrigger/previous()
	 */
	previous(): ScrollTrigger | undefined;
	/**
	 * Forces the ScrollTrigger instance to re-calculate its start and end values (the scroll positions where it'll be activated).
	 *
	 * ```js
	 * scrollTrigger.refresh();
	 * ```
	 *
	 * @memberof ScrollTrigger
	 * @link https://greensock.com/docs/v3/Plugins/ScrollTrigger/refresh()
	 */
	refresh(): void;
	/**
	 * Gets the scroll position of the ScrollTrigger's scroller.
	 *
	 * ```js
	 * scrollTrigger.scroll();
	 * ```
	 *
	 * @returns {number} The scroll position of the scroller
	 * @memberof ScrollTrigger
	 * @link https://greensock.com/docs/v3/Plugins/ScrollTrigger/scroll()
	 */
	scroll(): number;
	/**
	 * Sets the scroll position of the ScrollTrigger's scroller.
	 *
	 * ```js
	 * scrollTrigger.scroll(100);
	 * ```
	 *
	 * @param {number} position
	 * @memberof ScrollTrigger
	 * @link https://greensock.com/docs/v3/Plugins/ScrollTrigger/scroll()
	 */
	scroll(position: number): void;
	/**
	 * Animates the scroll position of the ScrollTrigger's scroller.
	 *
	 * ```js
	 * scrollTrigger.tweenTo(100);
	 * ```
	 *
	 * @param {number} position
	 * @returns {gsap.core.Tween} Tween
	 * @memberof ScrollTrigger
	 */
	tweenTo(position: number): gsap.core.Tween;
	update(reset?: boolean, recordVelocity?: boolean, forceFake?: boolean): void;
}
declare namespace ScrollTrigger {
	interface RectObj {
		top: number;
		left: number;
		width: number;
		height: number;
	}
	interface MatchMediaObject {
		[key: string]: Function;
	}
	type Callback = (self: ScrollTrigger) => any;
	type BatchCallback = (targets: Element[], triggers: ScrollTrigger[]) => any;
	type NumFunc = () => number;
	type SnapFunc = (value: number) => number;
	type SnapDirectionalFunc = (value: number, direction?: number, threshold?: number) => number;
	type GetterSetterNumFunc = (value?: number) => number | void;
	type GetterRectFunc = () => RectObj;
	type StartEndFunc = (self: ScrollTrigger) => string | number;
	type ScrollFunc = (position: number) => void;
	interface MarkersVars {
		endColor?: string;
		fontSize?: string;
		fontWeight?: string;
		indent?: number;
		startColor?: string;
	}
	interface ToggleClassVars {
		className: string;
		targets?: gsap.DOMTarget;
	}
	interface SnapVars {
		delay?: number;
		duration?: number | RangeObject;
		inertia?: boolean;
		ease?: string | gsap.EaseFunction;
		snapTo?: number | number[] | 'labels' | 'labelsDirectional' | SnapFunc;
		directional?: boolean;
		onInterrupt?: Callback;
		onStart?: Callback;
		onComplete?: Callback;
	}
	interface RangeObject {
		min?: number;
		max?: number;
	}
	interface Vars {
		anticipatePin?: number;
		containerAnimation?: gsap.core.Animation;
		end?: string | number | StartEndFunc;
		endTrigger?: gsap.DOMTarget;
		fastScrollEnd?: boolean | number;
		horizontal?: boolean;
		id?: string;
		immediateRender?: boolean;
		invalidateOnRefresh?: boolean;
		markers?: boolean | MarkersVars;
		once?: boolean;
		onEnter?: Callback;
		onEnterBack?: Callback;
		onKill?: Callback;
		onLeave?: Callback;
		onLeaveBack?: Callback;
		onRefresh?: Callback;
		onRefreshInit?: Callback;
		onSnapComplete?: Callback;
		onScrubComplete?: Callback;
		onUpdate?: Callback;
		onToggle?: Callback;
		pin?: boolean | gsap.DOMTarget;
		pinnedContainer?: gsap.DOMTarget;
		pinReparent?: boolean;
		pinSpacing?: boolean | string;
		pinSpacer?: gsap.DOMTarget;
		pinType?: 'fixed' | 'transform';
		preventOverlaps?: boolean | string | Callback;
		refreshPriority?: number;
		scroller?: gsap.DOMTarget | Window;
		scrub?: boolean | number;
		snap?: number | number[] | 'labels' | 'labelsDirectional' | SnapFunc | SnapVars;
		start?: string | number | StartEndFunc;
		toggleActions?: string;
		toggleClass?: string | ToggleClassVars;
		trigger?: gsap.DOMTarget;
	}
	interface StaticVars extends Vars {
		animation?: gsap.core.Animation;
	}
	interface BatchVars {
		interval?: number;
		batchMax?: number | NumFunc;
		anticipatePin?: number;
		end?: string | number | StartEndFunc;
		fastScrollEnd?: boolean | number;
		horizontal?: boolean;
		once?: boolean;
		onEnter?: BatchCallback;
		onEnterBack?: BatchCallback;
		onLeave?: BatchCallback;
		onLeaveBack?: BatchCallback;
		onRefresh?: BatchCallback;
		onRefreshInit?: Callback;
		onUpdate?: BatchCallback;
		onToggle?: BatchCallback;
		pin?: boolean | gsap.DOMTarget;
		pinReparent?: boolean;
		pinSpacing?: boolean | string;
		pinSpacer?: gsap.DOMTarget;
		pinType?: 'fixed' | 'transform';
		preventOverlaps?: boolean | string | Callback;
		scroller?: gsap.DOMTarget | Window;
		start?: string | number | StartEndFunc;
		toggleClass?: string | ToggleClassVars;
	}
	interface ConfigVars {
		limitCallbacks?: boolean;
		syncInterval?: number;
		autoRefreshEvents?: string;
		ignoreMobileResize?: boolean;
	}
	interface ScrollerProxyVars {
		scrollTop?: GetterSetterNumFunc;
		scrollLeft?: GetterSetterNumFunc;
		scrollWidth?: GetterSetterNumFunc;
		scrollHeight?: GetterSetterNumFunc;
		fixedMarkers?: boolean;
		getBoundingClientRect?: GetterRectFunc;
		pinType?: 'fixed' | 'transform';
		content?: gsap.DOMTarget;
	}
	interface NormalizeVars extends Observer.ObserverVars {
		momentum?: number | Function;
		content?: gsap.DOMTarget;
		allowNestedScroll?: boolean;
	}
}
declare namespace gsap.plugins {
	/**
	 * @deprecated since 3.7.0
	 * @see ScrollTrigger.ScrollerProxyVars
	 */
	type ScrollerProxyVars = ScrollTrigger.ScrollerProxyVars;
	/**
	 * @deprecated since 3.7.0
	 * @see ScrollTrigger
	 */
	type ScrollTrigger = any;
	/**
	 * @deprecated since 3.7.0
	 * @see ScrollTrigger.BatchVars
	 */
	type ScrollTriggerBatchVars = ScrollTrigger.BatchVars;
	/**
	 * @deprecated since 3.7.0
	 * @see ScrollTrigger.ConfigVars
	 */
	type ScrollTriggerConfigVars = ScrollTrigger.ConfigVars;
	/**
	 * @deprecated since 3.7.0
	 * @see ScrollTrigger
	 */
	class ScrollTriggerInstance extends ScrollTrigger {}
	/**
	 * @deprecated since 3.7.0
	 * @see ScrollTrigger.Vars
	 */
	type ScrollTriggerInstanceVars = ScrollTrigger.Vars;
	/**
	 * @deprecated since 3.7.0
	 * @see ScrollTrigger
	 */
	class ScrollTriggerStatic extends ScrollTrigger {}
	/**
	 * @deprecated since 3.7.0
	 * @see ScrollTrigger.StaticVars
	 */
	type ScrollTriggerStaticVars = ScrollTrigger.StaticVars;
	/**
	 * @deprecated since 3.7.0
	 * @see ScrollTrigger.SnapVars;
	 */
	type SnapVars = ScrollTrigger.SnapVars;
	/**
	 * @deprecated since 3.7.0
	 * @see ScrollTrigger.ToggleClassVars
	 */
	type ToggleClassVars = ScrollTrigger.ToggleClassVars;
}
declare class ScrollSmoother {
	static readonly version: string;
	readonly scrollTrigger: ScrollTrigger;
	readonly progress: number;
	readonly normalizer?: Observer;
	/**
	 * Creates an instance of ScrollSmoother.
	 * @param {ScrollSmoother.Vars} vars
	 * @memberof ScrollSmoother
	 */
	constructor(vars: ScrollSmoother.Vars);
	/**
	 * Create a ScrollSmoother instance to smooth the scrolling of the page (only one can exist at any time)
	 *
	 * ```js
	 * ScrollSmoother.create({
	 *   content: "#smooth-content",
	 *   wrapper: "#smooth-wrapper",
	 *   smooth: 1.5,
	 *   effects: true
	 * });
	 * ```
	 *
	 * @static
	 * @param {ScrollSmoother.Vars} vars
	 * @returns {ScrollSmoother} The ScrollSmoother
	 * @memberof ScrollSmoother
	 * @link https://greensock.com/docs/v3/Plugins/ScrollSmoother/static.create()
	 */
	static create(vars: ScrollSmoother.Vars): ScrollSmoother;
	/**
	 * Returns the ScrollSmoother instance (if one has been created). Only one is allowed at any given time.
	 *
	 * ```js
	 * let smoother = ScrollSmoother.get();
	 * ```
	 *
	 * @static
	 * @returns {ScrollSmoother} The ScrollSmoother
	 * @memberof ScrollSmoother
	 * @link https://greensock.com/docs/v3/Plugins/ScrollSmoother/static.get()
	 */
	static get(): ScrollSmoother | undefined;
	/**
	 * Refreshes all ScrollTriggers (same as ScrollTrigger.refresh())
	 *
	 * ```js
	 * ScrollSmoother.refresh();
	 * ```
	 *
	 * @param {boolean} safe
	 * @memberof ScrollSmoother
	 * @link https://greensock.com/docs/v3/Plugins/ScrollSmoother/static.refresh()
	 */
	static refresh(safe?: boolean): void;
	/**
	 * Sets the content element (the element that moves up and down when scrolling)
	 *
	 * ```js
	 * smoother.content("#content");
	 * ```
	 *
	 * @param {gsap.DOMTarget} element
	 * @returns {ScrollSmoother} The ScrollSmoother instance (to make chaining easier)
	 * @memberof ScrollSmoother
	 * @link https://greensock.com/docs/v3/Plugins/ScrollSmoother/content()
	 */
	content(element: gsap.DOMTarget): this;
	/**
	 * Gets the content element (the element that moves up and down when scrolling)
	 *
	 * ```js
	 * let el = smoother.content();
	 * ```
	 *
	 * @returns {HTMLElement} The content Element
	 * @memberof ScrollSmoother
	 * @link https://greensock.com/docs/v3/Plugins/ScrollSmoother/content()
	 */
	content(): HTMLElement;
	/**
	 * Applies "speed" and/or "lag" effects to the supplied targets (instead of using HTML attributes like data-speed and data-lag)
	 *
	 * ```js
	 * scroller.effects(".box", {
	 *    speed: (i, el) => 0.5 + i * 0.1,
	 *    lag: 0.5
	 * });
	 * ```
	 *
	 * @param {gsap.DOMTarget} targets
	 * @param {ScrollSmoother.EffectsVars} vars
	 * @returns {ScrollTrigger[]} An Array of ScrollTrigger instances that were created to handle the effects
	 * @memberof ScrollSmoother
	 * @link https://greensock.com/docs/v3/Plugins/ScrollSmoother/effects()
	 */
	effects(targets: gsap.DOMTarget, vars?: ScrollSmoother.EffectsVars | null): ScrollTrigger[];
	/**
	 * Gets the ScrollTrigger instances that are managing the effects (like "speed" and/or "lag")
	 *
	 * ```js
	 * let effectTriggers = scroller.effects();
	 * ```
	 *
	 * @returns {ScrollTrigger[]} An Array of ScrollTrigger instances that were created to handle the effects
	 * @memberof ScrollSmoother
	 * @link https://greensock.com/docs/v3/Plugins/ScrollSmoother/effects()
	 */
	effects(): ScrollTrigger[];
	/**
	 * Returns the velocity of the vertical scrolling in pixels per second
	 *
	 * ```js
	 * let velocity = smoother.getVelocity()
	 * ```
	 *
	 * @returns {number} The velocity of the vertical scrolling (in pixels per second)
	 * @memberof ScrollSmoother
	 * @link https://greensock.com/docs/v3/Plugins/ScrollSmoother/getVelocity()
	 */
	getVelocity(): number;
	/**
	 * Kills the ScrollSmoother instance, reverting the inline CSS of the content and wrapper, removing listeners, etc. This is permanent but you can ScrollSmoother.create() a new one.
	 *
	 * ```js
	 * scrollSmoother.kill();
	 * ```
	 *
	 * @memberof ScrollSmoother
	 * @link https://greensock.com/docs/v3/Plugins/ScrollSmoother/kill()
	 */
	kill(): void;
	/**
	 * Gets the numeric offset (scroll position) associated with a particular element.
	 *
	 * ```js
	 * let offset = smoother.offset("#id", "center center");
	 * ```
	 *
	 * @param {gsap.DOMTarget} target
	 * @param {string} position - like "top center" or "50% bottom-=50px"
	 * @returns {number} The numeric offset (scroll position)
	 * @memberof ScrollSmoother
	 * @link https://greensock.com/docs/v3/Plugins/ScrollSmoother/offset()
	 */
	offset(target: gsap.DOMTarget, position?: string): number;
	/**
	 * Sets the paused state - if true, nothing will scroll (except via .scrollTop() or .scrollTo() on this instance). Serves as a getter and setter function
	 *
	 * ```js
	 * smoother.paused(true);
	 * ```
	 *
	 * @param {boolean} value
	 * @returns {ScrollSmoother} The ScrollSmoother instance (for easier chaining)
	 * @memberof ScrollSmoother
	 * @link https://greensock.com/docs/v3/Plugins/ScrollSmoother/paused()
	 */
	paused(value: boolean): this;
	/**
	 * Gets the paused state. Serves as a getter and setter function.
	 *
	 * ```js
	 * if (!smoother.paused()) {
	 *     ...
	 * }
	 * ```
	 *
	 * @returns {boolean} The paused state (true or false)
	 * @memberof ScrollSmoother
	 * @link https://greensock.com/docs/v3/Plugins/ScrollSmoother/paused()
	 */
	paused(): boolean;
	/**
	 * Refreshes only the main page's smoothing ScrollTrigger
	 *
	 * ```js
	 * smoother.refresh();
	 * ```
	 *
	 * @param {boolean} soft
	 * @param {boolean} force
	 * @memberof ScrollSmoother
	 * @link https://greensock.com/docs/v3/Plugins/ScrollSmoother/refresh()
	 */
	refresh(soft?: boolean, force?: boolean): void;
	/**
	 * Scrolls to a particular position or target immediately or in a smooth manner.
	 *
	 * ```js
	 * smoother.scrollTo("#id", true, "center center");
	 * ```
	 *
	 * @param {gsap.DOMTarget | number} target
	 * @param {boolean} smooth
	 * @param {string} position
	 * @returns {void}
	 * @memberof ScrollSmoother
	 * @link https://greensock.com/docs/v3/Plugins/ScrollSmoother/scrollTo()
	 */
	scrollTo(target: gsap.DOMTarget | number, smooth?: boolean, position?: string): void;
	/**
	 * Immediately scrolls to a particular numeric scroll position
	 *
	 * ```js
	 * smoother.scrollTop(500);
	 * ```
	 *
	 * @param {number} position
	 * @returns {ScrollSmoother} Returns the instance itself for easier chaining
	 * @memberof ScrollSmoother
	 * @link https://greensock.com/docs/v3/Plugins/ScrollSmoother/scrollTop()
	 */
	scrollTop(position: number): this;
	/**
	 * Gets the scroll position (numeric offset)
	 *
	 * ```js
	 * let offset = smoother.scrollTop();
	 * ```
	 *
	 * @returns {number} the numeric offset
	 * @memberof ScrollSmoother
	 * @link https://greensock.com/docs/v3/Plugins/ScrollSmoother/scrollTop()
	 */
	scrollTop(): number;
	//
	// /**
	//  * Sets up ScrollTriggers to handle hiding elements (sections) when they're sufficiently outside the viewport in order to improve performance in some situations.
	//  *
	//  * ```js
	//  * smoother.sections("[data-section]");
	//  * ```
	//  *
	//  * @param {gsap.DOMTarget} targets
	//  * @param {ScrollSmoother.SectionVars} vars
	//  * @returns {ScrollTrigger[]} An Array of ScrollTrigger instances that were created to handle the sections
	//  * @memberof ScrollSmoother
	//  * @link https://greensock.com/docs/v3/Plugins/ScrollSmoother/sections()
	//  */
	// sections(targets: gsap.DOMTarget, vars?: ScrollSmoother.SectionVars | null): ScrollTrigger[];
	//
	// /**
	//  * Gets the ScrollTrigger instances that are managing the sections
	//  *
	//  * ```js
	//  * let sectionTriggers = smoother.sections();
	//  * ```
	//  *
	//  * @returns {ScrollTrigger[]} An Array of ScrollTrigger instances that were created to handle the sections
	//  * @memberof ScrollSmoother
	//  * @link https://greensock.com/docs/v3/Plugins/ScrollSmoother/sections()
	//  */
	// sections(): ScrollTrigger[];
	/**
	 * Sets the number of seconds it takes to catch up to the scroll position (smoothing).
	 *
	 * ```js
	 * smoother.smooth(1.5);
	 * ```
	 *
	 * @param {number} value
	 * @memberof ScrollSmoother
	 * @link https://greensock.com/docs/v3/Plugins/ScrollSmoother/smooth()
	 */
	smooth(value: number): void;
	/**
	 * Gets the number of seconds it takes to catch up to the scroll position (smoothing).
	 *
	 * ```js
	 * let duration = smoother.smooth();
	 * ```
	 *
	 * @returns {number} The amount of smoothing applied (in seconds)
	 * @memberof ScrollSmoother
	 * @link https://greensock.com/docs/v3/Plugins/ScrollSmoother/smooth()
	 */
	smooth(): number;
	/**
	 * Sets the wrapper element which serves as the viewport (scrolls the content)
	 *
	 * ```js
	 * smoother.wrapper("#wrapper");
	 * ```
	 *
	 * @param {gsap.DOMTarget} element
	 * @returns {ScrollSmoother} The ScrollSmoother instance (to make chaining easier)
	 * @memberof ScrollSmoother
	 * @link https://greensock.com/docs/v3/Plugins/ScrollSmoother/wrapper()
	 */
	wrapper(element: gsap.DOMTarget): this;
	/**
	 * Gets the wrapper element which serves as the viewport (scrolls the content)
	 *
	 * ```js
	 * let el = smoother.wrapper();
	 * ```
	 *
	 * @returns {HTMLElement} The wrapper Element
	 * @memberof ScrollSmoother
	 * @link https://greensock.com/docs/v3/Plugins/ScrollSmoother/wrapper()
	 */
	wrapper(): HTMLElement;
}
declare namespace ScrollSmoother {
	type Callback = (self: ScrollSmoother) => any;
	type EventCallback = (self: ScrollSmoother, event: Event) => any;
	type EffectFunc = (index: number, element: Element) => number | string;
	interface EffectsVars {
		speed?: number | string | EffectFunc;
		lag?: number | EffectFunc;
		effectsPadding?: number | string | EffectFunc;
	}
	//
	// interface SectionVars {
	//   add?: boolean;
	// }
	interface Vars {
		autoResize?: boolean;
		content?: gsap.DOMTarget;
		ease?: string | Function;
		effects?: boolean | gsap.DOMTarget;
		effectsPrefix?: string;
		effectsPadding?: number;
		ignoreMobileResize?: boolean;
		normalizeScroll?: boolean | ScrollTrigger.NormalizeVars;
		onFocusIn?: EventCallback;
		onUpdate?: Callback;
		onStop?: Callback;
		//   sections?: boolean | gsap.DOMTarget;
		smooth?: boolean | number;
		smoothTouch?: boolean | number;
		speed?: number;
		wrapper?: gsap.DOMTarget;
	}
}
declare class SplitText {
	readonly chars: Element[];
	readonly lines: Element[];
	readonly words: Element[];
	readonly selector: string | Function;
	constructor(target: gsap.DOMTarget, vars?: SplitText.Vars);
	/**
	 * Reverts the innerHTML to the original content.
	 *
	 * ```js
	 * split.revert();
	 * ```
	 *
	 * @memberof SplitText
	 * @link https://greensock.com/docs/v3/Plugins/SplitText/revert()
	 */
	revert(): void;
	/**
	 * Re-splits a SplitText according to the vars provided. It will automatically call revert() first if necessary. Useful if you want to change the way the text is split after the SplitText instance is created.
	 *
	 * ```js
	 * split.split({type: "lines,chars"});
	 * ```
	 *
	 * @param {SplitText.Vars} vars
	 * @returns {SplitText} The SplitText object created
	 * @memberof SplitText
	 * @link https://greensock.com/docs/v3/Plugins/SplitText/split()
	 */
	split(vars: SplitText.Vars): SplitText;
}
declare namespace SplitText {
	interface Vars {
		[key: string]: any;
		type?: string;
		charsClass?: string;
		wordsClass?: string;
		linesClass?: string;
		position?: string;
		lineThreshold?: number;
		reduceWhiteSpace?: boolean;
		specialChars?: string[] | Function;
		wordDelimiter?: string;
	}
}
declare namespace TextPlugin {
	interface Vars {
		value: string;
		type?: string;
		rtl?: boolean;
		speed?: number;
		delimiter?: string;
		padSpace?: boolean;
		newClass?: string;
		oldClass?: string;
		preserveSpaces?: boolean;
	}
}
declare namespace gsap {
	interface TweenVars {
		text?: string | TextPlugin.Vars;
	}
}
declare namespace gsap.plugins {
	interface TextPlugin extends Plugin {}
	interface TextPluginClass extends TextPlugin {
		new (): PluginScope & TextPlugin;
		prototype: PluginScope & TextPlugin;
	}
	const text: TextPluginClass;
}
declare const TextPlugin: gsap.plugins.TextPlugin;
declare namespace gsap.core {
	type TimelineChild = string | Animation | Callback | Array<string | Animation | Callback>;
	interface Labels {
		[key: string]: number;
	}
	class Timeline extends Animation {
		autoRemoveChildren: boolean;
		labels: Labels;
		smoothChildTiming: boolean;
		vars: TimelineVars;
		[key: string]: any; // for gsap.registerEffect({... extendTimeline: true})
		constructor(vars?: TimelineVars, time?: number);
		static updateRoot(time: number): void;
		/**
		 * Adds a label, tween, timeline, or an array of those values to the timeline, optionally at the specified time.
		 *
		 * ```js
		 * tl.add("myLabel");  // add a label at the end of the timeline
		 * tl.add(myTween, 1); // add a tween at the 1 second mark
		 * tl.add(myTimeline, "-=1"); // add a timeline 1 second before the end of the timeline
		 * tl.add(["myLabel", myTween, myTimeline], "<"); // add a label, tween, and timeline at the start of the previous tween
		 * ```
		 *
		 * @param {TimelineChild} child
		 * @param {Position} [position]
		 * @returns {Timeline} The timeline
		 * @memberof Timeline
		 * @link https://greensock.com/docs/v3/GSAP/Timeline/add()
		 */
		add(child: TimelineChild, position?: Position): this;
		/**
		 * Adds a label to the timeline, optionally at the specified time.
		 *
		 * ```js
		 * tl.addLabel("myLabel", 1); // add a label at the 1 second mark
		 * ```
		 *
		 * @param {string} label
		 * @param {Position} [position]
		 * @returns {Timeline} The timeline
		 * @memberof Timeline
		 * @link https://greensock.com/docs/v3/GSAP/Timeline/addLabel()
		 */
		addLabel(label: string, position?: Position): this;
		/**
		 * Adds a pause to the timeline, optionally at the specified time.
		 *
		 * ```js
		 * tl.addPause(); // add a pause at the end of the timeline
		 * tl.addPause(1, myCallback); // add a pause at the 1 second mark with a callback
		 * ```
		 *
		 * @param {Position} [position]
		 * @param {Callback} [callback]
		 * @param {any[]} [params]
		 * @returns {Timeline} The timeline
		 * @memberof Timeline
		 * @link https://greensock.com/docs/v3/GSAP/Timeline/addPause()
		 */
		addPause(position?: Position, callback?: Callback, params?: any[]): this;
		/**
		 * Call a function, optionally at the specified time.
		 *
		 * ```js
		 * tl.call(myCallback); // add a function call at the end of the timeline
		 * tl.call(myCallback, ["param"], 1); // add a function call at the 1 second mark with a parameter passed in
		 * ```
		 *
		 * @param {Callback} callback
		 * @param {any[]} [params]
		 * @param {Position} [position]
		 * @returns {Timeline} The timeline
		 * @memberof Timeline
		 * @link https://greensock.com/docs/v3/GSAP/Timeline/call()
		 */
		call(callback: Callback, params?: any[], position?: Position): this;
		/**
		 * Empties the timeline of all tweens, timelines, callbacks, and optionally labels.
		 *
		 * ```js
		 * tl.clear();     // empty the timeline not including labels
		 * tl.clear(true); // empy the timeline including labels
		 * ```
		 *
		 * @param {boolean} labels
		 * @returns {Timeline} The timeline
		 * @memberof Timeline
		 * @link https://greensock.com/docs/v3/GSAP/Timeline/clear()
		 */
		clear(labels?: boolean): this;
		/**
		 * Makes the timeline's progress jump to the provided label.
		 *
		 * ```js
		 * tl.currentLabel("myLabel");
		 * ```
		 *
		 * @param {string} value
		 * @returns {Timeline} The timeline
		 * @memberof Timeline
		 * @link https://greensock.com/docs/v3/GSAP/Timeline/currentLabel()
		 */
		currentLabel(value: string): this;
		/**
		 * Gets the closest label that is at or before the current time.
		 *
		 * ```js
		 * tl.currentLabel();
		 * ```
		 *
		 * @returns {string} The nearest label
		 * @memberof Timeline
		 * @link https://greensock.com/docs/v3/GSAP/Timeline/currentLabel()
		 */
		currentLabel(): string;
		/**
		 * Creates a tween coming FROM the given values.
		 *
		 * ```js
		 * tl.from(".class", { x: 100 }, "+=1"); // adds the tween one second after the end of the timeline
		 * ```
		 *
		 * @param {TweenTarget} targets
		 * @param {TweenVars} vars
		 * @param {Position} [position]
		 * @returns {Timeline} The timeline
		 * @memberof Timeline
		 * @link https://greensock.com/docs/v3/GSAP/Timeline/from()
		 */
		from(targets: TweenTarget, vars: TweenVars, position?: Position): this;
		/**
		 * **Deprecated method signature.** Use the `duration` property instead.
		 *
		 * ```js
		 * tl.from(".class", 1, { x: 100 }, "+=1"); // adds the tween one second after the end of the timeline
		 * ```
		 *
		 * @deprecated since version 3.0.0
		 * @param {TweenTarget} targets
		 * @param {number} duration - The duration parameter is deprecated. Use the `duration` property instead.
		 * @param {TweenVars} vars
		 * @param {Position} [position]
		 * @returns {Timeline} The timeline
		 * @memberof Timeline
		 * @link https://greensock.com/docs/v3/GSAP/Timeline/from()
		 */
		from(targets: TweenTarget, duration: number, vars: TweenVars, position?: Position): this;
		/**
		 * Creates a tween coming FROM the first set of values going TO the second set of values.
		 *
		 * ```js
		 * tl.fromTo(".class", {x: 0}, { x: 100 }, "+=1"); // adds the tween one second after the end of the timeline
		 * ```
		 *
		 * @param {TweenTarget} targets
		 * @param {TweenVars} fromVars
		 * @param {TweenVars} toVars
		 * @param {Position} [position]
		 * @returns {Timeline} The timeline
		 * @memberof Timeline
		 * @link https://greensock.com/docs/v3/GSAP/Timeline/fromTo()
		 */
		fromTo(targets: TweenTarget, fromVars: TweenVars, toVars: TweenVars, position?: Position): this;
		/**
		 * **Deprecated method signature.** Use the `duration` property instead.
		 *
		 * ```js
		 * tl.fromTo(".class", 1, {x: 0}, { x: 100 }, "+=1"); // adds the tween one second after the end of the timeline
		 * ```
		 *
		 * @deprecated since version 3.0.0
		 * @param {TweenTarget} targets
		 * @param {number} duration - The duration parameter is deprecated. Use the `duration` property instead.
		 * @param {TweenVars} fromVars
		 * @param {TweenVars} toVars
		 * @param {Position} [position]
		 * @returns {Timeline} The timeline
		 * @memberof Timeline
		 * @link https://greensock.com/docs/v3/GSAP/Timeline/fromTo()
		 */
		fromTo(
			targets: TweenTarget,
			duration: number,
			fromVars: TweenVars,
			toVars: TweenVars,
			position?: Position
		): this;
		/**
		 * Returns the tween or timeline associated with the provided ID.
		 *
		 * ```js
		 * tl.getById("myTween");
		 * ```
		 *
		 * @param {string} id
		 * @returns {Tween | Timeline}
		 * @memberof Timeline
		 * @link https://greensock.com/docs/v3/GSAP/Timeline/getById()
		 */
		getById(id: string): Tween | Timeline;
		/**
		 * Returns an array containing all the tweens and/or timelines nested in this timeline.
		 *
		 * ```js
		 * tl.getChildren();
		 * tl.getChildren(true, true, true, 0.5);
		 * ```
		 *
		 * @param {boolean} [nested]
		 * @param {boolean} [tweens]
		 * @param {boolean} [timelines]
		 * @param {number} [ignoreBeforeTime]
		 * @returns {(Tween | Timeline)[]} Array of tweens and timelines
		 * @memberof Timeline
		 * @link https://greensock.com/docs/v3/GSAP/Timeline/getChildren()
		 */
		getChildren(
			nested?: boolean,
			tweens?: boolean,
			timelines?: boolean,
			ignoreBeforeTime?: number
		): (Tween | Timeline)[];
		/**
		 * Returns the tweens of a particular object that are inside this timeline.
		 *
		 * ```js
		 * tl.getTweensOf(".myClass");
		 * tl.getTweensOf(myElem, true);
		 * ```
		 *
		 * @param {TweenTarget} targets
		 * @param {boolean} [onlyActive]
		 * @returns {Tween[]} Array of tweens
		 * @memberof Timeline
		 * @link https://greensock.com/docs/v3/GSAP/Timeline/getTweensOf()
		 */
		getTweensOf(targets: TweenTarget, onlyActive?: boolean): Tween[];
		/**
		 * Returns the next label in the timeline, optionally from the provided time.
		 *
		 * ```js
		 * tl.nextLabel();
		 * tl.nextLabel(2);
		 * ```
		 *
		 * @param {number} [time]
		 * @returns {string} The next label
		 * @memberof Timeline
		 * @link https://greensock.com/docs/v3/GSAP/Timeline/nextLabel()
		 */
		nextLabel(time?: number): string;
		/**
		 * Returns the previous label in the timeline, optionally from the provided time.
		 *
		 * ```js
		 * tl.previousLabel();
		 * tl.previousLabel(2);
		 * ```
		 *
		 * @param {number} [time]
		 * @returns {string} The previous label
		 * @memberof Timeline
		 * @link https://greensock.com/docs/v3/GSAP/Timeline/previousLabel()
		 */
		previousLabel(time?: number): string;
		/**
		 * Returns the most recently added child tween, timeline, or callback regardless of its position in the timeline.
		 *
		 * ```js
		 * tl.recent();
		 * ```
		 *
		 * @returns {Tween | Timeline | Function} The most recent tween, timeline, or callback
		 * @memberof Timeline
		 * @link https://greensock.com/docs/v3/GSAP/Timeline/recent()
		 */
		recent(): Tween | Timeline | Function;
		/**
		 * Removes a tween, timeline, callback, label, or array of those values from the timeline.
		 *
		 * ```js
		 * tl.remove(myTween);
		 * tl.remove([myTween, mySubTimeline, "myLabel"]);
		 * ```
		 *
		 * @param {TimelineChild} value
		 * @returns {Timeline} The timeline
		 * @memberof Timeline
		 * @link https://greensock.com/docs/v3/GSAP/Timeline/remove()
		 */
		remove(value: TimelineChild): this;
		/**
		 * Removes a label from the timeline and returns the time of that label.
		 *
		 * ```js
		 * tl.removeLabel("myLabel"); // returns the label time like 1.0
		 * ```
		 *
		 * @param {string} label
		 * @returns {number} The time of the removed label
		 * @memberof Timeline
		 * @link https://greensock.com/docs/v3/GSAP/Timeline/removeLabel()
		 */
		removeLabel(label: string): number;
		/**
		 * Removes pauses that were added to a timeline via its .addPause() method.
		 *
		 * ```js
		 * tl.removePause(1); // returns the pause at time 1
		 * ```
		 *
		 * @param {Position} position
		 * @returns {Timeline} The timeline
		 * @memberof Timeline
		 * @link https://greensock.com/docs/v3/GSAP/Timeline/removePause()
		 */
		removePause(position: Position): this;
		/**
		 * Sets properties of the target(s) to the properties specified at the time of the set call.
		 *
		 * ```js
		 * tl.set(".class", {x: 100, y: 50, opacity: 0}, 1);
		 * ```
		 *
		 * @param {TweenTarget} targets
		 * @param {TweenVars} vars
		 * @param {Position} [position]
		 * @returns {Timeline} The timeline
		 * @memberof Timeline
		 * @link https://greensock.com/docs/v3/GSAP/Timeline/set()
		 */
		set(targets: TweenTarget, vars: TweenVars, position?: Position): this;
		/**
		 * Shifts the startTime of the timeline's children by a certain amount and optionally adjusts labels too.
		 *
		 * ```js
		 * tl.shiftChildren(1); // shift the child tweens, timelines, and callbacks by 1 second
		 * ```
		 *
		 * @param {number} amount
		 * @param {boolean} [adjustLabels]
		 * @param {number} [ignoreBeforeTime]
		 * @returns {Timeline} The timeline
		 * @memberof Timeline
		 * @link https://greensock.com/docs/v3/GSAP/Timeline/shiftChildren()
		 */
		shiftChildren(amount: number, adjustLabels?: boolean, ignoreBeforeTime?: number): this;
		/**
		 * **Deprecated method.** Use the `.from()` method instead.
		 *
		 * @deprecated since version 3.0.0
		 * @param {TweenTarget} targets
		 * @param {TweenVars} vars
		 * @param {Position} position
		 * @returns {Timeline} The timeline
		 * @memberof Timeline
		 * @link https://greensock.com/docs/v3/GSAP/Timeline/from()
		 */
		staggerFrom(targets: TweenTarget, vars: TweenVars, position?: Position): this;
		/**
		 * **Deprecated method.** Use the `.from()` method instead.
		 *
		 * @deprecated since version 3.0.0
		 * @param {TweenTarget} targets
		 * @param {number} duration - The duration parameter is deprecated. Use the `duration` property instead.
		 * @param {Timeline} vars
		 * @param {Position} position
		 * @returns {Timeline} The timeline
		 * @memberof Timeline
		 * @link https://greensock.com/docs/v3/GSAP/Timeline/from()
		 */
		staggerFrom(targets: TweenTarget, duration: number, vars: TweenVars, position?: Position): this;
		/**
		 * **Deprecated method.** Use the `.fromTo()` method instead.
		 *
		 * @deprecated since version 3.0.0
		 * @param {TweenTarget} targets
		 * @param {TweenVars} vars
		 * @param {Position} position
		 * @returns {Timeline} The timeline
		 * @memberof Timeline
		 * @link https://greensock.com/docs/v3/GSAP/Timeline/fromTo()
		 */
		staggerFromTo(targets: TweenTarget, fromVars: TweenVars, toVars: TweenVars, position?: Position): this;
		/**
		 * **Deprecated method.** Use the `.fromTo()` method instead.
		 *
		 * @deprecated since version 3.0.0
		 * @param {TweenTarget} targets
		 * @param {number} duration - The duration parameter is deprecated. Use the `duration` property instead.
		 * @param {Timeline} vars
		 * @param {Position} position
		 * @returns {Timeline} The timeline
		 * @memberof Timeline
		 * @link https://greensock.com/docs/v3/GSAP/Timeline/fromTo()
		 */
		staggerFromTo(
			targets: TweenTarget,
			duration: number,
			fromVars: TweenVars,
			toVars: TweenVars,
			position?: Position
		): this;
		/**
		 * **Deprecated method.** Use the `.to()` method instead.
		 *
		 * @deprecated since version 3.0.0
		 * @param {TweenTarget} targets
		 * @param {TweenVars} vars
		 * @param {Position} position
		 * @returns {Timeline} The timeline
		 * @memberof Timeline
		 * @link https://greensock.com/docs/v3/GSAP/Timeline/to()
		 */
		staggerTo(targets: TweenTarget, vars: TweenVars, position?: Position): this;
		/**
		 * **Deprecated method.** Use the `.to()` method instead.
		 *
		 * @deprecated since version 3.0.0
		 * @param {TweenTarget} targets
		 * @param {number} duration - The duration parameter is deprecated. Use the `duration` property instead.
		 * @param {Timeline} vars
		 * @param {Position} position
		 * @returns {Timeline} The timeline
		 * @memberof Timeline
		 * @link https://greensock.com/docs/v3/GSAP/Timeline/to()
		 */
		staggerTo(targets: TweenTarget, duration: number, vars: TweenVars, position?: Position): this;
		/**
		 * Creates a tween going TO the given values.
		 *
		 * ```js
		 * tl.to(".class", {x: 100}, 1);
		 * ```
		 *
		 * @param {TweenTarget} targets
		 * @param {TweenVars} vars
		 * @param {Position} position
		 * @returns {Timeline} The timeline
		 * @memberof Timeline
		 * @link https://greensock.com/docs/v3/GSAP/Timeline/to()
		 */
		to(targets: TweenTarget, vars: TweenVars, position?: Position): this;
		/**
		 * **Deprecated method signature.** Use the `duration` property instead.
		 *
		 * ```js
		 * tl.to(".class", 1, {x: 100}, 1);
		 * ```
		 * @deprecated since version 3.0.0
		 * @param {TweenTarget} targets
		 * @param {number} duration - The duration parameter is deprecated. Use the `duration` property instead.
		 * @param {Timeline} vars
		 * @param {Position} position
		 * @returns {Timeline} The timeline
		 * @memberof Timeline
		 * @link https://greensock.com/docs/v3/GSAP/Timeline/to()
		 */
		to(targets: TweenTarget, duration: number, vars: TweenVars, position?: Position): this;
		/**
		 * Tween linearly from a particular time or label to another time or label and then stops.
		 *
		 * ```js
		 * tl.tweenFromTo("myLabel", 5}); // tween from myLabel to the 5 second mark
		 * ```
		 *
		 * @param {Position} fromPosition
		 * @param {Position} toPosition
		 * @param {TweenVars} [vars]
		 * @returns {Tween} The tweenFromTo tween
		 * @memberof Timeline
		 * @link https://greensock.com/docs/v3/GSAP/Timeline/tweenFromTo()
		 */
		tweenFromTo(fromPosition: Position, toPosition: Position, vars?: TweenVars): Tween;
		/**
		 * Tween linearly to a particular time and then stops.
		 *
		 * ```js
		 * tl.tweenTo("myLabel"}); // tween to myLabel
		 * ```
		 *
		 * @param {Position} position
		 * @param {TweenVars} [vars]
		 * @returns {Tween} The tweenTo tween
		 * @memberof Timeline
		 * @link https://greensock.com/docs/v3/GSAP/Timeline/tweenTo()
		 */
		tweenTo(position: Position, vars?: TweenVars): Tween;
	}
}
declare namespace gsap.core {
	class Tween extends Animation {
		data: any;
		vars: TweenVars;
		ratio: number;
		constructor(targets: TweenTarget, vars: TweenVars, time?: number);
		constructor(targets: TweenTarget, duration: number, vars: TweenVars);
		/**
		 * **Deprecated method.** Use `gsap.to()` instead.
		 *
		 * @deprecated since 3.0.0
		 * @static
		 * @param {TweenTarget} targets
		 * @param {number} duration
		 * @param {TweenVars} vars
		 * @returns {Tween} Tween instance
		 * @memberof Tween
		 * @link https://greensock.com/docs/v3/GSAP/gsap.to()
		 */
		static to(targets: TweenTarget, duration: number, vars: TweenVars): Tween;
		/**
		 * **Deprecated method.** Use `gsap.to()` instead.
		 *
		 * @deprecated since 3.0.0
		 * @static
		 * @param {TweenTarget} targets
		 * @param {TweenVars} vars
		 * @returns {Tween}  Tween instance
		 * @memberof Tween
		 * @link https://greensock.com/docs/v3/GSAP/gsap.to()
		 */
		static to(targets: TweenTarget, vars: TweenVars): Tween;
		/**
		 * **Deprecated method.** Use `gsap.from()` instead.
		 *
		 * @deprecated since 3.0.0
		 * @static
		 * @param {TweenTarget} targets
		 * @param {number} duration
		 * @param {TweenVars} vars
		 * @returns {Tween} Tween instance
		 * @memberof Tween
		 * @link https://greensock.com/docs/v3/GSAP/gsap.from()
		 */
		static from(targets: TweenTarget, duration: number, vars: TweenVars): Tween;
		/**
		 * **Deprecated method.** Use `gsap.from()` instead.
		 *
		 * @deprecated since 3.0.0
		 * @static
		 * @param {TweenTarget} targets
		 * @param {TweenVars} vars
		 * @returns {Tween} Tween instance
		 * @memberof Tween
		 * @link https://greensock.com/docs/v3/GSAP/gsap.from()
		 */
		static from(targets: TweenTarget, vars: TweenVars): Tween;
		/**
		 * **Deprecated method.** Use `gsap.fromTo()` instead.
		 *
		 * @deprecated since 3.0.0
		 * @static
		 * @param {TweenTarget} targets
		 * @param {number} duration
		 * @param {TweenVars} fromVars
		 * @param {TweenVars} toVars
		 * @returns {Tween} Tween instance
		 * @memberof Tween
		 * @link https://greensock.com/docs/v3/GSAP/gsap.fromTo()
		 */
		static fromTo(targets: TweenTarget, duration: number, fromVars: TweenVars, toVars: TweenVars): Tween;
		/**
		 * **Deprecated method.** Use `gsap.fromTo()` instead.
		 *
		 * @deprecated since 3.0.0
		 * @static
		 * @param {TweenTarget} targets
		 * @param {TweenVars} fromVars
		 * @param {TweenVars} toVars
		 * @returns {Tween} Tween instance
		 * @memberof Tween
		 * @link https://greensock.com/docs/v3/GSAP/gsap.fromTo()
		 */
		static fromTo(targets: TweenTarget, fromVars: TweenVars, toVars: TweenVars): Tween;
		/**
		 * **Deprecated method.** Use `gsap.set()` instead.
		 *
		 * @deprecated since 3.0.0
		 * @static
		 * @param {TweenTarget} targets
		 * @param {TweenVars} vars
		 * @returns {Tween} Tween instance
		 * @memberof Tween
		 * @link https://greensock.com/docs/v3/GSAP/gsap.set()
		 */
		static set(targets: TweenTarget, vars: TweenVars): Tween;
		/**
		 * **Deprecated method.** Use `gsap.from()` instead.
		 *
		 * @deprecated since 3.0.0
		 * @static
		 * @param {TweenTarget} targets
		 * @param {number} duration
		 * @param {TweenVars} vars
		 * @returns {Tween} Tween instance
		 * @memberof Tween
		 * @link https://greensock.com/docs/v3/GSAP/gsap.from()
		 */
		static staggerFrom(targets: TweenTarget, duration: number, vars: TweenVars): Tween;
		/**
		 * **Deprecated method.** Use `gsap.from()` instead.
		 *
		 * @deprecated since 3.0.0
		 * @static
		 * @param {TweenTarget} targets
		 * @param {TweenVars} vars
		 * @returns {Tween} Tween instance
		 * @memberof Tween
		 * @link https://greensock.com/docs/v3/GSAP/gsap.from()
		 */
		static staggerFrom(targets: TweenTarget, vars: TweenVars): Tween;
		/**
		 * **Deprecated method.** Use `gsap.fromTo()` instead.
		 *
		 * @deprecated since 3.0.0
		 * @static
		 * @param {TweenTarget} targets
		 * @param {number} duration
		 * @param {TweenVars} vars
		 * @returns {Tween} Tween instance
		 * @memberof Tween
		 * @link https://greensock.com/docs/v3/GSAP/gsap.fromTo()
		 */
		static staggerFromTo(targets: TweenTarget, duration: number, fromVars: TweenVars, toVars: TweenVars): Tween;
		/**
		 * **Deprecated method.** Use `gsap.fromTo()` instead.
		 *
		 * @deprecated since 3.0.0
		 * @static
		 * @param {TweenTarget} targets
		 * @param {TweenVars} vars
		 * @returns {Tween} Tween instance
		 * @memberof Tween
		 * @link https://greensock.com/docs/v3/GSAP/gsap.fromTo()
		 */
		static staggerFromTo(targets: TweenTarget, fromVars: TweenVars, toVars: TweenVars): Tween;
		/**
		 * **Deprecated method.** Use `gsap.to()` instead.
		 *
		 * @deprecated since 3.0.0
		 * @static
		 * @param {TweenTarget} targets
		 * @param {number} duration
		 * @param {TweenVars} vars
		 * @returns {Tween} Tween instance
		 * @memberof Tween
		 * @link https://greensock.com/docs/v3/GSAP/gsap.to()
		 */
		static staggerTo(targets: TweenTarget, duration: number, vars: TweenVars): Tween;
		/**
		 * **Deprecated method.** Use `gsap.to()` instead.
		 *
		 * @deprecated since 3.0.0
		 * @static
		 * @param {TweenTarget} targets
		 * @param {TweenVars} vars
		 * @returns {Tween} Tween instance
		 * @memberof Tween
		 * @link https://greensock.com/docs/v3/GSAP/gsap.to()
		 */
		static staggerTo(targets: TweenTarget, vars: TweenVars): Tween;
		/**
		 * Kills the parts of the tween specified.
		 * To kill means to immediately stop the tween, remove it from its parent timeline, and release it for garbage collection.
		 *
		 * ```js
		 * // kills the entire tween
		 * tween.kill();
		 *
		 * // kill all parts of the tween related to the target "myObject" (if the tween has multiple targets, the others will not be affected):
		 * tween.kill(myObject);
		 *
		 * // kill only the "x" and "y" properties of the tween (all targets):
		 * tween.kill(null, "x,y");
		 *
		 * // kill only the "x" and "y" properties of tween of the target "myObject":
		 * tween.kill(myObject, "x,y");
		 *
		 * // kill only the "opacity" properties of the tween of the targets "myObject1" and "myObject2":
		 * tween.kill([myObject1, myObject2], "opacity");
		 * ```
		 *
		 * @returns {Tween} The tween
		 * @memberof Tween
		 * @link https://greensock.com/docs/v3/GSAP/Tween/kill()
		 */
		kill(target?: object, propertiesList?: string): this;
		/**
		 * Redirects a property [that's already being animated by the tween] to a new value and restarts the tween in a performant way.
		 * A more common technique is to use gsap.quickTo() which uses resetTo() under the hood.
		 *
		 * ```js
		 * tween.resetTo("x", 200);
		 * ```
		 *
		 * @param {string} property
		 * @param {number} value
		 * @param {number} start
		 * @param {boolean} startIsRelative
		 * @returns {Tween} The tween
		 * @memberof Tween
		 * @link https://greensock.com/docs/v3/GSAP/Tween/resetTo()
		 */
		resetTo(property: string, value: number, start?: number, startIsRelative?: boolean): this;
		/**
		 * Returns an array of all of the tween's targets.
		 *
		 * ```js
		 * tween.targets();
		 * ```
		 *
		 * @returns {T[]} The array of targets
		 * @memberof Tween
		 * @link https://greensock.com/docs/v3/GSAP/Tween/targets()
		 */
		targets<T>(): T[];
	}
}
declare namespace gsap {
	type VelocityType = 'num' | 'deg' | 'rad';
	interface VelocityMap {
		[key: string]: number;
	}
	interface VelocityTrackerInstance {
		readonly target: object;
		add(property: string, type?: VelocityType): void;
		kill(shallow?: boolean): void;
		remove(property: string): void;
		getAll(): VelocityMap;
		get(property: string): number;
	}
	interface VelocityTrackerStatic {
		getByTarget(target: TweenTarget): VelocityTrackerInstance;
		getVelocity(target: TweenTarget, property: string): number;
		isTracking(target: TweenTarget, property?: string): boolean;
		track(target: TweenTarget, properties: string, type?: VelocityType): VelocityTrackerInstance[];
		untrack(target: TweenTarget, properties?: string): void;
	}
	interface VelocityTracker extends VelocityTrackerStatic {
		new (
			target: TweenTarget,
			properties?: string,
			type?: VelocityType,
			next?: VelocityTrackerInstance
		): VelocityTrackerInstance;
		prototype: VelocityTrackerInstance;
		register(core: typeof gsap): void;
	}
}
declare namespace gsap {
	type RegisterablePlugins =
		| Ease
		| EasePack
		| ExpoScaleEase
		| Plugin
		| RoughEase
		| SteppedEase
		| VelocityTracker
		| typeof core.Animation
		| typeof core.Tween
		| typeof core.Timeline
		| typeof Draggable
		| typeof GSDevTools
		| typeof MotionPathHelper
		| typeof SplitText
		| typeof Flip
		| typeof ScrollTrigger
		| typeof Observer
		| typeof ScrollSmoother;
	// querySelector returns type Element | null
	type DOMTarget = Element | string | null | Window | ArrayLike<Element | string | Window | null>;
	type TweenTarget = string | object | null;
	type Callback = (...args: any[]) => void | null;
	type ContextFunc = (context: Context) => Function | any | void;
	type CallbackType = 'onComplete' | 'onInterrupt' | 'onRepeat' | 'onReverseComplete' | 'onStart' | 'onUpdate';
	type TickerCallback = (time: number, deltaTime: number, frame: number, elapsed: number) => void | null;
	type Point2D = {
		x: number;
		y: number;
	};
	type Position = number | string;
	type FunctionBasedValue<T> = (index: number, target: any, targets: any[]) => T;
	type ArrayValue = any[] | FunctionBasedValue<any[]>;
	type BooleanValue = boolean | FunctionBasedValue<boolean>;
	type NumberValue = number | FunctionBasedValue<number>;
	type StringValue = string | FunctionBasedValue<string>;
	type ElementValue = Element | FunctionBasedValue<Element>;
	type TweenValue = NumberValue | StringValue;
	type QuickToFunc = {
		(value: number, start?: number, startIsRelative?: boolean): core.Tween;
		tween: core.Tween;
	};
	type SVGPathValue = string | SVGPathElement;
	type SVGPathTarget = SVGPathValue | ArrayLike<SVGPathValue>;
	type SVGPrimitive =
		| SVGCircleElement
		| SVGRectElement
		| SVGEllipseElement
		| SVGPolygonElement
		| SVGPolylineElement
		| SVGLineElement;
	interface Conditions {
		[key: string]: boolean;
	}
	interface Context {
		[key: string]: Function | any;
		selector?: Function;
		isReverted: boolean;
		conditions?: Conditions;
		queries?: object;
		add(methodName: string, func: Function, scope?: Element | string | object): Function;
		add(func: Function, scope?: Element | string | object): void;
		ignore(func: Function): void;
		kill(revert?: boolean): void;
		revert(config?: object): void;
		clear(): void;
	}
	interface MatchMedia {
		contexts: Context[];
		add(conditions: string | object, func: ContextFunc, scope?: Element | string | object): MatchMedia;
		revert(config?: object): void;
		kill(revert?: boolean): void;
	}
	interface AnimationVars extends CallbackVars {
		[key: string]: any;
		data?: any;
		id?: string | number;
		inherit?: boolean;
		paused?: boolean;
		repeat?: number;
		repeatDelay?: number;
		repeatRefresh?: boolean;
		reversed?: boolean;
		yoyo?: boolean;
	}
	interface CallbackVars {
		callbackScope?: object;
		onComplete?: Callback;
		onCompleteParams?: any[];
		onRepeat?: Callback;
		onRepeatParams?: any[];
		onReverseComplete?: Callback;
		onReverseCompleteParams?: any[];
		onStart?: Callback;
		onStartParams?: any[];
		onUpdate?: Callback;
		onUpdateParams?: any[];
	}
	interface EaseMap {
		[key: string]: EaseFunction;
	}
	interface EffectsMap {
		[key: string]: any;
	}
	interface GSAPConfig {
		autoKillThreshold?: number;
		autoSleep?: number;
		force3D?: 'auto' | boolean;
		nullTargetWarn?: boolean;
		resistance?: number;
		stringFilter?: Callback; // TODO: Find out signature
		unitFactors?: {
			time?: number;
			totalTime?: number;
		};
		units?: GSAPUnits;
	}
	type GSAPUnits = {
		bottom?: string;
		fontSize?: string;
		height?: string;
		left?: string;
		lineHeight?: string;
		margin?: string;
		padding?: string;
		perspective?: string;
		right?: string;
		rotation?: string;
		rotationX?: string;
		rotationY?: string;
		skewX?: string;
		skewY?: string;
		top?: string;
		width?: string;
		x?: string;
		y?: string;
		z?: string;
	} & {
		[key: string]: string;
	};
	interface StaggerVars extends CallbackVars, utils.DistributeConfig {
		repeat?: number;
		repeatDelay?: number;
		yoyo?: boolean;
		yoyoEase?: boolean | string | EaseFunction;
	}
	interface Ticker {
		add(callback: TickerCallback, once?: boolean, prioritize?: boolean): Callback;
		fps(fps: number): void;
		frame: number;
		lagSmoothing(threshold: number | boolean, adjustedLag?: number): void;
		remove(callback: Callback): void;
		sleep(): void;
		tick(): void;
		time: number;
		deltaRatio(fps?: number): number;
		wake(): void;
	}
	interface TimelineVars extends AnimationVars {
		autoRemoveChildren?: boolean;
		defaults?: TweenVars;
		delay?: number;
		smoothChildTiming?: boolean;
	}
	interface TweenVars extends AnimationVars {
		delay?: TweenValue;
		duration?: TweenValue;
		ease?: string | EaseFunction;
		endArray?: any[];
		immediateRender?: boolean;
		lazy?: boolean;
		keyframes?: TweenVars[] | object;
		onInterrupt?: Callback;
		onInterruptParams?: any[];
		overwrite?: 'auto' | boolean;
		runBackwards?: boolean;
		stagger?: NumberValue | StaggerVars;
		startAt?: TweenVars;
		yoyoEase?: boolean | string | EaseFunction;
	}
	const effects: EffectsMap;
	const globalTimeline: core.Timeline;
	const ticker: Ticker;
	const version: string;
	/**
	 * Gets or sets GSAP's global configuration settings.
	 *
	 * Options: autoSleep, force3D, nullTargetWarn, and units
	 *
	 * ```js
	 * gsap.config({force3D: false});
	 * ```
	 *
	 * @param {GSAPConfig} [config]
	 * @returns {GSAPConfig} Configuration object
	 * @memberof gsap
	 * @link https://greensock.com/docs/v3/GSAP/gsap.config()
	 */
	function config(config?: GSAPConfig): GSAPConfig;
	/**
	 * Creates a Context object for recording/reverting any GSAP animations and/or ScrollTriggers that are in the provided function
	 *
	 * ```js
	 * let ctx = gsap.context((self) => {
	 *     gsap.to(".box", {x: 100});
	 * }, myElement);
	 *
	 * // then later
	 * ctx.revert();
	 * ```
	 *
	 * @param {ContextFunc} [func]
	 * @param {Element | string | object} [scope]
	 * @returns {Context} Context object
	 * @memberof gsap
	 * @link https://greensock.com/docs/v3/GSAP/gsap.context()
	 */
	function context(func?: ContextFunc, scope?: Element | string | object): Context;
	/**
	 * Gets or sets GSAP's global defaults. These will be inherited by every tween.
	 *
	 * ```js
	 * gsap.defaults({ease: "none", duration: 1});
	 * ```
	 *
	 * @param {TweenVars} [defaults]
	 * @returns {TweenVars} Defaults object
	 * @memberof gsap
	 * @link https://greensock.com/docs/v3/GSAP/gsap.defaults()
	 */
	function defaults(defaults?: TweenVars): TweenVars;
	/**
	 * Delays the call of a function by the specified amount.
	 *
	 * ```js
	 * let delayTween = gsap.delayedCall(1, myFunc);
	 * ```
	 *
	 * @param {number} delay
	 * @param {Function} callback
	 * @param {any[]} [params]
	 * @returns {Tween} Tween instance
	 * @memberof gsap
	 * @link https://greensock.com/docs/v3/GSAP/gsap.delayedCall()
	 */
	function delayedCall(delay: number, callback: Function, params?: any[]): core.Tween;
	/**
	 * Transfers all tweens, timelines, and (optionally) delayed calls from the root timeline into a new timeline.
	 *
	 * ```js
	 * let exportedTL = gsap.exportRoot();
	 * ```
	 *
	 * @param {TimelineVars} [vars]
	 * @param {boolean} [includeDelayedCalls]
	 * @returns {Timeline} Timeline instance
	 * @memberof gsap
	 * @link https://greensock.com/docs/v3/GSAP/gsap.exportRoot()
	 */
	function exportRoot(vars?: TimelineVars, includeDelayedCalls?: boolean): core.Timeline;
	/**
	 * Creates a tween coming FROM the given values.
	 *
	 * ```js
	 * gsap.from(".class", {x: 100});
	 * ```
	 *
	 * @param {TweenTarget} targets
	 * @param {TweenVars} vars
	 * @returns {Tween} Tween instance
	 * @memberof gsap
	 * @link https://greensock.com/docs/v3/GSAP/gsap.from()
	 */
	function from(targets: TweenTarget, vars: TweenVars): core.Tween;
	/**
	 * **Deprecated method signature.** Use the `duration` property instead.
	 *
	 * ```js
	 * gsap.from(".class", 1, {x: 100});
	 * ```
	 * @deprecated since 3.0.0
	 * @param {TweenTarget} targets
	 * @param {number} duration - The duration parameter is deprecated. Use the `duration` property instead.
	 * @param {TweenVars} vars
	 * @returns {Tween} Tween instance
	 * @memberof gsap
	 * @link https://greensock.com/docs/v3/GSAP/gsap.from()
	 */
	function from(targets: TweenTarget, duration: number, vars: TweenVars): core.Tween;
	/**
	 * Creates a tween coming FROM the first set of values going TO the second set of values.
	 *
	 * ```js
	 * gsap.fromTo(".class", {x: 0}, {x: 100});
	 * ```
	 *
	 * @param {TweenTarget} targets
	 * @param {TweenVars} fromVars
	 * @param {TweenVars} toVars
	 * @returns {Tween} Tween instance
	 * @memberof gsap
	 * @link https://greensock.com/docs/v3/GSAP/gsap.fromTo()
	 */
	function fromTo(targets: TweenTarget, fromVars: TweenVars, toVars: TweenVars): core.Tween;
	/**
	 * **Deprecated method signature.** Use the `duration` property instead.
	 *
	 * ```js
	 * gsap.fromTo(".class", 1, {x: 0}, {x: 100});
	 * ```
	 * @deprecated since version 3.0.0
	 * @param {TweenTarget} targets
	 * @param {number} duration - The duration parameter is deprecated. Use the `duration` property instead.
	 * @param {TweenVars} fromVars
	 * @param {TweenVars} toVars
	 * @returns {Tween} Tween instance
	 * @link https://greensock.com/docs/v3/GSAP/gsap.fromTo()
	 */
	function fromTo(targets: TweenTarget, duration: number, fromVars: TweenVars, toVars: TweenVars): core.Tween;
	/**
	 * Gets the tween or timeline with the specified ID if it exists.
	 *
	 * ```js
	 * gsap.to(obj, {id: "myTween", x: 100});
	 *
	 * // later
	 * let tween = gsap.getById("myTween");
	 * ```
	 *
	 * @param {string | number} id
	 * @returns {Tween} Tween instance
	 * @memberof gsap
	 * @link https://greensock.com/docs/v3/GSAP/gsap.getById()
	 */
	function getById<T extends core.Animation>(id: string | number): T;
	/**
	 * Gets the specified property of the target (or first of the targets) if it exists.
	 *
	 * ```js
	 * gsap.getProperty(element, "x");
	 * ```
	 *
	 * @param {TweenTarget} target
	 * @param {string} property
	 * @param {string} [unit]
	 * @returns {string | number} Value
	 * @memberof gsap
	 * @link https://greensock.com/docs/v3/GSAP/gsap.getProperty()
	 */
	function getProperty(target: TweenTarget, property: string, unit?: string): string | number;
	function getProperty(target: TweenTarget): (property: string, unit?: string) => string | number;
	/**
	 * Gets all of the tweens whose targets include the specified target or group of targets.
	 *
	 * ```js
	 * gsap.getTweensOf(element);
	 * ```
	 *
	 * @param {TweenTarget} targets
	 * @param {boolean} [onlyActive]
	 * @returns {Tween} Tween instance
	 * @memberof gsap
	 * @link https://greensock.com/docs/v3/GSAP/gsap.getTweensOf()
	 */
	function getTweensOf(targets: TweenTarget, onlyActive?: boolean): core.Tween[];
	/**
	 * Used to add all the GSAP globals to a particular tween object.
	 *
	 * ```js
	 * gsap.install(myTween);
	 * ```
	 *
	 * @param {object} targets
	 * @returns {gsap} The gsap object
	 * @memberof gsap
	 */
	function install(targets: object): typeof gsap;
	/**
	 * Reports whether or not a particular object is actively animating.
	 *
	 * ```js
	 * gsap.isTweening("#id");
	 * ```
	 *
	 * @param {TweenTarget} targets
	 * @returns {boolean} Status
	 * @memberof gsap
	 * @link https://greensock.com/docs/v3/GSAP/gsap.isTweening()
	 */
	function isTweening(targets: TweenTarget): boolean;
	/**
	 * Kills all the tweens (or specific tweening properties) of a particular object or the delayedCalls to a particular function.
	 *
	 * ```js
	 * gsap.killTweensOf(".myClass");
	 * gsap.killTweensOf(myObject, "opacity,x");
	 * ```
	 *
	 * @param {TweenTarget} targets
	 * @param {object | string} [properties]
	 * @param {boolean} [onlyActive]
	 * @returns {void} Void
	 * @memberof gsap
	 * @link https://greensock.com/docs/v3/GSAP/gsap.killTweensOf()
	 */
	function killTweensOf(targets: TweenTarget, properties?: object | string, onlyActive?: boolean): void;
	/**
	 * Creates a MatchMedia object for adding functions that run when a media query matches
	 *
	 * ```js
	 * let mm = gsap.matchMedia(myElement);
	 * mm.add("(max-width: 500px)", (context) => {
	 *     gsap.to(".box", {x: 100});
	 * });
	 * ```
	 *
	 * @param {Element | string | object} [scope]
	 * @returns {MatchMedia} MatchMedia object
	 * @memberof gsap
	 * @link https://greensock.com/docs/v3/GSAP/gsap.matchMedia()
	 */
	function matchMedia(scope?: Element | string | object): MatchMedia;
	/**
	 * Immediately reverts all active/matching MatchMedia objects and then runs any that currently match.
	 *
	 * ```js
	 * gsap.matchMediaRefresh();
	 * ```
	 *
	 * @memberof gsap
	 * @link https://greensock.com/docs/v3/GSAP/gsap.matchMediaRefresh()
	 */
	function matchMediaRefresh(): void;
	/**
	 * Returns the corresponding easing function for the given easing string.
	 *
	 * ```js
	 * let ease = gsap.parseEase("power1");
	 * ```
	 *
	 * @param {string | EaseFunction} ease
	 * @returns {EaseFunction} Ease function
	 * @memberof gsap
	 * @link https://greensock.com/docs/v3/GSAP/gsap.parseEase()
	 */
	function parseEase(ease: string | EaseFunction): EaseFunction;
	function parseEase(): EaseMap;
	/**
	 * Returns a function that acts as a simpler alternative of gsap.set() that is more performant but less versatile.
	 *
	 * ```js
	 * let setX = gsap.quickSetter("#id", "x", "px");
	 *
	 * // later
	 * setX(100);
	 * ```
	 *
	 * @param {TweenTarget} targets
	 * @param {string} property
	 * @param {string} [unit]
	 * @returns {Function} Setter function
	 * @memberof gsap
	 * @link https://greensock.com/docs/v3/GSAP/gsap.quickSetter()
	 */
	function quickSetter(targets: TweenTarget, property: string, unit?: string): Function;
	/**
	 * Returns a reusable function that performantly redirects a specific property to a new value, restarting the animation each time you feed in a new number.
	 *
	 * ```js
	 * let xTo = gsap.quickTo("#id", "x", {duration: 0.8, ease: "power3"});
	 *
	 * // later
	 * xTo(100);
	 * ```
	 *
	 * @param {TweenTarget} target
	 * @param {string} property
	 * @param {TweenVars} vars
	 * @returns {QuickToFunc} Setter function
	 * @memberof gsap
	 * @link https://greensock.com/docs/v3/GSAP/gsap.quickTo()
	 */
	function quickTo(target: TweenTarget, property: string, vars?: TweenVars): QuickToFunc;
	/**
	 * Register custom easing functions with GSAP, giving it a name so it can be referenced in any tweens.
	 *
	 * ```js
	 * gsap.registerEase("myEaseName", function(progress) {
	 *   return progress; //linear
	 * });
	 * ```
	 *
	 * @param {string} name
	 * @param {EaseFunction} ease
	 * @memberof gsap
	 * @link https://greensock.com/docs/v3/GSAP/gsap.registerEase()
	 */
	function registerEase(name: string, ease: EaseFunction): void;
	// TODO: Create interface for effect
	/**
	 * Registers custom effects (named tweens) for reuse with optional arguments.
	 *
	 * ```js
	 * // register the effect with GSAP:
	 * gsap.registerEffect({
	 *   name: "fade",
	 *   effect: (targets, config) => {
	 *     return gsap.to(targets, {duration: config.duration, opacity: 0});
	 *   },
	 *   defaults: {duration: 2}, //defaults get applied to any "config" object passed to the effect
	 *   extendTimeline: true, //now you can call the effect directly on any GSAP timeline to have the result immediately inserted in the position you define (default is sequenced at the end)
	 * });
	 *
	 * // now we can use it like this:
	 * gsap.effects.fade(".box");
	 * // or
	 * tl.fade(".box", {duration: 3})
	 * ```
	 *
	 * @param {object} effect
	 * @memberof gsap
	 * @link https://greensock.com/docs/v3/GSAP/gsap.registerEffect()
	 */
	function registerEffect(effect: object): void;
	/**
	 * Installs the specified GSAP plugins, provided they have been loaded already.
	 *
	 * ```js
	 * gsap.registerPlugin(MorphSVPlugin, MotionPathPlugin);
	 * ```
	 *
	 * @param {RegisterablePlugins[]} args
	 * @memberof gsap
	 * @link https://greensock.com/docs/v3/GSAP/gsap.registerPlugin()
	 */
	function registerPlugin(...args: object[]): void;
	/**
	 * Immediately sets properties of the target(s) to the properties specified.
	 *
	 * ```js
	 * gsap.set(".class", {x: 100, y: 50, opacity: 0});
	 * ```
	 *
	 * @param {TweenTarget} targets
	 * @param {TweenVars} vars
	 * @returns {Tween} Tween instance
	 * @memberof gsap
	 * @link https://greensock.com/docs/v3/GSAP/gsap.set()
	 */
	function set(targets: TweenTarget, vars: TweenVars): core.Tween;
	/**
	 * Creates a new timeline, used to compose sequences of tweens.
	 *
	 * @param {TimelineVars} [vars]
	 * @returns {Timeline} Timeline instance
	 * @memberof gsap
	 * @link https://greensock.com/docs/v3/GSAP/gsap.timeline()
	 */
	function timeline(vars?: TimelineVars): core.Timeline;
	/**
	 * Creates a tween going TO the given values.
	 *
	 * ```js
	 * gsap.to(".class", {x: 100});
	 * ```
	 *
	 * @param {TweenTarget} targets
	 * @param {TweenVars} vars
	 * @returns {Tween} Tween instance
	 * @memberof gsap
	 * @link https://greensock.com/docs/v3/GSAP/gsap.to()
	 */
	function to(targets: TweenTarget, vars: TweenVars): core.Tween;
	/**
	 * **Deprecated method signature.** Use the `duration` property instead.
	 *
	 * ```js
	 * gsap.to(".class", 1, {x: 100});
	 * ```
	 * @deprecated since version 3.0.0
	 * @param {TweenTarget} targets
	 * @param {number} duration - The duration parameter is deprecated. Use the `duration` property instead.
	 * @param {TweenVars} vars
	 * @returns {Tween} Tween instance
	 * @memberof gsap
	 * @link https://greensock.com/docs/v3/GSAP/gsap.to()
	 */
	function to(targets: TweenTarget, duration: number, vars: TweenVars): core.Tween;
	/**
	 * Manually update the root (global) timeline. Make sure to unhook GSAP's default ticker.
	 *
	 * ```js
	 * // unhooks the GSAP ticker
	 * gsap.ticker.remove(gsap.updateRoot);
	 *
	 * // sets the root time to 20 seconds manually
	 * gsap.updateRoot(20);
	 * ```
	 *
	 * @param {number} number
	 * @returns {void} Void
	 * @memberof gsap
	 * @link https://greensock.com/docs/v3/GSAP/gsap.updateRoot()
	 */
	function updateRoot(time: number): void;
}
export declare type GsapCoreTimeline = gsap.core.Timeline;
export interface RampPointJson {
	position: number;
	value: number;
}
export interface RampValueJson {
	points: RampPointJson[];
	interpolation: RampInterpolation;
}
declare class RampPoint {
	private _position;
	private _value;
	constructor(_position?: number, _value?: number);
	toJSON(): RampPointJson;
	position(): number;
	value(): number;
	copy(point: RampPoint): void;
	clone(): RampPoint;
	isEqual(other_point: RampPoint): boolean;
	isEqualJSON(json: RampPointJson): boolean;
	fromJSON(json: RampPointJson): void;
	static areEqualJSON(json1: RampPointJson, json2: RampPointJson): boolean;
	static fromJSON(json: RampPointJson): RampPoint;
}
declare enum RampInterpolation {
	CUBIC = 'cubic',
}
declare class RampValue {
	private _interpolation;
	private _points;
	private _uuid;
	constructor(_interpolation?: RampInterpolation, _points?: RampPoint[]);
	uuid(): string;
	interpolation(): RampInterpolation;
	points(): RampPoint[];
	static createInterpolantFromValues(positions: Float32Array, values: Float32Array): CubicInterpolant;
	createInterpolant(): CubicInterpolant;
	static createInterpolant(rampValue: RampValue): CubicInterpolant;
	static fromJSON(json: RampValueJson): RampValue;
	toJSON(): RampValueJson;
	clone(): RampValue;
	copy(ramp: RampValue): void;
	isEqual(other_ramp_value: RampValue): boolean;
	isEqualJSON(json: RampValueJson): boolean;
	static are_json_equal(json1: RampValueJson, json2: RampValueJson): boolean;
	fromJSON(json: RampValueJson): void;
}
export declare type ParamInitValuesTypeMapGeneric = {
	[key in ParamType]: any;
};
export interface ParamInitValuesTypeMap extends ParamInitValuesTypeMapGeneric {
	[ParamType.BOOLEAN]: number | boolean | string;
	[ParamType.BUTTON]: null;
	[ParamType.COLOR]: StringOrNumber3 | Color;
	[ParamType.FLOAT]: StringOrNumber;
	[ParamType.FOLDER]: null;
	[ParamType.INTEGER]: StringOrNumber;
	[ParamType.PARAM_PATH]: string;
	[ParamType.NODE_PATH]: string;
	[ParamType.RAMP]: RampValue | RampValueJson;
	[ParamType.STRING]: string;
	[ParamType.VECTOR2]: StringOrNumber2 | Vector2;
	[ParamType.VECTOR3]: StringOrNumber3 | Vector3;
	[ParamType.VECTOR4]: StringOrNumber4 | Vector4;
}
declare abstract class TypedNumericParam<T extends ParamType> extends TypedParam<T> {
	isNumeric(): boolean;
	isDefault(): boolean;
	protected _prefilterInvalidRawInput(raw_input: any): ParamInitValuesTypeMap[T];
	protected processRawInput(): void;
	protected processComputation(): Promise<void>;
	private _updateValue;
}
declare class NodeBaseState<NC extends NodeContext> {
	protected node: TypedNode<NC, any>;
	constructor(node: TypedNode<NC, any>);
}
declare class NodeErrorState<NC extends NodeContext> extends NodeBaseState<NC> {
	private _message;
	set(message: string | undefined): void;
	message(): string | undefined;
	clear(): void;
	active(): boolean;
	protected onUpdate(): void;
}
declare class ParamErrorState {
	private param;
	private _message;
	constructor(param: BaseParamType);
	set(message: string | undefined): void;
	message(): string | undefined;
	clear(): void;
	active(): boolean;
}
declare class BooleanParam extends TypedNumericParam<ParamType.BOOLEAN> {
	static type(): ParamType;
	defaultValueSerialized(): string | boolean;
	rawInputSerialized(): string | number | boolean;
	valueSerialized(): boolean;
	protected _copyValue(param: BooleanParam): void;
	static areRawInputEqual(
		raw_input1: ParamInitValuesTypeMap[ParamType.BOOLEAN],
		raw_input2: ParamInitValuesTypeMap[ParamType.BOOLEAN]
	): boolean;
	static areValuesEqual(
		val1: ParamValuesTypeMap[ParamType.BOOLEAN],
		val2: ParamValuesTypeMap[ParamType.BOOLEAN]
	): boolean;
	convert(raw_val: ParamInitValuesTypeMap[ParamType.BOOLEAN]): boolean | null;
}
declare class ButtonParam extends TypedParam<ParamType.BUTTON> {
	static type(): ParamType;
	defaultValueSerialized(): null;
	rawInputSerialized(): null;
	valueSerialized(): null;
	protected _copyValue(param: ButtonParam): void;
	static areRawInputEqual(
		raw_input1: ParamInitValuesTypeMap[ParamType.BUTTON],
		raw_input2: ParamInitValuesTypeMap[ParamType.BUTTON]
	): boolean;
	static areValuesEqual(
		val1: ParamValuesTypeMap[ParamType.BUTTON],
		val2: ParamValuesTypeMap[ParamType.BUTTON]
	): boolean;
	pressButton(): Promise<void>;
}
declare class FolderParam extends TypedParam<ParamType.FOLDER> {
	static type(): ParamType;
	defaultValueSerialized(): null;
	rawInputSerialized(): null;
	valueSerialized(): null;
	protected _copyValue(param: FolderParam): void;
	static areRawInputEqual(
		raw_input1: ParamInitValuesTypeMap[ParamType.FOLDER],
		raw_input2: ParamInitValuesTypeMap[ParamType.FOLDER]
	): boolean;
	static areValuesEqual(
		val1: ParamValuesTypeMap[ParamType.FOLDER],
		val2: ParamValuesTypeMap[ParamType.FOLDER]
	): boolean;
}
declare class IntegerParam extends TypedNumericParam<ParamType.INTEGER> {
	static type(): ParamType;
	defaultValueSerialized(): StringOrNumber;
	rawInputSerialized(): StringOrNumber;
	valueSerialized(): number;
	protected _copyValue(param: IntegerParam): void;
	protected _prefilterInvalidRawInput(raw_input: any): ParamInitValuesTypeMap[ParamType.INTEGER];
	static areRawInputEqual(
		raw_input1: ParamInitValuesTypeMap[ParamType.INTEGER],
		raw_input2: ParamInitValuesTypeMap[ParamType.INTEGER]
	): boolean;
	static areValuesEqual(
		val1: ParamValuesTypeMap[ParamType.INTEGER],
		val2: ParamValuesTypeMap[ParamType.INTEGER]
	): boolean;
	static convert(raw_val: ParamInitValuesTypeMap[ParamType.INTEGER]): number | null;
	convert(raw_val: ParamInitValuesTypeMap[ParamType.INTEGER]): number | null;
}
declare abstract class TypedStringParam<
	T extends ParamType.STRING | ParamType.NODE_PATH | ParamType.PARAM_PATH
> extends TypedParam<T> {
	protected abstract _assignValue(value: ParamValuesTypeMap[T] | string): void;
	expressionParsedAsString(): boolean;
	protected processRawInput(): void;
	protected abstract processRawInputWithoutExpression(): void;
	protected processComputation(): Promise<void>;
}
declare abstract class TypedPathParam<
	T extends ParamType.NODE_PATH | ParamType.PARAM_PATH
> extends TypedStringParam<T> {
	readonly decomposedPath: DecomposedPath;
	dispose(): void;
	abstract notifyPathRebuildRequired(node: BaseNodeType | BaseParamType): void;
	abstract notifyTargetParamOwnerParamsUpdated(node: BaseNodeType | BaseParamType): void;
	protected abstract _findTarget(): void;
	protected _handleReferences(node: BaseNodeType | BaseParamType | null, path: string): void;
	protected processComputation(): Promise<void>;
	protected processRawInputWithoutExpression(): void;
	protected _setValuePathAndFindTarget(path: string, setDirty: boolean): void;
}
declare class ParamPathParam extends TypedPathParam<ParamType.PARAM_PATH> {
	static type(): ParamType;
	protected _initializeParam(): void;
	defaultValueSerialized(): string;
	rawInputSerialized(): string;
	valueSerialized(): string;
	protected _copyValue(param: ParamPathParam): void;
	static areRawInputEqual(
		raw_input1: ParamInitValuesTypeMap[ParamType.PARAM_PATH],
		raw_input2: ParamInitValuesTypeMap[ParamType.PARAM_PATH]
	): boolean;
	static areValuesEqual(
		val1: ParamValuesTypeMap[ParamType.PARAM_PATH],
		val2: ParamValuesTypeMap[ParamType.PARAM_PATH]
	): boolean;
	isDefault(): boolean;
	setParam(param: BaseParamType): void;
	protected _assignValue(value: ParamValuesTypeMap[ParamType.PARAM_PATH] | string): void;
	convert(rawVal: any): ParamValuesTypeMap[ParamType.PARAM_PATH] | null;
	protected _findTarget(): void;
	private _assignFoundParam;
	notifyPathRebuildRequired(param: BaseParamType): void;
	notifyTargetParamOwnerParamsUpdated(node: BaseNodeType): void;
	private _onResolvedParamDisposeBound;
	private _onResolvedParamDispose;
}
export interface SetNodeOptions {
	relative: boolean;
}
declare class NodePathParam extends TypedPathParam<ParamType.NODE_PATH> {
	static type(): ParamType;
	protected _initializeParam(): void;
	defaultValueSerialized(): string;
	rawInputSerialized(): string;
	valueSerialized(): string;
	protected _copyValue(param: NodePathParam): void;
	static areRawInputEqual(
		raw_input1: ParamInitValuesTypeMap[ParamType.NODE_PATH],
		raw_input2: ParamInitValuesTypeMap[ParamType.NODE_PATH]
	): boolean;
	static areValuesEqual(
		val1: ParamValuesTypeMap[ParamType.NODE_PATH],
		val2: ParamValuesTypeMap[ParamType.NODE_PATH]
	): boolean;
	isDefault(): boolean;
	setNode(node: BaseNodeType, options?: SetNodeOptions): void;
	protected _assignValue(value: ParamValuesTypeMap[ParamType.NODE_PATH] | string): void;
	convert(rawVal: any): ParamValuesTypeMap[ParamType.NODE_PATH] | null;
	protected _findTarget(): void;
	private _assignFoundNode;
	private _expectedContext;
	private _isNodeExpectedContext;
	private _expectedNodeTypes;
	private _isNodeExpectedType;
	notifyPathRebuildRequired(node: BaseNodeType): void;
	notifyTargetParamOwnerParamsUpdated(node: BaseNodeType): void;
}
declare class RampParam extends TypedParam<ParamType.RAMP> {
	static type(): ParamType;
	private _rampInterpolant;
	private _textureData;
	private _rampTexture;
	static DEFAULT_VALUE: RampValue;
	static DEFAULT_VALUE_JSON: RampValueJson;
	defaultValueSerialized(): RampValueJson;
	protected _cloneRawInput(raw_input: ParamInitValuesTypeMap[ParamType.RAMP]): RampValueJson | RampValue;
	rawInputSerialized(): RampValueJson;
	valueSerialized(): RampValueJson;
	protected _copyValue(param: RampParam): void;
	static areRawInputEqual(
		raw_input1: ParamInitValuesTypeMap[ParamType.RAMP],
		raw_input2: ParamInitValuesTypeMap[ParamType.RAMP]
	): boolean;
	static areValuesEqual(val1: ParamValuesTypeMap[ParamType.RAMP], val2: ParamValuesTypeMap[ParamType.RAMP]): boolean;
	isDefault(): boolean;
	protected processRawInput(): void;
	hasExpression(): boolean;
	private _resetRampInterpolant;
	rampTexture(): DataTexture;
	private _updateRampTexture;
	private _updateRampTextureData;
	interpolant(): CubicInterpolant;
	private _createInterpolant;
	valueAtPosition(position: number): number;
}
declare class StringParam extends TypedStringParam<ParamType.STRING> {
	static type(): ParamType;
	defaultValueSerialized(): string;
	protected _cloneRawInput(raw_input: ParamInitValuesTypeMap[ParamType.STRING]): string;
	rawInputSerialized(): string;
	valueSerialized(): string;
	protected _copyValue(param: StringParam): void;
	static areRawInputEqual(
		raw_input1: ParamInitValuesTypeMap[ParamType.STRING],
		raw_input2: ParamInitValuesTypeMap[ParamType.STRING]
	): boolean;
	static areValuesEqual(
		val1: ParamValuesTypeMap[ParamType.STRING],
		val2: ParamValuesTypeMap[ParamType.STRING]
	): boolean;
	isDefault(): boolean;
	convert(rawVal: any): string;
	rawInput(): string;
	protected _assignValue(value: string): void;
	protected processRawInputWithoutExpression(): Promise<void>;
}
declare class Vector2Param extends TypedMultipleParam<ParamType.VECTOR2> {
	protected _value: Vector2;
	x: FloatParam;
	y: FloatParam;
	static type(): ParamType;
	componentNames(): Readonly<string[]>;
	defaultValueSerialized(): StringOrNumber2;
	_prefilterInvalidRawInput(rawInput: any): StringOrNumber2 | Vector2;
	valueSerialized(): Number2;
	private _copied_value;
	protected _copyValue(param: Vector2Param): void;
	protected _cloneRawInput(raw_input: ParamInitValuesTypeMap[ParamType.VECTOR2]): StringOrNumber2 | Vector2;
	static areRawInputEqual(
		raw_input1: ParamInitValuesTypeMap[ParamType.VECTOR2],
		raw_input2: ParamInitValuesTypeMap[ParamType.VECTOR2]
	): boolean;
	static areValuesEqual(
		val1: ParamValuesTypeMap[ParamType.VECTOR2],
		val2: ParamValuesTypeMap[ParamType.VECTOR2]
	): boolean;
	initComponents(): void;
	setValueFromComponents(): void;
}
declare class Vector3Param extends TypedMultipleParam<ParamType.VECTOR3> {
	protected _value: Vector3;
	x: FloatParam;
	y: FloatParam;
	z: FloatParam;
	static type(): ParamType;
	componentNames(): Readonly<string[]>;
	defaultValueSerialized(): StringOrNumber3;
	_prefilterInvalidRawInput(rawInput: any): StringOrNumber3 | Vector3;
	valueSerialized(): Number3;
	private _copied_value;
	protected _copyValue(param: Vector3Param): void;
	protected _cloneRawInput(raw_input: ParamInitValuesTypeMap[ParamType.VECTOR3]): StringOrNumber3 | Vector3;
	static areRawInputEqual(
		raw_input1: ParamInitValuesTypeMap[ParamType.VECTOR3],
		raw_input2: ParamInitValuesTypeMap[ParamType.VECTOR3]
	): boolean;
	static areValuesEqual(
		val1: ParamValuesTypeMap[ParamType.VECTOR3],
		val2: ParamValuesTypeMap[ParamType.VECTOR3]
	): boolean;
	initComponents(): void;
	setValueFromComponents(): void;
}
declare class Vector4Param extends TypedMultipleParam<ParamType.VECTOR4> {
	protected _value: Vector4;
	x: FloatParam;
	y: FloatParam;
	z: FloatParam;
	w: FloatParam;
	static type(): ParamType;
	componentNames(): Readonly<string[]>;
	defaultValueSerialized(): StringOrNumber4;
	_prefilterInvalidRawInput(rawInput: any): StringOrNumber4 | Vector4;
	valueSerialized(): Number4;
	private _copied_value;
	protected _copyValue(param: Vector4Param): void;
	protected _cloneRawInput(raw_input: ParamInitValuesTypeMap[ParamType.VECTOR4]): StringOrNumber4 | Vector4;
	static areRawInputEqual(
		raw_input1: ParamInitValuesTypeMap[ParamType.VECTOR4],
		raw_input2: ParamInitValuesTypeMap[ParamType.VECTOR4]
	): boolean;
	static areValuesEqual(
		val1: ParamValuesTypeMap[ParamType.VECTOR4],
		val2: ParamValuesTypeMap[ParamType.VECTOR4]
	): boolean;
	initComponents(): void;
	setValueFromComponents(): void;
}
export declare type ParamConstructorMapType = {
	[key in ParamType]: TypedParam<ParamType>;
};
export interface ParamConstructorMap extends ParamConstructorMapType {
	[ParamType.BOOLEAN]: BooleanParam;
	[ParamType.BUTTON]: ButtonParam;
	[ParamType.COLOR]: ColorParam;
	[ParamType.FLOAT]: FloatParam;
	[ParamType.FOLDER]: FolderParam;
	[ParamType.INTEGER]: IntegerParam;
	[ParamType.PARAM_PATH]: ParamPathParam;
	[ParamType.NODE_PATH]: NodePathParam;
	[ParamType.RAMP]: RampParam;
	[ParamType.STRING]: StringParam;
	[ParamType.VECTOR2]: Vector2Param;
	[ParamType.VECTOR3]: Vector3Param;
	[ParamType.VECTOR4]: Vector4Param;
}
declare abstract class GraphNodePathParamValue<T extends CoreGraphNode> {
	protected _path: string;
	protected _graphNode: T | null;
	constructor(_path?: string);
	graphNode(): T | null;
	private _setGraphNode;
	abstract graphNodePath(): string | undefined;
	path(): string;
	setPath(path: string): void;
	clone(): this;
}
declare class TypedNodePathParamValue extends GraphNodePathParamValue<BaseNodeType> {
	setNode(node: BaseNodeType | null): void;
	node(): BaseNodeType | null;
	graphNodePath(): string | undefined;
	resolve(nodeStart: BaseNodeType): void;
	nodeWithContext<N extends NodeContext, K extends NodeContext>(
		context: N,
		errorState?: NodeErrorState<K>
	): BaseNodeByContextMap[N] | undefined;
}
declare class TypedParamPathParamValue extends GraphNodePathParamValue<BaseParamType> {
	setParam(param: BaseParamType | null): void;
	param(): BaseParamType | null;
	graphNodePath(): string | undefined;
	resolve(nodeStart: BaseNodeType): void;
	paramWithType<T extends ParamType>(paramType: T, error_state?: ParamErrorState): ParamConstructorMap[T] | undefined;
}
export declare type ParamValuesTypeMapGeneric = {
	[key in ParamType]: any;
};
export interface ParamValuesTypeMap extends ParamValuesTypeMapGeneric {
	[ParamType.BOOLEAN]: boolean;
	[ParamType.BUTTON]: null;
	[ParamType.COLOR]: Color;
	[ParamType.FLOAT]: number;
	[ParamType.FOLDER]: null;
	[ParamType.INTEGER]: number;
	[ParamType.PARAM_PATH]: TypedParamPathParamValue;
	[ParamType.NODE_PATH]: TypedNodePathParamValue;
	[ParamType.RAMP]: RampValue;
	[ParamType.STRING]: string;
	[ParamType.VECTOR2]: Vector2;
	[ParamType.VECTOR3]: Vector3;
	[ParamType.VECTOR4]: Vector4;
}
declare class FloatParam extends TypedNumericParam<ParamType.FLOAT> {
	static type(): ParamType;
	defaultValueSerialized(): StringOrNumber;
	rawInputSerialized(): StringOrNumber;
	valueSerialized(): number;
	protected _copyValue(param: FloatParam): void;
	protected _prefilterInvalidRawInput(raw_input: any): ParamInitValuesTypeMap[ParamType.INTEGER];
	static areRawInputEqual(
		raw_input1: ParamInitValuesTypeMap[ParamType.FLOAT],
		raw_input2: ParamInitValuesTypeMap[ParamType.FLOAT]
	): boolean;
	static areValuesEqual(
		val1: ParamValuesTypeMap[ParamType.FLOAT],
		val2: ParamValuesTypeMap[ParamType.FLOAT]
	): boolean;
	static convert(raw_val: ParamInitValuesTypeMap[ParamType.FLOAT]): number | null;
	convert(raw_val: ParamInitValuesTypeMap[ParamType.FLOAT]): number | null;
}
export interface ParamInitValueSerializedTypeMap {
	[ParamType.BOOLEAN]: ParamInitValuesTypeMap[ParamType.BOOLEAN];
	[ParamType.BUTTON]: ParamInitValuesTypeMap[ParamType.BUTTON];
	[ParamType.COLOR]: StringOrNumber3;
	[ParamType.FLOAT]: ParamInitValuesTypeMap[ParamType.FLOAT];
	[ParamType.FOLDER]: ParamInitValuesTypeMap[ParamType.FOLDER];
	[ParamType.INTEGER]: ParamInitValuesTypeMap[ParamType.INTEGER];
	[ParamType.NODE_PATH]: ParamInitValuesTypeMap[ParamType.NODE_PATH];
	[ParamType.PARAM_PATH]: ParamInitValuesTypeMap[ParamType.PARAM_PATH];
	[ParamType.RAMP]: RampValueJson;
	[ParamType.STRING]: ParamInitValuesTypeMap[ParamType.STRING];
	[ParamType.VECTOR2]: StringOrNumber2;
	[ParamType.VECTOR3]: StringOrNumber3;
	[ParamType.VECTOR4]: StringOrNumber4;
}
declare abstract class TypedMultipleParam<T extends ParamType> extends TypedParam<T> {
	private _components_contructor;
	protected _components: FloatParam[];
	get components(): FloatParam[];
	isNumeric(): boolean;
	isDefault(): boolean;
	rawInput(): ParamInitValueSerializedTypeMap[T];
	rawInputSerialized(): ParamInitValueSerializedTypeMap[T];
	protected _copyValue(param: TypedMultipleParam<T>): void;
	initComponents(): void;
	protected processComputation(): Promise<void>;
	abstract setValueFromComponents(): void;
	hasExpression(): boolean;
	private compute_components;
	protected _prefilterInvalidRawInput(raw_input: any): ParamInitValuesTypeMap[T];
	protected processRawInput(): void;
}
declare enum ColorConversion {
	NONE = 'no conversion',
	SRGB_TO_LINEAR = 'sRGB -> linear',
	LINEAR_TO_SRGB = 'linear -> sRGB',
}
declare class ColorParam extends TypedMultipleParam<ParamType.COLOR> {
	protected _value: Color;
	private _valuePreConversion;
	private _valueSerializedDirty;
	private _valueSerialized;
	private _valuePreConversionSerialized;
	r: FloatParam;
	g: FloatParam;
	b: FloatParam;
	static type(): ParamType;
	componentNames(): Readonly<string[]>;
	defaultValueSerialized(): StringOrNumber3;
	_prefilterInvalidRawInput(rawInput: any): StringOrNumber3 | Color;
	valueSerialized(): Number3;
	valuePreConversionSerialized(): Number3;
	private _copiedValue;
	protected _copyValue(param: ColorParam): void;
	protected _cloneRawInput(raw_input: ParamInitValuesTypeMap[ParamType.COLOR]): StringOrNumber3 | Color;
	static areRawInputEqual(
		raw_input1: ParamInitValuesTypeMap[ParamType.COLOR],
		raw_input2: ParamInitValuesTypeMap[ParamType.COLOR]
	): boolean;
	static areValuesEqual(
		val1: ParamValuesTypeMap[ParamType.COLOR],
		val2: ParamValuesTypeMap[ParamType.COLOR]
	): boolean;
	initComponents(): void;
	postOptionsInitialize(): void;
	private _updateValueSerializedIfRequired;
	valuePreConversion(): Color;
	setConversion(conversion: ColorConversion): Promise<void>;
	setValueFromComponents(): void;
	private _applyColorConversion;
}
export interface PropertyTargetOptions {
	node?: {
		path: string;
		relativeTo: BaseNodeType;
	};
	object?: {
		list?: Object3D[];
		mask?: string;
	};
}
declare class AnimPropertyTarget {
	private _scene;
	private _options;
	constructor(_scene: PolyScene, _options: PropertyTargetOptions);
	clone(): AnimPropertyTarget;
	objects(): Object3D<Event>[] | undefined;
	node(): BaseNodeType | null | undefined;
}
export interface RegisterOptions {
	registerproperties?: boolean;
	propertyTarget?: AnimPropertyTarget;
}
export interface AddToTimelineOptions extends RegisterOptions {
	timelineBuilder: TimelineBuilder;
	timeline: GsapCoreTimeline;
	target: AnimPropertyTarget;
}
declare enum Operation {
	SET = 'set',
	ADD = 'add',
	SUBTRACT = 'subtract',
}
export interface AnimationRepeatParams {
	count: number;
	delay: number;
	yoyo: boolean;
}
export declare type AnimPropertyTargetValue = number | Vector2 | Vector3 | Color | Vector4 | Quaternion;
declare class TimelineBuilderProperty {
	private _propertyName;
	private _targetValue;
	constructor();
	setName(name: string): void;
	setTargetValue(value: AnimPropertyTargetValue): void;
	name(): string | undefined;
	targetValue(): AnimPropertyTargetValue | undefined;
	private _debug;
	setDebug(debug: boolean): void;
	private _printDebug;
	clone(): TimelineBuilderProperty;
	addToTimeline(options: AddToTimelineOptions): void;
	private _populateWithObjects;
	private _populateVarsForObjectProperty;
	private _sceneGraphProps;
	private _populateWithNode;
	private _populateVarsForParam;
}
declare enum AnimationPositionMode {
	RELATIVE = 'relative',
	ABSOLUTE = 'absolute',
}
declare enum AnimationPositionRelativeTo {
	START = 'start',
	END = 'end',
}
declare class AnimationPosition {
	private _mode;
	private _relativeTo;
	private _offset;
	clone(): AnimationPosition;
	setMode(mode: AnimationPositionMode): void;
	mode(): AnimationPositionMode;
	setRelativeTo(relative_to: AnimationPositionRelativeTo): void;
	relativeTo(): AnimationPositionRelativeTo;
	setOffset(offset: number): void;
	offset(): number;
	toParameter(): string | number;
	private _relative_position_param;
	private _absolutePositionParam;
	private _offsetString;
}
declare class AnimationUpdateCallback {
	private _update_matrix;
	clone(): AnimationUpdateCallback;
	setUpdateMatrix(update_matrix: boolean): void;
	updateMatrix(): boolean;
}
declare class TimelineBuilder {
	private _timelineBuilders;
	private _parent;
	private _target;
	private _duration;
	private _keyframes;
	private _easing;
	private _operation;
	private _repeatParams;
	private _delay;
	private _position;
	private _property;
	private _updateCallback;
	private _stoppable;
	private _debug;
	setDebug(debug: boolean): void;
	private _printDebug;
	addTimelineBuilder(timeline_builder: TimelineBuilder): void;
	timelineBuilders(): TimelineBuilder[];
	setParent(parent: TimelineBuilder): void;
	parent(): TimelineBuilder | undefined;
	setTarget(target: AnimPropertyTarget): void;
	target(): AnimPropertyTarget | undefined;
	setDuration(duration: number): void;
	duration(): number;
	setKeyframes(keyframes: RampValue): void;
	keyframes(): RampValue | undefined;
	setEasing(easing: string): void;
	easing(): string | undefined;
	setOperation(operation: Operation): void;
	operation(): Operation;
	setRepeatParams(repeat_params: AnimationRepeatParams): void;
	repeatParams(): AnimationRepeatParams | undefined;
	setDelay(delay: number): void;
	delay(): number;
	setPosition(position: AnimationPosition | undefined): void;
	position(): AnimationPosition | undefined;
	setStoppable(state: boolean): void;
	stoppable(): boolean;
	setUpdateCallback(update_callback: AnimationUpdateCallback): void;
	updateCallback(): AnimationUpdateCallback | undefined;
	clone(): TimelineBuilder;
	setPropertyName(name: string): void;
	property(): TimelineBuilderProperty;
	propertyName(): string | undefined;
	setPropertyValue(value: AnimPropertyTargetValue): void;
	propertyValue(): AnimPropertyTargetValue | undefined;
	populate(timeline: GsapCoreTimeline, options: RegisterOptions): void;
}
export declare type SourceType = Source<any> | UserMedia;
export declare type InstrumentType = Instrument<any>;
export declare type EnvelopeParamsType = Partial<Omit<EnvelopeOptions, keyof ToneAudioNodeOptions>>;
export declare type OscillatorParamsType = Partial<OmniOscillatorSynthOptions>;
declare class AudioBuilder {
	private _source;
	private _instrument;
	private _audioNode;
	private _oscillatorParams;
	private _envelopeParams;
	setAudioNode(inputNode: ToneAudioNode | undefined): void;
	audioNode():
		| ToneAudioNode<import('tone/build/esm/core/context/ToneWithContext').ToneWithContextOptions>
		| undefined;
	setSource(source: SourceType | undefined): void;
	source(): SourceType | undefined;
	setInstrument(instrument: InstrumentType | undefined): void;
	instrument(): InstrumentType | undefined;
	setOscillatorParams(params: OscillatorParamsType | undefined): void;
	oscillatorParams(): OscillatorParamsType | undefined;
	setEnvelopeParams(params: EnvelopeParamsType | undefined): void;
	envelopeParams(): Partial<Omit<EnvelopeOptions, 'context'>> | undefined;
	clone(): AudioBuilder;
}
export interface ContainableMap {
	[NodeContext.ACTOR]: string;
	[NodeContext.ANIM]: TimelineBuilder;
	[NodeContext.AUDIO]: AudioBuilder;
	[NodeContext.COP]: Texture;
	[NodeContext.EVENT]: string;
	[NodeContext.GL]: string;
	[NodeContext.JS]: string;
	[NodeContext.MANAGER]: boolean;
	[NodeContext.MAT]: Material;
	[NodeContext.OBJ]: Object3D;
	[NodeContext.ROP]: any;
	[NodeContext.POST]: number;
	[NodeContext.SOP]: CoreGroup;
}
declare abstract class TypedContainer<NC extends NodeContext> {
	protected _node: TypedNode<NC, any>;
	protected _content: ContainableMap[NC];
	constructor(_node: TypedNode<NC, any>);
	set_node(node: TypedNode<NC, any>): void;
	node(): TypedNode<NC, any>;
	set_content(content: ContainableMap[NC]): void;
	has_content(): boolean;
	content(): ContainableMap[NC];
	protected _post_set_content(): void;
	coreContent(): ContainableMap[NC] | undefined;
	coreContentCloned(): ContainableMap[NC] | undefined;
	infos(): any;
}
declare class BaseContainer extends TypedContainer<any> {}
export interface BaseMethodFindDependencyArgs {
	indexOrPath: string | number | undefined;
	node?: BaseNodeType;
}
declare class BaseMethod {
	readonly param: BaseParamType;
	constructor(param: BaseParamType);
	private _node;
	protected node(): BaseNodeType | undefined;
	static requiredArguments(): any[];
	static optionalArguments(): any[];
	static minAllowedArgumentsCount(): number;
	static maxAllowedArgumentsCount(): number;
	static allowedArgumentsCount(count: number): boolean;
	processArguments(args: any): Promise<any>;
	getReferencedNodeContainer(indexOrPath: number | string): Promise<BaseContainer>;
	getReferencedParam(path: string, decomposedPath?: DecomposedPath): BaseParamType | null;
	findReferencedGraphNode(indexOrPath: number | string, decomposedPath?: DecomposedPath): CoreGraphNode | null;
	getReferencedNode(indexOrPath: string | number, decomposedPath?: DecomposedPath): BaseNodeType | null;
	findDependency(arg: BaseMethodFindDependencyArgs): MethodDependency | null;
	protected createDependencyFromIndexOrPath(args: BaseMethodFindDependencyArgs): MethodDependency | null;
	protected createDependency(
		node: CoreGraphNode,
		pathArgs: BaseMethodFindDependencyArgs,
		decomposedPath?: DecomposedPath
	): MethodDependency | null;
}
declare class MethodDependency extends CoreGraphNode {
	param: BaseParamType;
	pathArgs: BaseMethodFindDependencyArgs;
	decomposedPath?: DecomposedPath | undefined;
	jsep_node: jsep.Expression | undefined;
	resolved_graph_node: CoreGraphNode | undefined;
	unresolved_path: string | undefined;
	private _updateFromNameChangeBound;
	constructor(
		param: BaseParamType,
		pathArgs: BaseMethodFindDependencyArgs,
		decomposedPath?: DecomposedPath | undefined
	);
	private _updateFromNameChange;
	reset(): void;
	listen_for_name_changes(): void;
	set_jsep_node(jsep_node: jsep.Expression): void;
	set_resolved_graph_node(node: CoreGraphNode): void;
	set_unresolved_path(path: string): void;
	static create(
		param: BaseParamType,
		pathArgs: BaseMethodFindDependencyArgs,
		node: CoreGraphNode,
		decomposedPath?: DecomposedPath
	): MethodDependency;
}
declare class FunctionGenerator extends BaseTraverser {
	param: BaseParamType;
	private _entitiesDependent;
	private function;
	private _attribute_requirements_controller;
	private function_main_string;
	private methods;
	private method_index;
	methodDependencies: MethodDependency[];
	immutableDependencies: CoreGraphNode[];
	constructor(param: BaseParamType);
	entitiesDependent(): boolean;
	parseTree(parsedTree: ParsedTree): void;
	reset(): void;
	private _functionBody;
	evalAllowed(): boolean;
	evalFunction(): any;
	protected traverse_CallExpression(node: jsep.CallExpression): string | undefined;
	protected traverse_BinaryExpression(node: jsep.BinaryExpression): string;
	protected traverse_UnaryExpression(node: jsep.UnaryExpression): string;
	protected traverse_Identifier(node: jsep.Identifier): string | undefined;
	protected traverse_Identifier_F(): string;
	protected traverse_Identifier_T(): string;
	protected traverse_Identifier_OS(): string;
	protected traverse_Identifier_CH(): string;
	protected traverse_Identifier_CEX(): string;
	protected traverse_Identifier_CEY(): string;
	protected traverse_Identifier_CEZ(): string;
	private _method_centroid;
	private _createMethodAndDependencies;
}
declare class DependenciesController {
	param: BaseParamType;
	error_message: string | undefined;
	private _cyclicGraphDetected;
	private methodDependencies;
	constructor(param: BaseParamType);
	protected set_error(message: string): void;
	reset(): void;
	update(functionGenerator: FunctionGenerator): void;
	private _connectImmutableDependencies;
	private _handleMethodDependencies;
	private _handleMethodDependency;
	private _listenForNameChanges;
}
declare class ExpressionManager {
	param: BaseParamType;
	private _parseStarted;
	private _functionGenerator;
	private _expressionStringGenerator;
	dependenciesController: DependenciesController;
	private parsedTree;
	constructor(param: BaseParamType);
	generatedFunctionEntitiesDependent(): boolean;
	parseExpression(expression: string): void;
	computeFunction(): Promise<any>;
	reset(): void;
	is_errored(): boolean;
	error_message(): string | undefined;
	private _computeAllowed;
	updateFromMethodDependencyNameChange(): void;
}
export declare type EntityCallback<T extends ParamType> = (
	entity: CoreEntity,
	value: ParamValuesTypeMap[T] | any
) => void;
export declare type PointEntityCallback<T extends ParamType> = (
	entity: CorePoint,
	value: ParamValuesTypeMap[T] | any
) => void;
export declare type ObjectEntityCallback<T extends ParamType> = (
	entity: CoreObject,
	value: ParamValuesTypeMap[T] | any
) => void;
export declare type CoreGroupEntityCallback<T extends ParamType> = (
	entity: CoreGroup,
	value: ParamValuesTypeMap[T] | any
) => void;
declare class ExpressionController<T extends ParamType> {
	protected param: BaseParamType;
	protected _expression: string | undefined;
	protected _entities: CoreEntity[] | undefined;
	protected _entityCallback: EntityCallback<T> | undefined;
	protected _manager: ExpressionManager | undefined;
	protected _method_dependencies_by_graph_node_id: Map<CoreGraphNodeId, MethodDependency> | undefined;
	constructor(param: BaseParamType);
	dispose(): void;
	private _resetMethodDependencies;
	registerMethodDependency(method_dependency: MethodDependency): void;
	active(): boolean;
	expression(): string | undefined;
	is_errored(): boolean;
	error_message(): string | null | undefined;
	entitiesDependent(): boolean;
	set_expression(expression: string | undefined, set_dirty?: boolean): void;
	updateFromMethodDependencyNameChange(): void;
	computeExpression(): Promise<any> | undefined;
	computeExpressionForEntities(entities: CoreEntity[], callback: EntityCallback<T>): Promise<void>;
	computeExpressionForPoints(entities: CorePoint[], callback: PointEntityCallback<T>): Promise<void>;
	computeExpressionForObjects<OT extends CoreObjectType>(
		entities: BaseCoreObject<OT>[],
		callback: ObjectEntityCallback<T>
	): Promise<void>;
	computeExpressionForCoreGroup(entity: CoreGroup, callback: CoreGroupEntityCallback<T>): Promise<void>;
	entities(): CoreEntity[] | undefined;
	entityCallback(): EntityCallback<T> | undefined;
	private _setEntities;
	private _resetEntities;
}
declare enum ParamEvent {
	VISIBLE_UPDATED = 'param_visible_updated',
	EDITABLE_UPDATED = 'param_editable_updated',
	RAW_INPUT_UPDATED = 'raw_input_updated',
	VALUE_UPDATED = 'param_value_updated',
	EXPRESSION_UPDATED = 'param_expression_update',
	ERROR_UPDATED = 'param_error_updated',
	DELETED = 'param_deleted',
	ASSET_RELOAD_REQUEST = 'param_asset_reload_request',
}
declare class EmitController {
	protected param: BaseParamType;
	_blockedEmit: boolean;
	_blockedParentEmit: boolean;
	_countByEventName: Map<string, number>;
	constructor(param: BaseParamType);
	emitAllowed(): boolean;
	blockEmit(): boolean;
	unblockEmit(): boolean;
	blockParentEmit(): boolean;
	unblockParentEmit(): boolean;
	incrementCount(eventName: ParamEvent): void;
	eventsCount(eventName: ParamEvent): number;
	emit(event: ParamEvent): void;
}
export interface ParamValueSerializedTypeMap {
	[ParamType.BOOLEAN]: boolean;
	[ParamType.BUTTON]: ParamInitValuesTypeMap[ParamType.BUTTON];
	[ParamType.COLOR]: Number3;
	[ParamType.FLOAT]: number;
	[ParamType.FOLDER]: null;
	[ParamType.INTEGER]: number;
	[ParamType.NODE_PATH]: ParamInitValuesTypeMap[ParamType.NODE_PATH];
	[ParamType.PARAM_PATH]: ParamInitValuesTypeMap[ParamType.PARAM_PATH];
	[ParamType.RAMP]: RampValueJson;
	[ParamType.STRING]: ParamInitValuesTypeMap[ParamType.STRING];
	[ParamType.VECTOR2]: Number2;
	[ParamType.VECTOR3]: Number3;
	[ParamType.VECTOR4]: Number4;
}
export interface ParamValuePreConversionSerializedTypeMap {
	[ParamType.BOOLEAN]: undefined;
	[ParamType.BUTTON]: undefined;
	[ParamType.COLOR]: Number3;
	[ParamType.FLOAT]: undefined;
	[ParamType.FOLDER]: undefined;
	[ParamType.INTEGER]: undefined;
	[ParamType.NODE_PATH]: undefined;
	[ParamType.PARAM_PATH]: undefined;
	[ParamType.RAMP]: undefined;
	[ParamType.STRING]: undefined;
	[ParamType.VECTOR2]: undefined;
	[ParamType.VECTOR3]: undefined;
	[ParamType.VECTOR4]: undefined;
}
export interface ParamSerializerData<T extends ParamType> {
	name: string;
	type: T;
	raw_input: ParamInitValueSerializedTypeMap[T];
	value: ParamValueSerializedTypeMap[T];
	value_pre_conversion: ParamValuePreConversionSerializedTypeMap[T];
	expression?: string;
	graph_node_id: CoreGraphNodeId;
	error_message?: string;
	is_visible: boolean;
	editable: boolean;
	folder_name?: string;
	components?: CoreGraphNodeId[];
}
declare class ParamSerializer<T extends ParamType> {
	protected param: TypedParam<T>;
	constructor(param: TypedParam<T>);
	toJSON(): ParamSerializerData<T>;
	rawInput(): ParamInitValueSerializedTypeMap[T];
	value(): ParamValueSerializedTypeMap[T];
	value_pre_conversion(): ParamValuePreConversionSerializedTypeMap[T];
	expression(): string | undefined;
	error_message(): string | undefined;
	is_visible(): boolean;
	editable(): boolean;
}
declare class ParamTimeDependentState {
	protected param: BaseParamType;
	constructor(param: BaseParamType);
	active(): boolean;
}
declare class ParamStatesController {
	protected param: BaseParamType;
	timeDependent: ParamTimeDependentState;
	error: ParamErrorState;
	constructor(param: BaseParamType);
}
export declare type ComputeCallback = (value: void) => void;
export declare type OnDisposeCallback = () => void;
declare abstract class TypedParam<T extends ParamType> extends CoreGraphNode {
	protected _default_value: ParamInitValuesTypeMap[T];
	protected _raw_input: ParamInitValuesTypeMap[T];
	protected _value: ParamValuesTypeMap[T];
	protected _node: BaseNodeType | undefined;
	protected _parent_param: TypedMultipleParam<any> | undefined;
	protected _components: FloatParam[] | undefined;
	protected _computeResolves: ComputeCallback[] | undefined;
	private _options;
	get options(): OptionsController;
	private _emitController;
	get emitController(): EmitController;
	protected _expression_controller: ExpressionController<T> | undefined;
	get expressionController(): ExpressionController<T> | undefined;
	expressionParsedAsString(): boolean;
	private _serializer;
	get serializer(): ParamSerializer<T>;
	private _states;
	get states(): ParamStatesController;
	constructor(scene: PolyScene, node: BaseNodeType);
	dispose(): void;
	protected _initializeParam(): void;
	postOptionsInitialize(): void;
	static type(): ParamType;
	type(): T;
	isNumeric(): boolean;
	setName(name: string): void;
	get value(): ParamValuesTypeMap[T];
	abstract defaultValueSerialized(): ParamInitValueSerializedTypeMap[T];
	abstract rawInputSerialized(): ParamInitValueSerializedTypeMap[T];
	abstract valueSerialized(): ParamValueSerializedTypeMap[T];
	copyValue(param: BaseParamType): void;
	protected _copyValue(param: TypedParam<T>): void;
	valuePreConversionSerialized(): ParamValuePreConversionSerializedTypeMap[T];
	convert(rawVal: any): ParamValuesTypeMap[T] | null;
	static areRawInputEqual(val1: any, val2: any): boolean;
	isRawInputEqual(other_raw_input: ParamInitValuesTypeMap[T]): any;
	isDefaultValueEqual(other_default_value: ParamInitValuesTypeMap[T]): any;
	static areValuesEqual(val1: any, val2: any): boolean;
	isValueEqual(other_val: ParamValuesTypeMap[T]): any;
	protected _cloneRawInput(raw_input: ParamInitValuesTypeMap[T]): ParamInitValuesTypeMap[T];
	set(raw_input: ParamInitValuesTypeMap[T]): void;
	protected _prefilterInvalidRawInput(raw_input: any): ParamInitValuesTypeMap[T];
	defaultValue(): ParamInitValuesTypeMap[T];
	isDefault(): boolean;
	rawInput(): ParamInitValuesTypeMap[T];
	protected processRawInput(): void;
	private _isComputing;
	isComputing(): boolean;
	compute(): Promise<void>;
	protected processComputation(): Promise<void>;
	setInitValue(init_value: ParamInitValuesTypeMap[T]): void;
	_setupNodeDependencies(node: BaseNodeType | null): void;
	get node(): BaseNodeType;
	parent(): BaseNodeType;
	set_parent_param(param: TypedMultipleParam<any>): void;
	parentParam(): TypedMultipleParam<any> | undefined;
	has_parent_param(): boolean;
	path(): string;
	pathRelativeTo(node: BaseNodeType): string;
	emit(eventName: ParamEvent): void;
	get components(): FloatParam[] | undefined;
	componentNames(): Readonly<string[]>;
	isMultiple(): boolean;
	initComponents(): void;
	hasExpression(): boolean;
	toJSON(): ParamSerializerData<T>;
	private _onDisposeCallbacks;
	onDispose(callback: OnDisposeCallback): void;
	deregisterOnDispose(callback: OnDisposeCallback): void;
	private _runOnDisposeCallbacks;
}
export declare type BaseParamType = TypedParam<ParamType>;
export interface GenericParamOptionsMenuEntry<T> {
	name: string;
	value: T;
}
export declare type StringParamOptionsMenuEntry = GenericParamOptionsMenuEntry<string>;
export declare type NumericParamOptionsMenuEntry = GenericParamOptionsMenuEntry<number>;
export interface MenuNumericParamOptions {
	menu?: {
		entries: NumericParamOptionsMenuEntry[];
	};
}
export interface MenuStringParamOptions {
	menuString?: {
		entries: StringParamOptionsMenuEntry[];
	};
}
declare enum StringParamLanguage {
	CSS = 'css',
	GLSL = 'glsl',
	HTML = 'html',
	TYPESCRIPT = 'typescript',
	JSON = 'json',
}
export declare type VisibleIfParamOptions = PolyDictionary<number | boolean | string>;
export interface BaseParamOptions {
	cook?: boolean;
	spare?: boolean;
	hidden?: boolean;
	field?: boolean;
	visibleIf?: VisibleIfParamOptions | VisibleIfParamOptions[];
	separatorBefore?: boolean;
	separatorAfter?: boolean;
	joinToPreviousParam?: boolean;
	editable?: boolean;
}
export interface ExpressionParamOptions {
	expression?: {
		forEntities?: boolean;
	};
}
export interface NumberParamOptions extends BaseParamOptions {
	range?: Number2;
	rangeLocked?: Boolean2;
	step?: number;
}
export interface FileParamOptions {
	fileBrowse?: {
		extensions: string[];
	};
}
export interface ComputeOnDirtyParamOptions {
	computeOnDirty?: boolean;
}
export interface CallbackParamOptions {
	callback?: (node: BaseNodeType, param: BaseParamType) => any;
	callbackString?: string;
}
export interface LabelParamOptions {
	label?: string;
}
export interface LabelVisibilityParamOptions {
	hideLabel?: boolean;
}
export interface ColorConversionOptions {
	conversion?: ColorConversion;
}
export interface BooleanParamOptions
	extends BaseParamOptions,
		ComputeOnDirtyParamOptions,
		MenuNumericParamOptions,
		ExpressionParamOptions,
		CallbackParamOptions,
		LabelParamOptions {}
export interface ButtonParamOptions extends BaseParamOptions, CallbackParamOptions, LabelParamOptions {}
export interface ColorParamOptions
	extends BaseParamOptions,
		ColorConversionOptions,
		ExpressionParamOptions,
		CallbackParamOptions,
		ComputeOnDirtyParamOptions {}
export interface FloatParamOptions
	extends NumberParamOptions,
		MenuNumericParamOptions,
		ComputeOnDirtyParamOptions,
		ExpressionParamOptions,
		CallbackParamOptions {}
export interface FolderParamOptions extends BaseParamOptions {
	level?: number;
}
export interface IntegerParamOptions
	extends NumberParamOptions,
		MenuNumericParamOptions,
		ComputeOnDirtyParamOptions,
		ExpressionParamOptions,
		CallbackParamOptions {}
export interface NodePathParamOptions
	extends BaseParamOptions,
		FileParamOptions,
		ComputeOnDirtyParamOptions,
		CallbackParamOptions {
	nodeSelection?: {
		context?: NodeContext;
		types?: Readonly<string[]>;
	};
	dependentOnFoundNode?: boolean;
}
export interface ParamPathParamOptions
	extends BaseParamOptions,
		FileParamOptions,
		ComputeOnDirtyParamOptions,
		CallbackParamOptions {
	dependentOnFoundParam?: boolean;
	paramSelection?: ParamType | boolean;
}
export interface RampParamOptions extends BaseParamOptions, LabelVisibilityParamOptions {}
export interface StringParamOptions
	extends BaseParamOptions,
		MenuStringParamOptions,
		FileParamOptions,
		CallbackParamOptions,
		ExpressionParamOptions,
		LabelVisibilityParamOptions {
	multiline?: boolean;
	language?: StringParamLanguage;
	objectMask?: boolean;
}
export interface VectorParamOptions
	extends BaseParamOptions,
		ExpressionParamOptions,
		CallbackParamOptions,
		ComputeOnDirtyParamOptions {}
export interface Vector2ParamOptions extends VectorParamOptions {}
export interface Vector3ParamOptions extends VectorParamOptions {}
export interface QuaternionOptions {
	asQuaternion?: boolean;
}
export interface Vector4ParamOptions extends VectorParamOptions, QuaternionOptions {}
export interface ParamOptions
	extends NumberParamOptions,
		ColorConversionOptions,
		ComputeOnDirtyParamOptions,
		FolderParamOptions,
		ExpressionParamOptions,
		ButtonParamOptions,
		FileParamOptions,
		MenuNumericParamOptions,
		StringParamOptions,
		NodePathParamOptions,
		ParamPathParamOptions,
		LabelVisibilityParamOptions,
		QuaternionOptions {
	texture?: {
		env?: boolean;
	};
}
declare class OptionsController {
	private _param;
	private _programaticVisibleState;
	private _options;
	private _default_options;
	constructor(_param: BaseParamType);
	dispose(): void;
	set(options: ParamOptions): void;
	copy(options_controller: OptionsController): void;
	setOption<K extends keyof ParamOptions>(optionName: K, value: ParamOptions[K]): void;
	private _validateOption;
	private postSetOptions;
	param(): BaseParamType;
	node(): BaseNodeType;
	default(): ParamOptions;
	current(): ParamOptions;
	hasOptionsOverridden(): boolean;
	overriddenOptions(): ParamOptions;
	overriddenOptionNames(): Array<keyof ParamOptions>;
	computeOnDirty(): boolean;
	private _computeOnDirtyCallbackAdded;
	private _handleComputeOnDirty;
	private _computeParam;
	hasCallback(): boolean;
	private _callbackAllowed;
	allowCallback(): void;
	executeCallback(): Promise<void>;
	private getCallback;
	private createCallbackFromString;
	colorConversion(): ColorConversion;
	makesNodeDirtyWhenDirty(): boolean;
	fileBrowseOption():
		| {
				extensions: string[];
		  }
		| undefined;
	fileBrowseAllowed(): boolean;
	fileBrowseExtensions(): string[] | null;
	separatorBefore(): boolean | undefined;
	separatorAfter(): boolean | undefined;
	joinToPreviousParam(): boolean | undefined;
	setEditableState(state: boolean): void;
	editable(): boolean;
	isExpressionForEntities(): boolean;
	level(): number;
	hasMenu(): boolean;
	private menuOptions;
	private menuStringOptions;
	menuEntries(): Array<NumericParamOptionsMenuEntry | StringParamOptionsMenuEntry>;
	ensureValueInMenuEntries(value: number): number;
	isMultiline(): boolean;
	language(): StringParamLanguage | undefined;
	isCode(): boolean;
	nodeSelectionOptions():
		| {
				context?: NodeContext | undefined;
				types?: readonly string[] | undefined;
		  }
		| undefined;
	nodeSelectionContext(): NodeContext | undefined;
	nodeSelectionTypes(): readonly string[] | undefined;
	objectMask(): boolean;
	dependentOnFoundNode(): boolean | undefined;
	dependentOnFoundParam(): boolean | undefined;
	isSelectingParam(): boolean;
	range(): Number2;
	step(): number | undefined;
	asQuaternion(): boolean;
	private rangeLocked;
	ensureInRange(value: number): number;
	isSpare(): boolean;
	textureOptions():
		| {
				env?: boolean | undefined;
		  }
		| undefined;
	textureAsEnv(): boolean;
	isHidden(): boolean;
	isVisible(): boolean;
	setVisibleState(state: boolean): void;
	label(): string | undefined;
	isLabelHidden(): boolean;
	isFieldHidden(): boolean;
	uiDataDependsOnOtherParams(): boolean;
	visibilityPredecessors(): BaseParamType[];
	private _updateVisibilityAndRemoveDirtyBound;
	private _visibility_graph_node;
	private _ui_data_dependency_set;
	setUiDataDependency(): void;
	private updateVisibilityAndRemoveDirty;
	updateVisibility(): Promise<void>;
}
export declare type ParamOptionsByTypeMapGeneric = {
	[key in ParamType]: object;
};
export interface ParamOptionsByTypeMap extends ParamOptionsByTypeMapGeneric {
	[ParamType.BOOLEAN]: BooleanParamOptions;
	[ParamType.BUTTON]: ButtonParamOptions;
	[ParamType.COLOR]: ColorParamOptions;
	[ParamType.FLOAT]: FloatParamOptions;
	[ParamType.FOLDER]: FolderParamOptions;
	[ParamType.INTEGER]: IntegerParamOptions;
	[ParamType.NODE_PATH]: NodePathParamOptions;
	[ParamType.PARAM_PATH]: ParamPathParamOptions;
	[ParamType.RAMP]: RampParamOptions;
	[ParamType.STRING]: StringParamOptions;
	[ParamType.VECTOR2]: Vector2ParamOptions;
	[ParamType.VECTOR3]: Vector3ParamOptions;
	[ParamType.VECTOR4]: Vector4ParamOptions;
}
declare class ParamTemplate<T extends ParamType> {
	type: T;
	init_value: ParamInitValuesTypeMap[T];
	options?: ParamOptions | undefined;
	readonly value_type: ParamValuesTypeMap[T];
	readonly param_class: ParamConstructorMap[T];
	constructor(type: T, init_value: ParamInitValuesTypeMap[T], options?: ParamOptions | undefined);
}
declare class ParamConfig {
	static BUTTON(
		init_value: ParamInitValuesTypeMap[ParamType.BUTTON],
		options?: ParamOptionsByTypeMap[ParamType.BUTTON]
	): ParamTemplate<ParamType.BUTTON>;
	static BOOLEAN(
		init_value: ParamInitValuesTypeMap[ParamType.BOOLEAN],
		options?: ParamOptionsByTypeMap[ParamType.BOOLEAN]
	): ParamTemplate<ParamType.BOOLEAN>;
	static COLOR(
		init_value: ParamInitValuesTypeMap[ParamType.COLOR],
		options?: ParamOptionsByTypeMap[ParamType.COLOR]
	): ParamTemplate<ParamType.COLOR>;
	static FLOAT(
		init_value: ParamInitValuesTypeMap[ParamType.FLOAT],
		options?: ParamOptionsByTypeMap[ParamType.FLOAT]
	): ParamTemplate<ParamType.FLOAT>;
	static FOLDER(
		init_value?: ParamInitValuesTypeMap[ParamType.FOLDER],
		options?: ParamOptionsByTypeMap[ParamType.FOLDER]
	): ParamTemplate<ParamType.FOLDER>;
	static INTEGER(
		init_value: ParamInitValuesTypeMap[ParamType.INTEGER],
		options?: ParamOptionsByTypeMap[ParamType.INTEGER]
	): ParamTemplate<ParamType.INTEGER>;
	static RAMP(
		init_value?: ParamInitValuesTypeMap[ParamType.RAMP],
		options?: ParamOptionsByTypeMap[ParamType.RAMP]
	): ParamTemplate<ParamType.RAMP>;
	static STRING(
		init_value?: ParamInitValuesTypeMap[ParamType.STRING],
		options?: ParamOptionsByTypeMap[ParamType.STRING]
	): ParamTemplate<ParamType.STRING>;
	static VECTOR2(
		init_value: ParamInitValuesTypeMap[ParamType.VECTOR2],
		options?: ParamOptionsByTypeMap[ParamType.VECTOR2]
	): ParamTemplate<ParamType.VECTOR2>;
	static VECTOR3(
		init_value: ParamInitValuesTypeMap[ParamType.VECTOR3],
		options?: ParamOptionsByTypeMap[ParamType.VECTOR3]
	): ParamTemplate<ParamType.VECTOR3>;
	static VECTOR4(
		init_value: ParamInitValuesTypeMap[ParamType.VECTOR4],
		options?: ParamOptionsByTypeMap[ParamType.VECTOR4]
	): ParamTemplate<ParamType.VECTOR4>;
	static NODE_PATH(
		init_value: '', // forces at empty value at init, instead of ParamInitValuesTypeMap[ParamType.NODE_PATH],
		options?: ParamOptionsByTypeMap[ParamType.NODE_PATH]
	): ParamTemplate<ParamType.NODE_PATH>;
	static PARAM_PATH(
		init_value: '', // forces at empty value at init, instead of ParamInitValuesTypeMap[ParamType.PARAM_PATH],
		options?: ParamOptionsByTypeMap[ParamType.PARAM_PATH]
	): ParamTemplate<ParamType.PARAM_PATH>;
}
declare class NodeParamsConfig {}
declare class TypedAnimNode<K extends NodeParamsConfig> extends TypedNode<NodeContext.ANIM, K> {
	readonly flags: FlagsControllerB;
	static context(): NodeContext;
	static displayedInputNames(): string[];
	initializeBaseNode(): void;
	protected setTimelineBuilder(timeline_builder: TimelineBuilder): void;
}
export declare type BaseAnimNodeType = TypedAnimNode<NodeParamsConfig>;
declare class TypedAudioNode<K extends NodeParamsConfig> extends TypedNode<NodeContext.AUDIO, K> {
	readonly flags: FlagsControllerB;
	static context(): NodeContext;
	static displayedInputNames(): string[];
	initializeBaseNode(): void;
	protected setAudioBuilder(audioBuilder: AudioBuilder): void;
}
export declare type BaseAudioNodeType = TypedAudioNode<NodeParamsConfig>;
declare class TypedCopNode<K extends NodeParamsConfig> extends TypedNode<NodeContext.COP, K> {
	readonly flags: FlagsControllerBO;
	static context(): NodeContext;
	static displayedInputNames(): string[];
	initializeBaseNode(): void;
	private ___textureSync;
	__textureSync__(): Texture | undefined;
	setTexture(texture: Texture): void;
	protected _clearTexture(): void;
}
export declare type BaseCopNodeType = TypedCopNode<any>;
declare abstract class TypedInputEventNode<K extends BaseInputEventParamsConfig> extends TypedEventNode<K> {
	initializeBaseNode(): void;
	processEvent(eventContext: EventContext<Event>): void;
	static PARAM_CALLBACK_updateRegister(node: BaseInputEventNodeType): void;
	private _updateRegister;
	private _activeEventDatas;
	private _updateActiveEventDatas;
	protected abstract acceptedEventTypes(): Set<EventType>;
	activeEventDatas(): EventData[];
}
declare class BaseInputEventParamsConfig extends NodeParamsConfig {
	active: ParamTemplate<ParamType.BOOLEAN>;
	/** @param set which element triggers the event */
	element: ParamTemplate<ParamType.INTEGER>;
}
export declare type BaseInputEventNodeType = TypedInputEventNode<BaseInputEventParamsConfig>;
declare enum PolyEventName {
	POLY_PROGRESS = 'POLYProgress',
	SCENE_CREATED = 'POLYSceneCreated',
	SCENE_READY = 'POLYSceneReady',
	SCENE_PLAY = 'POLYScenePlay',
	SCENE_PAUSE = 'POLYScenePause',
	VIEWER_MOUNTED = 'POLYViewerMounted',
	VIEWER_READY = 'POLYViewerReady',
}
declare class PolySceneEvent extends Event {
	constructor(type: PolyEventName);
	get type(): PolyEventName;
}
declare class SceneEventsController {
	dispatch<T extends PolyEventName>(eventContext: EventContext<PolySceneEvent>): void;
	private _observersByEventType;
	removeObserverFromAllEventTypes(eventNode: BaseEventNodeType): void;
	addObserver(eventNode: BaseEventNodeType, eventType: PolyEventName): void;
}
declare enum EventInputType {
	DRAG = 'drag',
	KEYBOARD = 'keyboard',
	MOUSE = 'mouse',
	POINTER = 'pointer',
	TOUCH = 'touch',
	WINDOW = 'window',
}
declare class PointerEventParamsConfig extends NodeParamsConfig {
	/** @param toggle on to allow any event to be listened to */
	active: ParamTemplate<ParamType.BOOLEAN>;
	/** @param set which element triggers the event */
	element: ParamTemplate<ParamType.INTEGER>;
	/** @param toggle on to listen to click events */
	pointerdown: ParamTemplate<ParamType.BOOLEAN>;
	/** @param toggle on to listen to pointermove events */
	pointermove: ParamTemplate<ParamType.BOOLEAN>;
	/** @param toggle on to listen to pointerup events */
	pointerup: ParamTemplate<ParamType.BOOLEAN>;
	/** @param requires ctrlKey */
	ctrlKey: ParamTemplate<ParamType.BOOLEAN>;
	/** @param requires altKey */
	altKey: ParamTemplate<ParamType.BOOLEAN>;
	/** @param requires shiftKey */
	shiftKey: ParamTemplate<ParamType.BOOLEAN>;
	/** @param requires metaKey */
	metaKey: ParamTemplate<ParamType.BOOLEAN>;
}
declare class PointerEventNode extends TypedInputEventNode<PointerEventParamsConfig> {
	paramsConfig: PointerEventParamsConfig;
	static type(): EventInputType;
	protected acceptedEventTypes(): Set<PointerEventType>;
	initializeNode(): void;
	processEvent(eventContext: EventContext<MouseEvent>): void;
}
declare class DragEventsController extends BaseSceneEventsController<MouseEvent, PointerEventNode> {
	protected _requireCanvasEventListeners: boolean;
	type(): string;
	acceptedEventTypes(): Set<DragEventType>;
}
declare class KeyboardEventParamsConfig extends NodeParamsConfig {
	/** @param toggle on to allow any event to be listened to */
	active: ParamTemplate<ParamType.BOOLEAN>;
	/** @param set which element triggers the event */
	element: ParamTemplate<ParamType.INTEGER>;
	/** @param toggle on to listen to keydown events */
	keydown: ParamTemplate<ParamType.BOOLEAN>;
	/** @param toggle on to listen to keypress events */
	keypress: ParamTemplate<ParamType.BOOLEAN>;
	/** @param toggle on to listen to keyup events */
	keyup: ParamTemplate<ParamType.BOOLEAN>;
	/** @param space separated list of accepted key codes. If this is empty then any key is accepted. */
	keyCodes: ParamTemplate<ParamType.STRING>;
	/** @param requires ctrlKey */
	ctrlKey: ParamTemplate<ParamType.BOOLEAN>;
	/** @param requires altKey */
	altKey: ParamTemplate<ParamType.BOOLEAN>;
	/** @param requires shiftKey */
	shiftKey: ParamTemplate<ParamType.BOOLEAN>;
	/** @param requires metaKey */
	metaKey: ParamTemplate<ParamType.BOOLEAN>;
}
declare class KeyboardEventNode extends TypedInputEventNode<KeyboardEventParamsConfig> {
	paramsConfig: KeyboardEventParamsConfig;
	static type(): EventInputType;
	protected acceptedEventTypes(): Set<KeyboardEventType>;
	initializeNode(): void;
	setElement(element: CoreEventEmitter): void;
	processEvent(eventContext: EventContext<KeyboardEvent>): void;
}
declare class KeyboardEventsController extends BaseSceneEventsController<KeyboardEvent, KeyboardEventNode> {
	private timeController;
	private keyboardEventsController;
	constructor(dispatcher: SceneEventsDispatcher);
	protected _requireCanvasEventListeners: boolean;
	type(): string;
	acceptedEventTypes(): Set<string>;
	private _currentEvents;
	private _lastProcessedFrame;
	currentEvents(): KeyboardEvent[];
	processEvent(eventContext: EventContext<KeyboardEvent>): void;
}
declare class MouseEventParamsConfig extends NodeParamsConfig {
	/** @param toggle on to allow any event to be listened to */
	active: ParamTemplate<ParamType.BOOLEAN>;
	/** @param set which element triggers the event */
	element: ParamTemplate<ParamType.INTEGER>;
	/** @param toggle on to listen to auxclick events */
	auxclick: ParamTemplate<ParamType.BOOLEAN>;
	/** @param toggle on to listen to click events */
	click: ParamTemplate<ParamType.BOOLEAN>;
	/** @param toggle on to listen to contextmenu events */
	contextmenu: ParamTemplate<ParamType.BOOLEAN>;
	/** @param toggle on to listen to dblclick events */
	dblclick: ParamTemplate<ParamType.BOOLEAN>;
	/** @param toggle on to listen to mousedown events */
	mousedown: ParamTemplate<ParamType.BOOLEAN>;
	/** @param toggle on to listen to mouseenter events */
	mouseenter: ParamTemplate<ParamType.BOOLEAN>;
	/** @param toggle on to listen to mouseleave events */
	mouseleave: ParamTemplate<ParamType.BOOLEAN>;
	/** @param toggle on to listen to mousemove events */
	mousemove: ParamTemplate<ParamType.BOOLEAN>;
	/** @param toggle on to listen to mouseover events */
	mouseover: ParamTemplate<ParamType.BOOLEAN>;
	/** @param toggle on to listen to mouseout events */
	mouseout: ParamTemplate<ParamType.BOOLEAN>;
	/** @param toggle on to listen to mouseup events */
	mouseup: ParamTemplate<ParamType.BOOLEAN>;
	/** @param toggle on to listen to pointerlockchange events */
	pointerlockchange: ParamTemplate<ParamType.BOOLEAN>;
	/** @param toggle on to listen to pointerlockerror events */
	pointerlockerror: ParamTemplate<ParamType.BOOLEAN>;
	/** @param toggle on to listen to select events */
	select: ParamTemplate<ParamType.BOOLEAN>;
	/** @param toggle on to listen to wheel events */
	wheel: ParamTemplate<ParamType.BOOLEAN>;
	/** @param requires ctrlKey */
	ctrlKey: ParamTemplate<ParamType.BOOLEAN>;
	/** @param requires altKey */
	altKey: ParamTemplate<ParamType.BOOLEAN>;
	/** @param requires shiftKey */
	shiftKey: ParamTemplate<ParamType.BOOLEAN>;
	/** @param requires metaKey */
	metaKey: ParamTemplate<ParamType.BOOLEAN>;
}
declare class MouseEventNode extends TypedInputEventNode<MouseEventParamsConfig> {
	paramsConfig: MouseEventParamsConfig;
	static type(): EventInputType;
	protected acceptedEventTypes(): Set<MouseEventType>;
	initializeNode(): void;
	processEvent(eventContext: EventContext<MouseEvent>): void;
}
declare class MouseEventsController extends BaseSceneEventsController<MouseEvent, MouseEventNode> {
	protected _requireCanvasEventListeners: boolean;
	type(): string;
	acceptedEventTypes(): Set<MouseEventType>;
}
export interface RaycasterUpdateOptions {
	pointsThreshold: number;
	lineThreshold: number;
}
declare class PointerEventsController extends BaseSceneEventsController<MouseEvent, PointerEventNode> {
	private pointerEventsController;
	constructor(dispatcher: SceneEventsDispatcher);
	protected _requireCanvasEventListeners: boolean;
	private _cursorHelper;
	protected _cursor0: import('@vue/reactivity').Ref<{
		x: number;
		y: number;
		width: number;
		height: number;
		readonly isVector2: true;
		set: (x: number, y: number) => Vector2;
		setScalar: (scalar: number) => Vector2;
		setX: (x: number) => Vector2;
		setY: (y: number) => Vector2;
		setComponent: (index: number, value: number) => Vector2;
		getComponent: (index: number) => number;
		clone: () => Vector2;
		copy: (v: Vector2) => Vector2;
		add: (v: Vector2, w?: Vector2 | undefined) => Vector2;
		addScalar: (s: number) => Vector2;
		addVectors: (a: Vector2, b: Vector2) => Vector2;
		addScaledVector: (v: Vector2, s: number) => Vector2;
		sub: (v: Vector2) => Vector2;
		subScalar: (s: number) => Vector2;
		subVectors: (a: Vector2, b: Vector2) => Vector2;
		multiply: (v: Vector2) => Vector2;
		multiplyScalar: (scalar: number) => Vector2;
		divide: (v: Vector2) => Vector2;
		divideScalar: (s: number) => Vector2;
		applyMatrix3: (m: Matrix3) => Vector2;
		min: (v: Vector2) => Vector2;
		max: (v: Vector2) => Vector2;
		clamp: (min: Vector2, max: Vector2) => Vector2;
		clampScalar: (min: number, max: number) => Vector2;
		clampLength: (min: number, max: number) => Vector2;
		floor: () => Vector2;
		ceil: () => Vector2;
		round: () => Vector2;
		roundToZero: () => Vector2;
		negate: () => Vector2;
		dot: (v: Vector2) => number;
		cross: (v: Vector2) => number;
		lengthSq: () => number;
		length: () => number;
		lengthManhattan: () => number;
		manhattanLength: () => number;
		normalize: () => Vector2;
		angle: () => number;
		distanceTo: (v: Vector2) => number;
		distanceToSquared: (v: Vector2) => number;
		distanceToManhattan: (v: Vector2) => number;
		manhattanDistanceTo: (v: Vector2) => number;
		setLength: (length: number) => Vector2;
		lerp: (v: Vector2, alpha: number) => Vector2;
		lerpVectors: (v1: Vector2, v2: Vector2, alpha: number) => Vector2;
		equals: (v: Vector2) => boolean;
		fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Vector2;
		toArray: {
			(array?: number[] | undefined, offset?: number | undefined): number[];
			(array?: Vector2Tuple | undefined, offset?: 0 | undefined): Vector2Tuple;
			(array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
		};
		fromBufferAttribute: (attribute: BufferAttribute, index: number) => Vector2;
		rotateAround: (center: Vector2, angle: number) => Vector2;
		random: () => Vector2;
	}>;
	private _raycaster0;
	type(): string;
	acceptedEventTypes(): Set<PointerEventType>;
	setRaycaster(raycaster: Raycaster): void;
	processEvent(eventContext: EventContext<MouseEvent>): void;
	raycaster(): import('@vue/reactivity').Ref<{
		ray: {
			origin: {
				x: number;
				y: number;
				z: number;
				readonly isVector3: true;
				set: (x: number, y: number, z: number) => Vector3;
				setScalar: (scalar: number) => Vector3;
				setX: (x: number) => Vector3;
				setY: (y: number) => Vector3;
				setZ: (z: number) => Vector3;
				setComponent: (index: number, value: number) => Vector3;
				getComponent: (index: number) => number;
				clone: () => Vector3;
				copy: (v: Vector3) => Vector3;
				add: (v: Vector3) => Vector3;
				addScalar: (s: number) => Vector3;
				addScaledVector: (v: Vector3, s: number) => Vector3;
				addVectors: (a: Vector3, b: Vector3) => Vector3;
				sub: (a: Vector3) => Vector3;
				subScalar: (s: number) => Vector3;
				subVectors: (a: Vector3, b: Vector3) => Vector3;
				multiply: (v: Vector3) => Vector3;
				multiplyScalar: (s: number) => Vector3;
				multiplyVectors: (a: Vector3, b: Vector3) => Vector3;
				applyEuler: (euler: Euler) => Vector3;
				applyAxisAngle: (axis: Vector3, angle: number) => Vector3;
				applyMatrix3: (m: Matrix3) => Vector3;
				applyNormalMatrix: (m: Matrix3) => Vector3;
				applyMatrix4: (m: Matrix4) => Vector3;
				applyQuaternion: (q: Quaternion) => Vector3;
				project: (camera: Camera) => Vector3;
				unproject: (camera: Camera) => Vector3;
				transformDirection: (m: Matrix4) => Vector3;
				divide: (v: Vector3) => Vector3;
				divideScalar: (s: number) => Vector3;
				min: (v: Vector3) => Vector3;
				max: (v: Vector3) => Vector3;
				clamp: (min: Vector3, max: Vector3) => Vector3;
				clampScalar: (min: number, max: number) => Vector3;
				clampLength: (min: number, max: number) => Vector3;
				floor: () => Vector3;
				ceil: () => Vector3;
				round: () => Vector3;
				roundToZero: () => Vector3;
				negate: () => Vector3;
				dot: (v: Vector3) => number;
				lengthSq: () => number;
				length: () => number;
				lengthManhattan: () => number;
				manhattanLength: () => number;
				manhattanDistanceTo: (v: Vector3) => number;
				normalize: () => Vector3;
				setLength: (l: number) => Vector3;
				lerp: (v: Vector3, alpha: number) => Vector3;
				lerpVectors: (v1: Vector3, v2: Vector3, alpha: number) => Vector3;
				cross: (a: Vector3) => Vector3;
				crossVectors: (a: Vector3, b: Vector3) => Vector3;
				projectOnVector: (v: Vector3) => Vector3;
				projectOnPlane: (planeNormal: Vector3) => Vector3;
				reflect: (vector: Vector3) => Vector3;
				angleTo: (v: Vector3) => number;
				distanceTo: (v: Vector3) => number;
				distanceToSquared: (v: Vector3) => number;
				distanceToManhattan: (v: Vector3) => number;
				setFromSpherical: (s: Spherical) => Vector3;
				setFromSphericalCoords: (r: number, phi: number, theta: number) => Vector3;
				setFromCylindrical: (s: Cylindrical) => Vector3;
				setFromCylindricalCoords: (radius: number, theta: number, y: number) => Vector3;
				setFromMatrixPosition: (m: Matrix4) => Vector3;
				setFromMatrixScale: (m: Matrix4) => Vector3;
				setFromMatrixColumn: (matrix: Matrix4, index: number) => Vector3;
				setFromMatrix3Column: (matrix: Matrix3, index: number) => Vector3;
				setFromEuler: (e: Euler) => Vector3;
				equals: (v: Vector3) => boolean;
				fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Vector3;
				toArray: {
					(array?: number[] | undefined, offset?: number | undefined): number[];
					(array?: Vector3Tuple | undefined, offset?: 0 | undefined): Vector3Tuple;
					(array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
				};
				fromBufferAttribute: (
					attribute: BufferAttribute | InterleavedBufferAttribute,
					index: number
				) => Vector3;
				random: () => Vector3;
				randomDirection: () => Vector3;
			};
			direction: {
				x: number;
				y: number;
				z: number;
				readonly isVector3: true;
				set: (x: number, y: number, z: number) => Vector3;
				setScalar: (scalar: number) => Vector3;
				setX: (x: number) => Vector3;
				setY: (y: number) => Vector3;
				setZ: (z: number) => Vector3;
				setComponent: (index: number, value: number) => Vector3;
				getComponent: (index: number) => number;
				clone: () => Vector3;
				copy: (v: Vector3) => Vector3;
				add: (v: Vector3) => Vector3;
				addScalar: (s: number) => Vector3;
				addScaledVector: (v: Vector3, s: number) => Vector3;
				addVectors: (a: Vector3, b: Vector3) => Vector3;
				sub: (a: Vector3) => Vector3;
				subScalar: (s: number) => Vector3;
				subVectors: (a: Vector3, b: Vector3) => Vector3;
				multiply: (v: Vector3) => Vector3;
				multiplyScalar: (s: number) => Vector3;
				multiplyVectors: (a: Vector3, b: Vector3) => Vector3;
				applyEuler: (euler: Euler) => Vector3;
				applyAxisAngle: (axis: Vector3, angle: number) => Vector3;
				applyMatrix3: (m: Matrix3) => Vector3;
				applyNormalMatrix: (m: Matrix3) => Vector3;
				applyMatrix4: (m: Matrix4) => Vector3;
				applyQuaternion: (q: Quaternion) => Vector3;
				project: (camera: Camera) => Vector3;
				unproject: (camera: Camera) => Vector3;
				transformDirection: (m: Matrix4) => Vector3;
				divide: (v: Vector3) => Vector3;
				divideScalar: (s: number) => Vector3;
				min: (v: Vector3) => Vector3;
				max: (v: Vector3) => Vector3;
				clamp: (min: Vector3, max: Vector3) => Vector3;
				clampScalar: (min: number, max: number) => Vector3;
				clampLength: (min: number, max: number) => Vector3;
				floor: () => Vector3;
				ceil: () => Vector3;
				round: () => Vector3;
				roundToZero: () => Vector3;
				negate: () => Vector3;
				dot: (v: Vector3) => number;
				lengthSq: () => number;
				length: () => number;
				lengthManhattan: () => number;
				manhattanLength: () => number;
				manhattanDistanceTo: (v: Vector3) => number;
				normalize: () => Vector3;
				setLength: (l: number) => Vector3;
				lerp: (v: Vector3, alpha: number) => Vector3;
				lerpVectors: (v1: Vector3, v2: Vector3, alpha: number) => Vector3;
				cross: (a: Vector3) => Vector3;
				crossVectors: (a: Vector3, b: Vector3) => Vector3;
				projectOnVector: (v: Vector3) => Vector3;
				projectOnPlane: (planeNormal: Vector3) => Vector3;
				reflect: (vector: Vector3) => Vector3;
				angleTo: (v: Vector3) => number;
				distanceTo: (v: Vector3) => number;
				distanceToSquared: (v: Vector3) => number;
				distanceToManhattan: (v: Vector3) => number;
				setFromSpherical: (s: Spherical) => Vector3;
				setFromSphericalCoords: (r: number, phi: number, theta: number) => Vector3;
				setFromCylindrical: (s: Cylindrical) => Vector3;
				setFromCylindricalCoords: (radius: number, theta: number, y: number) => Vector3;
				setFromMatrixPosition: (m: Matrix4) => Vector3;
				setFromMatrixScale: (m: Matrix4) => Vector3;
				setFromMatrixColumn: (matrix: Matrix4, index: number) => Vector3;
				setFromMatrix3Column: (matrix: Matrix3, index: number) => Vector3;
				setFromEuler: (e: Euler) => Vector3;
				equals: (v: Vector3) => boolean;
				fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Vector3;
				toArray: {
					(array?: number[] | undefined, offset?: number | undefined): number[];
					(array?: Vector3Tuple | undefined, offset?: 0 | undefined): Vector3Tuple;
					(array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
				};
				fromBufferAttribute: (
					attribute: BufferAttribute | InterleavedBufferAttribute,
					index: number
				) => Vector3;
				random: () => Vector3;
				randomDirection: () => Vector3;
			};
			set: (origin: Vector3, direction: Vector3) => Ray;
			clone: () => Ray;
			copy: (ray: Ray) => Ray;
			at: (t: number, target: Vector3) => Vector3;
			lookAt: (v: Vector3) => Ray;
			recast: (t: number) => Ray;
			closestPointToPoint: (point: Vector3, target: Vector3) => Vector3;
			distanceToPoint: (point: Vector3) => number;
			distanceSqToPoint: (point: Vector3) => number;
			distanceSqToSegment: (
				v0: Vector3,
				v1: Vector3,
				optionalPointOnRay?: Vector3 | undefined,
				optionalPointOnSegment?: Vector3 | undefined
			) => number;
			intersectSphere: (sphere: Sphere, target: Vector3) => Vector3 | null;
			intersectsSphere: (sphere: Sphere) => boolean;
			distanceToPlane: (plane: Plane) => number;
			intersectPlane: (plane: Plane, target: Vector3) => Vector3 | null;
			intersectsPlane: (plane: Plane) => boolean;
			intersectBox: (box: Box3, target: Vector3) => Vector3 | null;
			intersectsBox: (box: Box3) => boolean;
			intersectTriangle: (
				a: Vector3,
				b: Vector3,
				c: Vector3,
				backfaceCulling: boolean,
				target: Vector3
			) => Vector3 | null;
			applyMatrix4: (matrix4: Matrix4) => Ray;
			equals: (ray: Ray) => boolean;
			isIntersectionBox: (b: any) => any;
			isIntersectionPlane: (p: any) => any;
			isIntersectionSphere: (s: any) => any;
		};
		near: number;
		far: number;
		camera: {
			matrixWorldInverse: {
				elements: number[];
				set: (
					n11: number,
					n12: number,
					n13: number,
					n14: number,
					n21: number,
					n22: number,
					n23: number,
					n24: number,
					n31: number,
					n32: number,
					n33: number,
					n34: number,
					n41: number,
					n42: number,
					n43: number,
					n44: number
				) => Matrix4;
				identity: () => Matrix4;
				clone: () => Matrix4;
				copy: (m: Matrix4) => Matrix4;
				copyPosition: (m: Matrix4) => Matrix4;
				extractBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix4;
				makeBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix4;
				extractRotation: (m: Matrix4) => Matrix4;
				makeRotationFromEuler: (euler: Euler) => Matrix4;
				makeRotationFromQuaternion: (q: Quaternion) => Matrix4;
				lookAt: (eye: Vector3, target: Vector3, up: Vector3) => Matrix4;
				multiply: (m: Matrix4) => Matrix4;
				premultiply: (m: Matrix4) => Matrix4;
				multiplyMatrices: (a: Matrix4, b: Matrix4) => Matrix4;
				multiplyToArray: (a: Matrix4, b: Matrix4, r: number[]) => Matrix4;
				multiplyScalar: (s: number) => Matrix4;
				determinant: () => number;
				transpose: () => Matrix4;
				setPosition: (v: number | Vector3, y?: number | undefined, z?: number | undefined) => Matrix4;
				invert: () => Matrix4;
				scale: (v: Vector3) => Matrix4;
				getMaxScaleOnAxis: () => number;
				makeTranslation: (x: number, y: number, z: number) => Matrix4;
				makeRotationX: (theta: number) => Matrix4;
				makeRotationY: (theta: number) => Matrix4;
				makeRotationZ: (theta: number) => Matrix4;
				makeRotationAxis: (axis: Vector3, angle: number) => Matrix4;
				makeScale: (x: number, y: number, z: number) => Matrix4;
				makeShear: (xy: number, xz: number, yx: number, yz: number, zx: number, zy: number) => Matrix4;
				compose: (translation: Vector3, rotation: Quaternion, scale: Vector3) => Matrix4;
				decompose: (translation: Vector3, rotation: Quaternion, scale: Vector3) => Matrix4;
				makePerspective: {
					(left: number, right: number, bottom: number, top: number, near: number, far: number): Matrix4;
					(fov: number, aspect: number, near: number, far: number): Matrix4;
				};
				makeOrthographic: (
					left: number,
					right: number,
					top: number,
					bottom: number,
					near: number,
					far: number
				) => Matrix4;
				equals: (matrix: Matrix4) => boolean;
				fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Matrix4;
				toArray: {
					(array?: number[] | undefined, offset?: number | undefined): number[];
					(array?: Matrix4Tuple | undefined, offset?: 0 | undefined): Matrix4Tuple;
					(array?: ArrayLike<number> | undefined, offset?: number | undefined): ArrayLike<number>;
				};
				setFromMatrix3: (m: Matrix3) => Matrix4;
				extractPosition: (m: Matrix4) => Matrix4;
				setRotationFromQuaternion: (q: Quaternion) => Matrix4;
				multiplyVector3: (v: any) => any;
				multiplyVector4: (v: any) => any;
				multiplyVector3Array: (array: number[]) => number[];
				rotateAxis: (v: any) => void;
				crossVector: (v: any) => void;
				flattenToArrayOffset: (array: number[], offset: number) => number[];
				getInverse: (matrix: Matrix) => Matrix;
			};
			projectionMatrix: {
				elements: number[];
				set: (
					n11: number,
					n12: number,
					n13: number,
					n14: number,
					n21: number,
					n22: number,
					n23: number,
					n24: number,
					n31: number,
					n32: number,
					n33: number,
					n34: number,
					n41: number,
					n42: number,
					n43: number,
					n44: number
				) => Matrix4;
				identity: () => Matrix4;
				clone: () => Matrix4;
				copy: (m: Matrix4) => Matrix4;
				copyPosition: (m: Matrix4) => Matrix4;
				extractBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix4;
				makeBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix4;
				extractRotation: (m: Matrix4) => Matrix4;
				makeRotationFromEuler: (euler: Euler) => Matrix4;
				makeRotationFromQuaternion: (q: Quaternion) => Matrix4;
				lookAt: (eye: Vector3, target: Vector3, up: Vector3) => Matrix4;
				multiply: (m: Matrix4) => Matrix4;
				premultiply: (m: Matrix4) => Matrix4;
				multiplyMatrices: (a: Matrix4, b: Matrix4) => Matrix4;
				multiplyToArray: (a: Matrix4, b: Matrix4, r: number[]) => Matrix4;
				multiplyScalar: (s: number) => Matrix4;
				determinant: () => number;
				transpose: () => Matrix4;
				setPosition: (v: number | Vector3, y?: number | undefined, z?: number | undefined) => Matrix4;
				invert: () => Matrix4;
				scale: (v: Vector3) => Matrix4;
				getMaxScaleOnAxis: () => number;
				makeTranslation: (x: number, y: number, z: number) => Matrix4;
				makeRotationX: (theta: number) => Matrix4;
				makeRotationY: (theta: number) => Matrix4;
				makeRotationZ: (theta: number) => Matrix4;
				makeRotationAxis: (axis: Vector3, angle: number) => Matrix4;
				makeScale: (x: number, y: number, z: number) => Matrix4;
				makeShear: (xy: number, xz: number, yx: number, yz: number, zx: number, zy: number) => Matrix4;
				compose: (translation: Vector3, rotation: Quaternion, scale: Vector3) => Matrix4;
				decompose: (translation: Vector3, rotation: Quaternion, scale: Vector3) => Matrix4;
				makePerspective: {
					(left: number, right: number, bottom: number, top: number, near: number, far: number): Matrix4;
					(fov: number, aspect: number, near: number, far: number): Matrix4;
				};
				makeOrthographic: (
					left: number,
					right: number,
					top: number,
					bottom: number,
					near: number,
					far: number
				) => Matrix4;
				equals: (matrix: Matrix4) => boolean;
				fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Matrix4;
				toArray: {
					(array?: number[] | undefined, offset?: number | undefined): number[];
					(array?: Matrix4Tuple | undefined, offset?: 0 | undefined): Matrix4Tuple;
					(array?: ArrayLike<number> | undefined, offset?: number | undefined): ArrayLike<number>;
				};
				setFromMatrix3: (m: Matrix3) => Matrix4;
				extractPosition: (m: Matrix4) => Matrix4;
				setRotationFromQuaternion: (q: Quaternion) => Matrix4;
				multiplyVector3: (v: any) => any;
				multiplyVector4: (v: any) => any;
				multiplyVector3Array: (array: number[]) => number[];
				rotateAxis: (v: any) => void;
				crossVector: (v: any) => void;
				flattenToArrayOffset: (array: number[], offset: number) => number[];
				getInverse: (matrix: Matrix) => Matrix;
			};
			projectionMatrixInverse: {
				elements: number[];
				set: (
					n11: number,
					n12: number,
					n13: number,
					n14: number,
					n21: number,
					n22: number,
					n23: number,
					n24: number,
					n31: number,
					n32: number,
					n33: number,
					n34: number,
					n41: number,
					n42: number,
					n43: number,
					n44: number
				) => Matrix4;
				identity: () => Matrix4;
				clone: () => Matrix4;
				copy: (m: Matrix4) => Matrix4;
				copyPosition: (m: Matrix4) => Matrix4;
				extractBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix4;
				makeBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix4;
				extractRotation: (m: Matrix4) => Matrix4;
				makeRotationFromEuler: (euler: Euler) => Matrix4;
				makeRotationFromQuaternion: (q: Quaternion) => Matrix4;
				lookAt: (eye: Vector3, target: Vector3, up: Vector3) => Matrix4;
				multiply: (m: Matrix4) => Matrix4;
				premultiply: (m: Matrix4) => Matrix4;
				multiplyMatrices: (a: Matrix4, b: Matrix4) => Matrix4;
				multiplyToArray: (a: Matrix4, b: Matrix4, r: number[]) => Matrix4;
				multiplyScalar: (s: number) => Matrix4;
				determinant: () => number;
				transpose: () => Matrix4;
				setPosition: (v: number | Vector3, y?: number | undefined, z?: number | undefined) => Matrix4;
				invert: () => Matrix4;
				scale: (v: Vector3) => Matrix4;
				getMaxScaleOnAxis: () => number;
				makeTranslation: (x: number, y: number, z: number) => Matrix4;
				makeRotationX: (theta: number) => Matrix4;
				makeRotationY: (theta: number) => Matrix4;
				makeRotationZ: (theta: number) => Matrix4;
				makeRotationAxis: (axis: Vector3, angle: number) => Matrix4;
				makeScale: (x: number, y: number, z: number) => Matrix4;
				makeShear: (xy: number, xz: number, yx: number, yz: number, zx: number, zy: number) => Matrix4;
				compose: (translation: Vector3, rotation: Quaternion, scale: Vector3) => Matrix4;
				decompose: (translation: Vector3, rotation: Quaternion, scale: Vector3) => Matrix4;
				makePerspective: {
					(left: number, right: number, bottom: number, top: number, near: number, far: number): Matrix4;
					(fov: number, aspect: number, near: number, far: number): Matrix4;
				};
				makeOrthographic: (
					left: number,
					right: number,
					top: number,
					bottom: number,
					near: number,
					far: number
				) => Matrix4;
				equals: (matrix: Matrix4) => boolean;
				fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Matrix4;
				toArray: {
					(array?: number[] | undefined, offset?: number | undefined): number[];
					(array?: Matrix4Tuple | undefined, offset?: 0 | undefined): Matrix4Tuple;
					(array?: ArrayLike<number> | undefined, offset?: number | undefined): ArrayLike<number>;
				};
				setFromMatrix3: (m: Matrix3) => Matrix4;
				extractPosition: (m: Matrix4) => Matrix4;
				setRotationFromQuaternion: (q: Quaternion) => Matrix4;
				multiplyVector3: (v: any) => any;
				multiplyVector4: (v: any) => any;
				multiplyVector3Array: (array: number[]) => number[];
				rotateAxis: (v: any) => void;
				crossVector: (v: any) => void;
				flattenToArrayOffset: (array: number[], offset: number) => number[];
				getInverse: (matrix: Matrix) => Matrix;
			};
			readonly isCamera: true;
			getWorldDirection: (target: Vector3) => Vector3;
			updateMatrixWorld: (force?: boolean | undefined) => void;
			id: number;
			uuid: string;
			name: string;
			type: string;
			parent: {
				id: number;
				uuid: string;
				name: string;
				type: string;
				parent: any | null;
				children: any[];
				up: {
					x: number;
					y: number;
					z: number;
					readonly isVector3: true;
					set: (x: number, y: number, z: number) => Vector3;
					setScalar: (scalar: number) => Vector3;
					setX: (x: number) => Vector3;
					setY: (y: number) => Vector3;
					setZ: (z: number) => Vector3;
					setComponent: (index: number, value: number) => Vector3;
					getComponent: (index: number) => number;
					clone: () => Vector3;
					copy: (v: Vector3) => Vector3;
					add: (v: Vector3) => Vector3;
					addScalar: (s: number) => Vector3;
					addScaledVector: (v: Vector3, s: number) => Vector3;
					addVectors: (a: Vector3, b: Vector3) => Vector3;
					sub: (a: Vector3) => Vector3;
					subScalar: (s: number) => Vector3;
					subVectors: (a: Vector3, b: Vector3) => Vector3;
					multiply: (v: Vector3) => Vector3;
					multiplyScalar: (s: number) => Vector3;
					multiplyVectors: (a: Vector3, b: Vector3) => Vector3;
					applyEuler: (euler: Euler) => Vector3;
					applyAxisAngle: (axis: Vector3, angle: number) => Vector3;
					applyMatrix3: (m: Matrix3) => Vector3;
					applyNormalMatrix: (m: Matrix3) => Vector3;
					applyMatrix4: (m: Matrix4) => Vector3;
					applyQuaternion: (q: Quaternion) => Vector3;
					project: (camera: Camera) => Vector3;
					unproject: (camera: Camera) => Vector3;
					transformDirection: (m: Matrix4) => Vector3;
					divide: (v: Vector3) => Vector3;
					divideScalar: (s: number) => Vector3;
					min: (v: Vector3) => Vector3;
					max: (v: Vector3) => Vector3;
					clamp: (min: Vector3, max: Vector3) => Vector3;
					clampScalar: (min: number, max: number) => Vector3;
					clampLength: (min: number, max: number) => Vector3;
					floor: () => Vector3;
					ceil: () => Vector3;
					round: () => Vector3;
					roundToZero: () => Vector3;
					negate: () => Vector3;
					dot: (v: Vector3) => number;
					lengthSq: () => number;
					length: () => number;
					lengthManhattan: () => number;
					manhattanLength: () => number;
					manhattanDistanceTo: (v: Vector3) => number;
					normalize: () => Vector3;
					setLength: (l: number) => Vector3;
					lerp: (v: Vector3, alpha: number) => Vector3;
					lerpVectors: (v1: Vector3, v2: Vector3, alpha: number) => Vector3;
					cross: (a: Vector3) => Vector3;
					crossVectors: (a: Vector3, b: Vector3) => Vector3;
					projectOnVector: (v: Vector3) => Vector3;
					projectOnPlane: (planeNormal: Vector3) => Vector3;
					reflect: (vector: Vector3) => Vector3;
					angleTo: (v: Vector3) => number;
					distanceTo: (v: Vector3) => number;
					distanceToSquared: (v: Vector3) => number;
					distanceToManhattan: (v: Vector3) => number;
					setFromSpherical: (s: Spherical) => Vector3;
					setFromSphericalCoords: (r: number, phi: number, theta: number) => Vector3;
					setFromCylindrical: (s: Cylindrical) => Vector3;
					setFromCylindricalCoords: (radius: number, theta: number, y: number) => Vector3;
					setFromMatrixPosition: (m: Matrix4) => Vector3;
					setFromMatrixScale: (m: Matrix4) => Vector3;
					setFromMatrixColumn: (matrix: Matrix4, index: number) => Vector3;
					setFromMatrix3Column: (matrix: Matrix3, index: number) => Vector3;
					setFromEuler: (e: Euler) => Vector3;
					equals: (v: Vector3) => boolean;
					fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Vector3;
					toArray: {
						(array?: number[] | undefined, offset?: number | undefined): number[];
						(array?: Vector3Tuple | undefined, offset?: 0 | undefined): Vector3Tuple;
						(array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
					};
					fromBufferAttribute: (
						attribute: BufferAttribute | InterleavedBufferAttribute,
						index: number
					) => Vector3;
					random: () => Vector3;
					randomDirection: () => Vector3;
				};
				readonly position: {
					x: number;
					y: number;
					z: number;
					readonly isVector3: true;
					set: (x: number, y: number, z: number) => Vector3;
					setScalar: (scalar: number) => Vector3;
					setX: (x: number) => Vector3;
					setY: (y: number) => Vector3;
					setZ: (z: number) => Vector3;
					setComponent: (index: number, value: number) => Vector3;
					getComponent: (index: number) => number;
					clone: () => Vector3;
					copy: (v: Vector3) => Vector3;
					add: (v: Vector3) => Vector3;
					addScalar: (s: number) => Vector3;
					addScaledVector: (v: Vector3, s: number) => Vector3;
					addVectors: (a: Vector3, b: Vector3) => Vector3;
					sub: (a: Vector3) => Vector3;
					subScalar: (s: number) => Vector3;
					subVectors: (a: Vector3, b: Vector3) => Vector3;
					multiply: (v: Vector3) => Vector3;
					multiplyScalar: (s: number) => Vector3;
					multiplyVectors: (a: Vector3, b: Vector3) => Vector3;
					applyEuler: (euler: Euler) => Vector3;
					applyAxisAngle: (axis: Vector3, angle: number) => Vector3;
					applyMatrix3: (m: Matrix3) => Vector3;
					applyNormalMatrix: (m: Matrix3) => Vector3;
					applyMatrix4: (m: Matrix4) => Vector3;
					applyQuaternion: (q: Quaternion) => Vector3;
					project: (camera: Camera) => Vector3;
					unproject: (camera: Camera) => Vector3;
					transformDirection: (m: Matrix4) => Vector3;
					divide: (v: Vector3) => Vector3;
					divideScalar: (s: number) => Vector3;
					min: (v: Vector3) => Vector3;
					max: (v: Vector3) => Vector3;
					clamp: (min: Vector3, max: Vector3) => Vector3;
					clampScalar: (min: number, max: number) => Vector3;
					clampLength: (min: number, max: number) => Vector3;
					floor: () => Vector3;
					ceil: () => Vector3;
					round: () => Vector3;
					roundToZero: () => Vector3;
					negate: () => Vector3;
					dot: (v: Vector3) => number;
					lengthSq: () => number;
					length: () => number;
					lengthManhattan: () => number;
					manhattanLength: () => number;
					manhattanDistanceTo: (v: Vector3) => number;
					normalize: () => Vector3;
					setLength: (l: number) => Vector3;
					lerp: (v: Vector3, alpha: number) => Vector3;
					lerpVectors: (v1: Vector3, v2: Vector3, alpha: number) => Vector3;
					cross: (a: Vector3) => Vector3;
					crossVectors: (a: Vector3, b: Vector3) => Vector3;
					projectOnVector: (v: Vector3) => Vector3;
					projectOnPlane: (planeNormal: Vector3) => Vector3;
					reflect: (vector: Vector3) => Vector3;
					angleTo: (v: Vector3) => number;
					distanceTo: (v: Vector3) => number;
					distanceToSquared: (v: Vector3) => number;
					distanceToManhattan: (v: Vector3) => number;
					setFromSpherical: (s: Spherical) => Vector3;
					setFromSphericalCoords: (r: number, phi: number, theta: number) => Vector3;
					setFromCylindrical: (s: Cylindrical) => Vector3;
					setFromCylindricalCoords: (radius: number, theta: number, y: number) => Vector3;
					setFromMatrixPosition: (m: Matrix4) => Vector3;
					setFromMatrixScale: (m: Matrix4) => Vector3;
					setFromMatrixColumn: (matrix: Matrix4, index: number) => Vector3;
					setFromMatrix3Column: (matrix: Matrix3, index: number) => Vector3;
					setFromEuler: (e: Euler) => Vector3;
					equals: (v: Vector3) => boolean;
					fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Vector3;
					toArray: {
						(array?: number[] | undefined, offset?: number | undefined): number[];
						(array?: Vector3Tuple | undefined, offset?: 0 | undefined): Vector3Tuple;
						(array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
					};
					fromBufferAttribute: (
						attribute: BufferAttribute | InterleavedBufferAttribute,
						index: number
					) => Vector3;
					random: () => Vector3;
					randomDirection: () => Vector3;
				};
				readonly rotation: {
					x: number;
					y: number;
					z: number;
					order: EulerOrder;
					readonly isEuler: true;
					_onChangeCallback: () => void;
					set: (x: number, y: number, z: number, order?: EulerOrder | undefined) => Euler;
					clone: () => Euler;
					copy: (euler: Euler) => Euler;
					setFromRotationMatrix: (
						m: Matrix4,
						order?: EulerOrder | undefined,
						update?: boolean | undefined
					) => Euler;
					setFromQuaternion: (
						q: Quaternion,
						order?: EulerOrder | undefined,
						update?: boolean | undefined
					) => Euler;
					setFromVector3: (v: Vector3, order?: EulerOrder | undefined) => Euler;
					reorder: (newOrder: EulerOrder) => Euler;
					equals: (euler: Euler) => boolean;
					fromArray: (xyzo: [number, number, number, (EulerOrder | undefined)?, ...any[]]) => Euler;
					toArray: (
						array?: (string | number | undefined)[] | undefined,
						offset?: number | undefined
					) => (string | number | undefined)[];
					_onChange: (callback: () => void) => Euler;
					[Symbol.iterator]: () => Generator<string | number, void, unknown>;
				};
				readonly quaternion: {
					x: number;
					y: number;
					z: number;
					w: number;
					readonly isQuaternion: true;
					set: (x: number, y: number, z: number, w: number) => Quaternion;
					clone: () => Quaternion;
					copy: (q: Quaternion) => Quaternion;
					setFromEuler: (euler: Euler, update?: boolean | undefined) => Quaternion;
					setFromAxisAngle: (axis: Vector3, angle: number) => Quaternion;
					setFromRotationMatrix: (m: Matrix4) => Quaternion;
					setFromUnitVectors: (vFrom: Vector3, vTo: Vector3) => Quaternion;
					angleTo: (q: Quaternion) => number;
					rotateTowards: (q: Quaternion, step: number) => Quaternion;
					identity: () => Quaternion;
					invert: () => Quaternion;
					conjugate: () => Quaternion;
					dot: (v: Quaternion) => number;
					lengthSq: () => number;
					length: () => number;
					normalize: () => Quaternion;
					multiply: (q: Quaternion) => Quaternion;
					premultiply: (q: Quaternion) => Quaternion;
					multiplyQuaternions: (a: Quaternion, b: Quaternion) => Quaternion;
					slerp: (qb: Quaternion, t: number) => Quaternion;
					slerpQuaternions: (qa: Quaternion, qb: Quaternion, t: number) => Quaternion;
					equals: (v: Quaternion) => boolean;
					fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Quaternion;
					toArray: {
						(array?: number[] | undefined, offset?: number | undefined): number[];
						(array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
					};
					fromBufferAttribute: (
						attribute: BufferAttribute | InterleavedBufferAttribute,
						index: number
					) => Quaternion;
					_onChange: (callback: () => void) => Quaternion;
					_onChangeCallback: () => void;
					multiplyVector3: (v: any) => any;
					random: () => Quaternion;
					[Symbol.iterator]: () => Generator<number, void, unknown>;
				};
				readonly scale: {
					x: number;
					y: number;
					z: number;
					readonly isVector3: true;
					set: (x: number, y: number, z: number) => Vector3;
					setScalar: (scalar: number) => Vector3;
					setX: (x: number) => Vector3;
					setY: (y: number) => Vector3;
					setZ: (z: number) => Vector3;
					setComponent: (index: number, value: number) => Vector3;
					getComponent: (index: number) => number;
					clone: () => Vector3;
					copy: (v: Vector3) => Vector3;
					add: (v: Vector3) => Vector3;
					addScalar: (s: number) => Vector3;
					addScaledVector: (v: Vector3, s: number) => Vector3;
					addVectors: (a: Vector3, b: Vector3) => Vector3;
					sub: (a: Vector3) => Vector3;
					subScalar: (s: number) => Vector3;
					subVectors: (a: Vector3, b: Vector3) => Vector3;
					multiply: (v: Vector3) => Vector3;
					multiplyScalar: (s: number) => Vector3;
					multiplyVectors: (a: Vector3, b: Vector3) => Vector3;
					applyEuler: (euler: Euler) => Vector3;
					applyAxisAngle: (axis: Vector3, angle: number) => Vector3;
					applyMatrix3: (m: Matrix3) => Vector3;
					applyNormalMatrix: (m: Matrix3) => Vector3;
					applyMatrix4: (m: Matrix4) => Vector3;
					applyQuaternion: (q: Quaternion) => Vector3;
					project: (camera: Camera) => Vector3;
					unproject: (camera: Camera) => Vector3;
					transformDirection: (m: Matrix4) => Vector3;
					divide: (v: Vector3) => Vector3;
					divideScalar: (s: number) => Vector3;
					min: (v: Vector3) => Vector3;
					max: (v: Vector3) => Vector3;
					clamp: (min: Vector3, max: Vector3) => Vector3;
					clampScalar: (min: number, max: number) => Vector3;
					clampLength: (min: number, max: number) => Vector3;
					floor: () => Vector3;
					ceil: () => Vector3;
					round: () => Vector3;
					roundToZero: () => Vector3;
					negate: () => Vector3;
					dot: (v: Vector3) => number;
					lengthSq: () => number;
					length: () => number;
					lengthManhattan: () => number;
					manhattanLength: () => number;
					manhattanDistanceTo: (v: Vector3) => number;
					normalize: () => Vector3;
					setLength: (l: number) => Vector3;
					lerp: (v: Vector3, alpha: number) => Vector3;
					lerpVectors: (v1: Vector3, v2: Vector3, alpha: number) => Vector3;
					cross: (a: Vector3) => Vector3;
					crossVectors: (a: Vector3, b: Vector3) => Vector3;
					projectOnVector: (v: Vector3) => Vector3;
					projectOnPlane: (planeNormal: Vector3) => Vector3;
					reflect: (vector: Vector3) => Vector3;
					angleTo: (v: Vector3) => number;
					distanceTo: (v: Vector3) => number;
					distanceToSquared: (v: Vector3) => number;
					distanceToManhattan: (v: Vector3) => number;
					setFromSpherical: (s: Spherical) => Vector3;
					setFromSphericalCoords: (r: number, phi: number, theta: number) => Vector3;
					setFromCylindrical: (s: Cylindrical) => Vector3;
					setFromCylindricalCoords: (radius: number, theta: number, y: number) => Vector3;
					setFromMatrixPosition: (m: Matrix4) => Vector3;
					setFromMatrixScale: (m: Matrix4) => Vector3;
					setFromMatrixColumn: (matrix: Matrix4, index: number) => Vector3;
					setFromMatrix3Column: (matrix: Matrix3, index: number) => Vector3;
					setFromEuler: (e: Euler) => Vector3;
					equals: (v: Vector3) => boolean;
					fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Vector3;
					toArray: {
						(array?: number[] | undefined, offset?: number | undefined): number[];
						(array?: Vector3Tuple | undefined, offset?: 0 | undefined): Vector3Tuple;
						(array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
					};
					fromBufferAttribute: (
						attribute: BufferAttribute | InterleavedBufferAttribute,
						index: number
					) => Vector3;
					random: () => Vector3;
					randomDirection: () => Vector3;
				};
				readonly modelViewMatrix: {
					elements: number[];
					set: (
						n11: number,
						n12: number,
						n13: number,
						n14: number,
						n21: number,
						n22: number,
						n23: number,
						n24: number,
						n31: number,
						n32: number,
						n33: number,
						n34: number,
						n41: number,
						n42: number,
						n43: number,
						n44: number
					) => Matrix4;
					identity: () => Matrix4;
					clone: () => Matrix4;
					copy: (m: Matrix4) => Matrix4;
					copyPosition: (m: Matrix4) => Matrix4;
					extractBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix4;
					makeBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix4;
					extractRotation: (m: Matrix4) => Matrix4;
					makeRotationFromEuler: (euler: Euler) => Matrix4;
					makeRotationFromQuaternion: (q: Quaternion) => Matrix4;
					lookAt: (eye: Vector3, target: Vector3, up: Vector3) => Matrix4;
					multiply: (m: Matrix4) => Matrix4;
					premultiply: (m: Matrix4) => Matrix4;
					multiplyMatrices: (a: Matrix4, b: Matrix4) => Matrix4;
					multiplyToArray: (a: Matrix4, b: Matrix4, r: number[]) => Matrix4;
					multiplyScalar: (s: number) => Matrix4;
					determinant: () => number;
					transpose: () => Matrix4;
					setPosition: (v: number | Vector3, y?: number | undefined, z?: number | undefined) => Matrix4;
					invert: () => Matrix4;
					scale: (v: Vector3) => Matrix4;
					getMaxScaleOnAxis: () => number;
					makeTranslation: (x: number, y: number, z: number) => Matrix4;
					makeRotationX: (theta: number) => Matrix4;
					makeRotationY: (theta: number) => Matrix4;
					makeRotationZ: (theta: number) => Matrix4;
					makeRotationAxis: (axis: Vector3, angle: number) => Matrix4;
					makeScale: (x: number, y: number, z: number) => Matrix4;
					makeShear: (xy: number, xz: number, yx: number, yz: number, zx: number, zy: number) => Matrix4;
					compose: (translation: Vector3, rotation: Quaternion, scale: Vector3) => Matrix4;
					decompose: (translation: Vector3, rotation: Quaternion, scale: Vector3) => Matrix4;
					makePerspective: {
						(left: number, right: number, bottom: number, top: number, near: number, far: number): Matrix4;
						(fov: number, aspect: number, near: number, far: number): Matrix4;
					};
					makeOrthographic: (
						left: number,
						right: number,
						top: number,
						bottom: number,
						near: number,
						far: number
					) => Matrix4;
					equals: (matrix: Matrix4) => boolean;
					fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Matrix4;
					toArray: {
						(array?: number[] | undefined, offset?: number | undefined): number[];
						(array?: Matrix4Tuple | undefined, offset?: 0 | undefined): Matrix4Tuple;
						(array?: ArrayLike<number> | undefined, offset?: number | undefined): ArrayLike<number>;
					};
					setFromMatrix3: (m: Matrix3) => Matrix4;
					extractPosition: (m: Matrix4) => Matrix4;
					setRotationFromQuaternion: (q: Quaternion) => Matrix4;
					multiplyVector3: (v: any) => any;
					multiplyVector4: (v: any) => any;
					multiplyVector3Array: (array: number[]) => number[];
					rotateAxis: (v: any) => void;
					crossVector: (v: any) => void;
					flattenToArrayOffset: (array: number[], offset: number) => number[];
					getInverse: (matrix: Matrix) => Matrix;
				};
				readonly normalMatrix: {
					elements: number[];
					set: (
						n11: number,
						n12: number,
						n13: number,
						n21: number,
						n22: number,
						n23: number,
						n31: number,
						n32: number,
						n33: number
					) => Matrix3;
					identity: () => Matrix3;
					clone: () => Matrix3;
					copy: (m: Matrix3) => Matrix3;
					extractBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix3;
					setFromMatrix4: (m: Matrix4) => Matrix3;
					multiplyScalar: (s: number) => Matrix3;
					determinant: () => number;
					invert: () => Matrix3;
					transpose: () => Matrix3;
					getNormalMatrix: (matrix4: Matrix4) => Matrix3;
					transposeIntoArray: (r: number[]) => Matrix3;
					setUvTransform: (
						tx: number,
						ty: number,
						sx: number,
						sy: number,
						rotation: number,
						cx: number,
						cy: number
					) => Matrix3;
					scale: (sx: number, sy: number) => Matrix3;
					makeTranslation: {
						(x: number, y: number): Matrix3;
						(x: number, y: number): Matrix3;
					};
					makeRotation: {
						(theta: number): Matrix3;
						(theta: number): Matrix3;
					};
					makeScale: {
						(x: number, y: number): Matrix3;
						(x: number, y: number): Matrix3;
					};
					rotate: (theta: number) => Matrix3;
					translate: (tx: number, ty: number) => Matrix3;
					equals: (matrix: Matrix3) => boolean;
					fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Matrix3;
					toArray: {
						(array?: number[] | undefined, offset?: number | undefined): number[];
						(array?: Matrix3Tuple | undefined, offset?: 0 | undefined): Matrix3Tuple;
						(array?: ArrayLike<number> | undefined, offset?: number | undefined): ArrayLike<number>;
					};
					multiply: (m: Matrix3) => Matrix3;
					premultiply: (m: Matrix3) => Matrix3;
					multiplyMatrices: (a: Matrix3, b: Matrix3) => Matrix3;
					multiplyVector3: (vector: Vector3) => any;
					multiplyVector3Array: (a: any) => any;
					getInverse: {
						(matrix: Matrix4, throwOnDegenerate?: boolean | undefined): Matrix3;
						(matrix: Matrix): Matrix;
					};
					flattenToArrayOffset: (array: number[], offset: number) => number[];
				};
				matrix: {
					elements: number[];
					set: (
						n11: number,
						n12: number,
						n13: number,
						n14: number,
						n21: number,
						n22: number,
						n23: number,
						n24: number,
						n31: number,
						n32: number,
						n33: number,
						n34: number,
						n41: number,
						n42: number,
						n43: number,
						n44: number
					) => Matrix4;
					identity: () => Matrix4;
					clone: () => Matrix4;
					copy: (m: Matrix4) => Matrix4;
					copyPosition: (m: Matrix4) => Matrix4;
					extractBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix4;
					makeBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix4;
					extractRotation: (m: Matrix4) => Matrix4;
					makeRotationFromEuler: (euler: Euler) => Matrix4;
					makeRotationFromQuaternion: (q: Quaternion) => Matrix4;
					lookAt: (eye: Vector3, target: Vector3, up: Vector3) => Matrix4;
					multiply: (m: Matrix4) => Matrix4;
					premultiply: (m: Matrix4) => Matrix4;
					multiplyMatrices: (a: Matrix4, b: Matrix4) => Matrix4;
					multiplyToArray: (a: Matrix4, b: Matrix4, r: number[]) => Matrix4;
					multiplyScalar: (s: number) => Matrix4;
					determinant: () => number;
					transpose: () => Matrix4;
					setPosition: (v: number | Vector3, y?: number | undefined, z?: number | undefined) => Matrix4;
					invert: () => Matrix4;
					scale: (v: Vector3) => Matrix4;
					getMaxScaleOnAxis: () => number;
					makeTranslation: (x: number, y: number, z: number) => Matrix4;
					makeRotationX: (theta: number) => Matrix4;
					makeRotationY: (theta: number) => Matrix4;
					makeRotationZ: (theta: number) => Matrix4;
					makeRotationAxis: (axis: Vector3, angle: number) => Matrix4;
					makeScale: (x: number, y: number, z: number) => Matrix4;
					makeShear: (xy: number, xz: number, yx: number, yz: number, zx: number, zy: number) => Matrix4;
					compose: (translation: Vector3, rotation: Quaternion, scale: Vector3) => Matrix4;
					decompose: (translation: Vector3, rotation: Quaternion, scale: Vector3) => Matrix4;
					makePerspective: {
						(left: number, right: number, bottom: number, top: number, near: number, far: number): Matrix4;
						(fov: number, aspect: number, near: number, far: number): Matrix4;
					};
					makeOrthographic: (
						left: number,
						right: number,
						top: number,
						bottom: number,
						near: number,
						far: number
					) => Matrix4;
					equals: (matrix: Matrix4) => boolean;
					fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Matrix4;
					toArray: {
						(array?: number[] | undefined, offset?: number | undefined): number[];
						(array?: Matrix4Tuple | undefined, offset?: 0 | undefined): Matrix4Tuple;
						(array?: ArrayLike<number> | undefined, offset?: number | undefined): ArrayLike<number>;
					};
					setFromMatrix3: (m: Matrix3) => Matrix4;
					extractPosition: (m: Matrix4) => Matrix4;
					setRotationFromQuaternion: (q: Quaternion) => Matrix4;
					multiplyVector3: (v: any) => any;
					multiplyVector4: (v: any) => any;
					multiplyVector3Array: (array: number[]) => number[];
					rotateAxis: (v: any) => void;
					crossVector: (v: any) => void;
					flattenToArrayOffset: (array: number[], offset: number) => number[];
					getInverse: (matrix: Matrix) => Matrix;
				};
				matrixWorld: {
					elements: number[];
					set: (
						n11: number,
						n12: number,
						n13: number,
						n14: number,
						n21: number,
						n22: number,
						n23: number,
						n24: number,
						n31: number,
						n32: number,
						n33: number,
						n34: number,
						n41: number,
						n42: number,
						n43: number,
						n44: number
					) => Matrix4;
					identity: () => Matrix4;
					clone: () => Matrix4;
					copy: (m: Matrix4) => Matrix4;
					copyPosition: (m: Matrix4) => Matrix4;
					extractBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix4;
					makeBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix4;
					extractRotation: (m: Matrix4) => Matrix4;
					makeRotationFromEuler: (euler: Euler) => Matrix4;
					makeRotationFromQuaternion: (q: Quaternion) => Matrix4;
					lookAt: (eye: Vector3, target: Vector3, up: Vector3) => Matrix4;
					multiply: (m: Matrix4) => Matrix4;
					premultiply: (m: Matrix4) => Matrix4;
					multiplyMatrices: (a: Matrix4, b: Matrix4) => Matrix4;
					multiplyToArray: (a: Matrix4, b: Matrix4, r: number[]) => Matrix4;
					multiplyScalar: (s: number) => Matrix4;
					determinant: () => number;
					transpose: () => Matrix4;
					setPosition: (v: number | Vector3, y?: number | undefined, z?: number | undefined) => Matrix4;
					invert: () => Matrix4;
					scale: (v: Vector3) => Matrix4;
					getMaxScaleOnAxis: () => number;
					makeTranslation: (x: number, y: number, z: number) => Matrix4;
					makeRotationX: (theta: number) => Matrix4;
					makeRotationY: (theta: number) => Matrix4;
					makeRotationZ: (theta: number) => Matrix4;
					makeRotationAxis: (axis: Vector3, angle: number) => Matrix4;
					makeScale: (x: number, y: number, z: number) => Matrix4;
					makeShear: (xy: number, xz: number, yx: number, yz: number, zx: number, zy: number) => Matrix4;
					compose: (translation: Vector3, rotation: Quaternion, scale: Vector3) => Matrix4;
					decompose: (translation: Vector3, rotation: Quaternion, scale: Vector3) => Matrix4;
					makePerspective: {
						(left: number, right: number, bottom: number, top: number, near: number, far: number): Matrix4;
						(fov: number, aspect: number, near: number, far: number): Matrix4;
					};
					makeOrthographic: (
						left: number,
						right: number,
						top: number,
						bottom: number,
						near: number,
						far: number
					) => Matrix4;
					equals: (matrix: Matrix4) => boolean;
					fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Matrix4;
					toArray: {
						(array?: number[] | undefined, offset?: number | undefined): number[];
						(array?: Matrix4Tuple | undefined, offset?: 0 | undefined): Matrix4Tuple;
						(array?: ArrayLike<number> | undefined, offset?: number | undefined): ArrayLike<number>;
					};
					setFromMatrix3: (m: Matrix3) => Matrix4;
					extractPosition: (m: Matrix4) => Matrix4;
					setRotationFromQuaternion: (q: Quaternion) => Matrix4;
					multiplyVector3: (v: any) => any;
					multiplyVector4: (v: any) => any;
					multiplyVector3Array: (array: number[]) => number[];
					rotateAxis: (v: any) => void;
					crossVector: (v: any) => void;
					flattenToArrayOffset: (array: number[], offset: number) => number[];
					getInverse: (matrix: Matrix) => Matrix;
				};
				matrixAutoUpdate: boolean;
				matrixWorldAutoUpdate: boolean;
				matrixWorldNeedsUpdate: boolean;
				layers: {
					mask: number;
					set: (channel: number) => void;
					enable: (channel: number) => void;
					enableAll: () => void;
					toggle: (channel: number) => void;
					disable: (channel: number) => void;
					disableAll: () => void;
					test: (layers: Layers) => boolean;
					isEnabled: (channel: number) => boolean;
				};
				visible: boolean;
				castShadow: boolean;
				receiveShadow: boolean;
				frustumCulled: boolean;
				renderOrder: number;
				animations: {
					name: string;
					tracks: {
						name: string;
						times: {
							[x: number]: number;
							readonly BYTES_PER_ELEMENT: number;
							readonly buffer:
								| {
										readonly byteLength: number;
										slice: (begin: number, end?: number | undefined) => ArrayBuffer;
										readonly [Symbol.toStringTag]: string;
								  }
								| {
										readonly byteLength: number;
										slice: (begin: number, end?: number | undefined) => SharedArrayBuffer;
										readonly [Symbol.species]: SharedArrayBuffer;
										readonly [Symbol.toStringTag]: 'SharedArrayBuffer';
								  };
							readonly byteLength: number;
							readonly byteOffset: number;
							copyWithin: (target: number, start: number, end?: number | undefined) => Float32Array;
							every: (
								predicate: (value: number, index: number, array: Float32Array) => unknown,
								thisArg?: any
							) => boolean;
							fill: (value: number, start?: number | undefined, end?: number | undefined) => Float32Array;
							filter: (
								predicate: (value: number, index: number, array: Float32Array) => any,
								thisArg?: any
							) => Float32Array;
							find: (
								predicate: (value: number, index: number, obj: Float32Array) => boolean,
								thisArg?: any
							) => number | undefined;
							findIndex: (
								predicate: (value: number, index: number, obj: Float32Array) => boolean,
								thisArg?: any
							) => number;
							forEach: (
								callbackfn: (value: number, index: number, array: Float32Array) => void,
								thisArg?: any
							) => void;
							indexOf: (searchElement: number, fromIndex?: number | undefined) => number;
							join: (separator?: string | undefined) => string;
							lastIndexOf: (searchElement: number, fromIndex?: number | undefined) => number;
							readonly length: number;
							map: (
								callbackfn: (value: number, index: number, array: Float32Array) => number,
								thisArg?: any
							) => Float32Array;
							reduce: {
								(
									callbackfn: (
										previousValue: number,
										currentValue: number,
										currentIndex: number,
										array: Float32Array
									) => number
								): number;
								(
									callbackfn: (
										previousValue: number,
										currentValue: number,
										currentIndex: number,
										array: Float32Array
									) => number,
									initialValue: number
								): number;
								<U>(
									callbackfn: (
										previousValue: U,
										currentValue: number,
										currentIndex: number,
										array: Float32Array
									) => U,
									initialValue: U
								): U;
							};
							reduceRight: {
								(
									callbackfn: (
										previousValue: number,
										currentValue: number,
										currentIndex: number,
										array: Float32Array
									) => number
								): number;
								(
									callbackfn: (
										previousValue: number,
										currentValue: number,
										currentIndex: number,
										array: Float32Array
									) => number,
									initialValue: number
								): number;
								<U_1>(
									callbackfn: (
										previousValue: U_1,
										currentValue: number,
										currentIndex: number,
										array: Float32Array
									) => U_1,
									initialValue: U_1
								): U_1;
							};
							reverse: () => Float32Array;
							set: (array: ArrayLike<number>, offset?: number | undefined) => void;
							slice: (start?: number | undefined, end?: number | undefined) => Float32Array;
							some: (
								predicate: (value: number, index: number, array: Float32Array) => unknown,
								thisArg?: any
							) => boolean;
							sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
							subarray: (begin?: number | undefined, end?: number | undefined) => Float32Array;
							toLocaleString: () => string;
							toString: () => string;
							valueOf: () => Float32Array;
							entries: () => IterableIterator<[number, number]>;
							keys: () => IterableIterator<number>;
							values: () => IterableIterator<number>;
							includes: (searchElement: number, fromIndex?: number | undefined) => boolean;
							[Symbol.iterator]: () => IterableIterator<number>;
							readonly [Symbol.toStringTag]: 'Float32Array';
							at: (index: number) => number | undefined;
						};
						values: {
							[x: number]: number;
							readonly BYTES_PER_ELEMENT: number;
							readonly buffer:
								| {
										readonly byteLength: number;
										slice: (begin: number, end?: number | undefined) => ArrayBuffer;
										readonly [Symbol.toStringTag]: string;
								  }
								| {
										readonly byteLength: number;
										slice: (begin: number, end?: number | undefined) => SharedArrayBuffer;
										readonly [Symbol.species]: SharedArrayBuffer;
										readonly [Symbol.toStringTag]: 'SharedArrayBuffer';
								  };
							readonly byteLength: number;
							readonly byteOffset: number;
							copyWithin: (target: number, start: number, end?: number | undefined) => Float32Array;
							every: (
								predicate: (value: number, index: number, array: Float32Array) => unknown,
								thisArg?: any
							) => boolean;
							fill: (value: number, start?: number | undefined, end?: number | undefined) => Float32Array;
							filter: (
								predicate: (value: number, index: number, array: Float32Array) => any,
								thisArg?: any
							) => Float32Array;
							find: (
								predicate: (value: number, index: number, obj: Float32Array) => boolean,
								thisArg?: any
							) => number | undefined;
							findIndex: (
								predicate: (value: number, index: number, obj: Float32Array) => boolean,
								thisArg?: any
							) => number;
							forEach: (
								callbackfn: (value: number, index: number, array: Float32Array) => void,
								thisArg?: any
							) => void;
							indexOf: (searchElement: number, fromIndex?: number | undefined) => number;
							join: (separator?: string | undefined) => string;
							lastIndexOf: (searchElement: number, fromIndex?: number | undefined) => number;
							readonly length: number;
							map: (
								callbackfn: (value: number, index: number, array: Float32Array) => number,
								thisArg?: any
							) => Float32Array;
							reduce: {
								(
									callbackfn: (
										previousValue: number,
										currentValue: number,
										currentIndex: number,
										array: Float32Array
									) => number
								): number;
								(
									callbackfn: (
										previousValue: number,
										currentValue: number,
										currentIndex: number,
										array: Float32Array
									) => number,
									initialValue: number
								): number;
								<U>(
									callbackfn: (
										previousValue: U,
										currentValue: number,
										currentIndex: number,
										array: Float32Array
									) => U,
									initialValue: U
								): U;
							};
							reduceRight: {
								(
									callbackfn: (
										previousValue: number,
										currentValue: number,
										currentIndex: number,
										array: Float32Array
									) => number
								): number;
								(
									callbackfn: (
										previousValue: number,
										currentValue: number,
										currentIndex: number,
										array: Float32Array
									) => number,
									initialValue: number
								): number;
								<U_1>(
									callbackfn: (
										previousValue: U_1,
										currentValue: number,
										currentIndex: number,
										array: Float32Array
									) => U_1,
									initialValue: U_1
								): U_1;
							};
							reverse: () => Float32Array;
							set: (array: ArrayLike<number>, offset?: number | undefined) => void;
							slice: (start?: number | undefined, end?: number | undefined) => Float32Array;
							some: (
								predicate: (value: number, index: number, array: Float32Array) => unknown,
								thisArg?: any
							) => boolean;
							sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
							subarray: (begin?: number | undefined, end?: number | undefined) => Float32Array;
							toLocaleString: () => string;
							toString: () => string;
							valueOf: () => Float32Array;
							entries: () => IterableIterator<[number, number]>;
							keys: () => IterableIterator<number>;
							values: () => IterableIterator<number>;
							includes: (searchElement: number, fromIndex?: number | undefined) => boolean;
							[Symbol.iterator]: () => IterableIterator<number>;
							readonly [Symbol.toStringTag]: 'Float32Array';
							at: (index: number) => number | undefined;
						};
						ValueTypeName: string;
						TimeBufferType: {
							[x: number]: number;
							readonly BYTES_PER_ELEMENT: number;
							readonly buffer:
								| {
										readonly byteLength: number;
										slice: (begin: number, end?: number | undefined) => ArrayBuffer;
										readonly [Symbol.toStringTag]: string;
								  }
								| {
										readonly byteLength: number;
										slice: (begin: number, end?: number | undefined) => SharedArrayBuffer;
										readonly [Symbol.species]: SharedArrayBuffer;
										readonly [Symbol.toStringTag]: 'SharedArrayBuffer';
								  };
							readonly byteLength: number;
							readonly byteOffset: number;
							copyWithin: (target: number, start: number, end?: number | undefined) => Float32Array;
							every: (
								predicate: (value: number, index: number, array: Float32Array) => unknown,
								thisArg?: any
							) => boolean;
							fill: (value: number, start?: number | undefined, end?: number | undefined) => Float32Array;
							filter: (
								predicate: (value: number, index: number, array: Float32Array) => any,
								thisArg?: any
							) => Float32Array;
							find: (
								predicate: (value: number, index: number, obj: Float32Array) => boolean,
								thisArg?: any
							) => number | undefined;
							findIndex: (
								predicate: (value: number, index: number, obj: Float32Array) => boolean,
								thisArg?: any
							) => number;
							forEach: (
								callbackfn: (value: number, index: number, array: Float32Array) => void,
								thisArg?: any
							) => void;
							indexOf: (searchElement: number, fromIndex?: number | undefined) => number;
							join: (separator?: string | undefined) => string;
							lastIndexOf: (searchElement: number, fromIndex?: number | undefined) => number;
							readonly length: number;
							map: (
								callbackfn: (value: number, index: number, array: Float32Array) => number,
								thisArg?: any
							) => Float32Array;
							reduce: {
								(
									callbackfn: (
										previousValue: number,
										currentValue: number,
										currentIndex: number,
										array: Float32Array
									) => number
								): number;
								(
									callbackfn: (
										previousValue: number,
										currentValue: number,
										currentIndex: number,
										array: Float32Array
									) => number,
									initialValue: number
								): number;
								<U>(
									callbackfn: (
										previousValue: U,
										currentValue: number,
										currentIndex: number,
										array: Float32Array
									) => U,
									initialValue: U
								): U;
							};
							reduceRight: {
								(
									callbackfn: (
										previousValue: number,
										currentValue: number,
										currentIndex: number,
										array: Float32Array
									) => number
								): number;
								(
									callbackfn: (
										previousValue: number,
										currentValue: number,
										currentIndex: number,
										array: Float32Array
									) => number,
									initialValue: number
								): number;
								<U_1>(
									callbackfn: (
										previousValue: U_1,
										currentValue: number,
										currentIndex: number,
										array: Float32Array
									) => U_1,
									initialValue: U_1
								): U_1;
							};
							reverse: () => Float32Array;
							set: (array: ArrayLike<number>, offset?: number | undefined) => void;
							slice: (start?: number | undefined, end?: number | undefined) => Float32Array;
							some: (
								predicate: (value: number, index: number, array: Float32Array) => unknown,
								thisArg?: any
							) => boolean;
							sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
							subarray: (begin?: number | undefined, end?: number | undefined) => Float32Array;
							toLocaleString: () => string;
							toString: () => string;
							valueOf: () => Float32Array;
							entries: () => IterableIterator<[number, number]>;
							keys: () => IterableIterator<number>;
							values: () => IterableIterator<number>;
							includes: (searchElement: number, fromIndex?: number | undefined) => boolean;
							[Symbol.iterator]: () => IterableIterator<number>;
							readonly [Symbol.toStringTag]: 'Float32Array';
							at: (index: number) => number | undefined;
						};
						ValueBufferType: {
							[x: number]: number;
							readonly BYTES_PER_ELEMENT: number;
							readonly buffer:
								| {
										readonly byteLength: number;
										slice: (begin: number, end?: number | undefined) => ArrayBuffer;
										readonly [Symbol.toStringTag]: string;
								  }
								| {
										readonly byteLength: number;
										slice: (begin: number, end?: number | undefined) => SharedArrayBuffer;
										readonly [Symbol.species]: SharedArrayBuffer;
										readonly [Symbol.toStringTag]: 'SharedArrayBuffer';
								  };
							readonly byteLength: number;
							readonly byteOffset: number;
							copyWithin: (target: number, start: number, end?: number | undefined) => Float32Array;
							every: (
								predicate: (value: number, index: number, array: Float32Array) => unknown,
								thisArg?: any
							) => boolean;
							fill: (value: number, start?: number | undefined, end?: number | undefined) => Float32Array;
							filter: (
								predicate: (value: number, index: number, array: Float32Array) => any,
								thisArg?: any
							) => Float32Array;
							find: (
								predicate: (value: number, index: number, obj: Float32Array) => boolean,
								thisArg?: any
							) => number | undefined;
							findIndex: (
								predicate: (value: number, index: number, obj: Float32Array) => boolean,
								thisArg?: any
							) => number;
							forEach: (
								callbackfn: (value: number, index: number, array: Float32Array) => void,
								thisArg?: any
							) => void;
							indexOf: (searchElement: number, fromIndex?: number | undefined) => number;
							join: (separator?: string | undefined) => string;
							lastIndexOf: (searchElement: number, fromIndex?: number | undefined) => number;
							readonly length: number;
							map: (
								callbackfn: (value: number, index: number, array: Float32Array) => number,
								thisArg?: any
							) => Float32Array;
							reduce: {
								(
									callbackfn: (
										previousValue: number,
										currentValue: number,
										currentIndex: number,
										array: Float32Array
									) => number
								): number;
								(
									callbackfn: (
										previousValue: number,
										currentValue: number,
										currentIndex: number,
										array: Float32Array
									) => number,
									initialValue: number
								): number;
								<U>(
									callbackfn: (
										previousValue: U,
										currentValue: number,
										currentIndex: number,
										array: Float32Array
									) => U,
									initialValue: U
								): U;
							};
							reduceRight: {
								(
									callbackfn: (
										previousValue: number,
										currentValue: number,
										currentIndex: number,
										array: Float32Array
									) => number
								): number;
								(
									callbackfn: (
										previousValue: number,
										currentValue: number,
										currentIndex: number,
										array: Float32Array
									) => number,
									initialValue: number
								): number;
								<U_1>(
									callbackfn: (
										previousValue: U_1,
										currentValue: number,
										currentIndex: number,
										array: Float32Array
									) => U_1,
									initialValue: U_1
								): U_1;
							};
							reverse: () => Float32Array;
							set: (array: ArrayLike<number>, offset?: number | undefined) => void;
							slice: (start?: number | undefined, end?: number | undefined) => Float32Array;
							some: (
								predicate: (value: number, index: number, array: Float32Array) => unknown,
								thisArg?: any
							) => boolean;
							sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
							subarray: (begin?: number | undefined, end?: number | undefined) => Float32Array;
							toLocaleString: () => string;
							toString: () => string;
							valueOf: () => Float32Array;
							entries: () => IterableIterator<[number, number]>;
							keys: () => IterableIterator<number>;
							values: () => IterableIterator<number>;
							includes: (searchElement: number, fromIndex?: number | undefined) => boolean;
							[Symbol.iterator]: () => IterableIterator<number>;
							readonly [Symbol.toStringTag]: 'Float32Array';
							at: (index: number) => number | undefined;
						};
						DefaultInterpolation: InterpolationModes;
						InterpolantFactoryMethodDiscrete: (result: any) => DiscreteInterpolant;
						InterpolantFactoryMethodLinear: (result: any) => LinearInterpolant;
						InterpolantFactoryMethodSmooth: (result: any) => CubicInterpolant;
						setInterpolation: (interpolation: InterpolationModes) => KeyframeTrack;
						getInterpolation: () => InterpolationModes;
						createInterpolant: () => Interpolant;
						getValueSize: () => number;
						shift: (timeOffset: number) => KeyframeTrack;
						scale: (timeScale: number) => KeyframeTrack;
						trim: (startTime: number, endTime: number) => KeyframeTrack;
						validate: () => boolean;
						optimize: () => KeyframeTrack;
						clone: () => KeyframeTrack;
					}[];
					blendMode: AnimationBlendMode;
					duration: number;
					uuid: string;
					results: any[];
					resetDuration: () => AnimationClip;
					trim: () => AnimationClip;
					validate: () => boolean;
					optimize: () => AnimationClip;
					clone: () => AnimationClip;
					toJSON: (clip: AnimationClip) => any;
				}[];
				userData: {
					[key: string]: any;
				};
				customDepthMaterial: {
					alphaTest: number;
					alphaToCoverage: boolean;
					blendDst: BlendingDstFactor;
					blendDstAlpha: number | null;
					blendEquation: BlendingEquation;
					blendEquationAlpha: number | null;
					blending: Blending;
					blendSrc: BlendingDstFactor | BlendingSrcFactor;
					blendSrcAlpha: number | null;
					clipIntersection: boolean;
					clippingPlanes: any;
					clipShadows: boolean;
					colorWrite: boolean;
					defines:
						| {
								[key: string]: any;
						  }
						| undefined;
					depthFunc: DepthModes;
					depthTest: boolean;
					depthWrite: boolean;
					id: number;
					stencilWrite: boolean;
					stencilFunc: StencilFunc;
					stencilRef: number;
					stencilWriteMask: number;
					stencilFuncMask: number;
					stencilFail: StencilOp;
					stencilZFail: StencilOp;
					stencilZPass: StencilOp;
					readonly isMaterial: true;
					name: string;
					needsUpdate: boolean;
					opacity: number;
					polygonOffset: boolean;
					polygonOffsetFactor: number;
					polygonOffsetUnits: number;
					precision: 'highp' | 'mediump' | 'lowp' | null;
					premultipliedAlpha: boolean;
					forceSinglePass: boolean;
					dithering: boolean;
					side: Side;
					shadowSide: Side | null;
					toneMapped: boolean;
					transparent: boolean;
					type: string;
					uuid: string;
					vertexColors: boolean;
					visible: boolean;
					userData: any;
					version: number;
					clone: () => Material;
					copy: (material: Material) => Material;
					dispose: () => void;
					onBeforeCompile: (shader: Shader, renderer: WebGLRenderer) => void;
					customProgramCacheKey: () => string;
					setValues: (values: MaterialParameters) => void;
					toJSON: (meta?: any) => any;
					addEventListener: <T extends string>(type: T, listener: EventListener<Event, T, Material>) => void;
					hasEventListener: <T_1 extends string>(
						type: T_1,
						listener: EventListener<Event, T_1, Material>
					) => boolean;
					removeEventListener: <T_2 extends string>(
						type: T_2,
						listener: EventListener<Event, T_2, Material>
					) => void;
					dispatchEvent: (event: Event) => void;
				};
				customDistanceMaterial: {
					alphaTest: number;
					alphaToCoverage: boolean;
					blendDst: BlendingDstFactor;
					blendDstAlpha: number | null;
					blendEquation: BlendingEquation;
					blendEquationAlpha: number | null;
					blending: Blending;
					blendSrc: BlendingDstFactor | BlendingSrcFactor;
					blendSrcAlpha: number | null;
					clipIntersection: boolean;
					clippingPlanes: any;
					clipShadows: boolean;
					colorWrite: boolean;
					defines:
						| {
								[key: string]: any;
						  }
						| undefined;
					depthFunc: DepthModes;
					depthTest: boolean;
					depthWrite: boolean;
					id: number;
					stencilWrite: boolean;
					stencilFunc: StencilFunc;
					stencilRef: number;
					stencilWriteMask: number;
					stencilFuncMask: number;
					stencilFail: StencilOp;
					stencilZFail: StencilOp;
					stencilZPass: StencilOp;
					readonly isMaterial: true;
					name: string;
					needsUpdate: boolean;
					opacity: number;
					polygonOffset: boolean;
					polygonOffsetFactor: number;
					polygonOffsetUnits: number;
					precision: 'highp' | 'mediump' | 'lowp' | null;
					premultipliedAlpha: boolean;
					forceSinglePass: boolean;
					dithering: boolean;
					side: Side;
					shadowSide: Side | null;
					toneMapped: boolean;
					transparent: boolean;
					type: string;
					uuid: string;
					vertexColors: boolean;
					visible: boolean;
					userData: any;
					version: number;
					clone: () => Material;
					copy: (material: Material) => Material;
					dispose: () => void;
					onBeforeCompile: (shader: Shader, renderer: WebGLRenderer) => void;
					customProgramCacheKey: () => string;
					setValues: (values: MaterialParameters) => void;
					toJSON: (meta?: any) => any;
					addEventListener: <T extends string>(type: T, listener: EventListener<Event, T, Material>) => void;
					hasEventListener: <T_1 extends string>(
						type: T_1,
						listener: EventListener<Event, T_1, Material>
					) => boolean;
					removeEventListener: <T_2 extends string>(
						type: T_2,
						listener: EventListener<Event, T_2, Material>
					) => void;
					dispatchEvent: (event: Event) => void;
				};
				readonly isObject3D: true;
				onBeforeRender: (
					renderer: WebGLRenderer,
					scene: Scene,
					camera: Camera,
					geometry: BufferGeometry,
					material: Material,
					group: Group
				) => void;
				onAfterRender: (
					renderer: WebGLRenderer,
					scene: Scene,
					camera: Camera,
					geometry: BufferGeometry,
					material: Material,
					group: Group
				) => void;
				applyMatrix4: (matrix: Matrix4) => void;
				applyQuaternion: (quaternion: Quaternion) => Object3D<Event>;
				setRotationFromAxisAngle: (axis: Vector3, angle: number) => void;
				setRotationFromEuler: (euler: Euler) => void;
				setRotationFromMatrix: (m: Matrix4) => void;
				setRotationFromQuaternion: (q: Quaternion) => void;
				rotateOnAxis: (axis: Vector3, angle: number) => Object3D<Event>;
				rotateOnWorldAxis: (axis: Vector3, angle: number) => Object3D<Event>;
				rotateX: (angle: number) => Object3D<Event>;
				rotateY: (angle: number) => Object3D<Event>;
				rotateZ: (angle: number) => Object3D<Event>;
				translateOnAxis: (axis: Vector3, distance: number) => Object3D<Event>;
				translateX: (distance: number) => Object3D<Event>;
				translateY: (distance: number) => Object3D<Event>;
				translateZ: (distance: number) => Object3D<Event>;
				localToWorld: (vector: Vector3) => Vector3;
				worldToLocal: (vector: Vector3) => Vector3;
				lookAt: {
					(vector: Vector3): void;
					(x: number, y: number, z: number): void;
				};
				add: (...object: Object3D<Event>[]) => Object3D<Event>;
				remove: (...object: Object3D<Event>[]) => Object3D<Event>;
				removeFromParent: () => Object3D<Event>;
				clear: () => Object3D<Event>;
				attach: (object: Object3D<Event>) => Object3D<Event>;
				getObjectById: (id: number) => Object3D<Event> | undefined;
				getObjectByName: (name: string) => Object3D<Event> | undefined;
				getObjectByProperty: (name: string, value: any) => Object3D<Event> | undefined;
				getObjectsByProperty: (name: string, value: any) => Object3D<Event>[];
				getWorldPosition: (target: Vector3) => Vector3;
				getWorldQuaternion: (target: Quaternion) => Quaternion;
				getWorldScale: (target: Vector3) => Vector3;
				getWorldDirection: (target: Vector3) => Vector3;
				raycast: (raycaster: Raycaster, intersects: Intersection<Object3D<Event>>[]) => void;
				traverse: (callback: (object: Object3D<Event>) => any) => void;
				traverseVisible: (callback: (object: Object3D<Event>) => any) => void;
				traverseAncestors: (callback: (object: Object3D<Event>) => any) => void;
				updateMatrix: () => void;
				updateMatrixWorld: (force?: boolean | undefined) => void;
				updateWorldMatrix: (updateParents: boolean, updateChildren: boolean) => void;
				toJSON: (
					meta?:
						| {
								geometries: any;
								materials: any;
								textures: any;
								images: any;
						  }
						| undefined
				) => any;
				clone: (recursive?: boolean | undefined) => Object3D<Event>;
				copy: (source: Object3D<Event>, recursive?: boolean | undefined) => Object3D<Event>;
				addEventListener: <T_3 extends string>(
					type: T_3,
					listener: EventListener<Event, T_3, Object3D<Event>>
				) => void;
				hasEventListener: <T_4 extends string>(
					type: T_4,
					listener: EventListener<Event, T_4, Object3D<Event>>
				) => boolean;
				removeEventListener: <T_5 extends string>(
					type: T_5,
					listener: EventListener<Event, T_5, Object3D<Event>>
				) => void;
				dispatchEvent: (event: Event) => void;
			} | null;
			children: {
				id: number;
				uuid: string;
				name: string;
				type: string;
				parent: any | null;
				children: any[];
				up: {
					x: number;
					y: number;
					z: number;
					readonly isVector3: true;
					set: (x: number, y: number, z: number) => Vector3;
					setScalar: (scalar: number) => Vector3;
					setX: (x: number) => Vector3;
					setY: (y: number) => Vector3;
					setZ: (z: number) => Vector3;
					setComponent: (index: number, value: number) => Vector3;
					getComponent: (index: number) => number;
					clone: () => Vector3;
					copy: (v: Vector3) => Vector3;
					add: (v: Vector3) => Vector3;
					addScalar: (s: number) => Vector3;
					addScaledVector: (v: Vector3, s: number) => Vector3;
					addVectors: (a: Vector3, b: Vector3) => Vector3;
					sub: (a: Vector3) => Vector3;
					subScalar: (s: number) => Vector3;
					subVectors: (a: Vector3, b: Vector3) => Vector3;
					multiply: (v: Vector3) => Vector3;
					multiplyScalar: (s: number) => Vector3;
					multiplyVectors: (a: Vector3, b: Vector3) => Vector3;
					applyEuler: (euler: Euler) => Vector3;
					applyAxisAngle: (axis: Vector3, angle: number) => Vector3;
					applyMatrix3: (m: Matrix3) => Vector3;
					applyNormalMatrix: (m: Matrix3) => Vector3;
					applyMatrix4: (m: Matrix4) => Vector3;
					applyQuaternion: (q: Quaternion) => Vector3;
					project: (camera: Camera) => Vector3;
					unproject: (camera: Camera) => Vector3;
					transformDirection: (m: Matrix4) => Vector3;
					divide: (v: Vector3) => Vector3;
					divideScalar: (s: number) => Vector3;
					min: (v: Vector3) => Vector3;
					max: (v: Vector3) => Vector3;
					clamp: (min: Vector3, max: Vector3) => Vector3;
					clampScalar: (min: number, max: number) => Vector3;
					clampLength: (min: number, max: number) => Vector3;
					floor: () => Vector3;
					ceil: () => Vector3;
					round: () => Vector3;
					roundToZero: () => Vector3;
					negate: () => Vector3;
					dot: (v: Vector3) => number;
					lengthSq: () => number;
					length: () => number;
					lengthManhattan: () => number;
					manhattanLength: () => number;
					manhattanDistanceTo: (v: Vector3) => number;
					normalize: () => Vector3;
					setLength: (l: number) => Vector3;
					lerp: (v: Vector3, alpha: number) => Vector3;
					lerpVectors: (v1: Vector3, v2: Vector3, alpha: number) => Vector3;
					cross: (a: Vector3) => Vector3;
					crossVectors: (a: Vector3, b: Vector3) => Vector3;
					projectOnVector: (v: Vector3) => Vector3;
					projectOnPlane: (planeNormal: Vector3) => Vector3;
					reflect: (vector: Vector3) => Vector3;
					angleTo: (v: Vector3) => number;
					distanceTo: (v: Vector3) => number;
					distanceToSquared: (v: Vector3) => number;
					distanceToManhattan: (v: Vector3) => number;
					setFromSpherical: (s: Spherical) => Vector3;
					setFromSphericalCoords: (r: number, phi: number, theta: number) => Vector3;
					setFromCylindrical: (s: Cylindrical) => Vector3;
					setFromCylindricalCoords: (radius: number, theta: number, y: number) => Vector3;
					setFromMatrixPosition: (m: Matrix4) => Vector3;
					setFromMatrixScale: (m: Matrix4) => Vector3;
					setFromMatrixColumn: (matrix: Matrix4, index: number) => Vector3;
					setFromMatrix3Column: (matrix: Matrix3, index: number) => Vector3;
					setFromEuler: (e: Euler) => Vector3;
					equals: (v: Vector3) => boolean;
					fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Vector3;
					toArray: {
						(array?: number[] | undefined, offset?: number | undefined): number[];
						(array?: Vector3Tuple | undefined, offset?: 0 | undefined): Vector3Tuple;
						(array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
					};
					fromBufferAttribute: (
						attribute: BufferAttribute | InterleavedBufferAttribute,
						index: number
					) => Vector3;
					random: () => Vector3;
					randomDirection: () => Vector3;
				};
				readonly position: {
					x: number;
					y: number;
					z: number;
					readonly isVector3: true;
					set: (x: number, y: number, z: number) => Vector3;
					setScalar: (scalar: number) => Vector3;
					setX: (x: number) => Vector3;
					setY: (y: number) => Vector3;
					setZ: (z: number) => Vector3;
					setComponent: (index: number, value: number) => Vector3;
					getComponent: (index: number) => number;
					clone: () => Vector3;
					copy: (v: Vector3) => Vector3;
					add: (v: Vector3) => Vector3;
					addScalar: (s: number) => Vector3;
					addScaledVector: (v: Vector3, s: number) => Vector3;
					addVectors: (a: Vector3, b: Vector3) => Vector3;
					sub: (a: Vector3) => Vector3;
					subScalar: (s: number) => Vector3;
					subVectors: (a: Vector3, b: Vector3) => Vector3;
					multiply: (v: Vector3) => Vector3;
					multiplyScalar: (s: number) => Vector3;
					multiplyVectors: (a: Vector3, b: Vector3) => Vector3;
					applyEuler: (euler: Euler) => Vector3;
					applyAxisAngle: (axis: Vector3, angle: number) => Vector3;
					applyMatrix3: (m: Matrix3) => Vector3;
					applyNormalMatrix: (m: Matrix3) => Vector3;
					applyMatrix4: (m: Matrix4) => Vector3;
					applyQuaternion: (q: Quaternion) => Vector3;
					project: (camera: Camera) => Vector3;
					unproject: (camera: Camera) => Vector3;
					transformDirection: (m: Matrix4) => Vector3;
					divide: (v: Vector3) => Vector3;
					divideScalar: (s: number) => Vector3;
					min: (v: Vector3) => Vector3;
					max: (v: Vector3) => Vector3;
					clamp: (min: Vector3, max: Vector3) => Vector3;
					clampScalar: (min: number, max: number) => Vector3;
					clampLength: (min: number, max: number) => Vector3;
					floor: () => Vector3;
					ceil: () => Vector3;
					round: () => Vector3;
					roundToZero: () => Vector3;
					negate: () => Vector3;
					dot: (v: Vector3) => number;
					lengthSq: () => number;
					length: () => number;
					lengthManhattan: () => number;
					manhattanLength: () => number;
					manhattanDistanceTo: (v: Vector3) => number;
					normalize: () => Vector3;
					setLength: (l: number) => Vector3;
					lerp: (v: Vector3, alpha: number) => Vector3;
					lerpVectors: (v1: Vector3, v2: Vector3, alpha: number) => Vector3;
					cross: (a: Vector3) => Vector3;
					crossVectors: (a: Vector3, b: Vector3) => Vector3;
					projectOnVector: (v: Vector3) => Vector3;
					projectOnPlane: (planeNormal: Vector3) => Vector3;
					reflect: (vector: Vector3) => Vector3;
					angleTo: (v: Vector3) => number;
					distanceTo: (v: Vector3) => number;
					distanceToSquared: (v: Vector3) => number;
					distanceToManhattan: (v: Vector3) => number;
					setFromSpherical: (s: Spherical) => Vector3;
					setFromSphericalCoords: (r: number, phi: number, theta: number) => Vector3;
					setFromCylindrical: (s: Cylindrical) => Vector3;
					setFromCylindricalCoords: (radius: number, theta: number, y: number) => Vector3;
					setFromMatrixPosition: (m: Matrix4) => Vector3;
					setFromMatrixScale: (m: Matrix4) => Vector3;
					setFromMatrixColumn: (matrix: Matrix4, index: number) => Vector3;
					setFromMatrix3Column: (matrix: Matrix3, index: number) => Vector3;
					setFromEuler: (e: Euler) => Vector3;
					equals: (v: Vector3) => boolean;
					fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Vector3;
					toArray: {
						(array?: number[] | undefined, offset?: number | undefined): number[];
						(array?: Vector3Tuple | undefined, offset?: 0 | undefined): Vector3Tuple;
						(array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
					};
					fromBufferAttribute: (
						attribute: BufferAttribute | InterleavedBufferAttribute,
						index: number
					) => Vector3;
					random: () => Vector3;
					randomDirection: () => Vector3;
				};
				readonly rotation: {
					x: number;
					y: number;
					z: number;
					order: EulerOrder;
					readonly isEuler: true;
					_onChangeCallback: () => void;
					set: (x: number, y: number, z: number, order?: EulerOrder | undefined) => Euler;
					clone: () => Euler;
					copy: (euler: Euler) => Euler;
					setFromRotationMatrix: (
						m: Matrix4,
						order?: EulerOrder | undefined,
						update?: boolean | undefined
					) => Euler;
					setFromQuaternion: (
						q: Quaternion,
						order?: EulerOrder | undefined,
						update?: boolean | undefined
					) => Euler;
					setFromVector3: (v: Vector3, order?: EulerOrder | undefined) => Euler;
					reorder: (newOrder: EulerOrder) => Euler;
					equals: (euler: Euler) => boolean;
					fromArray: (xyzo: [number, number, number, (EulerOrder | undefined)?, ...any[]]) => Euler;
					toArray: (
						array?: (string | number | undefined)[] | undefined,
						offset?: number | undefined
					) => (string | number | undefined)[];
					_onChange: (callback: () => void) => Euler;
					[Symbol.iterator]: () => Generator<string | number, void, unknown>;
				};
				readonly quaternion: {
					x: number;
					y: number;
					z: number;
					w: number;
					readonly isQuaternion: true;
					set: (x: number, y: number, z: number, w: number) => Quaternion;
					clone: () => Quaternion;
					copy: (q: Quaternion) => Quaternion;
					setFromEuler: (euler: Euler, update?: boolean | undefined) => Quaternion;
					setFromAxisAngle: (axis: Vector3, angle: number) => Quaternion;
					setFromRotationMatrix: (m: Matrix4) => Quaternion;
					setFromUnitVectors: (vFrom: Vector3, vTo: Vector3) => Quaternion;
					angleTo: (q: Quaternion) => number;
					rotateTowards: (q: Quaternion, step: number) => Quaternion;
					identity: () => Quaternion;
					invert: () => Quaternion;
					conjugate: () => Quaternion;
					dot: (v: Quaternion) => number;
					lengthSq: () => number;
					length: () => number;
					normalize: () => Quaternion;
					multiply: (q: Quaternion) => Quaternion;
					premultiply: (q: Quaternion) => Quaternion;
					multiplyQuaternions: (a: Quaternion, b: Quaternion) => Quaternion;
					slerp: (qb: Quaternion, t: number) => Quaternion;
					slerpQuaternions: (qa: Quaternion, qb: Quaternion, t: number) => Quaternion;
					equals: (v: Quaternion) => boolean;
					fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Quaternion;
					toArray: {
						(array?: number[] | undefined, offset?: number | undefined): number[];
						(array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
					};
					fromBufferAttribute: (
						attribute: BufferAttribute | InterleavedBufferAttribute,
						index: number
					) => Quaternion;
					_onChange: (callback: () => void) => Quaternion;
					_onChangeCallback: () => void;
					multiplyVector3: (v: any) => any;
					random: () => Quaternion;
					[Symbol.iterator]: () => Generator<number, void, unknown>;
				};
				readonly scale: {
					x: number;
					y: number;
					z: number;
					readonly isVector3: true;
					set: (x: number, y: number, z: number) => Vector3;
					setScalar: (scalar: number) => Vector3;
					setX: (x: number) => Vector3;
					setY: (y: number) => Vector3;
					setZ: (z: number) => Vector3;
					setComponent: (index: number, value: number) => Vector3;
					getComponent: (index: number) => number;
					clone: () => Vector3;
					copy: (v: Vector3) => Vector3;
					add: (v: Vector3) => Vector3;
					addScalar: (s: number) => Vector3;
					addScaledVector: (v: Vector3, s: number) => Vector3;
					addVectors: (a: Vector3, b: Vector3) => Vector3;
					sub: (a: Vector3) => Vector3;
					subScalar: (s: number) => Vector3;
					subVectors: (a: Vector3, b: Vector3) => Vector3;
					multiply: (v: Vector3) => Vector3;
					multiplyScalar: (s: number) => Vector3;
					multiplyVectors: (a: Vector3, b: Vector3) => Vector3;
					applyEuler: (euler: Euler) => Vector3;
					applyAxisAngle: (axis: Vector3, angle: number) => Vector3;
					applyMatrix3: (m: Matrix3) => Vector3;
					applyNormalMatrix: (m: Matrix3) => Vector3;
					applyMatrix4: (m: Matrix4) => Vector3;
					applyQuaternion: (q: Quaternion) => Vector3;
					project: (camera: Camera) => Vector3;
					unproject: (camera: Camera) => Vector3;
					transformDirection: (m: Matrix4) => Vector3;
					divide: (v: Vector3) => Vector3;
					divideScalar: (s: number) => Vector3;
					min: (v: Vector3) => Vector3;
					max: (v: Vector3) => Vector3;
					clamp: (min: Vector3, max: Vector3) => Vector3;
					clampScalar: (min: number, max: number) => Vector3;
					clampLength: (min: number, max: number) => Vector3;
					floor: () => Vector3;
					ceil: () => Vector3;
					round: () => Vector3;
					roundToZero: () => Vector3;
					negate: () => Vector3;
					dot: (v: Vector3) => number;
					lengthSq: () => number;
					length: () => number;
					lengthManhattan: () => number;
					manhattanLength: () => number;
					manhattanDistanceTo: (v: Vector3) => number;
					normalize: () => Vector3;
					setLength: (l: number) => Vector3;
					lerp: (v: Vector3, alpha: number) => Vector3;
					lerpVectors: (v1: Vector3, v2: Vector3, alpha: number) => Vector3;
					cross: (a: Vector3) => Vector3;
					crossVectors: (a: Vector3, b: Vector3) => Vector3;
					projectOnVector: (v: Vector3) => Vector3;
					projectOnPlane: (planeNormal: Vector3) => Vector3;
					reflect: (vector: Vector3) => Vector3;
					angleTo: (v: Vector3) => number;
					distanceTo: (v: Vector3) => number;
					distanceToSquared: (v: Vector3) => number;
					distanceToManhattan: (v: Vector3) => number;
					setFromSpherical: (s: Spherical) => Vector3;
					setFromSphericalCoords: (r: number, phi: number, theta: number) => Vector3;
					setFromCylindrical: (s: Cylindrical) => Vector3;
					setFromCylindricalCoords: (radius: number, theta: number, y: number) => Vector3;
					setFromMatrixPosition: (m: Matrix4) => Vector3;
					setFromMatrixScale: (m: Matrix4) => Vector3;
					setFromMatrixColumn: (matrix: Matrix4, index: number) => Vector3;
					setFromMatrix3Column: (matrix: Matrix3, index: number) => Vector3;
					setFromEuler: (e: Euler) => Vector3;
					equals: (v: Vector3) => boolean;
					fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Vector3;
					toArray: {
						(array?: number[] | undefined, offset?: number | undefined): number[];
						(array?: Vector3Tuple | undefined, offset?: 0 | undefined): Vector3Tuple;
						(array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
					};
					fromBufferAttribute: (
						attribute: BufferAttribute | InterleavedBufferAttribute,
						index: number
					) => Vector3;
					random: () => Vector3;
					randomDirection: () => Vector3;
				};
				readonly modelViewMatrix: {
					elements: number[];
					set: (
						n11: number,
						n12: number,
						n13: number,
						n14: number,
						n21: number,
						n22: number,
						n23: number,
						n24: number,
						n31: number,
						n32: number,
						n33: number,
						n34: number,
						n41: number,
						n42: number,
						n43: number,
						n44: number
					) => Matrix4;
					identity: () => Matrix4;
					clone: () => Matrix4;
					copy: (m: Matrix4) => Matrix4;
					copyPosition: (m: Matrix4) => Matrix4;
					extractBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix4;
					makeBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix4;
					extractRotation: (m: Matrix4) => Matrix4;
					makeRotationFromEuler: (euler: Euler) => Matrix4;
					makeRotationFromQuaternion: (q: Quaternion) => Matrix4;
					lookAt: (eye: Vector3, target: Vector3, up: Vector3) => Matrix4;
					multiply: (m: Matrix4) => Matrix4;
					premultiply: (m: Matrix4) => Matrix4;
					multiplyMatrices: (a: Matrix4, b: Matrix4) => Matrix4;
					multiplyToArray: (a: Matrix4, b: Matrix4, r: number[]) => Matrix4;
					multiplyScalar: (s: number) => Matrix4;
					determinant: () => number;
					transpose: () => Matrix4;
					setPosition: (v: number | Vector3, y?: number | undefined, z?: number | undefined) => Matrix4;
					invert: () => Matrix4;
					scale: (v: Vector3) => Matrix4;
					getMaxScaleOnAxis: () => number;
					makeTranslation: (x: number, y: number, z: number) => Matrix4;
					makeRotationX: (theta: number) => Matrix4;
					makeRotationY: (theta: number) => Matrix4;
					makeRotationZ: (theta: number) => Matrix4;
					makeRotationAxis: (axis: Vector3, angle: number) => Matrix4;
					makeScale: (x: number, y: number, z: number) => Matrix4;
					makeShear: (xy: number, xz: number, yx: number, yz: number, zx: number, zy: number) => Matrix4;
					compose: (translation: Vector3, rotation: Quaternion, scale: Vector3) => Matrix4;
					decompose: (translation: Vector3, rotation: Quaternion, scale: Vector3) => Matrix4;
					makePerspective: {
						(left: number, right: number, bottom: number, top: number, near: number, far: number): Matrix4;
						(fov: number, aspect: number, near: number, far: number): Matrix4;
					};
					makeOrthographic: (
						left: number,
						right: number,
						top: number,
						bottom: number,
						near: number,
						far: number
					) => Matrix4;
					equals: (matrix: Matrix4) => boolean;
					fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Matrix4;
					toArray: {
						(array?: number[] | undefined, offset?: number | undefined): number[];
						(array?: Matrix4Tuple | undefined, offset?: 0 | undefined): Matrix4Tuple;
						(array?: ArrayLike<number> | undefined, offset?: number | undefined): ArrayLike<number>;
					};
					setFromMatrix3: (m: Matrix3) => Matrix4;
					extractPosition: (m: Matrix4) => Matrix4;
					setRotationFromQuaternion: (q: Quaternion) => Matrix4;
					multiplyVector3: (v: any) => any;
					multiplyVector4: (v: any) => any;
					multiplyVector3Array: (array: number[]) => number[];
					rotateAxis: (v: any) => void;
					crossVector: (v: any) => void;
					flattenToArrayOffset: (array: number[], offset: number) => number[];
					getInverse: (matrix: Matrix) => Matrix;
				};
				readonly normalMatrix: {
					elements: number[];
					set: (
						n11: number,
						n12: number,
						n13: number,
						n21: number,
						n22: number,
						n23: number,
						n31: number,
						n32: number,
						n33: number
					) => Matrix3;
					identity: () => Matrix3;
					clone: () => Matrix3;
					copy: (m: Matrix3) => Matrix3;
					extractBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix3;
					setFromMatrix4: (m: Matrix4) => Matrix3;
					multiplyScalar: (s: number) => Matrix3;
					determinant: () => number;
					invert: () => Matrix3;
					transpose: () => Matrix3;
					getNormalMatrix: (matrix4: Matrix4) => Matrix3;
					transposeIntoArray: (r: number[]) => Matrix3;
					setUvTransform: (
						tx: number,
						ty: number,
						sx: number,
						sy: number,
						rotation: number,
						cx: number,
						cy: number
					) => Matrix3;
					scale: (sx: number, sy: number) => Matrix3;
					makeTranslation: {
						(x: number, y: number): Matrix3;
						(x: number, y: number): Matrix3;
					};
					makeRotation: {
						(theta: number): Matrix3;
						(theta: number): Matrix3;
					};
					makeScale: {
						(x: number, y: number): Matrix3;
						(x: number, y: number): Matrix3;
					};
					rotate: (theta: number) => Matrix3;
					translate: (tx: number, ty: number) => Matrix3;
					equals: (matrix: Matrix3) => boolean;
					fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Matrix3;
					toArray: {
						(array?: number[] | undefined, offset?: number | undefined): number[];
						(array?: Matrix3Tuple | undefined, offset?: 0 | undefined): Matrix3Tuple;
						(array?: ArrayLike<number> | undefined, offset?: number | undefined): ArrayLike<number>;
					};
					multiply: (m: Matrix3) => Matrix3;
					premultiply: (m: Matrix3) => Matrix3;
					multiplyMatrices: (a: Matrix3, b: Matrix3) => Matrix3;
					multiplyVector3: (vector: Vector3) => any;
					multiplyVector3Array: (a: any) => any;
					getInverse: {
						(matrix: Matrix4, throwOnDegenerate?: boolean | undefined): Matrix3;
						(matrix: Matrix): Matrix;
					};
					flattenToArrayOffset: (array: number[], offset: number) => number[];
				};
				matrix: {
					elements: number[];
					set: (
						n11: number,
						n12: number,
						n13: number,
						n14: number,
						n21: number,
						n22: number,
						n23: number,
						n24: number,
						n31: number,
						n32: number,
						n33: number,
						n34: number,
						n41: number,
						n42: number,
						n43: number,
						n44: number
					) => Matrix4;
					identity: () => Matrix4;
					clone: () => Matrix4;
					copy: (m: Matrix4) => Matrix4;
					copyPosition: (m: Matrix4) => Matrix4;
					extractBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix4;
					makeBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix4;
					extractRotation: (m: Matrix4) => Matrix4;
					makeRotationFromEuler: (euler: Euler) => Matrix4;
					makeRotationFromQuaternion: (q: Quaternion) => Matrix4;
					lookAt: (eye: Vector3, target: Vector3, up: Vector3) => Matrix4;
					multiply: (m: Matrix4) => Matrix4;
					premultiply: (m: Matrix4) => Matrix4;
					multiplyMatrices: (a: Matrix4, b: Matrix4) => Matrix4;
					multiplyToArray: (a: Matrix4, b: Matrix4, r: number[]) => Matrix4;
					multiplyScalar: (s: number) => Matrix4;
					determinant: () => number;
					transpose: () => Matrix4;
					setPosition: (v: number | Vector3, y?: number | undefined, z?: number | undefined) => Matrix4;
					invert: () => Matrix4;
					scale: (v: Vector3) => Matrix4;
					getMaxScaleOnAxis: () => number;
					makeTranslation: (x: number, y: number, z: number) => Matrix4;
					makeRotationX: (theta: number) => Matrix4;
					makeRotationY: (theta: number) => Matrix4;
					makeRotationZ: (theta: number) => Matrix4;
					makeRotationAxis: (axis: Vector3, angle: number) => Matrix4;
					makeScale: (x: number, y: number, z: number) => Matrix4;
					makeShear: (xy: number, xz: number, yx: number, yz: number, zx: number, zy: number) => Matrix4;
					compose: (translation: Vector3, rotation: Quaternion, scale: Vector3) => Matrix4;
					decompose: (translation: Vector3, rotation: Quaternion, scale: Vector3) => Matrix4;
					makePerspective: {
						(left: number, right: number, bottom: number, top: number, near: number, far: number): Matrix4;
						(fov: number, aspect: number, near: number, far: number): Matrix4;
					};
					makeOrthographic: (
						left: number,
						right: number,
						top: number,
						bottom: number,
						near: number,
						far: number
					) => Matrix4;
					equals: (matrix: Matrix4) => boolean;
					fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Matrix4;
					toArray: {
						(array?: number[] | undefined, offset?: number | undefined): number[];
						(array?: Matrix4Tuple | undefined, offset?: 0 | undefined): Matrix4Tuple;
						(array?: ArrayLike<number> | undefined, offset?: number | undefined): ArrayLike<number>;
					};
					setFromMatrix3: (m: Matrix3) => Matrix4;
					extractPosition: (m: Matrix4) => Matrix4;
					setRotationFromQuaternion: (q: Quaternion) => Matrix4;
					multiplyVector3: (v: any) => any;
					multiplyVector4: (v: any) => any;
					multiplyVector3Array: (array: number[]) => number[];
					rotateAxis: (v: any) => void;
					crossVector: (v: any) => void;
					flattenToArrayOffset: (array: number[], offset: number) => number[];
					getInverse: (matrix: Matrix) => Matrix;
				};
				matrixWorld: {
					elements: number[];
					set: (
						n11: number,
						n12: number,
						n13: number,
						n14: number,
						n21: number,
						n22: number,
						n23: number,
						n24: number,
						n31: number,
						n32: number,
						n33: number,
						n34: number,
						n41: number,
						n42: number,
						n43: number,
						n44: number
					) => Matrix4;
					identity: () => Matrix4;
					clone: () => Matrix4;
					copy: (m: Matrix4) => Matrix4;
					copyPosition: (m: Matrix4) => Matrix4;
					extractBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix4;
					makeBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix4;
					extractRotation: (m: Matrix4) => Matrix4;
					makeRotationFromEuler: (euler: Euler) => Matrix4;
					makeRotationFromQuaternion: (q: Quaternion) => Matrix4;
					lookAt: (eye: Vector3, target: Vector3, up: Vector3) => Matrix4;
					multiply: (m: Matrix4) => Matrix4;
					premultiply: (m: Matrix4) => Matrix4;
					multiplyMatrices: (a: Matrix4, b: Matrix4) => Matrix4;
					multiplyToArray: (a: Matrix4, b: Matrix4, r: number[]) => Matrix4;
					multiplyScalar: (s: number) => Matrix4;
					determinant: () => number;
					transpose: () => Matrix4;
					setPosition: (v: number | Vector3, y?: number | undefined, z?: number | undefined) => Matrix4;
					invert: () => Matrix4;
					scale: (v: Vector3) => Matrix4;
					getMaxScaleOnAxis: () => number;
					makeTranslation: (x: number, y: number, z: number) => Matrix4;
					makeRotationX: (theta: number) => Matrix4;
					makeRotationY: (theta: number) => Matrix4;
					makeRotationZ: (theta: number) => Matrix4;
					makeRotationAxis: (axis: Vector3, angle: number) => Matrix4;
					makeScale: (x: number, y: number, z: number) => Matrix4;
					makeShear: (xy: number, xz: number, yx: number, yz: number, zx: number, zy: number) => Matrix4;
					compose: (translation: Vector3, rotation: Quaternion, scale: Vector3) => Matrix4;
					decompose: (translation: Vector3, rotation: Quaternion, scale: Vector3) => Matrix4;
					makePerspective: {
						(left: number, right: number, bottom: number, top: number, near: number, far: number): Matrix4;
						(fov: number, aspect: number, near: number, far: number): Matrix4;
					};
					makeOrthographic: (
						left: number,
						right: number,
						top: number,
						bottom: number,
						near: number,
						far: number
					) => Matrix4;
					equals: (matrix: Matrix4) => boolean;
					fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Matrix4;
					toArray: {
						(array?: number[] | undefined, offset?: number | undefined): number[];
						(array?: Matrix4Tuple | undefined, offset?: 0 | undefined): Matrix4Tuple;
						(array?: ArrayLike<number> | undefined, offset?: number | undefined): ArrayLike<number>;
					};
					setFromMatrix3: (m: Matrix3) => Matrix4;
					extractPosition: (m: Matrix4) => Matrix4;
					setRotationFromQuaternion: (q: Quaternion) => Matrix4;
					multiplyVector3: (v: any) => any;
					multiplyVector4: (v: any) => any;
					multiplyVector3Array: (array: number[]) => number[];
					rotateAxis: (v: any) => void;
					crossVector: (v: any) => void;
					flattenToArrayOffset: (array: number[], offset: number) => number[];
					getInverse: (matrix: Matrix) => Matrix;
				};
				matrixAutoUpdate: boolean;
				matrixWorldAutoUpdate: boolean;
				matrixWorldNeedsUpdate: boolean;
				layers: {
					mask: number;
					set: (channel: number) => void;
					enable: (channel: number) => void;
					enableAll: () => void;
					toggle: (channel: number) => void;
					disable: (channel: number) => void;
					disableAll: () => void;
					test: (layers: Layers) => boolean;
					isEnabled: (channel: number) => boolean;
				};
				visible: boolean;
				castShadow: boolean;
				receiveShadow: boolean;
				frustumCulled: boolean;
				renderOrder: number;
				animations: {
					name: string;
					tracks: {
						name: string;
						times: {
							[x: number]: number;
							readonly BYTES_PER_ELEMENT: number;
							readonly buffer:
								| {
										readonly byteLength: number;
										slice: (begin: number, end?: number | undefined) => ArrayBuffer;
										readonly [Symbol.toStringTag]: string;
								  }
								| {
										readonly byteLength: number;
										slice: (begin: number, end?: number | undefined) => SharedArrayBuffer;
										readonly [Symbol.species]: SharedArrayBuffer;
										readonly [Symbol.toStringTag]: 'SharedArrayBuffer';
								  };
							readonly byteLength: number;
							readonly byteOffset: number;
							copyWithin: (target: number, start: number, end?: number | undefined) => Float32Array;
							every: (
								predicate: (value: number, index: number, array: Float32Array) => unknown,
								thisArg?: any
							) => boolean;
							fill: (value: number, start?: number | undefined, end?: number | undefined) => Float32Array;
							filter: (
								predicate: (value: number, index: number, array: Float32Array) => any,
								thisArg?: any
							) => Float32Array;
							find: (
								predicate: (value: number, index: number, obj: Float32Array) => boolean,
								thisArg?: any
							) => number | undefined;
							findIndex: (
								predicate: (value: number, index: number, obj: Float32Array) => boolean,
								thisArg?: any
							) => number;
							forEach: (
								callbackfn: (value: number, index: number, array: Float32Array) => void,
								thisArg?: any
							) => void;
							indexOf: (searchElement: number, fromIndex?: number | undefined) => number;
							join: (separator?: string | undefined) => string;
							lastIndexOf: (searchElement: number, fromIndex?: number | undefined) => number;
							readonly length: number;
							map: (
								callbackfn: (value: number, index: number, array: Float32Array) => number,
								thisArg?: any
							) => Float32Array;
							reduce: {
								(
									callbackfn: (
										previousValue: number,
										currentValue: number,
										currentIndex: number,
										array: Float32Array
									) => number
								): number;
								(
									callbackfn: (
										previousValue: number,
										currentValue: number,
										currentIndex: number,
										array: Float32Array
									) => number,
									initialValue: number
								): number;
								<U>(
									callbackfn: (
										previousValue: U,
										currentValue: number,
										currentIndex: number,
										array: Float32Array
									) => U,
									initialValue: U
								): U;
							};
							reduceRight: {
								(
									callbackfn: (
										previousValue: number,
										currentValue: number,
										currentIndex: number,
										array: Float32Array
									) => number
								): number;
								(
									callbackfn: (
										previousValue: number,
										currentValue: number,
										currentIndex: number,
										array: Float32Array
									) => number,
									initialValue: number
								): number;
								<U_1>(
									callbackfn: (
										previousValue: U_1,
										currentValue: number,
										currentIndex: number,
										array: Float32Array
									) => U_1,
									initialValue: U_1
								): U_1;
							};
							reverse: () => Float32Array;
							set: (array: ArrayLike<number>, offset?: number | undefined) => void;
							slice: (start?: number | undefined, end?: number | undefined) => Float32Array;
							some: (
								predicate: (value: number, index: number, array: Float32Array) => unknown,
								thisArg?: any
							) => boolean;
							sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
							subarray: (begin?: number | undefined, end?: number | undefined) => Float32Array;
							toLocaleString: () => string;
							toString: () => string;
							valueOf: () => Float32Array;
							entries: () => IterableIterator<[number, number]>;
							keys: () => IterableIterator<number>;
							values: () => IterableIterator<number>;
							includes: (searchElement: number, fromIndex?: number | undefined) => boolean;
							[Symbol.iterator]: () => IterableIterator<number>;
							readonly [Symbol.toStringTag]: 'Float32Array';
							at: (index: number) => number | undefined;
						};
						values: {
							[x: number]: number;
							readonly BYTES_PER_ELEMENT: number;
							readonly buffer:
								| {
										readonly byteLength: number;
										slice: (begin: number, end?: number | undefined) => ArrayBuffer;
										readonly [Symbol.toStringTag]: string;
								  }
								| {
										readonly byteLength: number;
										slice: (begin: number, end?: number | undefined) => SharedArrayBuffer;
										readonly [Symbol.species]: SharedArrayBuffer;
										readonly [Symbol.toStringTag]: 'SharedArrayBuffer';
								  };
							readonly byteLength: number;
							readonly byteOffset: number;
							copyWithin: (target: number, start: number, end?: number | undefined) => Float32Array;
							every: (
								predicate: (value: number, index: number, array: Float32Array) => unknown,
								thisArg?: any
							) => boolean;
							fill: (value: number, start?: number | undefined, end?: number | undefined) => Float32Array;
							filter: (
								predicate: (value: number, index: number, array: Float32Array) => any,
								thisArg?: any
							) => Float32Array;
							find: (
								predicate: (value: number, index: number, obj: Float32Array) => boolean,
								thisArg?: any
							) => number | undefined;
							findIndex: (
								predicate: (value: number, index: number, obj: Float32Array) => boolean,
								thisArg?: any
							) => number;
							forEach: (
								callbackfn: (value: number, index: number, array: Float32Array) => void,
								thisArg?: any
							) => void;
							indexOf: (searchElement: number, fromIndex?: number | undefined) => number;
							join: (separator?: string | undefined) => string;
							lastIndexOf: (searchElement: number, fromIndex?: number | undefined) => number;
							readonly length: number;
							map: (
								callbackfn: (value: number, index: number, array: Float32Array) => number,
								thisArg?: any
							) => Float32Array;
							reduce: {
								(
									callbackfn: (
										previousValue: number,
										currentValue: number,
										currentIndex: number,
										array: Float32Array
									) => number
								): number;
								(
									callbackfn: (
										previousValue: number,
										currentValue: number,
										currentIndex: number,
										array: Float32Array
									) => number,
									initialValue: number
								): number;
								<U>(
									callbackfn: (
										previousValue: U,
										currentValue: number,
										currentIndex: number,
										array: Float32Array
									) => U,
									initialValue: U
								): U;
							};
							reduceRight: {
								(
									callbackfn: (
										previousValue: number,
										currentValue: number,
										currentIndex: number,
										array: Float32Array
									) => number
								): number;
								(
									callbackfn: (
										previousValue: number,
										currentValue: number,
										currentIndex: number,
										array: Float32Array
									) => number,
									initialValue: number
								): number;
								<U_1>(
									callbackfn: (
										previousValue: U_1,
										currentValue: number,
										currentIndex: number,
										array: Float32Array
									) => U_1,
									initialValue: U_1
								): U_1;
							};
							reverse: () => Float32Array;
							set: (array: ArrayLike<number>, offset?: number | undefined) => void;
							slice: (start?: number | undefined, end?: number | undefined) => Float32Array;
							some: (
								predicate: (value: number, index: number, array: Float32Array) => unknown,
								thisArg?: any
							) => boolean;
							sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
							subarray: (begin?: number | undefined, end?: number | undefined) => Float32Array;
							toLocaleString: () => string;
							toString: () => string;
							valueOf: () => Float32Array;
							entries: () => IterableIterator<[number, number]>;
							keys: () => IterableIterator<number>;
							values: () => IterableIterator<number>;
							includes: (searchElement: number, fromIndex?: number | undefined) => boolean;
							[Symbol.iterator]: () => IterableIterator<number>;
							readonly [Symbol.toStringTag]: 'Float32Array';
							at: (index: number) => number | undefined;
						};
						ValueTypeName: string;
						TimeBufferType: {
							[x: number]: number;
							readonly BYTES_PER_ELEMENT: number;
							readonly buffer:
								| {
										readonly byteLength: number;
										slice: (begin: number, end?: number | undefined) => ArrayBuffer;
										readonly [Symbol.toStringTag]: string;
								  }
								| {
										readonly byteLength: number;
										slice: (begin: number, end?: number | undefined) => SharedArrayBuffer;
										readonly [Symbol.species]: SharedArrayBuffer;
										readonly [Symbol.toStringTag]: 'SharedArrayBuffer';
								  };
							readonly byteLength: number;
							readonly byteOffset: number;
							copyWithin: (target: number, start: number, end?: number | undefined) => Float32Array;
							every: (
								predicate: (value: number, index: number, array: Float32Array) => unknown,
								thisArg?: any
							) => boolean;
							fill: (value: number, start?: number | undefined, end?: number | undefined) => Float32Array;
							filter: (
								predicate: (value: number, index: number, array: Float32Array) => any,
								thisArg?: any
							) => Float32Array;
							find: (
								predicate: (value: number, index: number, obj: Float32Array) => boolean,
								thisArg?: any
							) => number | undefined;
							findIndex: (
								predicate: (value: number, index: number, obj: Float32Array) => boolean,
								thisArg?: any
							) => number;
							forEach: (
								callbackfn: (value: number, index: number, array: Float32Array) => void,
								thisArg?: any
							) => void;
							indexOf: (searchElement: number, fromIndex?: number | undefined) => number;
							join: (separator?: string | undefined) => string;
							lastIndexOf: (searchElement: number, fromIndex?: number | undefined) => number;
							readonly length: number;
							map: (
								callbackfn: (value: number, index: number, array: Float32Array) => number,
								thisArg?: any
							) => Float32Array;
							reduce: {
								(
									callbackfn: (
										previousValue: number,
										currentValue: number,
										currentIndex: number,
										array: Float32Array
									) => number
								): number;
								(
									callbackfn: (
										previousValue: number,
										currentValue: number,
										currentIndex: number,
										array: Float32Array
									) => number,
									initialValue: number
								): number;
								<U>(
									callbackfn: (
										previousValue: U,
										currentValue: number,
										currentIndex: number,
										array: Float32Array
									) => U,
									initialValue: U
								): U;
							};
							reduceRight: {
								(
									callbackfn: (
										previousValue: number,
										currentValue: number,
										currentIndex: number,
										array: Float32Array
									) => number
								): number;
								(
									callbackfn: (
										previousValue: number,
										currentValue: number,
										currentIndex: number,
										array: Float32Array
									) => number,
									initialValue: number
								): number;
								<U_1>(
									callbackfn: (
										previousValue: U_1,
										currentValue: number,
										currentIndex: number,
										array: Float32Array
									) => U_1,
									initialValue: U_1
								): U_1;
							};
							reverse: () => Float32Array;
							set: (array: ArrayLike<number>, offset?: number | undefined) => void;
							slice: (start?: number | undefined, end?: number | undefined) => Float32Array;
							some: (
								predicate: (value: number, index: number, array: Float32Array) => unknown,
								thisArg?: any
							) => boolean;
							sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
							subarray: (begin?: number | undefined, end?: number | undefined) => Float32Array;
							toLocaleString: () => string;
							toString: () => string;
							valueOf: () => Float32Array;
							entries: () => IterableIterator<[number, number]>;
							keys: () => IterableIterator<number>;
							values: () => IterableIterator<number>;
							includes: (searchElement: number, fromIndex?: number | undefined) => boolean;
							[Symbol.iterator]: () => IterableIterator<number>;
							readonly [Symbol.toStringTag]: 'Float32Array';
							at: (index: number) => number | undefined;
						};
						ValueBufferType: {
							[x: number]: number;
							readonly BYTES_PER_ELEMENT: number;
							readonly buffer:
								| {
										readonly byteLength: number;
										slice: (begin: number, end?: number | undefined) => ArrayBuffer;
										readonly [Symbol.toStringTag]: string;
								  }
								| {
										readonly byteLength: number;
										slice: (begin: number, end?: number | undefined) => SharedArrayBuffer;
										readonly [Symbol.species]: SharedArrayBuffer;
										readonly [Symbol.toStringTag]: 'SharedArrayBuffer';
								  };
							readonly byteLength: number;
							readonly byteOffset: number;
							copyWithin: (target: number, start: number, end?: number | undefined) => Float32Array;
							every: (
								predicate: (value: number, index: number, array: Float32Array) => unknown,
								thisArg?: any
							) => boolean;
							fill: (value: number, start?: number | undefined, end?: number | undefined) => Float32Array;
							filter: (
								predicate: (value: number, index: number, array: Float32Array) => any,
								thisArg?: any
							) => Float32Array;
							find: (
								predicate: (value: number, index: number, obj: Float32Array) => boolean,
								thisArg?: any
							) => number | undefined;
							findIndex: (
								predicate: (value: number, index: number, obj: Float32Array) => boolean,
								thisArg?: any
							) => number;
							forEach: (
								callbackfn: (value: number, index: number, array: Float32Array) => void,
								thisArg?: any
							) => void;
							indexOf: (searchElement: number, fromIndex?: number | undefined) => number;
							join: (separator?: string | undefined) => string;
							lastIndexOf: (searchElement: number, fromIndex?: number | undefined) => number;
							readonly length: number;
							map: (
								callbackfn: (value: number, index: number, array: Float32Array) => number,
								thisArg?: any
							) => Float32Array;
							reduce: {
								(
									callbackfn: (
										previousValue: number,
										currentValue: number,
										currentIndex: number,
										array: Float32Array
									) => number
								): number;
								(
									callbackfn: (
										previousValue: number,
										currentValue: number,
										currentIndex: number,
										array: Float32Array
									) => number,
									initialValue: number
								): number;
								<U>(
									callbackfn: (
										previousValue: U,
										currentValue: number,
										currentIndex: number,
										array: Float32Array
									) => U,
									initialValue: U
								): U;
							};
							reduceRight: {
								(
									callbackfn: (
										previousValue: number,
										currentValue: number,
										currentIndex: number,
										array: Float32Array
									) => number
								): number;
								(
									callbackfn: (
										previousValue: number,
										currentValue: number,
										currentIndex: number,
										array: Float32Array
									) => number,
									initialValue: number
								): number;
								<U_1>(
									callbackfn: (
										previousValue: U_1,
										currentValue: number,
										currentIndex: number,
										array: Float32Array
									) => U_1,
									initialValue: U_1
								): U_1;
							};
							reverse: () => Float32Array;
							set: (array: ArrayLike<number>, offset?: number | undefined) => void;
							slice: (start?: number | undefined, end?: number | undefined) => Float32Array;
							some: (
								predicate: (value: number, index: number, array: Float32Array) => unknown,
								thisArg?: any
							) => boolean;
							sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
							subarray: (begin?: number | undefined, end?: number | undefined) => Float32Array;
							toLocaleString: () => string;
							toString: () => string;
							valueOf: () => Float32Array;
							entries: () => IterableIterator<[number, number]>;
							keys: () => IterableIterator<number>;
							values: () => IterableIterator<number>;
							includes: (searchElement: number, fromIndex?: number | undefined) => boolean;
							[Symbol.iterator]: () => IterableIterator<number>;
							readonly [Symbol.toStringTag]: 'Float32Array';
							at: (index: number) => number | undefined;
						};
						DefaultInterpolation: InterpolationModes;
						InterpolantFactoryMethodDiscrete: (result: any) => DiscreteInterpolant;
						InterpolantFactoryMethodLinear: (result: any) => LinearInterpolant;
						InterpolantFactoryMethodSmooth: (result: any) => CubicInterpolant;
						setInterpolation: (interpolation: InterpolationModes) => KeyframeTrack;
						getInterpolation: () => InterpolationModes;
						createInterpolant: () => Interpolant;
						getValueSize: () => number;
						shift: (timeOffset: number) => KeyframeTrack;
						scale: (timeScale: number) => KeyframeTrack;
						trim: (startTime: number, endTime: number) => KeyframeTrack;
						validate: () => boolean;
						optimize: () => KeyframeTrack;
						clone: () => KeyframeTrack;
					}[];
					blendMode: AnimationBlendMode;
					duration: number;
					uuid: string;
					results: any[];
					resetDuration: () => AnimationClip;
					trim: () => AnimationClip;
					validate: () => boolean;
					optimize: () => AnimationClip;
					clone: () => AnimationClip;
					toJSON: (clip: AnimationClip) => any;
				}[];
				userData: {
					[key: string]: any;
				};
				customDepthMaterial: {
					alphaTest: number;
					alphaToCoverage: boolean;
					blendDst: BlendingDstFactor;
					blendDstAlpha: number | null;
					blendEquation: BlendingEquation;
					blendEquationAlpha: number | null;
					blending: Blending;
					blendSrc: BlendingDstFactor | BlendingSrcFactor;
					blendSrcAlpha: number | null;
					clipIntersection: boolean;
					clippingPlanes: any;
					clipShadows: boolean;
					colorWrite: boolean;
					defines:
						| {
								[key: string]: any;
						  }
						| undefined;
					depthFunc: DepthModes;
					depthTest: boolean;
					depthWrite: boolean;
					id: number;
					stencilWrite: boolean;
					stencilFunc: StencilFunc;
					stencilRef: number;
					stencilWriteMask: number;
					stencilFuncMask: number;
					stencilFail: StencilOp;
					stencilZFail: StencilOp;
					stencilZPass: StencilOp;
					readonly isMaterial: true;
					name: string;
					needsUpdate: boolean;
					opacity: number;
					polygonOffset: boolean;
					polygonOffsetFactor: number;
					polygonOffsetUnits: number;
					precision: 'highp' | 'mediump' | 'lowp' | null;
					premultipliedAlpha: boolean;
					forceSinglePass: boolean;
					dithering: boolean;
					side: Side;
					shadowSide: Side | null;
					toneMapped: boolean;
					transparent: boolean;
					type: string;
					uuid: string;
					vertexColors: boolean;
					visible: boolean;
					userData: any;
					version: number;
					clone: () => Material;
					copy: (material: Material) => Material;
					dispose: () => void;
					onBeforeCompile: (shader: Shader, renderer: WebGLRenderer) => void;
					customProgramCacheKey: () => string;
					setValues: (values: MaterialParameters) => void;
					toJSON: (meta?: any) => any;
					addEventListener: <T extends string>(type: T, listener: EventListener<Event, T, Material>) => void;
					hasEventListener: <T_1 extends string>(
						type: T_1,
						listener: EventListener<Event, T_1, Material>
					) => boolean;
					removeEventListener: <T_2 extends string>(
						type: T_2,
						listener: EventListener<Event, T_2, Material>
					) => void;
					dispatchEvent: (event: Event) => void;
				};
				customDistanceMaterial: {
					alphaTest: number;
					alphaToCoverage: boolean;
					blendDst: BlendingDstFactor;
					blendDstAlpha: number | null;
					blendEquation: BlendingEquation;
					blendEquationAlpha: number | null;
					blending: Blending;
					blendSrc: BlendingDstFactor | BlendingSrcFactor;
					blendSrcAlpha: number | null;
					clipIntersection: boolean;
					clippingPlanes: any;
					clipShadows: boolean;
					colorWrite: boolean;
					defines:
						| {
								[key: string]: any;
						  }
						| undefined;
					depthFunc: DepthModes;
					depthTest: boolean;
					depthWrite: boolean;
					id: number;
					stencilWrite: boolean;
					stencilFunc: StencilFunc;
					stencilRef: number;
					stencilWriteMask: number;
					stencilFuncMask: number;
					stencilFail: StencilOp;
					stencilZFail: StencilOp;
					stencilZPass: StencilOp;
					readonly isMaterial: true;
					name: string;
					needsUpdate: boolean;
					opacity: number;
					polygonOffset: boolean;
					polygonOffsetFactor: number;
					polygonOffsetUnits: number;
					precision: 'highp' | 'mediump' | 'lowp' | null;
					premultipliedAlpha: boolean;
					forceSinglePass: boolean;
					dithering: boolean;
					side: Side;
					shadowSide: Side | null;
					toneMapped: boolean;
					transparent: boolean;
					type: string;
					uuid: string;
					vertexColors: boolean;
					visible: boolean;
					userData: any;
					version: number;
					clone: () => Material;
					copy: (material: Material) => Material;
					dispose: () => void;
					onBeforeCompile: (shader: Shader, renderer: WebGLRenderer) => void;
					customProgramCacheKey: () => string;
					setValues: (values: MaterialParameters) => void;
					toJSON: (meta?: any) => any;
					addEventListener: <T extends string>(type: T, listener: EventListener<Event, T, Material>) => void;
					hasEventListener: <T_1 extends string>(
						type: T_1,
						listener: EventListener<Event, T_1, Material>
					) => boolean;
					removeEventListener: <T_2 extends string>(
						type: T_2,
						listener: EventListener<Event, T_2, Material>
					) => void;
					dispatchEvent: (event: Event) => void;
				};
				readonly isObject3D: true;
				onBeforeRender: (
					renderer: WebGLRenderer,
					scene: Scene,
					camera: Camera,
					geometry: BufferGeometry,
					material: Material,
					group: Group
				) => void;
				onAfterRender: (
					renderer: WebGLRenderer,
					scene: Scene,
					camera: Camera,
					geometry: BufferGeometry,
					material: Material,
					group: Group
				) => void;
				applyMatrix4: (matrix: Matrix4) => void;
				applyQuaternion: (quaternion: Quaternion) => Object3D<Event>;
				setRotationFromAxisAngle: (axis: Vector3, angle: number) => void;
				setRotationFromEuler: (euler: Euler) => void;
				setRotationFromMatrix: (m: Matrix4) => void;
				setRotationFromQuaternion: (q: Quaternion) => void;
				rotateOnAxis: (axis: Vector3, angle: number) => Object3D<Event>;
				rotateOnWorldAxis: (axis: Vector3, angle: number) => Object3D<Event>;
				rotateX: (angle: number) => Object3D<Event>;
				rotateY: (angle: number) => Object3D<Event>;
				rotateZ: (angle: number) => Object3D<Event>;
				translateOnAxis: (axis: Vector3, distance: number) => Object3D<Event>;
				translateX: (distance: number) => Object3D<Event>;
				translateY: (distance: number) => Object3D<Event>;
				translateZ: (distance: number) => Object3D<Event>;
				localToWorld: (vector: Vector3) => Vector3;
				worldToLocal: (vector: Vector3) => Vector3;
				lookAt: {
					(vector: Vector3): void;
					(x: number, y: number, z: number): void;
				};
				add: (...object: Object3D<Event>[]) => Object3D<Event>;
				remove: (...object: Object3D<Event>[]) => Object3D<Event>;
				removeFromParent: () => Object3D<Event>;
				clear: () => Object3D<Event>;
				attach: (object: Object3D<Event>) => Object3D<Event>;
				getObjectById: (id: number) => Object3D<Event> | undefined;
				getObjectByName: (name: string) => Object3D<Event> | undefined;
				getObjectByProperty: (name: string, value: any) => Object3D<Event> | undefined;
				getObjectsByProperty: (name: string, value: any) => Object3D<Event>[];
				getWorldPosition: (target: Vector3) => Vector3;
				getWorldQuaternion: (target: Quaternion) => Quaternion;
				getWorldScale: (target: Vector3) => Vector3;
				getWorldDirection: (target: Vector3) => Vector3;
				raycast: (raycaster: Raycaster, intersects: Intersection<Object3D<Event>>[]) => void;
				traverse: (callback: (object: Object3D<Event>) => any) => void;
				traverseVisible: (callback: (object: Object3D<Event>) => any) => void;
				traverseAncestors: (callback: (object: Object3D<Event>) => any) => void;
				updateMatrix: () => void;
				updateMatrixWorld: (force?: boolean | undefined) => void;
				updateWorldMatrix: (updateParents: boolean, updateChildren: boolean) => void;
				toJSON: (
					meta?:
						| {
								geometries: any;
								materials: any;
								textures: any;
								images: any;
						  }
						| undefined
				) => any;
				clone: (recursive?: boolean | undefined) => Object3D<Event>;
				copy: (source: Object3D<Event>, recursive?: boolean | undefined) => Object3D<Event>;
				addEventListener: <T_3 extends string>(
					type: T_3,
					listener: EventListener<Event, T_3, Object3D<Event>>
				) => void;
				hasEventListener: <T_4 extends string>(
					type: T_4,
					listener: EventListener<Event, T_4, Object3D<Event>>
				) => boolean;
				removeEventListener: <T_5 extends string>(
					type: T_5,
					listener: EventListener<Event, T_5, Object3D<Event>>
				) => void;
				dispatchEvent: (event: Event) => void;
			}[];
			up: {
				x: number;
				y: number;
				z: number;
				readonly isVector3: true;
				set: (x: number, y: number, z: number) => Vector3;
				setScalar: (scalar: number) => Vector3;
				setX: (x: number) => Vector3;
				setY: (y: number) => Vector3;
				setZ: (z: number) => Vector3;
				setComponent: (index: number, value: number) => Vector3;
				getComponent: (index: number) => number;
				clone: () => Vector3;
				copy: (v: Vector3) => Vector3;
				add: (v: Vector3) => Vector3;
				addScalar: (s: number) => Vector3;
				addScaledVector: (v: Vector3, s: number) => Vector3;
				addVectors: (a: Vector3, b: Vector3) => Vector3;
				sub: (a: Vector3) => Vector3;
				subScalar: (s: number) => Vector3;
				subVectors: (a: Vector3, b: Vector3) => Vector3;
				multiply: (v: Vector3) => Vector3;
				multiplyScalar: (s: number) => Vector3;
				multiplyVectors: (a: Vector3, b: Vector3) => Vector3;
				applyEuler: (euler: Euler) => Vector3;
				applyAxisAngle: (axis: Vector3, angle: number) => Vector3;
				applyMatrix3: (m: Matrix3) => Vector3;
				applyNormalMatrix: (m: Matrix3) => Vector3;
				applyMatrix4: (m: Matrix4) => Vector3;
				applyQuaternion: (q: Quaternion) => Vector3;
				project: (camera: Camera) => Vector3;
				unproject: (camera: Camera) => Vector3;
				transformDirection: (m: Matrix4) => Vector3;
				divide: (v: Vector3) => Vector3;
				divideScalar: (s: number) => Vector3;
				min: (v: Vector3) => Vector3;
				max: (v: Vector3) => Vector3;
				clamp: (min: Vector3, max: Vector3) => Vector3;
				clampScalar: (min: number, max: number) => Vector3;
				clampLength: (min: number, max: number) => Vector3;
				floor: () => Vector3;
				ceil: () => Vector3;
				round: () => Vector3;
				roundToZero: () => Vector3;
				negate: () => Vector3;
				dot: (v: Vector3) => number;
				lengthSq: () => number;
				length: () => number;
				lengthManhattan: () => number;
				manhattanLength: () => number;
				manhattanDistanceTo: (v: Vector3) => number;
				normalize: () => Vector3;
				setLength: (l: number) => Vector3;
				lerp: (v: Vector3, alpha: number) => Vector3;
				lerpVectors: (v1: Vector3, v2: Vector3, alpha: number) => Vector3;
				cross: (a: Vector3) => Vector3;
				crossVectors: (a: Vector3, b: Vector3) => Vector3;
				projectOnVector: (v: Vector3) => Vector3;
				projectOnPlane: (planeNormal: Vector3) => Vector3;
				reflect: (vector: Vector3) => Vector3;
				angleTo: (v: Vector3) => number;
				distanceTo: (v: Vector3) => number;
				distanceToSquared: (v: Vector3) => number;
				distanceToManhattan: (v: Vector3) => number;
				setFromSpherical: (s: Spherical) => Vector3;
				setFromSphericalCoords: (r: number, phi: number, theta: number) => Vector3;
				setFromCylindrical: (s: Cylindrical) => Vector3;
				setFromCylindricalCoords: (radius: number, theta: number, y: number) => Vector3;
				setFromMatrixPosition: (m: Matrix4) => Vector3;
				setFromMatrixScale: (m: Matrix4) => Vector3;
				setFromMatrixColumn: (matrix: Matrix4, index: number) => Vector3;
				setFromMatrix3Column: (matrix: Matrix3, index: number) => Vector3;
				setFromEuler: (e: Euler) => Vector3;
				equals: (v: Vector3) => boolean;
				fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Vector3;
				toArray: {
					(array?: number[] | undefined, offset?: number | undefined): number[];
					(array?: Vector3Tuple | undefined, offset?: 0 | undefined): Vector3Tuple;
					(array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
				};
				fromBufferAttribute: (
					attribute: BufferAttribute | InterleavedBufferAttribute,
					index: number
				) => Vector3;
				random: () => Vector3;
				randomDirection: () => Vector3;
			};
			readonly position: {
				x: number;
				y: number;
				z: number;
				readonly isVector3: true;
				set: (x: number, y: number, z: number) => Vector3;
				setScalar: (scalar: number) => Vector3;
				setX: (x: number) => Vector3;
				setY: (y: number) => Vector3;
				setZ: (z: number) => Vector3;
				setComponent: (index: number, value: number) => Vector3;
				getComponent: (index: number) => number;
				clone: () => Vector3;
				copy: (v: Vector3) => Vector3;
				add: (v: Vector3) => Vector3;
				addScalar: (s: number) => Vector3;
				addScaledVector: (v: Vector3, s: number) => Vector3;
				addVectors: (a: Vector3, b: Vector3) => Vector3;
				sub: (a: Vector3) => Vector3;
				subScalar: (s: number) => Vector3;
				subVectors: (a: Vector3, b: Vector3) => Vector3;
				multiply: (v: Vector3) => Vector3;
				multiplyScalar: (s: number) => Vector3;
				multiplyVectors: (a: Vector3, b: Vector3) => Vector3;
				applyEuler: (euler: Euler) => Vector3;
				applyAxisAngle: (axis: Vector3, angle: number) => Vector3;
				applyMatrix3: (m: Matrix3) => Vector3;
				applyNormalMatrix: (m: Matrix3) => Vector3;
				applyMatrix4: (m: Matrix4) => Vector3;
				applyQuaternion: (q: Quaternion) => Vector3;
				project: (camera: Camera) => Vector3;
				unproject: (camera: Camera) => Vector3;
				transformDirection: (m: Matrix4) => Vector3;
				divide: (v: Vector3) => Vector3;
				divideScalar: (s: number) => Vector3;
				min: (v: Vector3) => Vector3;
				max: (v: Vector3) => Vector3;
				clamp: (min: Vector3, max: Vector3) => Vector3;
				clampScalar: (min: number, max: number) => Vector3;
				clampLength: (min: number, max: number) => Vector3;
				floor: () => Vector3;
				ceil: () => Vector3;
				round: () => Vector3;
				roundToZero: () => Vector3;
				negate: () => Vector3;
				dot: (v: Vector3) => number;
				lengthSq: () => number;
				length: () => number;
				lengthManhattan: () => number;
				manhattanLength: () => number;
				manhattanDistanceTo: (v: Vector3) => number;
				normalize: () => Vector3;
				setLength: (l: number) => Vector3;
				lerp: (v: Vector3, alpha: number) => Vector3;
				lerpVectors: (v1: Vector3, v2: Vector3, alpha: number) => Vector3;
				cross: (a: Vector3) => Vector3;
				crossVectors: (a: Vector3, b: Vector3) => Vector3;
				projectOnVector: (v: Vector3) => Vector3;
				projectOnPlane: (planeNormal: Vector3) => Vector3;
				reflect: (vector: Vector3) => Vector3;
				angleTo: (v: Vector3) => number;
				distanceTo: (v: Vector3) => number;
				distanceToSquared: (v: Vector3) => number;
				distanceToManhattan: (v: Vector3) => number;
				setFromSpherical: (s: Spherical) => Vector3;
				setFromSphericalCoords: (r: number, phi: number, theta: number) => Vector3;
				setFromCylindrical: (s: Cylindrical) => Vector3;
				setFromCylindricalCoords: (radius: number, theta: number, y: number) => Vector3;
				setFromMatrixPosition: (m: Matrix4) => Vector3;
				setFromMatrixScale: (m: Matrix4) => Vector3;
				setFromMatrixColumn: (matrix: Matrix4, index: number) => Vector3;
				setFromMatrix3Column: (matrix: Matrix3, index: number) => Vector3;
				setFromEuler: (e: Euler) => Vector3;
				equals: (v: Vector3) => boolean;
				fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Vector3;
				toArray: {
					(array?: number[] | undefined, offset?: number | undefined): number[];
					(array?: Vector3Tuple | undefined, offset?: 0 | undefined): Vector3Tuple;
					(array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
				};
				fromBufferAttribute: (
					attribute: BufferAttribute | InterleavedBufferAttribute,
					index: number
				) => Vector3;
				random: () => Vector3;
				randomDirection: () => Vector3;
			};
			readonly rotation: {
				x: number;
				y: number;
				z: number;
				order: EulerOrder;
				readonly isEuler: true;
				_onChangeCallback: () => void;
				set: (x: number, y: number, z: number, order?: EulerOrder | undefined) => Euler;
				clone: () => Euler;
				copy: (euler: Euler) => Euler;
				setFromRotationMatrix: (
					m: Matrix4,
					order?: EulerOrder | undefined,
					update?: boolean | undefined
				) => Euler;
				setFromQuaternion: (
					q: Quaternion,
					order?: EulerOrder | undefined,
					update?: boolean | undefined
				) => Euler;
				setFromVector3: (v: Vector3, order?: EulerOrder | undefined) => Euler;
				reorder: (newOrder: EulerOrder) => Euler;
				equals: (euler: Euler) => boolean;
				fromArray: (xyzo: [number, number, number, (EulerOrder | undefined)?, ...any[]]) => Euler;
				toArray: (
					array?: (string | number | undefined)[] | undefined,
					offset?: number | undefined
				) => (string | number | undefined)[];
				_onChange: (callback: () => void) => Euler;
				[Symbol.iterator]: () => Generator<string | number, void, unknown>;
			};
			readonly quaternion: {
				x: number;
				y: number;
				z: number;
				w: number;
				readonly isQuaternion: true;
				set: (x: number, y: number, z: number, w: number) => Quaternion;
				clone: () => Quaternion;
				copy: (q: Quaternion) => Quaternion;
				setFromEuler: (euler: Euler, update?: boolean | undefined) => Quaternion;
				setFromAxisAngle: (axis: Vector3, angle: number) => Quaternion;
				setFromRotationMatrix: (m: Matrix4) => Quaternion;
				setFromUnitVectors: (vFrom: Vector3, vTo: Vector3) => Quaternion;
				angleTo: (q: Quaternion) => number;
				rotateTowards: (q: Quaternion, step: number) => Quaternion;
				identity: () => Quaternion;
				invert: () => Quaternion;
				conjugate: () => Quaternion;
				dot: (v: Quaternion) => number;
				lengthSq: () => number;
				length: () => number;
				normalize: () => Quaternion;
				multiply: (q: Quaternion) => Quaternion;
				premultiply: (q: Quaternion) => Quaternion;
				multiplyQuaternions: (a: Quaternion, b: Quaternion) => Quaternion;
				slerp: (qb: Quaternion, t: number) => Quaternion;
				slerpQuaternions: (qa: Quaternion, qb: Quaternion, t: number) => Quaternion;
				equals: (v: Quaternion) => boolean;
				fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Quaternion;
				toArray: {
					(array?: number[] | undefined, offset?: number | undefined): number[];
					(array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
				};
				fromBufferAttribute: (
					attribute: BufferAttribute | InterleavedBufferAttribute,
					index: number
				) => Quaternion;
				_onChange: (callback: () => void) => Quaternion;
				_onChangeCallback: () => void;
				multiplyVector3: (v: any) => any;
				random: () => Quaternion;
				[Symbol.iterator]: () => Generator<number, void, unknown>;
			};
			readonly scale: {
				x: number;
				y: number;
				z: number;
				readonly isVector3: true;
				set: (x: number, y: number, z: number) => Vector3;
				setScalar: (scalar: number) => Vector3;
				setX: (x: number) => Vector3;
				setY: (y: number) => Vector3;
				setZ: (z: number) => Vector3;
				setComponent: (index: number, value: number) => Vector3;
				getComponent: (index: number) => number;
				clone: () => Vector3;
				copy: (v: Vector3) => Vector3;
				add: (v: Vector3) => Vector3;
				addScalar: (s: number) => Vector3;
				addScaledVector: (v: Vector3, s: number) => Vector3;
				addVectors: (a: Vector3, b: Vector3) => Vector3;
				sub: (a: Vector3) => Vector3;
				subScalar: (s: number) => Vector3;
				subVectors: (a: Vector3, b: Vector3) => Vector3;
				multiply: (v: Vector3) => Vector3;
				multiplyScalar: (s: number) => Vector3;
				multiplyVectors: (a: Vector3, b: Vector3) => Vector3;
				applyEuler: (euler: Euler) => Vector3;
				applyAxisAngle: (axis: Vector3, angle: number) => Vector3;
				applyMatrix3: (m: Matrix3) => Vector3;
				applyNormalMatrix: (m: Matrix3) => Vector3;
				applyMatrix4: (m: Matrix4) => Vector3;
				applyQuaternion: (q: Quaternion) => Vector3;
				project: (camera: Camera) => Vector3;
				unproject: (camera: Camera) => Vector3;
				transformDirection: (m: Matrix4) => Vector3;
				divide: (v: Vector3) => Vector3;
				divideScalar: (s: number) => Vector3;
				min: (v: Vector3) => Vector3;
				max: (v: Vector3) => Vector3;
				clamp: (min: Vector3, max: Vector3) => Vector3;
				clampScalar: (min: number, max: number) => Vector3;
				clampLength: (min: number, max: number) => Vector3;
				floor: () => Vector3;
				ceil: () => Vector3;
				round: () => Vector3;
				roundToZero: () => Vector3;
				negate: () => Vector3;
				dot: (v: Vector3) => number;
				lengthSq: () => number;
				length: () => number;
				lengthManhattan: () => number;
				manhattanLength: () => number;
				manhattanDistanceTo: (v: Vector3) => number;
				normalize: () => Vector3;
				setLength: (l: number) => Vector3;
				lerp: (v: Vector3, alpha: number) => Vector3;
				lerpVectors: (v1: Vector3, v2: Vector3, alpha: number) => Vector3;
				cross: (a: Vector3) => Vector3;
				crossVectors: (a: Vector3, b: Vector3) => Vector3;
				projectOnVector: (v: Vector3) => Vector3;
				projectOnPlane: (planeNormal: Vector3) => Vector3;
				reflect: (vector: Vector3) => Vector3;
				angleTo: (v: Vector3) => number;
				distanceTo: (v: Vector3) => number;
				distanceToSquared: (v: Vector3) => number;
				distanceToManhattan: (v: Vector3) => number;
				setFromSpherical: (s: Spherical) => Vector3;
				setFromSphericalCoords: (r: number, phi: number, theta: number) => Vector3;
				setFromCylindrical: (s: Cylindrical) => Vector3;
				setFromCylindricalCoords: (radius: number, theta: number, y: number) => Vector3;
				setFromMatrixPosition: (m: Matrix4) => Vector3;
				setFromMatrixScale: (m: Matrix4) => Vector3;
				setFromMatrixColumn: (matrix: Matrix4, index: number) => Vector3;
				setFromMatrix3Column: (matrix: Matrix3, index: number) => Vector3;
				setFromEuler: (e: Euler) => Vector3;
				equals: (v: Vector3) => boolean;
				fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Vector3;
				toArray: {
					(array?: number[] | undefined, offset?: number | undefined): number[];
					(array?: Vector3Tuple | undefined, offset?: 0 | undefined): Vector3Tuple;
					(array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
				};
				fromBufferAttribute: (
					attribute: BufferAttribute | InterleavedBufferAttribute,
					index: number
				) => Vector3;
				random: () => Vector3;
				randomDirection: () => Vector3;
			};
			readonly modelViewMatrix: {
				elements: number[];
				set: (
					n11: number,
					n12: number,
					n13: number,
					n14: number,
					n21: number,
					n22: number,
					n23: number,
					n24: number,
					n31: number,
					n32: number,
					n33: number,
					n34: number,
					n41: number,
					n42: number,
					n43: number,
					n44: number
				) => Matrix4;
				identity: () => Matrix4;
				clone: () => Matrix4;
				copy: (m: Matrix4) => Matrix4;
				copyPosition: (m: Matrix4) => Matrix4;
				extractBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix4;
				makeBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix4;
				extractRotation: (m: Matrix4) => Matrix4;
				makeRotationFromEuler: (euler: Euler) => Matrix4;
				makeRotationFromQuaternion: (q: Quaternion) => Matrix4;
				lookAt: (eye: Vector3, target: Vector3, up: Vector3) => Matrix4;
				multiply: (m: Matrix4) => Matrix4;
				premultiply: (m: Matrix4) => Matrix4;
				multiplyMatrices: (a: Matrix4, b: Matrix4) => Matrix4;
				multiplyToArray: (a: Matrix4, b: Matrix4, r: number[]) => Matrix4;
				multiplyScalar: (s: number) => Matrix4;
				determinant: () => number;
				transpose: () => Matrix4;
				setPosition: (v: number | Vector3, y?: number | undefined, z?: number | undefined) => Matrix4;
				invert: () => Matrix4;
				scale: (v: Vector3) => Matrix4;
				getMaxScaleOnAxis: () => number;
				makeTranslation: (x: number, y: number, z: number) => Matrix4;
				makeRotationX: (theta: number) => Matrix4;
				makeRotationY: (theta: number) => Matrix4;
				makeRotationZ: (theta: number) => Matrix4;
				makeRotationAxis: (axis: Vector3, angle: number) => Matrix4;
				makeScale: (x: number, y: number, z: number) => Matrix4;
				makeShear: (xy: number, xz: number, yx: number, yz: number, zx: number, zy: number) => Matrix4;
				compose: (translation: Vector3, rotation: Quaternion, scale: Vector3) => Matrix4;
				decompose: (translation: Vector3, rotation: Quaternion, scale: Vector3) => Matrix4;
				makePerspective: {
					(left: number, right: number, bottom: number, top: number, near: number, far: number): Matrix4;
					(fov: number, aspect: number, near: number, far: number): Matrix4;
				};
				makeOrthographic: (
					left: number,
					right: number,
					top: number,
					bottom: number,
					near: number,
					far: number
				) => Matrix4;
				equals: (matrix: Matrix4) => boolean;
				fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Matrix4;
				toArray: {
					(array?: number[] | undefined, offset?: number | undefined): number[];
					(array?: Matrix4Tuple | undefined, offset?: 0 | undefined): Matrix4Tuple;
					(array?: ArrayLike<number> | undefined, offset?: number | undefined): ArrayLike<number>;
				};
				setFromMatrix3: (m: Matrix3) => Matrix4;
				extractPosition: (m: Matrix4) => Matrix4;
				setRotationFromQuaternion: (q: Quaternion) => Matrix4;
				multiplyVector3: (v: any) => any;
				multiplyVector4: (v: any) => any;
				multiplyVector3Array: (array: number[]) => number[];
				rotateAxis: (v: any) => void;
				crossVector: (v: any) => void;
				flattenToArrayOffset: (array: number[], offset: number) => number[];
				getInverse: (matrix: Matrix) => Matrix;
			};
			readonly normalMatrix: {
				elements: number[];
				set: (
					n11: number,
					n12: number,
					n13: number,
					n21: number,
					n22: number,
					n23: number,
					n31: number,
					n32: number,
					n33: number
				) => Matrix3;
				identity: () => Matrix3;
				clone: () => Matrix3;
				copy: (m: Matrix3) => Matrix3;
				extractBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix3;
				setFromMatrix4: (m: Matrix4) => Matrix3;
				multiplyScalar: (s: number) => Matrix3;
				determinant: () => number;
				invert: () => Matrix3;
				transpose: () => Matrix3;
				getNormalMatrix: (matrix4: Matrix4) => Matrix3;
				transposeIntoArray: (r: number[]) => Matrix3;
				setUvTransform: (
					tx: number,
					ty: number,
					sx: number,
					sy: number,
					rotation: number,
					cx: number,
					cy: number
				) => Matrix3;
				scale: (sx: number, sy: number) => Matrix3;
				makeTranslation: {
					(x: number, y: number): Matrix3;
					(x: number, y: number): Matrix3;
				};
				makeRotation: {
					(theta: number): Matrix3;
					(theta: number): Matrix3;
				};
				makeScale: {
					(x: number, y: number): Matrix3;
					(x: number, y: number): Matrix3;
				};
				rotate: (theta: number) => Matrix3;
				translate: (tx: number, ty: number) => Matrix3;
				equals: (matrix: Matrix3) => boolean;
				fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Matrix3;
				toArray: {
					(array?: number[] | undefined, offset?: number | undefined): number[];
					(array?: Matrix3Tuple | undefined, offset?: 0 | undefined): Matrix3Tuple;
					(array?: ArrayLike<number> | undefined, offset?: number | undefined): ArrayLike<number>;
				};
				multiply: (m: Matrix3) => Matrix3;
				premultiply: (m: Matrix3) => Matrix3;
				multiplyMatrices: (a: Matrix3, b: Matrix3) => Matrix3;
				multiplyVector3: (vector: Vector3) => any;
				multiplyVector3Array: (a: any) => any;
				getInverse: {
					(matrix: Matrix4, throwOnDegenerate?: boolean | undefined): Matrix3;
					(matrix: Matrix): Matrix;
				};
				flattenToArrayOffset: (array: number[], offset: number) => number[];
			};
			matrix: {
				elements: number[];
				set: (
					n11: number,
					n12: number,
					n13: number,
					n14: number,
					n21: number,
					n22: number,
					n23: number,
					n24: number,
					n31: number,
					n32: number,
					n33: number,
					n34: number,
					n41: number,
					n42: number,
					n43: number,
					n44: number
				) => Matrix4;
				identity: () => Matrix4;
				clone: () => Matrix4;
				copy: (m: Matrix4) => Matrix4;
				copyPosition: (m: Matrix4) => Matrix4;
				extractBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix4;
				makeBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix4;
				extractRotation: (m: Matrix4) => Matrix4;
				makeRotationFromEuler: (euler: Euler) => Matrix4;
				makeRotationFromQuaternion: (q: Quaternion) => Matrix4;
				lookAt: (eye: Vector3, target: Vector3, up: Vector3) => Matrix4;
				multiply: (m: Matrix4) => Matrix4;
				premultiply: (m: Matrix4) => Matrix4;
				multiplyMatrices: (a: Matrix4, b: Matrix4) => Matrix4;
				multiplyToArray: (a: Matrix4, b: Matrix4, r: number[]) => Matrix4;
				multiplyScalar: (s: number) => Matrix4;
				determinant: () => number;
				transpose: () => Matrix4;
				setPosition: (v: number | Vector3, y?: number | undefined, z?: number | undefined) => Matrix4;
				invert: () => Matrix4;
				scale: (v: Vector3) => Matrix4;
				getMaxScaleOnAxis: () => number;
				makeTranslation: (x: number, y: number, z: number) => Matrix4;
				makeRotationX: (theta: number) => Matrix4;
				makeRotationY: (theta: number) => Matrix4;
				makeRotationZ: (theta: number) => Matrix4;
				makeRotationAxis: (axis: Vector3, angle: number) => Matrix4;
				makeScale: (x: number, y: number, z: number) => Matrix4;
				makeShear: (xy: number, xz: number, yx: number, yz: number, zx: number, zy: number) => Matrix4;
				compose: (translation: Vector3, rotation: Quaternion, scale: Vector3) => Matrix4;
				decompose: (translation: Vector3, rotation: Quaternion, scale: Vector3) => Matrix4;
				makePerspective: {
					(left: number, right: number, bottom: number, top: number, near: number, far: number): Matrix4;
					(fov: number, aspect: number, near: number, far: number): Matrix4;
				};
				makeOrthographic: (
					left: number,
					right: number,
					top: number,
					bottom: number,
					near: number,
					far: number
				) => Matrix4;
				equals: (matrix: Matrix4) => boolean;
				fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Matrix4;
				toArray: {
					(array?: number[] | undefined, offset?: number | undefined): number[];
					(array?: Matrix4Tuple | undefined, offset?: 0 | undefined): Matrix4Tuple;
					(array?: ArrayLike<number> | undefined, offset?: number | undefined): ArrayLike<number>;
				};
				setFromMatrix3: (m: Matrix3) => Matrix4;
				extractPosition: (m: Matrix4) => Matrix4;
				setRotationFromQuaternion: (q: Quaternion) => Matrix4;
				multiplyVector3: (v: any) => any;
				multiplyVector4: (v: any) => any;
				multiplyVector3Array: (array: number[]) => number[];
				rotateAxis: (v: any) => void;
				crossVector: (v: any) => void;
				flattenToArrayOffset: (array: number[], offset: number) => number[];
				getInverse: (matrix: Matrix) => Matrix;
			};
			matrixWorld: {
				elements: number[];
				set: (
					n11: number,
					n12: number,
					n13: number,
					n14: number,
					n21: number,
					n22: number,
					n23: number,
					n24: number,
					n31: number,
					n32: number,
					n33: number,
					n34: number,
					n41: number,
					n42: number,
					n43: number,
					n44: number
				) => Matrix4;
				identity: () => Matrix4;
				clone: () => Matrix4;
				copy: (m: Matrix4) => Matrix4;
				copyPosition: (m: Matrix4) => Matrix4;
				extractBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix4;
				makeBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix4;
				extractRotation: (m: Matrix4) => Matrix4;
				makeRotationFromEuler: (euler: Euler) => Matrix4;
				makeRotationFromQuaternion: (q: Quaternion) => Matrix4;
				lookAt: (eye: Vector3, target: Vector3, up: Vector3) => Matrix4;
				multiply: (m: Matrix4) => Matrix4;
				premultiply: (m: Matrix4) => Matrix4;
				multiplyMatrices: (a: Matrix4, b: Matrix4) => Matrix4;
				multiplyToArray: (a: Matrix4, b: Matrix4, r: number[]) => Matrix4;
				multiplyScalar: (s: number) => Matrix4;
				determinant: () => number;
				transpose: () => Matrix4;
				setPosition: (v: number | Vector3, y?: number | undefined, z?: number | undefined) => Matrix4;
				invert: () => Matrix4;
				scale: (v: Vector3) => Matrix4;
				getMaxScaleOnAxis: () => number;
				makeTranslation: (x: number, y: number, z: number) => Matrix4;
				makeRotationX: (theta: number) => Matrix4;
				makeRotationY: (theta: number) => Matrix4;
				makeRotationZ: (theta: number) => Matrix4;
				makeRotationAxis: (axis: Vector3, angle: number) => Matrix4;
				makeScale: (x: number, y: number, z: number) => Matrix4;
				makeShear: (xy: number, xz: number, yx: number, yz: number, zx: number, zy: number) => Matrix4;
				compose: (translation: Vector3, rotation: Quaternion, scale: Vector3) => Matrix4;
				decompose: (translation: Vector3, rotation: Quaternion, scale: Vector3) => Matrix4;
				makePerspective: {
					(left: number, right: number, bottom: number, top: number, near: number, far: number): Matrix4;
					(fov: number, aspect: number, near: number, far: number): Matrix4;
				};
				makeOrthographic: (
					left: number,
					right: number,
					top: number,
					bottom: number,
					near: number,
					far: number
				) => Matrix4;
				equals: (matrix: Matrix4) => boolean;
				fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Matrix4;
				toArray: {
					(array?: number[] | undefined, offset?: number | undefined): number[];
					(array?: Matrix4Tuple | undefined, offset?: 0 | undefined): Matrix4Tuple;
					(array?: ArrayLike<number> | undefined, offset?: number | undefined): ArrayLike<number>;
				};
				setFromMatrix3: (m: Matrix3) => Matrix4;
				extractPosition: (m: Matrix4) => Matrix4;
				setRotationFromQuaternion: (q: Quaternion) => Matrix4;
				multiplyVector3: (v: any) => any;
				multiplyVector4: (v: any) => any;
				multiplyVector3Array: (array: number[]) => number[];
				rotateAxis: (v: any) => void;
				crossVector: (v: any) => void;
				flattenToArrayOffset: (array: number[], offset: number) => number[];
				getInverse: (matrix: Matrix) => Matrix;
			};
			matrixAutoUpdate: boolean;
			matrixWorldAutoUpdate: boolean;
			matrixWorldNeedsUpdate: boolean;
			layers: {
				mask: number;
				set: (channel: number) => void;
				enable: (channel: number) => void;
				enableAll: () => void;
				toggle: (channel: number) => void;
				disable: (channel: number) => void;
				disableAll: () => void;
				test: (layers: Layers) => boolean;
				isEnabled: (channel: number) => boolean;
			};
			visible: boolean;
			castShadow: boolean;
			receiveShadow: boolean;
			frustumCulled: boolean;
			renderOrder: number;
			animations: {
				name: string;
				tracks: {
					name: string;
					times: {
						[x: number]: number;
						readonly BYTES_PER_ELEMENT: number;
						readonly buffer:
							| {
									readonly byteLength: number;
									slice: (begin: number, end?: number | undefined) => ArrayBuffer;
									readonly [Symbol.toStringTag]: string;
							  }
							| {
									readonly byteLength: number;
									slice: (begin: number, end?: number | undefined) => SharedArrayBuffer;
									readonly [Symbol.species]: SharedArrayBuffer;
									readonly [Symbol.toStringTag]: 'SharedArrayBuffer';
							  };
						readonly byteLength: number;
						readonly byteOffset: number;
						copyWithin: (target: number, start: number, end?: number | undefined) => Float32Array;
						every: (
							predicate: (value: number, index: number, array: Float32Array) => unknown,
							thisArg?: any
						) => boolean;
						fill: (value: number, start?: number | undefined, end?: number | undefined) => Float32Array;
						filter: (
							predicate: (value: number, index: number, array: Float32Array) => any,
							thisArg?: any
						) => Float32Array;
						find: (
							predicate: (value: number, index: number, obj: Float32Array) => boolean,
							thisArg?: any
						) => number | undefined;
						findIndex: (
							predicate: (value: number, index: number, obj: Float32Array) => boolean,
							thisArg?: any
						) => number;
						forEach: (
							callbackfn: (value: number, index: number, array: Float32Array) => void,
							thisArg?: any
						) => void;
						indexOf: (searchElement: number, fromIndex?: number | undefined) => number;
						join: (separator?: string | undefined) => string;
						lastIndexOf: (searchElement: number, fromIndex?: number | undefined) => number;
						readonly length: number;
						map: (
							callbackfn: (value: number, index: number, array: Float32Array) => number,
							thisArg?: any
						) => Float32Array;
						reduce: {
							(
								callbackfn: (
									previousValue: number,
									currentValue: number,
									currentIndex: number,
									array: Float32Array
								) => number
							): number;
							(
								callbackfn: (
									previousValue: number,
									currentValue: number,
									currentIndex: number,
									array: Float32Array
								) => number,
								initialValue: number
							): number;
							<U>(
								callbackfn: (
									previousValue: U,
									currentValue: number,
									currentIndex: number,
									array: Float32Array
								) => U,
								initialValue: U
							): U;
						};
						reduceRight: {
							(
								callbackfn: (
									previousValue: number,
									currentValue: number,
									currentIndex: number,
									array: Float32Array
								) => number
							): number;
							(
								callbackfn: (
									previousValue: number,
									currentValue: number,
									currentIndex: number,
									array: Float32Array
								) => number,
								initialValue: number
							): number;
							<U_1>(
								callbackfn: (
									previousValue: U_1,
									currentValue: number,
									currentIndex: number,
									array: Float32Array
								) => U_1,
								initialValue: U_1
							): U_1;
						};
						reverse: () => Float32Array;
						set: (array: ArrayLike<number>, offset?: number | undefined) => void;
						slice: (start?: number | undefined, end?: number | undefined) => Float32Array;
						some: (
							predicate: (value: number, index: number, array: Float32Array) => unknown,
							thisArg?: any
						) => boolean;
						sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
						subarray: (begin?: number | undefined, end?: number | undefined) => Float32Array;
						toLocaleString: () => string;
						toString: () => string;
						valueOf: () => Float32Array;
						entries: () => IterableIterator<[number, number]>;
						keys: () => IterableIterator<number>;
						values: () => IterableIterator<number>;
						includes: (searchElement: number, fromIndex?: number | undefined) => boolean;
						[Symbol.iterator]: () => IterableIterator<number>;
						readonly [Symbol.toStringTag]: 'Float32Array';
						at: (index: number) => number | undefined;
					};
					values: {
						[x: number]: number;
						readonly BYTES_PER_ELEMENT: number;
						readonly buffer:
							| {
									readonly byteLength: number;
									slice: (begin: number, end?: number | undefined) => ArrayBuffer;
									readonly [Symbol.toStringTag]: string;
							  }
							| {
									readonly byteLength: number;
									slice: (begin: number, end?: number | undefined) => SharedArrayBuffer;
									readonly [Symbol.species]: SharedArrayBuffer;
									readonly [Symbol.toStringTag]: 'SharedArrayBuffer';
							  };
						readonly byteLength: number;
						readonly byteOffset: number;
						copyWithin: (target: number, start: number, end?: number | undefined) => Float32Array;
						every: (
							predicate: (value: number, index: number, array: Float32Array) => unknown,
							thisArg?: any
						) => boolean;
						fill: (value: number, start?: number | undefined, end?: number | undefined) => Float32Array;
						filter: (
							predicate: (value: number, index: number, array: Float32Array) => any,
							thisArg?: any
						) => Float32Array;
						find: (
							predicate: (value: number, index: number, obj: Float32Array) => boolean,
							thisArg?: any
						) => number | undefined;
						findIndex: (
							predicate: (value: number, index: number, obj: Float32Array) => boolean,
							thisArg?: any
						) => number;
						forEach: (
							callbackfn: (value: number, index: number, array: Float32Array) => void,
							thisArg?: any
						) => void;
						indexOf: (searchElement: number, fromIndex?: number | undefined) => number;
						join: (separator?: string | undefined) => string;
						lastIndexOf: (searchElement: number, fromIndex?: number | undefined) => number;
						readonly length: number;
						map: (
							callbackfn: (value: number, index: number, array: Float32Array) => number,
							thisArg?: any
						) => Float32Array;
						reduce: {
							(
								callbackfn: (
									previousValue: number,
									currentValue: number,
									currentIndex: number,
									array: Float32Array
								) => number
							): number;
							(
								callbackfn: (
									previousValue: number,
									currentValue: number,
									currentIndex: number,
									array: Float32Array
								) => number,
								initialValue: number
							): number;
							<U>(
								callbackfn: (
									previousValue: U,
									currentValue: number,
									currentIndex: number,
									array: Float32Array
								) => U,
								initialValue: U
							): U;
						};
						reduceRight: {
							(
								callbackfn: (
									previousValue: number,
									currentValue: number,
									currentIndex: number,
									array: Float32Array
								) => number
							): number;
							(
								callbackfn: (
									previousValue: number,
									currentValue: number,
									currentIndex: number,
									array: Float32Array
								) => number,
								initialValue: number
							): number;
							<U_1>(
								callbackfn: (
									previousValue: U_1,
									currentValue: number,
									currentIndex: number,
									array: Float32Array
								) => U_1,
								initialValue: U_1
							): U_1;
						};
						reverse: () => Float32Array;
						set: (array: ArrayLike<number>, offset?: number | undefined) => void;
						slice: (start?: number | undefined, end?: number | undefined) => Float32Array;
						some: (
							predicate: (value: number, index: number, array: Float32Array) => unknown,
							thisArg?: any
						) => boolean;
						sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
						subarray: (begin?: number | undefined, end?: number | undefined) => Float32Array;
						toLocaleString: () => string;
						toString: () => string;
						valueOf: () => Float32Array;
						entries: () => IterableIterator<[number, number]>;
						keys: () => IterableIterator<number>;
						values: () => IterableIterator<number>;
						includes: (searchElement: number, fromIndex?: number | undefined) => boolean;
						[Symbol.iterator]: () => IterableIterator<number>;
						readonly [Symbol.toStringTag]: 'Float32Array';
						at: (index: number) => number | undefined;
					};
					ValueTypeName: string;
					TimeBufferType: {
						[x: number]: number;
						readonly BYTES_PER_ELEMENT: number;
						readonly buffer:
							| {
									readonly byteLength: number;
									slice: (begin: number, end?: number | undefined) => ArrayBuffer;
									readonly [Symbol.toStringTag]: string;
							  }
							| {
									readonly byteLength: number;
									slice: (begin: number, end?: number | undefined) => SharedArrayBuffer;
									readonly [Symbol.species]: SharedArrayBuffer;
									readonly [Symbol.toStringTag]: 'SharedArrayBuffer';
							  };
						readonly byteLength: number;
						readonly byteOffset: number;
						copyWithin: (target: number, start: number, end?: number | undefined) => Float32Array;
						every: (
							predicate: (value: number, index: number, array: Float32Array) => unknown,
							thisArg?: any
						) => boolean;
						fill: (value: number, start?: number | undefined, end?: number | undefined) => Float32Array;
						filter: (
							predicate: (value: number, index: number, array: Float32Array) => any,
							thisArg?: any
						) => Float32Array;
						find: (
							predicate: (value: number, index: number, obj: Float32Array) => boolean,
							thisArg?: any
						) => number | undefined;
						findIndex: (
							predicate: (value: number, index: number, obj: Float32Array) => boolean,
							thisArg?: any
						) => number;
						forEach: (
							callbackfn: (value: number, index: number, array: Float32Array) => void,
							thisArg?: any
						) => void;
						indexOf: (searchElement: number, fromIndex?: number | undefined) => number;
						join: (separator?: string | undefined) => string;
						lastIndexOf: (searchElement: number, fromIndex?: number | undefined) => number;
						readonly length: number;
						map: (
							callbackfn: (value: number, index: number, array: Float32Array) => number,
							thisArg?: any
						) => Float32Array;
						reduce: {
							(
								callbackfn: (
									previousValue: number,
									currentValue: number,
									currentIndex: number,
									array: Float32Array
								) => number
							): number;
							(
								callbackfn: (
									previousValue: number,
									currentValue: number,
									currentIndex: number,
									array: Float32Array
								) => number,
								initialValue: number
							): number;
							<U>(
								callbackfn: (
									previousValue: U,
									currentValue: number,
									currentIndex: number,
									array: Float32Array
								) => U,
								initialValue: U
							): U;
						};
						reduceRight: {
							(
								callbackfn: (
									previousValue: number,
									currentValue: number,
									currentIndex: number,
									array: Float32Array
								) => number
							): number;
							(
								callbackfn: (
									previousValue: number,
									currentValue: number,
									currentIndex: number,
									array: Float32Array
								) => number,
								initialValue: number
							): number;
							<U_1>(
								callbackfn: (
									previousValue: U_1,
									currentValue: number,
									currentIndex: number,
									array: Float32Array
								) => U_1,
								initialValue: U_1
							): U_1;
						};
						reverse: () => Float32Array;
						set: (array: ArrayLike<number>, offset?: number | undefined) => void;
						slice: (start?: number | undefined, end?: number | undefined) => Float32Array;
						some: (
							predicate: (value: number, index: number, array: Float32Array) => unknown,
							thisArg?: any
						) => boolean;
						sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
						subarray: (begin?: number | undefined, end?: number | undefined) => Float32Array;
						toLocaleString: () => string;
						toString: () => string;
						valueOf: () => Float32Array;
						entries: () => IterableIterator<[number, number]>;
						keys: () => IterableIterator<number>;
						values: () => IterableIterator<number>;
						includes: (searchElement: number, fromIndex?: number | undefined) => boolean;
						[Symbol.iterator]: () => IterableIterator<number>;
						readonly [Symbol.toStringTag]: 'Float32Array';
						at: (index: number) => number | undefined;
					};
					ValueBufferType: {
						[x: number]: number;
						readonly BYTES_PER_ELEMENT: number;
						readonly buffer:
							| {
									readonly byteLength: number;
									slice: (begin: number, end?: number | undefined) => ArrayBuffer;
									readonly [Symbol.toStringTag]: string;
							  }
							| {
									readonly byteLength: number;
									slice: (begin: number, end?: number | undefined) => SharedArrayBuffer;
									readonly [Symbol.species]: SharedArrayBuffer;
									readonly [Symbol.toStringTag]: 'SharedArrayBuffer';
							  };
						readonly byteLength: number;
						readonly byteOffset: number;
						copyWithin: (target: number, start: number, end?: number | undefined) => Float32Array;
						every: (
							predicate: (value: number, index: number, array: Float32Array) => unknown,
							thisArg?: any
						) => boolean;
						fill: (value: number, start?: number | undefined, end?: number | undefined) => Float32Array;
						filter: (
							predicate: (value: number, index: number, array: Float32Array) => any,
							thisArg?: any
						) => Float32Array;
						find: (
							predicate: (value: number, index: number, obj: Float32Array) => boolean,
							thisArg?: any
						) => number | undefined;
						findIndex: (
							predicate: (value: number, index: number, obj: Float32Array) => boolean,
							thisArg?: any
						) => number;
						forEach: (
							callbackfn: (value: number, index: number, array: Float32Array) => void,
							thisArg?: any
						) => void;
						indexOf: (searchElement: number, fromIndex?: number | undefined) => number;
						join: (separator?: string | undefined) => string;
						lastIndexOf: (searchElement: number, fromIndex?: number | undefined) => number;
						readonly length: number;
						map: (
							callbackfn: (value: number, index: number, array: Float32Array) => number,
							thisArg?: any
						) => Float32Array;
						reduce: {
							(
								callbackfn: (
									previousValue: number,
									currentValue: number,
									currentIndex: number,
									array: Float32Array
								) => number
							): number;
							(
								callbackfn: (
									previousValue: number,
									currentValue: number,
									currentIndex: number,
									array: Float32Array
								) => number,
								initialValue: number
							): number;
							<U>(
								callbackfn: (
									previousValue: U,
									currentValue: number,
									currentIndex: number,
									array: Float32Array
								) => U,
								initialValue: U
							): U;
						};
						reduceRight: {
							(
								callbackfn: (
									previousValue: number,
									currentValue: number,
									currentIndex: number,
									array: Float32Array
								) => number
							): number;
							(
								callbackfn: (
									previousValue: number,
									currentValue: number,
									currentIndex: number,
									array: Float32Array
								) => number,
								initialValue: number
							): number;
							<U_1>(
								callbackfn: (
									previousValue: U_1,
									currentValue: number,
									currentIndex: number,
									array: Float32Array
								) => U_1,
								initialValue: U_1
							): U_1;
						};
						reverse: () => Float32Array;
						set: (array: ArrayLike<number>, offset?: number | undefined) => void;
						slice: (start?: number | undefined, end?: number | undefined) => Float32Array;
						some: (
							predicate: (value: number, index: number, array: Float32Array) => unknown,
							thisArg?: any
						) => boolean;
						sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
						subarray: (begin?: number | undefined, end?: number | undefined) => Float32Array;
						toLocaleString: () => string;
						toString: () => string;
						valueOf: () => Float32Array;
						entries: () => IterableIterator<[number, number]>;
						keys: () => IterableIterator<number>;
						values: () => IterableIterator<number>;
						includes: (searchElement: number, fromIndex?: number | undefined) => boolean;
						[Symbol.iterator]: () => IterableIterator<number>;
						readonly [Symbol.toStringTag]: 'Float32Array';
						at: (index: number) => number | undefined;
					};
					DefaultInterpolation: InterpolationModes;
					InterpolantFactoryMethodDiscrete: (result: any) => DiscreteInterpolant;
					InterpolantFactoryMethodLinear: (result: any) => LinearInterpolant;
					InterpolantFactoryMethodSmooth: (result: any) => CubicInterpolant;
					setInterpolation: (interpolation: InterpolationModes) => KeyframeTrack;
					getInterpolation: () => InterpolationModes;
					createInterpolant: () => Interpolant;
					getValueSize: () => number;
					shift: (timeOffset: number) => KeyframeTrack;
					scale: (timeScale: number) => KeyframeTrack;
					trim: (startTime: number, endTime: number) => KeyframeTrack;
					validate: () => boolean;
					optimize: () => KeyframeTrack;
					clone: () => KeyframeTrack;
				}[];
				blendMode: AnimationBlendMode;
				duration: number;
				uuid: string;
				results: any[];
				resetDuration: () => AnimationClip;
				trim: () => AnimationClip;
				validate: () => boolean;
				optimize: () => AnimationClip;
				clone: () => AnimationClip;
				toJSON: (clip: AnimationClip) => any;
			}[];
			userData: {
				[key: string]: any;
			};
			customDepthMaterial: {
				alphaTest: number;
				alphaToCoverage: boolean;
				blendDst: BlendingDstFactor;
				blendDstAlpha: number | null;
				blendEquation: BlendingEquation;
				blendEquationAlpha: number | null;
				blending: Blending;
				blendSrc: BlendingDstFactor | BlendingSrcFactor;
				blendSrcAlpha: number | null;
				clipIntersection: boolean;
				clippingPlanes: any;
				clipShadows: boolean;
				colorWrite: boolean;
				defines:
					| {
							[key: string]: any;
					  }
					| undefined;
				depthFunc: DepthModes;
				depthTest: boolean;
				depthWrite: boolean;
				id: number;
				stencilWrite: boolean;
				stencilFunc: StencilFunc;
				stencilRef: number;
				stencilWriteMask: number;
				stencilFuncMask: number;
				stencilFail: StencilOp;
				stencilZFail: StencilOp;
				stencilZPass: StencilOp;
				readonly isMaterial: true;
				name: string;
				needsUpdate: boolean;
				opacity: number;
				polygonOffset: boolean;
				polygonOffsetFactor: number;
				polygonOffsetUnits: number;
				precision: 'highp' | 'mediump' | 'lowp' | null;
				premultipliedAlpha: boolean;
				forceSinglePass: boolean;
				dithering: boolean;
				side: Side;
				shadowSide: Side | null;
				toneMapped: boolean;
				transparent: boolean;
				type: string;
				uuid: string;
				vertexColors: boolean;
				visible: boolean;
				userData: any;
				version: number;
				clone: () => Material;
				copy: (material: Material) => Material;
				dispose: () => void;
				onBeforeCompile: (shader: Shader, renderer: WebGLRenderer) => void;
				customProgramCacheKey: () => string;
				setValues: (values: MaterialParameters) => void;
				toJSON: (meta?: any) => any;
				addEventListener: <T extends string>(type: T, listener: EventListener<Event, T, Material>) => void;
				hasEventListener: <T_1 extends string>(
					type: T_1,
					listener: EventListener<Event, T_1, Material>
				) => boolean;
				removeEventListener: <T_2 extends string>(
					type: T_2,
					listener: EventListener<Event, T_2, Material>
				) => void;
				dispatchEvent: (event: Event) => void;
			};
			customDistanceMaterial: {
				alphaTest: number;
				alphaToCoverage: boolean;
				blendDst: BlendingDstFactor;
				blendDstAlpha: number | null;
				blendEquation: BlendingEquation;
				blendEquationAlpha: number | null;
				blending: Blending;
				blendSrc: BlendingDstFactor | BlendingSrcFactor;
				blendSrcAlpha: number | null;
				clipIntersection: boolean;
				clippingPlanes: any;
				clipShadows: boolean;
				colorWrite: boolean;
				defines:
					| {
							[key: string]: any;
					  }
					| undefined;
				depthFunc: DepthModes;
				depthTest: boolean;
				depthWrite: boolean;
				id: number;
				stencilWrite: boolean;
				stencilFunc: StencilFunc;
				stencilRef: number;
				stencilWriteMask: number;
				stencilFuncMask: number;
				stencilFail: StencilOp;
				stencilZFail: StencilOp;
				stencilZPass: StencilOp;
				readonly isMaterial: true;
				name: string;
				needsUpdate: boolean;
				opacity: number;
				polygonOffset: boolean;
				polygonOffsetFactor: number;
				polygonOffsetUnits: number;
				precision: 'highp' | 'mediump' | 'lowp' | null;
				premultipliedAlpha: boolean;
				forceSinglePass: boolean;
				dithering: boolean;
				side: Side;
				shadowSide: Side | null;
				toneMapped: boolean;
				transparent: boolean;
				type: string;
				uuid: string;
				vertexColors: boolean;
				visible: boolean;
				userData: any;
				version: number;
				clone: () => Material;
				copy: (material: Material) => Material;
				dispose: () => void;
				onBeforeCompile: (shader: Shader, renderer: WebGLRenderer) => void;
				customProgramCacheKey: () => string;
				setValues: (values: MaterialParameters) => void;
				toJSON: (meta?: any) => any;
				addEventListener: <T extends string>(type: T, listener: EventListener<Event, T, Material>) => void;
				hasEventListener: <T_1 extends string>(
					type: T_1,
					listener: EventListener<Event, T_1, Material>
				) => boolean;
				removeEventListener: <T_2 extends string>(
					type: T_2,
					listener: EventListener<Event, T_2, Material>
				) => void;
				dispatchEvent: (event: Event) => void;
			};
			readonly isObject3D: true;
			onBeforeRender: (
				renderer: WebGLRenderer,
				scene: Scene,
				camera: Camera,
				geometry: BufferGeometry,
				material: Material,
				group: Group
			) => void;
			onAfterRender: (
				renderer: WebGLRenderer,
				scene: Scene,
				camera: Camera,
				geometry: BufferGeometry,
				material: Material,
				group: Group
			) => void;
			applyMatrix4: (matrix: Matrix4) => void;
			applyQuaternion: (quaternion: Quaternion) => Camera;
			setRotationFromAxisAngle: (axis: Vector3, angle: number) => void;
			setRotationFromEuler: (euler: Euler) => void;
			setRotationFromMatrix: (m: Matrix4) => void;
			setRotationFromQuaternion: (q: Quaternion) => void;
			rotateOnAxis: (axis: Vector3, angle: number) => Camera;
			rotateOnWorldAxis: (axis: Vector3, angle: number) => Camera;
			rotateX: (angle: number) => Camera;
			rotateY: (angle: number) => Camera;
			rotateZ: (angle: number) => Camera;
			translateOnAxis: (axis: Vector3, distance: number) => Camera;
			translateX: (distance: number) => Camera;
			translateY: (distance: number) => Camera;
			translateZ: (distance: number) => Camera;
			localToWorld: (vector: Vector3) => Vector3;
			worldToLocal: (vector: Vector3) => Vector3;
			lookAt: {
				(vector: Vector3): void;
				(x: number, y: number, z: number): void;
			};
			add: (...object: Object3D<Event>[]) => Camera;
			remove: (...object: Object3D<Event>[]) => Camera;
			removeFromParent: () => Camera;
			clear: () => Camera;
			attach: (object: Object3D<Event>) => Camera;
			getObjectById: (id: number) => Object3D<Event> | undefined;
			getObjectByName: (name: string) => Object3D<Event> | undefined;
			getObjectByProperty: (name: string, value: any) => Object3D<Event> | undefined;
			getObjectsByProperty: (name: string, value: any) => Object3D<Event>[];
			getWorldPosition: (target: Vector3) => Vector3;
			getWorldQuaternion: (target: Quaternion) => Quaternion;
			getWorldScale: (target: Vector3) => Vector3;
			raycast: (raycaster: Raycaster, intersects: Intersection<Object3D<Event>>[]) => void;
			traverse: (callback: (object: Object3D<Event>) => any) => void;
			traverseVisible: (callback: (object: Object3D<Event>) => any) => void;
			traverseAncestors: (callback: (object: Object3D<Event>) => any) => void;
			updateMatrix: () => void;
			updateWorldMatrix: (updateParents: boolean, updateChildren: boolean) => void;
			toJSON: (
				meta?:
					| {
							geometries: any;
							materials: any;
							textures: any;
							images: any;
					  }
					| undefined
			) => any;
			clone: (recursive?: boolean | undefined) => Camera;
			copy: (source: Camera, recursive?: boolean | undefined) => Camera;
			addEventListener: <T_6 extends string>(type: T_6, listener: EventListener<Event, T_6, Camera>) => void;
			hasEventListener: <T_7 extends string>(type: T_7, listener: EventListener<Event, T_7, Camera>) => boolean;
			removeEventListener: <T_8 extends string>(type: T_8, listener: EventListener<Event, T_8, Camera>) => void;
			dispatchEvent: (event: Event) => void;
		};
		layers: {
			mask: number;
			set: (channel: number) => void;
			enable: (channel: number) => void;
			enableAll: () => void;
			toggle: (channel: number) => void;
			disable: (channel: number) => void;
			disableAll: () => void;
			test: (layers: Layers) => boolean;
			isEnabled: (channel: number) => boolean;
		};
		params: {
			Mesh?: any;
			Line?:
				| {
						threshold: number;
				  }
				| undefined;
			LOD?: any;
			Points?:
				| {
						threshold: number;
				  }
				| undefined;
			Sprite?: any;
		};
		set: (origin: Vector3, direction: Vector3) => void;
		setFromCamera: (
			coords: {
				x: number;
				y: number;
			},
			camera: Camera
		) => void;
		intersectObject: <TIntersected extends Object3D<Event>>(
			object: Object3D<Event>,
			recursive?: boolean | undefined,
			optionalTarget?: Intersection<TIntersected>[] | undefined
		) => Intersection<TIntersected>[];
		intersectObjects: <TIntersected_1 extends Object3D<Event>>(
			objects: Object3D<Event>[],
			recursive?: boolean | undefined,
			optionalTarget?: Intersection<TIntersected_1>[] | undefined
		) => Intersection<TIntersected_1>[];
		firstHitOnly?: boolean | undefined;
	}>;
	cursor(): import('@vue/reactivity').Ref<{
		x: number;
		y: number;
		width: number;
		height: number;
		readonly isVector2: true;
		set: (x: number, y: number) => Vector2;
		setScalar: (scalar: number) => Vector2;
		setX: (x: number) => Vector2;
		setY: (y: number) => Vector2;
		setComponent: (index: number, value: number) => Vector2;
		getComponent: (index: number) => number;
		clone: () => Vector2;
		copy: (v: Vector2) => Vector2;
		add: (v: Vector2, w?: Vector2 | undefined) => Vector2;
		addScalar: (s: number) => Vector2;
		addVectors: (a: Vector2, b: Vector2) => Vector2;
		addScaledVector: (v: Vector2, s: number) => Vector2;
		sub: (v: Vector2) => Vector2;
		subScalar: (s: number) => Vector2;
		subVectors: (a: Vector2, b: Vector2) => Vector2;
		multiply: (v: Vector2) => Vector2;
		multiplyScalar: (scalar: number) => Vector2;
		divide: (v: Vector2) => Vector2;
		divideScalar: (s: number) => Vector2;
		applyMatrix3: (m: Matrix3) => Vector2;
		min: (v: Vector2) => Vector2;
		max: (v: Vector2) => Vector2;
		clamp: (min: Vector2, max: Vector2) => Vector2;
		clampScalar: (min: number, max: number) => Vector2;
		clampLength: (min: number, max: number) => Vector2;
		floor: () => Vector2;
		ceil: () => Vector2;
		round: () => Vector2;
		roundToZero: () => Vector2;
		negate: () => Vector2;
		dot: (v: Vector2) => number;
		cross: (v: Vector2) => number;
		lengthSq: () => number;
		length: () => number;
		lengthManhattan: () => number;
		manhattanLength: () => number;
		normalize: () => Vector2;
		angle: () => number;
		distanceTo: (v: Vector2) => number;
		distanceToSquared: (v: Vector2) => number;
		distanceToManhattan: (v: Vector2) => number;
		manhattanDistanceTo: (v: Vector2) => number;
		setLength: (length: number) => Vector2;
		lerp: (v: Vector2, alpha: number) => Vector2;
		lerpVectors: (v1: Vector2, v2: Vector2, alpha: number) => Vector2;
		equals: (v: Vector2) => boolean;
		fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Vector2;
		toArray: {
			(array?: number[] | undefined, offset?: number | undefined): number[];
			(array?: Vector2Tuple | undefined, offset?: 0 | undefined): Vector2Tuple;
			(array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
		};
		fromBufferAttribute: (attribute: BufferAttribute, index: number) => Vector2;
		rotateAround: (center: Vector2, angle: number) => Vector2;
		random: () => Vector2;
	}>;
	updateRaycast(options: RaycasterUpdateOptions): void;
}
declare class WindowEventsController extends BaseSceneEventsController<Event, PointerEventNode> {
	protected _requireCanvasEventListeners: boolean;
	type(): string;
	acceptedEventTypes(): Set<string>;
}
declare class TouchEventsController extends BaseSceneEventsController<MouseEvent, PointerEventNode> {
	protected _requireCanvasEventListeners: boolean;
	type(): string;
	acceptedEventTypes(): Set<TouchEventType>;
}
export interface BaseConnectionPointData {
	name: string;
	type: string;
	isArray?: boolean;
}
declare abstract class BaseConnectionPoint {
	protected _name: string;
	protected _type: string;
	protected _init_value?: any;
	protected _json: BaseConnectionPointData | undefined;
	protected _inNodeDefinition: boolean;
	constructor(_name: string, _type: string, _init_value?: any);
	get init_value(): any;
	name(): string;
	type(): string;
	are_types_matched(src_type: string, dest_type: string): boolean;
	inNodeDefinition(): boolean;
	abstract get param_type(): ParamType | null;
	toJSON(): BaseConnectionPointData;
	protected _create_json(): BaseConnectionPointData;
}
declare enum GlConnectionPointType {
	BOOL = 'bool',
	INT = 'int',
	FLOAT = 'float',
	VEC2 = 'vec2',
	VEC3 = 'vec3',
	VEC4 = 'vec4',
	SAMPLER_2D = 'sampler2D',
	SAMPLER_2D_ARRAY = 'sampler2DArray',
	SAMPLER_3D = 'sampler3D',
	SAMPLER_CUBE = 'samplerCube',
	SSS_MODEL = 'SSSModel',
	SDF_CONTEXT = 'SDFContext',
	SDF_MATERIAL = 'SDFMaterial',
}
export declare type GlConnectionPointTypeToParamTypeMapGeneric = {
	[key in GlConnectionPointType]: ParamType;
};
export interface GlIConnectionPointTypeToParamTypeMap extends GlConnectionPointTypeToParamTypeMapGeneric {
	[GlConnectionPointType.BOOL]: ParamType.BOOLEAN;
	[GlConnectionPointType.INT]: ParamType.INTEGER;
	[GlConnectionPointType.FLOAT]: ParamType.FLOAT;
	[GlConnectionPointType.VEC2]: ParamType.VECTOR2;
	[GlConnectionPointType.VEC3]: ParamType.VECTOR3;
	[GlConnectionPointType.VEC4]: ParamType.VECTOR4;
}
export declare type GlConnectionPointInitValueMapGeneric = {
	[key in GlConnectionPointType]: ParamInitValuesTypeMap[GlIConnectionPointTypeToParamTypeMap[key]];
};
export interface GlConnectionPointData<T extends GlConnectionPointType> {
	name: string;
	type: T;
	isArray?: boolean;
}
declare class GlConnectionPoint<T extends GlConnectionPointType> extends BaseConnectionPoint {
	protected _name: string;
	protected _type: T;
	protected _init_value?: GlConnectionPointInitValueMapGeneric[T] | undefined;
	protected _json: GlConnectionPointData<T> | undefined;
	constructor(_name: string, _type: T, _init_value?: GlConnectionPointInitValueMapGeneric[T] | undefined);
	type(): T;
	are_types_matched(src_type: string, dest_type: string): boolean;
	get param_type(): GlIConnectionPointTypeToParamTypeMap[T];
	get init_value(): GlConnectionPointInitValueMapGeneric[T] | undefined;
	toJSON(): GlConnectionPointData<T>;
	protected _create_json(): GlConnectionPointData<T>;
}
export declare type BaseGlConnectionPoint = GlConnectionPoint<GlConnectionPointType>;
declare enum JsConnectionPointType {
	ANIMATION_MIXER = 'AnimationMixer',
	ANIMATION_ACTION = 'AnimationAction',
	BOOLEAN = 'boolean',
	BOOLEAN_ARRAY = 'boolean[]',
	BOX3 = 'Box3',
	CAMERA = 'Camera',
	CATMULL_ROM_CURVE3 = 'CatmullRomCurve3',
	COLOR = 'Color',
	COLOR_ARRAY = 'Color[]',
	FLOAT = 'float',
	FLOAT_ARRAY = 'float[]',
	INT = 'int',
	INT_ARRAY = 'int[]',
	INTERSECTION = 'Intersection',
	INTERSECTION_ARRAY = 'Intersection[]',
	MATERIAL = 'Material',
	MATRIX4 = 'Matrix4',
	MATRIX4_ARRAY = 'Matrix4[]',
	OBJECT_3D = 'Object3D',
	PLANE = 'Plane',
	QUATERNION = 'Quaternion',
	QUATERNION_ARRAY = 'Quaternion[]',
	RAY = 'Ray',
	SPHERE = 'Sphere',
	STRING = 'string',
	STRING_ARRAY = 'string[]',
	TEXTURE = 'Texture',
	TEXTURE_ARRAY = 'Texture[]',
	TRIGGER = 'trigger',
	VECTOR2 = 'Vector2',
	VECTOR2_ARRAY = 'Vector2[]',
	VECTOR3 = 'Vector3',
	VECTOR3_ARRAY = 'Vector3[]',
	VECTOR4 = 'Vector4',
	VECTOR4_ARRAY = 'Vector4[]',
}
export declare type PrimitiveArrayElement = boolean | number | string;
export declare type VectorArrayElement = Color | Matrix4 | Quaternion | Vector2 | Vector3 | Vector4;
export declare type ArrayableConnectionPointType =
	| JsConnectionPointType.BOOLEAN
	| JsConnectionPointType.COLOR
	| JsConnectionPointType.FLOAT
	| JsConnectionPointType.INT
	| JsConnectionPointType.INTERSECTION
	| JsConnectionPointType.MATRIX4
	| JsConnectionPointType.QUATERNION
	| JsConnectionPointType.STRING
	| JsConnectionPointType.TEXTURE
	| JsConnectionPointType.VECTOR2
	| JsConnectionPointType.VECTOR3
	| JsConnectionPointType.VECTOR4;
export declare type JsConnectionPointTypeArray =
	| JsConnectionPointType.BOOLEAN_ARRAY
	| JsConnectionPointType.COLOR_ARRAY
	| JsConnectionPointType.FLOAT_ARRAY
	| JsConnectionPointType.INT_ARRAY
	| JsConnectionPointType.INTERSECTION_ARRAY
	| JsConnectionPointType.MATRIX4_ARRAY
	| JsConnectionPointType.QUATERNION_ARRAY
	| JsConnectionPointType.STRING_ARRAY
	| JsConnectionPointType.TEXTURE_ARRAY
	| JsConnectionPointType.VECTOR2_ARRAY
	| JsConnectionPointType.VECTOR3_ARRAY
	| JsConnectionPointType.VECTOR4_ARRAY;
export declare type ParamConvertibleJsType =
	| JsConnectionPointType.BOOLEAN
	| JsConnectionPointType.COLOR
	| JsConnectionPointType.FLOAT
	| JsConnectionPointType.INT
	| JsConnectionPointType.STRING
	| JsConnectionPointType.VECTOR2
	| JsConnectionPointType.VECTOR3
	| JsConnectionPointType.VECTOR4;
export declare type JsDataType =
	| PrimitiveArrayElement
	| Array<PrimitiveArrayElement>
	| VectorArrayElement
	| Array<VectorArrayElement>
	| AnimationMixer
	| AnimationAction
	| Box3
	| Camera
	| CatmullRomCurve3
	| Intersection
	| Array<Intersection>
	| Material
	| Object3D
	| Ray
	| Sphere
	| Texture
	| Array<Texture>
	| null;
export declare type JSConnectionPointTypeToParamTypeMapGeneric = {
	[key in JsConnectionPointType]: ParamType | undefined;
};
export interface JsIConnectionPointTypeToParamTypeMap extends JSConnectionPointTypeToParamTypeMapGeneric {
	[JsConnectionPointType.ANIMATION_MIXER]: ParamType.BUTTON;
	[JsConnectionPointType.ANIMATION_ACTION]: ParamType.BUTTON;
	[JsConnectionPointType.BOOLEAN]: ParamType.BOOLEAN;
	[JsConnectionPointType.BOOLEAN_ARRAY]: ParamType.BUTTON;
	[JsConnectionPointType.BOX3]: ParamType.BUTTON;
	[JsConnectionPointType.CAMERA]: ParamType.BUTTON;
	[JsConnectionPointType.CATMULL_ROM_CURVE3]: ParamType.BUTTON;
	[JsConnectionPointType.COLOR]: ParamType.COLOR;
	[JsConnectionPointType.COLOR_ARRAY]: ParamType.BUTTON;
	[JsConnectionPointType.FLOAT]: ParamType.FLOAT;
	[JsConnectionPointType.FLOAT_ARRAY]: ParamType.BUTTON;
	[JsConnectionPointType.INT]: ParamType.INTEGER;
	[JsConnectionPointType.INT_ARRAY]: ParamType.BUTTON;
	[JsConnectionPointType.INTERSECTION]: ParamType.BUTTON;
	[JsConnectionPointType.INTERSECTION_ARRAY]: ParamType.BUTTON;
	[JsConnectionPointType.MATERIAL]: ParamType.BUTTON;
	[JsConnectionPointType.MATRIX4]: ParamType.BUTTON;
	[JsConnectionPointType.MATRIX4_ARRAY]: ParamType.BUTTON;
	[JsConnectionPointType.OBJECT_3D]: ParamType.BUTTON;
	[JsConnectionPointType.PLANE]: ParamType.BUTTON;
	[JsConnectionPointType.QUATERNION]: ParamType.BUTTON;
	[JsConnectionPointType.QUATERNION_ARRAY]: ParamType.BUTTON;
	[JsConnectionPointType.RAY]: ParamType.BUTTON;
	[JsConnectionPointType.SPHERE]: ParamType.BUTTON;
	[JsConnectionPointType.STRING]: ParamType.STRING;
	[JsConnectionPointType.STRING_ARRAY]: ParamType.BUTTON;
	[JsConnectionPointType.TEXTURE]: ParamType.BUTTON;
	[JsConnectionPointType.TEXTURE_ARRAY]: ParamType.BUTTON;
	[JsConnectionPointType.TRIGGER]: ParamType.BUTTON;
	[JsConnectionPointType.VECTOR2]: ParamType.VECTOR2;
	[JsConnectionPointType.VECTOR2_ARRAY]: ParamType.BUTTON;
	[JsConnectionPointType.VECTOR3]: ParamType.VECTOR3;
	[JsConnectionPointType.VECTOR3_ARRAY]: ParamType.BUTTON;
	[JsConnectionPointType.VECTOR4]: ParamType.VECTOR4;
	[JsConnectionPointType.VECTOR4_ARRAY]: ParamType.BUTTON;
}
export declare type ConnectionPointInitValueMapGeneric = {
	[key in JsConnectionPointType]: ParamInitValuesTypeMap[JsIConnectionPointTypeToParamTypeMap[key]];
};
export interface JsConnectionPointData<T extends JsConnectionPointType> {
	name: string;
	type: T;
	isArray?: boolean;
}
export interface JsConnectionPointOptions<T extends JsConnectionPointType> {
	inNodeDefinition?: boolean;
	init_value?: ConnectionPointInitValueMapGeneric[T];
}
declare class JsConnectionPoint<T extends JsConnectionPointType> extends BaseConnectionPoint {
	protected _type: T;
	protected _options?: JsConnectionPointOptions<T> | undefined;
	protected _json: JsConnectionPointData<T> | undefined;
	protected _init_value?: ConnectionPointInitValueMapGeneric[T];
	protected _isArray: boolean;
	constructor(_name: string, _type: T, _options?: JsConnectionPointOptions<T> | undefined);
	type(): T;
	are_types_matched(src_type: string, dest_type: string): boolean;
	get param_type(): JsIConnectionPointTypeToParamTypeMap[T];
	get init_value(): ConnectionPointInitValueMapGeneric[T] | undefined;
	toJSON(): JsConnectionPointData<T>;
	protected _create_json(): JsConnectionPointData<T>;
}
export declare type BaseJsConnectionPoint = JsConnectionPoint<JsConnectionPointType>;
declare enum EventConnectionPointType {
	BASE = 'base',
	DRAG = 'drag',
	KEYBOARD = 'keyboard',
	MOUSE = 'mouse',
	POINTER = 'pointer',
}
export interface EventConnectionPointData<T extends EventConnectionPointType> {
	name: string;
	type: T;
	isArray?: boolean;
}
declare class EventConnectionPoint<T extends EventConnectionPointType> extends BaseConnectionPoint {
	protected _name: string;
	protected _type: T;
	protected _event_listener?: ((event_context: EventContext<any>) => void) | undefined;
	protected _json: EventConnectionPointData<T> | undefined;
	constructor(
		_name: string,
		_type: T, // protected _init_value?: ConnectionPointInitValueMapGeneric[T]
		_event_listener?: ((event_context: EventContext<any>) => void) | undefined
	);
	type(): T;
	get param_type(): ParamType;
	are_types_matched(src_type: string, dest_type: string): boolean;
	get event_listener(): ((event_context: EventContext<any>) => void) | undefined;
	toJSON(): EventConnectionPointData<T>;
	protected _create_json(): EventConnectionPointData<T>;
}
export declare type BaseEventConnectionPoint = EventConnectionPoint<EventConnectionPointType>;
declare enum ActorConnectionPointType {
	ANIMATION_MIXER = 'AnimationMixer',
	ANIMATION_ACTION = 'AnimationAction',
	BOOLEAN = 'boolean',
	BOOLEAN_ARRAY = 'boolean[]',
	BOX3 = 'Box3',
	CAMERA = 'Camera',
	CATMULL_ROM_CURVE3 = 'CatmullRomCurve3',
	COLOR = 'Color',
	COLOR_ARRAY = 'Color[]',
	FLOAT = 'float',
	FLOAT_ARRAY = 'float[]',
	INTEGER = 'integer',
	INTEGER_ARRAY = 'integer[]',
	INTERSECTION = 'Intersection',
	INTERSECTION_ARRAY = 'Intersection[]',
	MATERIAL = 'Material',
	MATRIX4 = 'Matrix4',
	MATRIX4_ARRAY = 'Matrix4[]',
	OBJECT_3D = 'Object3D',
	PLANE = 'Plane',
	QUATERNION = 'Quaternion',
	QUATERNION_ARRAY = 'Quaternion[]',
	RAY = 'Ray',
	SPHERE = 'Sphere',
	STRING = 'string',
	STRING_ARRAY = 'string[]',
	TEXTURE = 'Texture',
	TEXTURE_ARRAY = 'Texture[]',
	TRIGGER = 'trigger',
	VECTOR2 = 'Vector2',
	VECTOR2_ARRAY = 'Vector2[]',
	VECTOR3 = 'Vector3',
	VECTOR3_ARRAY = 'Vector3[]',
	VECTOR4 = 'Vector4',
	VECTOR4_ARRAY = 'Vector4[]',
}
export declare type ActorConnectionPointTypeToParamTypeMapGeneric = {
	[key in ActorConnectionPointType]: ParamType;
};
export interface ActorIConnectionPointTypeToParamTypeMap extends ActorConnectionPointTypeToParamTypeMapGeneric {
	[ActorConnectionPointType.ANIMATION_MIXER]: ParamType.BUTTON;
	[ActorConnectionPointType.ANIMATION_ACTION]: ParamType.BUTTON;
	[ActorConnectionPointType.BOOLEAN]: ParamType.BOOLEAN;
	[ActorConnectionPointType.BOOLEAN_ARRAY]: ParamType.BUTTON;
	[ActorConnectionPointType.BOX3]: ParamType.BUTTON;
	[ActorConnectionPointType.CAMERA]: ParamType.BUTTON;
	[ActorConnectionPointType.CATMULL_ROM_CURVE3]: ParamType.BUTTON;
	[ActorConnectionPointType.COLOR]: ParamType.COLOR;
	[ActorConnectionPointType.COLOR_ARRAY]: ParamType.BUTTON;
	[ActorConnectionPointType.FLOAT]: ParamType.FLOAT;
	[ActorConnectionPointType.FLOAT_ARRAY]: ParamType.BUTTON;
	[ActorConnectionPointType.INTEGER]: ParamType.INTEGER;
	[ActorConnectionPointType.INTEGER_ARRAY]: ParamType.BUTTON;
	[ActorConnectionPointType.INTERSECTION]: ParamType.BUTTON;
	[ActorConnectionPointType.INTERSECTION_ARRAY]: ParamType.BUTTON;
	[ActorConnectionPointType.MATERIAL]: ParamType.BUTTON;
	[ActorConnectionPointType.MATRIX4]: ParamType.BUTTON;
	[ActorConnectionPointType.MATRIX4_ARRAY]: ParamType.BUTTON;
	[ActorConnectionPointType.OBJECT_3D]: ParamType.BUTTON;
	[ActorConnectionPointType.PLANE]: ParamType.BUTTON;
	[ActorConnectionPointType.QUATERNION]: ParamType.BUTTON;
	[ActorConnectionPointType.QUATERNION_ARRAY]: ParamType.BUTTON;
	[ActorConnectionPointType.RAY]: ParamType.BUTTON;
	[ActorConnectionPointType.SPHERE]: ParamType.BUTTON;
	[ActorConnectionPointType.STRING]: ParamType.STRING;
	[ActorConnectionPointType.STRING_ARRAY]: ParamType.BUTTON;
	[ActorConnectionPointType.TEXTURE]: ParamType.BUTTON;
	[ActorConnectionPointType.TEXTURE_ARRAY]: ParamType.BUTTON;
	[ActorConnectionPointType.TRIGGER]: ParamType.BUTTON;
	[ActorConnectionPointType.VECTOR2]: ParamType.VECTOR2;
	[ActorConnectionPointType.VECTOR2_ARRAY]: ParamType.BUTTON;
	[ActorConnectionPointType.VECTOR3]: ParamType.VECTOR3;
	[ActorConnectionPointType.VECTOR3_ARRAY]: ParamType.BUTTON;
	[ActorConnectionPointType.VECTOR4]: ParamType.VECTOR4;
	[ActorConnectionPointType.VECTOR4_ARRAY]: ParamType.BUTTON;
}
export declare type ActorConnectionPointInitValueMapGeneric = {
	[key in ActorConnectionPointType]: ParamInitValuesTypeMap[ActorIConnectionPointTypeToParamTypeMap[key]];
};
export declare type ReturnValueTypeByActorConnectionPointType = {
	[ActorConnectionPointType.ANIMATION_MIXER]: AnimationMixer;
	[ActorConnectionPointType.ANIMATION_ACTION]: AnimationAction;
	[ActorConnectionPointType.BOOLEAN]: boolean;
	[ActorConnectionPointType.BOOLEAN_ARRAY]: boolean[];
	[ActorConnectionPointType.BOX3]: Box3;
	[ActorConnectionPointType.CAMERA]: Camera;
	[ActorConnectionPointType.CATMULL_ROM_CURVE3]: CatmullRomCurve3;
	[ActorConnectionPointType.COLOR]: Color;
	[ActorConnectionPointType.COLOR_ARRAY]: Color[];
	[ActorConnectionPointType.FLOAT]: number;
	[ActorConnectionPointType.FLOAT_ARRAY]: number[];
	[ActorConnectionPointType.INTEGER]: number;
	[ActorConnectionPointType.INTEGER_ARRAY]: number[];
	[ActorConnectionPointType.INTERSECTION]: Intersection;
	[ActorConnectionPointType.INTERSECTION_ARRAY]: Intersection[];
	[ActorConnectionPointType.MATERIAL]: Material;
	[ActorConnectionPointType.MATRIX4]: Matrix4;
	[ActorConnectionPointType.MATRIX4_ARRAY]: Matrix4[];
	[ActorConnectionPointType.OBJECT_3D]: Object3D;
	[ActorConnectionPointType.PLANE]: Plane;
	[ActorConnectionPointType.QUATERNION]: Quaternion;
	[ActorConnectionPointType.QUATERNION_ARRAY]: Quaternion[];
	[ActorConnectionPointType.RAY]: Ray;
	[ActorConnectionPointType.SPHERE]: Sphere;
	[ActorConnectionPointType.STRING]: string;
	[ActorConnectionPointType.STRING_ARRAY]: string[];
	[ActorConnectionPointType.TEXTURE]: Texture;
	[ActorConnectionPointType.TEXTURE_ARRAY]: Texture[];
	[ActorConnectionPointType.TRIGGER]: null;
	[ActorConnectionPointType.VECTOR2]: Vector2;
	[ActorConnectionPointType.VECTOR2_ARRAY]: Vector2[];
	[ActorConnectionPointType.VECTOR3]: Vector3;
	[ActorConnectionPointType.VECTOR3_ARRAY]: Vector3[];
	[ActorConnectionPointType.VECTOR4]: Vector4;
	[ActorConnectionPointType.VECTOR4_ARRAY]: Vector4[];
};
export interface ActorConnectionPointData<T extends ActorConnectionPointType> {
	name: string;
	type: T;
	isArray: boolean;
}
export interface ActorConnectionPointOptions<T extends ActorConnectionPointType> {
	inNodeDefinition?: boolean;
	init_value?: ActorConnectionPointInitValueMapGeneric[T];
}
declare class ActorConnectionPoint<T extends ActorConnectionPointType> extends BaseConnectionPoint {
	protected _name: string;
	protected _type: T;
	protected _json: ActorConnectionPointData<T> | undefined;
	protected _init_value?: ActorConnectionPointInitValueMapGeneric[T];
	protected _isArray: boolean;
	constructor(_name: string, _type: T, _options?: ActorConnectionPointOptions<T>);
	type(): T;
	get param_type(): ActorIConnectionPointTypeToParamTypeMap[T] | null;
	get init_value(): ActorConnectionPointInitValueMapGeneric[T] | undefined;
	are_types_matched(srcType: string, destType: string): boolean;
	toJSON(): ActorConnectionPointData<T>;
	protected _create_json(): ActorConnectionPointData<T>;
}
export declare type BaseActorConnectionPoint = ActorConnectionPoint<ActorConnectionPointType>;
export declare type ConnectionPointTypeMapGeneric = {
	[key in NodeContext]:
		| BaseActorConnectionPoint
		| BaseEventConnectionPoint
		| BaseGlConnectionPoint
		| BaseJsConnectionPoint
		| undefined;
};
export interface ConnectionPointTypeMap extends ConnectionPointTypeMapGeneric {
	[NodeContext.ACTOR]: BaseActorConnectionPoint;
	[NodeContext.ANIM]: undefined;
	[NodeContext.AUDIO]: undefined;
	[NodeContext.COP]: undefined;
	[NodeContext.EVENT]: BaseEventConnectionPoint;
	[NodeContext.GL]: BaseGlConnectionPoint;
	[NodeContext.JS]: BaseJsConnectionPoint;
	[NodeContext.MANAGER]: undefined;
	[NodeContext.MAT]: undefined;
	[NodeContext.OBJ]: undefined;
	[NodeContext.POST]: undefined;
	[NodeContext.ROP]: undefined;
	[NodeContext.SOP]: undefined;
}
export declare type ConnectionPointEnumMapGeneric = {
	[key in NodeContext]:
		| ActorConnectionPointType
		| EventConnectionPointType
		| GlConnectionPointType
		| JsConnectionPointType
		| undefined;
};
export interface ConnectionPointEnumMap extends ConnectionPointEnumMapGeneric {
	[NodeContext.ACTOR]: ActorConnectionPointType;
	[NodeContext.ANIM]: undefined;
	[NodeContext.AUDIO]: undefined;
	[NodeContext.COP]: undefined;
	[NodeContext.EVENT]: EventConnectionPointType;
	[NodeContext.GL]: GlConnectionPointType;
	[NodeContext.JS]: JsConnectionPointType;
	[NodeContext.MANAGER]: undefined;
	[NodeContext.MAT]: undefined;
	[NodeContext.OBJ]: undefined;
	[NodeContext.POST]: undefined;
	[NodeContext.ROP]: undefined;
	[NodeContext.SOP]: undefined;
}
export interface DisconnectionOptions {
	setInput?: boolean;
	ignoreLockedState?: boolean;
}
declare class TypedNodeConnection<NC extends NodeContext> {
	private _node_src;
	private _node_dest;
	private _output_index;
	private _input_index;
	private static _next_id;
	private _id;
	constructor(
		_node_src: TypedNode<NC, any>,
		_node_dest: TypedNode<NC, any>,
		_output_index?: number,
		_input_index?: number
	);
	get id(): number;
	get node_src(): BaseNodeByContextMap[NC];
	get node_dest(): BaseNodeByContextMap[NC];
	get output_index(): number;
	get input_index(): number;
	src_connection_point(): ConnectionPointTypeMap[NC];
	dest_connection_point(): ConnectionPointTypeMap[NC];
	disconnect(options?: DisconnectionOptions): void;
	private __eventDispatcher;
	_eventDispatcher(): EventDispatcher<Event> | undefined;
	eventDispatcher(): EventDispatcher<Event>;
}
declare class SceneConnectionTriggerDispatcher {
	private _dispatchedConnections;
	constructor();
	dispatchTrigger<NC extends NodeContext>(connection: TypedNodeConnection<NC>): void;
}
declare class SceneEventsDispatcher {
	scene: PolyScene;
	readonly sceneEventsController: SceneEventsController;
	private _keyboardEventsController?;
	private _mouseEventsController?;
	private _dragEventsController?;
	private _pointerEventsController?;
	private _windowEventsController?;
	private _touchEventsController?;
	private _controllers;
	constructor(scene: PolyScene);
	registerEvaluatorGenerator(evaluatorGenerator: ActorEvaluatorGenerator): void;
	unregisterEvaluatorGenerator(evaluatorGenerator: ActorEvaluatorGenerator): void;
	registerEventNode(node: BaseInputEventNodeType): void;
	unregisterEventNode(node: BaseInputEventNodeType): void;
	updateViewerEventListeners(node: BaseInputEventNodeType): void;
	traverseControllers(callback: (controller: BaseSceneEventsController<Event, BaseInputEventNodeType>) => void): void;
	setRaycaster(raycaster: Raycaster): void;
	private _findOrCreateControllerForEventNode;
	private _findOrCreateControllerForEvaluator;
	private _findOrCreateControllerForEventInputType;
	private _findOrCreateControllerForJsType;
	get keyboardEventsController(): KeyboardEventsController;
	get mouseEventsController(): MouseEventsController;
	get dragEventsController(): DragEventsController;
	get pointerEventsController(): PointerEventsController;
	get windowEventsController(): WindowEventsController;
	get touchEventsController(): TouchEventsController;
	private _createController;
	private _connectionTriggerDispatcher;
	get connectionTriggerDispatcher(): SceneConnectionTriggerDispatcher;
}
export interface CameraControls {
	name?: string;
	enabled?: boolean;
	dispose: () => void;
	update: (delta: number) => void;
	addEventListener: (eventName: string, callback: () => void) => void;
	removeEventListener: (eventName: string, callback: () => void) => void;
}
declare abstract class TypedCameraControlsEventNode<K extends NodeParamsConfig> extends TypedEventNode<K> {
	private _controls_by_viewer;
	applyControls(camera: Camera, viewer: BaseViewerType): Promise<CameraControls | undefined>;
	controls_id(): string;
	abstract updateRequired(): boolean;
	cook(): void;
	abstract setupControls(controls: CameraControls): void;
	abstract disposeControlsForHtmlElementId(html_element_id: string): void;
	abstract createControlsInstance(camera: Camera, element: HTMLElement): Promise<CameraControls>;
	abstract endEventName(): string;
}
export declare type GetTargetFunction = (target: Vector3) => void;
export declare type SetTargetFunction = (target: Vector3) => void;
export interface ApplicableControlsNode {
	applyControls: (camera: Camera, viewer: BaseViewerType) => Promise<CameraControls>;
	target?: GetTargetFunction;
	setTarget?: SetTargetFunction;
}
declare class ViewerCamerasController {
	private _viewer;
	private _size;
	private _aspect;
	constructor(_viewer: BaseViewerType);
	camera(): Camera;
	get size(): Vector2;
	get aspect(): number;
	computeSizeAndAspect(pixelRatio: number): void;
	private _updateSize;
	private _getAspect;
	updateCameraAspect(): void;
	prepareCurrentCamera(): Promise<void>;
	_updateFromCameraContainer(): Promise<void>;
}
declare class ViewerControlsController<C extends Camera> {
	private viewer;
	protected _active: boolean;
	private _updateControlsFunc;
	protected _controls: CameraControls | undefined;
	private _unmounted;
	constructor(viewer: TypedViewer<C>);
	controls(): CameraControls | undefined;
	mount(): void;
	unmount(): void;
	private _disposeControls;
	update(delta: number): void;
}
export declare type ViewerEventListener = (e: Event) => void;
export interface EventListenerWithData {
	listener: ViewerEventListener;
	data: EventData;
}
export declare type ListenerByEventType = Map<EventType, EventListenerWithData>;
declare class ViewerEventsController {
	protected viewer: BaseViewerType;
	protected _bound_listener_map_by_event_controller_type: Map<string, ListenerByEventType>;
	constructor(viewer: BaseViewerType);
	updateEvents(eventsController: BaseSceneEventsControllerType): void;
	camera(): Camera;
	canvas(): HTMLCanvasElement;
	init(): void;
	registeredEventTypes(): string[];
	dispose(): void;
}
declare class ViewerWebGLController {
	protected viewer: BaseViewerType;
	request_animation_frame_id: number | undefined;
	constructor(viewer: BaseViewerType);
	init(): void;
	protected _on_webglcontextlost(): void;
	protected _on_webglcontextrestored(): void;
}
declare class ViewerAudioController {
	private _viewer;
	private __iconContainer;
	private _onIcon;
	private _offIcon;
	constructor(_viewer: BaseViewerType);
	update(): void;
	unmount(): void;
	private _showIcon;
	private _hideIcon;
	private _iconContainer;
	private _createIconContainer;
	private _setIconContainerStyle;
	private offIcon;
	private onIcon;
	private _toggleSound;
	private _updateIcon;
}
export declare type AbstractRenderer = Pick<
	WebGLRenderer,
	| 'domElement'
	| 'render'
	| 'getPixelRatio'
	| 'compile'
	| 'dispose'
	| 'setSize'
	| 'setRenderTarget'
	| 'readRenderTargetPixels'
	| 'capabilities'
>;
declare class RenderersController {
	private static _nextGlContextId;
	private _printDebug;
	private _require_webgl2;
	private _webgl2_available;
	setPrintDebug(state?: boolean): void;
	printDebug(): boolean;
	printDebugMessage(message: any): void;
	setRequireWebGL2(): void;
	webGL2Available(): boolean;
	private _setWebGL2Available;
	createWebGLRenderer(params: WebGLRendererParameters): WebGLRenderer;
	assignIdToRenderer(renderer: AbstractRenderer): void;
	rendererId(renderer: AbstractRenderer): number | undefined;
	getRenderingContext(canvas: HTMLCanvasElement): WebGLRenderingContext | null;
	private _getRenderingContextWebgl;
	renderTarget(width: number, height: number, parameters: WebGLRenderTargetOptions): WebGLRenderTarget;
	private _linearRenderer;
	linearRenderer(): WebGLRenderer | undefined;
	private _createLinearRenderer;
}
declare class PolyLibsController {
	private _rootPrefix;
	private _root;
	root(): string | undefined;
	setRoot(url: string | null): void;
	setRootPrefix(prefix: string): void;
	private _KTX2Path;
	KTX2Path(): string | null;
	private _DRACOPath;
	DRACOPath(): string | null;
	private _DRACOGLTFPath;
	DRACOGLTFPath(): string | null;
	private _XATLASPath;
	XATLASPath(): string | null;
	private _OCCTPath;
	OCCTPath(): string | null;
	private _ManifoldPath;
	ManifoldPath(): string | null;
}
declare class BaseCoreLogger {
	log(message?: any, ...optionalParams: any[]): void;
	warn(message?: any, ...optionalParams: any[]): void;
	error(message?: any, ...optionalParams: any[]): void;
}
declare enum InputCloneMode {
	ALWAYS = 'always',
	NEVER = 'never',
	FROM_NODE = 'from_node',
}
declare class AnimationContainer extends TypedContainer<NodeContext.ANIM> {
	set_content(content: ContainableMap[NodeContext.ANIM]): void;
	setTimelineBuilder(timeline_builder: TimelineBuilder): void;
	timelineBuilder(): TimelineBuilder;
	coreContentCloned(): TimelineBuilder | undefined;
}
declare class AudioContainer extends TypedContainer<NodeContext.AUDIO> {
	setContent(content: ContainableMap[NodeContext.AUDIO]): void;
	setAudioBuilder(audioBuilder: AudioBuilder): void;
	audioBuilder(): AudioBuilder;
	coreContentCloned(): AudioBuilder | undefined;
}
declare class EventContainer extends TypedContainer<NodeContext.EVENT> {
	set_content(content: ContainableMap[NodeContext.EVENT]): void;
}
declare class GeometryContainer extends TypedContainer<NodeContext.SOP> {
	coreContentCloned(): CoreGroup | undefined;
	set_content(content: ContainableMap[NodeContext.SOP]): void;
	private _firstObject;
	private firstGeometry;
	objectsCount(): number;
	objectsVisibleCount(): number;
	objectsCountByType(): PolyDictionary<number>;
	objectsNamesByType(): PolyDictionary<string[]>;
	pointAttributeNames(): string[];
	pointAttributeSizesByName(): PolyDictionary<number>;
	objectAttributeSizesByName(): PolyDictionary<AttribSize[]>;
	coreGroupAttributeSizesByName(): PolyDictionary<number>;
	pointAttributeTypesByName(): PolyDictionary<AttribType>;
	objectAttributeTypesByName(): PolyDictionary<AttribType[]>;
	objectAttributeTypeAndSizesByName(): PolyDictionary<Record<AttribType, AttribSize[]>>;
	coreGroupAttributeTypesByName(): PolyDictionary<AttribType>;
	coreGroupAttributeValuesByName(): PolyDictionary<AttribValue>;
	objectAttributeNames(): string[];
	pointsCount(): number;
	totalPointsCount(): number;
	objectsData(): Array<ObjectData>;
	boundingBox(target: Box3): void;
}
declare class GlContainer extends TypedContainer<NodeContext.GL> {
	object(): string;
}
declare class JsContainer extends TypedContainer<NodeContext.JS> {
	object(): string;
}
declare class ManagerContainer extends TypedContainer<NodeContext.MANAGER> {
	set_content(content: ContainableMap[NodeContext.MANAGER]): void;
}
declare class MaterialContainer extends TypedContainer<NodeContext.MAT> {
	set_content(content: ContainableMap[NodeContext.MAT]): void;
	coreContentCloned(): ContainableMap[NodeContext.MAT] | undefined;
	set_material(material: Material): void;
	has_material(): boolean;
	material(): Material;
}
declare class ObjectContainer extends TypedContainer<NodeContext.OBJ> {
	set_content(content: ContainableMap[NodeContext.OBJ]): void;
	set_object(object: Object3D): void;
	has_object(): boolean;
	object(): Object3D<Event>;
}
declare class TextureContainer extends TypedContainer<NodeContext.COP> {
	set_content(content: ContainableMap[NodeContext.COP]): void;
	texture(): ContainableMap[NodeContext.COP];
	coreContent(): ContainableMap[NodeContext.COP];
	coreContentCloned(): ContainableMap[NodeContext.COP] | undefined;
	object(): Texture;
	infos(): Texture[] | undefined;
	resolution(): Number2;
}
declare class PostProcessContainer extends TypedContainer<NodeContext.POST> {
	set_content(content: ContainableMap[NodeContext.POST]): void;
	render_pass(): number;
	object(options?: {}): number;
}
declare class RopContainer extends TypedContainer<NodeContext.ROP> {
	set_content(content: ContainableMap[NodeContext.ROP]): void;
	renderer(): any;
}
export declare type ContainerMapGeneric = {
	[key in NodeContext]: TypedContainer<key>;
};
export interface ContainerMap extends ContainerMapGeneric {
	[NodeContext.ANIM]: AnimationContainer;
	[NodeContext.AUDIO]: AudioContainer;
	[NodeContext.COP]: TextureContainer;
	[NodeContext.EVENT]: EventContainer;
	[NodeContext.GL]: GlContainer;
	[NodeContext.JS]: JsContainer;
	[NodeContext.MANAGER]: ManagerContainer;
	[NodeContext.MAT]: MaterialContainer;
	[NodeContext.OBJ]: ObjectContainer;
	[NodeContext.ROP]: RopContainer;
	[NodeContext.POST]: PostProcessContainer;
	[NodeContext.SOP]: GeometryContainer;
}
export declare type OnUpdateHook = () => void;
export declare type OnEvalSingleInputListen = () => Promise<void>;
export interface SetInputsOptions {
	noExceptionOnInvalidInput?: boolean;
	ignoreLockedState?: boolean;
}
declare class NodeInputsController<NC extends NodeContext> {
	node: TypedNode<NC, any>;
	private _graphNode;
	private _graphNodeInputs;
	private _inputs;
	private _has_named_inputs;
	private _named_input_connection_points;
	private _minInputsCount;
	private _maxInputsCount;
	private _maxInputsCountOnInput;
	private _depends_on_inputs;
	private _on_update_hooks;
	private _on_update_hook_names;
	dispose(): void;
	constructor(node: TypedNode<NC, any>);
	setDependsOnInputs(depends_on_inputs: boolean): void;
	private setMinCount;
	minCount(): number;
	private setMaxCount;
	private _singleInputIndexListenedTo;
	listenToSingleInputIndex(index: number): void;
	private _onEnsureListenToSingleInputIndexUpdatedCallback;
	onEnsureListenToSingleInputIndexUpdated(callback: OnEvalSingleInputListen): void;
	namedInputConnectionPointsByName(name: string): ConnectionPointTypeMap[NC] | undefined;
	setNamedInputConnectionPoints(newConnectionPoints: ConnectionPointTypeMap[NC][]): void;
	hasNamedInputs(): boolean;
	namedInputConnectionPoints(): ConnectionPointTypeMap[NC][];
	private _initGraphNodeInputs;
	private _createGraphNodeInput;
	maxInputsCount(): number;
	maxInputsCountOverriden(): boolean;
	inputGraphNode(input_index: number): CoreGraphNode;
	setCount(min: number, max?: number): void;
	private _initConnectionControllerInputs;
	isGraphNodeDirty(): boolean;
	private _isAnyInputDirty;
	containersWithoutEvaluation(): (ContainerMap[NC] | undefined)[];
	private _existingInputIndices;
	evalRequiredInputs(): Promise<(ContainerMap[NC] | null | undefined)[]>;
	evalRequiredInput(inputIndex: number): Promise<ContainerMap[NC] | undefined>;
	getNamedInputIndex(name: string): number;
	getInputIndex(input_index_or_name: number | string): number;
	setInput(
		inputIndexOrName: number | string,
		node: BaseNodeByContextMap[NC] | null,
		outputIndexOrName?: number | string,
		options?: Readonly<SetInputsOptions>
	): void;
	input(input_index: number): BaseNodeByContextMap[NC] | null;
	named_input(input_name: string): BaseNodeByContextMap[NC] | null;
	named_input_connection_point(input_name: string): ConnectionPointTypeMap[NC] | undefined;
	has_named_input(name: string): boolean;
	hasInput(input_index: number): boolean;
	inputs(): (BaseNodeByContextMap[NC] | null)[];
	private _clonedStatesController;
	initInputsClonedState(states: InputCloneMode | InputCloneMode[]): void;
	overrideClonedStateAllowed(): boolean;
	overrideClonedState(state: boolean): void;
	clonedStateOverriden(): boolean;
	cloneRequired(index: number): boolean;
	cloneRequiredStates(): boolean | boolean[];
	private _updateCloneRequiredState;
	add_on_set_input_hook(name: string, hook: OnUpdateHook): void;
	private _run_on_set_input_hooks;
}
declare class OutputsController<NC extends NodeContext> {
	private node;
	private _has_outputs;
	private _named_output_connection_points;
	private _has_named_outputs;
	constructor(node: TypedNode<NC, any>);
	private _onPlayingStateChangeBound;
	private _onPlayingStateChange;
	private _outputIndexCache;
	private _clearCache;
	dispose(): void;
	setHasOneOutput(): void;
	setHasNoOutput(): void;
	hasOutputs(): boolean;
	hasNamedOutputs(): boolean;
	hasNamedOutput(name: string): boolean;
	namedOutputConnectionPoints(): ConnectionPointTypeMap[NC][];
	namedOutputConnection(index: number): ConnectionPointTypeMap[NC] | undefined;
	getNamedOutputIndex(name: string): number;
	getOutputIndex(output_index_or_name: number | string): number;
	private _getOutputIndex;
	namedOutputConnectionPointsByName(name: string): ConnectionPointTypeMap[NC] | undefined;
	setNamedOutputConnectionPoints(connection_points: ConnectionPointTypeMap[NC][], set_dirty?: boolean): void;
	used_output_names(): string[];
}
declare class ConnectionsController<NC extends NodeContext> {
	protected _node: TypedNode<NC, any>;
	private _inputConnections;
	private _outputConnections;
	constructor(_node: TypedNode<NC, any>);
	initInputs(): void;
	dispose(): void;
	addInputConnection(connection: TypedNodeConnection<NC>): void;
	removeInputConnection(connection: TypedNodeConnection<NC>): void;
	inputConnection(index: number): TypedNodeConnection<NC> | undefined;
	firstInputConnection(): TypedNodeConnection<NC> | null;
	inputConnections(): (TypedNodeConnection<NC> | undefined)[] | undefined;
	existingInputConnections(): (TypedNodeConnection<NC> | undefined)[] | undefined;
	addOutputConnection(connection: TypedNodeConnection<NC>): void;
	removeOutputConnection(connection: TypedNodeConnection<NC>): void;
	outputConnectionsByOutputIndex(outputIndex: number): Map<number, TypedNodeConnection<NC>> | undefined;
	outputConnections(): TypedNodeConnection<NC>[];
}
declare class SavedConnectionPointsDataController<NC extends NodeContext> {
	protected _node: TypedNode<NC, any>;
	private _in;
	private _out;
	constructor(_node: TypedNode<NC, any>);
	set_in(data: BaseConnectionPointData[]): void;
	set_out(data: BaseConnectionPointData[]): void;
	clear(): void;
	in(): BaseConnectionPointData[] | undefined;
	out(): BaseConnectionPointData[] | undefined;
}
declare class ConnectionPointsSpareParamsController<NC extends NodeContext> {
	private node;
	private _context;
	private _inputless_param_names;
	private _raw_input_serialized_by_param_name;
	private _default_value_serialized_by_param_name;
	constructor(node: TypedNode<NC, any>, _context: NC);
	private _initialized;
	initializeNode(): void;
	initialized(): boolean;
	private _createInputsFromParams;
	setInputlessParamNames(names: string[]): string[];
	createSpareParameters(): void;
}
export declare type IONameFunction = (index: number) => string;
export declare type ExpectedConnectionTypesFunction<NC extends NodeContext> = () => ConnectionPointEnumMap[NC][];
declare class ConnectionPointsController<NC extends NodeContext> {
	private node;
	private _context;
	private _spare_params_controller;
	private _create_spare_params_from_inputs;
	private _functions_overridden;
	constructor(node: TypedNode<NC, any>, _context: NC);
	private _input_name_function;
	private _output_name_function;
	private _expected_input_types_function;
	private _expected_output_types_function;
	protected default_connection_type(): ConnectionPointEnumMap[NC];
	protected create_connection_point(name: string, type: ConnectionPointEnumMap[NC]): ConnectionPointTypeMap[NC];
	functions_overridden(): boolean;
	initialized(): boolean;
	set_create_spare_params_from_inputs(state: boolean): void;
	set_input_name_function(func: IONameFunction): void;
	set_output_name_function(func: IONameFunction): void;
	set_expected_input_types_function(func: ExpectedConnectionTypesFunction<NC>): void;
	set_expected_output_types_function(func: ExpectedConnectionTypesFunction<NC>): void;
	input_name(index: number): string;
	output_name(index: number): string;
	private _update_signature_if_required_bound;
	private _initialized;
	initializeNode(): void;
	private _initialize_if_required;
	get spare_params(): ConnectionPointsSpareParamsController<NC>;
	update_signature_if_required(dirty_trigger?: CoreGraphNode): void;
	private make_successors_update_signatures;
	update_connection_types(): void;
	protected _inputsOutputsMatchExpectations(): boolean;
	private _wrapped_expected_input_types_function;
	private _wrapped_expected_output_types_function;
	private _wrapped_input_name_function;
	private _wrapped_output_name_function;
	first_input_connection_type(): ConnectionPointEnumMap[NC] | undefined;
	input_connection_type(index: number): ConnectionPointEnumMap[NC] | undefined;
}
export declare type OverridenOptions = PolyDictionary<string | number>;
export declare type SimpleParamJsonExporterData<T extends ParamType> = ParamInitValueSerializedTypeMap[T];
export interface ComplexParamJsonExporterData<T extends ParamType> {
	type?: T;
	default_value?: ParamInitValueSerializedTypeMap[T];
	raw_input?: ParamInitValueSerializedTypeMap[T];
	options?: ParamOptions;
	overriden_options?: OverridenOptions;
}
export declare type ParamJsonExporterData<T extends ParamType> =
	| SimpleParamJsonExporterData<T>
	| ComplexParamJsonExporterData<T>;
export interface ParamInitData<T extends ParamType> {
	raw_input?: ParamInitValueSerializedTypeMap[T];
	simple_data?: SimpleParamJsonExporterData<T>;
	complex_data?: ComplexParamJsonExporterData<T>;
}
export declare type ParamsInitData = PolyDictionary<ParamInitData<ParamType>>;
declare class IOController<NC extends NodeContext> {
	protected node: TypedNode<NC, any>;
	protected _inputs: NodeInputsController<NC> | undefined;
	protected _outputs: OutputsController<NC> | undefined;
	protected _connections: ConnectionsController<NC>;
	protected _saved_connection_points_data: SavedConnectionPointsDataController<NC> | undefined;
	protected _connection_points: ConnectionPointsController<NC> | undefined;
	constructor(node: TypedNode<NC, any>);
	dispose(): void;
	get connections(): ConnectionsController<NC>;
	get inputs(): NodeInputsController<NC>;
	hasInputs(): boolean;
	get outputs(): OutputsController<NC>;
	has_outputs(): boolean;
	get connection_points(): ConnectionPointsController<NC>;
	get has_connection_points_controller(): boolean;
	get saved_connection_points_data(): SavedConnectionPointsDataController<NC>;
	clear_saved_connection_points_data(): void;
}
export declare type DefaultOperationParam<T extends ParamType> = ParamValuesTypeMap[T];
export declare type DefaultOperationParams = PolyDictionary<DefaultOperationParam<ParamType>>;
export interface OperationRegisterOptions {
	printWarnings?: boolean;
}
export interface NodeRegisterOptions {
	only?: string[];
	except?: string[];
	userAllowed?: boolean;
	polyNode?: boolean;
	printWarnings?: boolean;
}
export declare type BaseNodeConstructor = typeof BaseNodeClass;
export declare type NodeConstructorByType = Map<string, BaseNodeConstructor>;
export declare type NodeConstructorByTypeByContext = Map<NodeContext, NodeConstructorByType>;
export declare type BaseOperationConstructor = typeof BaseOperation;
export declare type OnNodeRegisterCallback = (poly: PolyEngine) => void;
export declare type OnOperationRegisterCallback = (poly: PolyEngine) => void;
declare class NodesRegister {
	private poly;
	private _nodesRegister;
	private _nodesRegisterCategories;
	private _nodesRegisterOptions;
	constructor(poly: PolyEngine);
	private static type;
	private static filterType;
	register(node: BaseNodeConstructor, tab_menu_category?: string | string[], options?: NodeRegisterOptions): void;
	deregister(context: NodeContext, nodeType: string): void;
	isRegistered(context: NodeContext, nodeType: string): boolean;
	nodeOptions(context: NodeContext, nodeType: string): NodeRegisterOptions | undefined;
	registeredNodesForParentNode(parentNode: BaseNodeType): (typeof BaseNodeClass)[];
	registeredNodes(parentNode: BaseNodeType): PolyDictionary<BaseNodeConstructor>;
	registeredCategory(context: NodeContext, nodeType: string): string[] | undefined;
	map(): NodeConstructorByTypeByContext;
}
declare class OperationsRegister {
	private poly;
	private _operation_register;
	constructor(poly: PolyEngine);
	private static type;
	private static filterType;
	register(operation: BaseOperationConstructor, options?: OperationRegisterOptions): void;
	registeredOperationsForContextAndParentType(context: NodeContext, parentNodeType: string): (typeof BaseOperation)[];
	registeredOperation(context: NodeContext, operationType: string): BaseOperationConstructor | undefined;
}
export interface ConvertExportParamDataParams {
	paramName: string;
	paramData: SimpleParamJsonExporterData<ParamType>;
	params: DefaultOperationParams;
}
declare class BaseOperation<NC extends NodeContext> {
	protected _scene: PolyScene;
	protected states?: NodeStatesController<NC> | undefined;
	protected _node?: BaseNodeType | undefined;
	static type(): string;
	type(): string;
	static onRegister: OnOperationRegisterCallback | undefined;
	static context(): NodeContext;
	context(): NodeContext;
	static readonly DEFAULT_PARAMS: DefaultOperationParams;
	static readonly INPUT_CLONED_STATE: InputCloneMode | InputCloneMode[];
	constructor(_scene: PolyScene, states?: NodeStatesController<NC> | undefined, _node?: BaseNodeType | undefined);
	scene(): PolyScene;
	cook(input_contents: any[], params: object): any;
	convertExportParamData(options: ConvertExportParamDataParams): string | number | boolean | void;
}
export interface BlobsControllerFetchNodeOptions {
	multiAssetsForNode?: boolean;
}
export interface FetchNodeBlobUrlOptions extends BlobsControllerFetchNodeOptions {
	fullUrl: string;
	node: BaseNodeType;
}
export interface FetchBlobResponse {
	blobWrapper?: BlobWrapper;
	error?: string;
}
export interface BlobWrapper {
	blob: Blob;
	blobUrl: string;
	referringNodeIds: Set<CoreGraphNodeId>;
}
export interface BlobData {
	url: string;
	blobWrapper: BlobWrapper;
}
export declare type BlobDataCallback = (params: BlobData) => void;
declare class BlobsController {
	private poly;
	private _blobWrappersByUrl;
	constructor(poly: PolyEngine);
	recording(): boolean;
	blobUrl(url: string): string | undefined;
	clear(): void;
	clearBlobsForNode(node: BaseNodeType): void;
	private _assignBlobToNode;
	setVirtualFile(file: File, uniqueId: string): Promise<void>;
	fetchBlobGlobal(url: string): Promise<FetchBlobResponse>;
	fetchBlobForNode(options: FetchNodeBlobUrlOptions): Promise<
		| {
				blobWrapper?: undefined;
				error?: undefined;
		  }
		| {
				blobWrapper: BlobWrapper;
				error?: undefined;
		  }
		| {
				error: string;
				blobWrapper?: undefined;
		  }
	>;
	traverse(callback: BlobDataCallback): void;
	private _createBlobUrl;
	assetsManifestWithBlobsMap(): {
		manifest: PolyDictionary<string>;
		blobsMap: Map<string, Blob>;
	};
}
declare class AssetUrlsController {
	private _map;
	setMap(map: PolyDictionary<string>): void;
	remapedUrl(url: string): string | undefined;
}
export interface PerformanceManager {
	now: () => number;
}
declare class PolyPerformanceformanceController {
	private _performanceManager;
	setPerformanceManager(p: PerformanceManager): void;
	performanceManager(): PerformanceManager;
}
declare class ScenesRegister {
	private _lastRegisteredScene;
	private _scenes;
	private _registerTimeByScene;
	registerScene(scene: PolyScene): void;
	deregisterScene(scene: PolyScene): void;
	lastRegisteredScene(): PolyScene | undefined;
	scenes(): PolyScene[];
	private _updateCache;
}
export declare type GetTokenFunc = () => Promise<string | undefined>;
declare class PolyThirdPartyMapboxController {
	private _token;
	private _getTokenFunc;
	setToken(token: string): void;
	setGetTokenFunction(tokenFunc: GetTokenFunc): void;
	token(): Promise<string | undefined>;
}
export declare type MarkerTrackingControllerRenderFunction = () => void;
export declare type MarkerTrackingControllerMountFunction = () => void;
export declare type MarkerTrackingControllerUnmountFunction = () => void;
export interface MarkerTrackingControllerConfig {
	renderFunction: MarkerTrackingControllerRenderFunction;
	mountFunction: MarkerTrackingControllerMountFunction;
	unmountFunction: MarkerTrackingControllerUnmountFunction;
}
declare enum MarkerTrackingSourceMode {
	WEBCAM = 'webcam',
	IMAGE = 'image',
	VIDEO = 'video',
}
declare enum MarkerTrackingTransformMode {
	CAMERA = 'camera',
	MARKER = 'marker',
}
export interface CoreMarkerTrackingControllerOptions {
	sourceMode: MarkerTrackingSourceMode;
	sourceUrl?: string;
	canvas: HTMLCanvasElement;
	camera: Camera;
	scene: Scene;
	barCode: {
		type: string;
		value: number;
	};
	transformMode: MarkerTrackingTransformMode;
	smooth: {
		active: boolean;
		count: number;
	};
}
declare class CoreMarkerTrackingController {
	constructor(options: CoreMarkerTrackingControllerOptions);
	errorMessage(): string | void;
	trackedMatrix(targetMatrix: Matrix4): void;
	config(): MarkerTrackingControllerConfig;
}
export declare type MarkerTrackingControllerCreateFunc = (
	options: CoreMarkerTrackingControllerOptions
) => CoreMarkerTrackingController;
export declare type MarkerTrackingBarCodeUrlFunc = (type: string, value: number) => string;
export interface MarkerTrackingConfig {
	barcodeUrl: MarkerTrackingBarCodeUrlFunc;
	createController: MarkerTrackingControllerCreateFunc;
	barCodes: {
		types: string[];
		valuesCountByType: Record<string, number>;
	};
}
declare class PolyMarkerTrackingController {
	private _config;
	private _controller;
	setConfig(config: MarkerTrackingConfig): void;
	barCodeUrl(type: string, value: number): string | void;
	barCodeTypes(): string[];
	config(): MarkerTrackingConfig | undefined;
	hasController(): boolean;
	createController(options: CoreMarkerTrackingControllerOptions): CoreMarkerTrackingController | undefined;
	controller(): CoreMarkerTrackingController | null;
}
declare class PolyThirdPartyController {
	private _markerTracking;
	markerTracking(): PolyMarkerTrackingController;
	private _mapbox;
	mapbox(): PolyThirdPartyMapboxController;
}
export declare type Hook = (object: Object3D) => void;
declare class PolyOnObjectsAddedHooksController {
	private _map;
	registerHook(hookName: string, hook: Hook): void;
	runHooks(objects: Object3D[]): void;
}
export interface Params extends CSGOBJTesselationParams, CADOBJTesselationParams, SDFOBJTesselationParams {}
export declare type SpecializedChildrenHook = (
	displayNode: BaseSopNodeType,
	coreGroup: CoreGroup,
	newObjects: Object3D[],
	params: Params
) => boolean;
declare class PolySpecializedChildrenController {
	private _map;
	private _hooks;
	registerHook(hookName: string, hook: SpecializedChildrenHook): void;
	private _updateCache;
	runHooks(displayNode: BaseSopNodeType, coreGroup: CoreGroup, newObjects: Object3D[], params: Params): boolean;
}
export declare type PolyPluginCallback = (poly: PolyEngine) => void;
export interface PolyPluginOptions {
	libraryName: string;
	libraryImportPath: string;
}
export interface PolyPluginData {
	name: string;
	libraryName: string;
	libraryImportPath: string;
}
declare class PolyPlugin {
	protected _name: string;
	protected _callback: PolyPluginCallback;
	protected _options: PolyPluginOptions;
	constructor(_name: string, _callback: PolyPluginCallback, _options: PolyPluginOptions);
	name(): string;
	libraryName(): string;
	init(poly: PolyEngine): void;
	toJSON(): PolyPluginData;
}
export declare type PolyPluginInterface = Pick<PolyPlugin, 'name' | 'libraryName' | 'init' | 'toJSON'>;
export interface PluginsRegisterData {
	plugins: PolyDictionary<PolyPluginData>;
	nodes: PolyDictionary<PolyDictionary<string>>;
	operations: PolyDictionary<PolyDictionary<string>>;
}
export declare type WrapConfigurePolygonjsCallback = () => void | Promise<void>;
declare class PluginsRegister {
	private poly;
	private _configurePolygonjsPlugin;
	private _currentPlugin;
	private _pluginsByName;
	private _pluginNameByNodeContextByType;
	private _pluginNameByOperationContextByType;
	constructor(poly: PolyEngine);
	wrapConfigurePolygonjs(callback: WrapConfigurePolygonjsCallback): Promise<void>;
	register(plugin: PolyPluginInterface): void;
	pluginByName(pluginName: string): PolyPluginInterface | undefined;
	registerNode(node: BaseNodeConstructor): void;
	registerOperation(operation: BaseOperationConstructor): void;
	toJson(): PluginsRegisterData;
}
export interface ViewerCallbackOptions<C extends Camera> {
	camera: C;
	scene: PolyScene;
	canvas?: HTMLCanvasElement;
	renderer?: AbstractRenderer;
}
export declare type ViewerCreateCallback<C extends Camera> = (options: ViewerCallbackOptions<C>) => TypedViewer<C>;
declare class PolyCamerasRegister {
	private _cameraNodeTypes;
	private _registeredViewerCreateCallbackByCamera;
	constructor(poly: PolyEngine);
	registerNodeType(nodeType: string): void;
	registeredNodeTypes(): string[];
	register<C extends Camera>(cameraClass: any, viewerCreateCallback: ViewerCreateCallback<C>): void;
	createViewer<C extends Camera>(options: ViewerCallbackOptions<C>): TypedViewer<Camera> | undefined;
	objectRegistered(object: Object3D): boolean;
}
declare enum ModuleName {
	CAD = 'CAD',
	CSG = 'CSG',
	SDF = 'SDF',
}
export interface BaseModule<M extends ModuleName> {
	moduleName: M;
	onRegister: (poly: PolyEngine) => void;
}
declare class BaseModulesRegister {
	private poly;
	private _moduleByName;
	constructor(poly: PolyEngine);
	register<K extends ModuleName>(moduleName: K, module: BaseModule<K>): void;
	moduleNames(): ModuleName[];
}
declare class DynamicModulesRegister extends BaseModulesRegister {}
declare enum ExpressionType {
	animationNames = 'animationNames',
	arg = 'arg',
	argc = 'argc',
	bbox = 'bbox',
	blob = 'blob',
	cameraName = 'cameraName',
	cameraNames = 'cameraNames',
	camerasCount = 'camerasCount',
	centroid = 'centroid',
	ch = 'ch',
	chsop = 'chsop',
	copy = 'copy',
	copRes = 'copRes',
	isDeviceMobile = 'isDeviceMobile',
	isDeviceTouch = 'isDeviceTouch',
	len = 'len',
	join = 'join',
	js = 'js',
	object = 'object',
	objectsCount = 'objectsCount',
	objectName = 'objectName',
	objectNames = 'objectNames',
	opdigits = 'opdigits',
	opname = 'opname',
	padzero = 'padzero',
	playerMode = 'playerMode',
	point = 'point',
	pointsCount = 'pointsCount',
	solverIteration = 'solverIteration',
	strCharsCount = 'strCharsCount',
	strConcat = 'strConcat',
	strIndex = 'strIndex',
	strSub = 'strSub',
	windowSize = 'windowSize',
}
declare class BaseExpressionRegister {
	private _methodsNames;
	private _methodsByName;
	register(expression: typeof BaseMethod, name: ExpressionType): void;
	getMethod(name: ExpressionType): typeof BaseMethod | undefined;
	availableMethods(): ExpressionType[];
}
declare class AnimationNamesExpression extends BaseMethod {
	static requiredArguments(): string[][];
	findDependency(args: BaseMethodFindDependencyArgs): MethodDependency | null;
	processArguments(args: any[]): Promise<any>;
}
declare class ArgExpression extends BaseMethod {
	static requiredArguments(): string[][];
	processArguments(args: any[]): Promise<any>;
}
declare class ArgcExpression extends BaseMethod {
	static requiredArguments(): string[][];
	processArguments(args: any[]): Promise<any>;
}
declare class BboxExpression extends BaseMethod {
	static requiredArguments(): string[][];
	findDependency(args: BaseMethodFindDependencyArgs): MethodDependency | null;
	processArguments(args: any[]): Promise<any>;
	private _get_value_from_container;
}
declare class BlobExpression extends BaseMethod {
	static requiredArguments(): string[][];
	processArguments(args: any[]): Promise<string>;
}
declare class CameraNameExpression extends BaseMethod {
	static requiredArguments(): string[][];
	findDependency(args: BaseMethodFindDependencyArgs): MethodDependency | null;
	processArguments(args: any[]): Promise<any>;
}
declare class CameraNamesExpression extends BaseMethod {
	static requiredArguments(): string[][];
	findDependency(args: BaseMethodFindDependencyArgs): MethodDependency | null;
	processArguments(args: any[]): Promise<any>;
}
declare class CamerasCountExpression extends BaseMethod {
	static requiredArguments(): string[][];
	findDependency(args: BaseMethodFindDependencyArgs): MethodDependency | null;
	processArguments(args: any[]): Promise<any>;
}
declare class CentroidExpression extends BaseMethod {
	static requiredArguments(): string[][];
	findDependency(args: BaseMethodFindDependencyArgs): MethodDependency | null;
	processArguments(args: any[]): Promise<any>;
}
declare class ChExpression extends BaseMethod {
	static requiredArguments(): string[][];
	private _referencedParam;
	findDependency(args: BaseMethodFindDependencyArgs): MethodDependency | null;
	processArguments(args: any[]): Promise<any>;
}
declare class ChsopExpression extends BaseMethod {
	static requiredArguments(): string[][];
	private _referencedParam;
	findDependency(args: BaseMethodFindDependencyArgs): MethodDependency | null;
	processArguments(args: any[]): Promise<any>;
}
declare class CopyExpression extends BaseMethod {
	static requiredArguments(): string[][];
	static optionalArguments(): string[][];
	findDependency(args: BaseMethodFindDependencyArgs): MethodDependency | null;
	processArguments(args: any[]): Promise<any>;
}
declare class CopResExpression extends BaseMethod {
	static requiredArguments(): string[][];
	findDependency(args: BaseMethodFindDependencyArgs): MethodDependency | null;
	private _resolution;
	processArguments(args: any[]): Promise<number | Vector2>;
}
declare class isDeviceMobileExpression extends BaseMethod {
	static requiredArguments(): never[];
	processArguments(args: any[]): Promise<boolean>;
}
declare class isDeviceTouchExpression extends BaseMethod {
	static requiredArguments(): never[];
	processArguments(args: any[]): Promise<boolean>;
}
declare class LenExpression extends BaseMethod {
	static requiredArguments(): string[][];
	processArguments(args: any[]): Promise<number>;
}
declare class JoinExpression extends BaseMethod {
	static requiredArguments(): string[][];
	processArguments(args: any[]): Promise<string>;
}
declare class JsExpression extends BaseMethod {
	private _function;
	static requiredArguments(): string[][];
	processArguments(args: any[]): Promise<any>;
	private _create_function;
}
declare class ObjectExpression extends BaseMethod {
	static requiredArguments(): string[][];
	findDependency(args: BaseMethodFindDependencyArgs): MethodDependency | null;
	processArguments(args: any[]): Promise<any>;
	_get_value_from_container(
		container: GeometryContainer,
		attrib_name: string,
		point_index: number
	): string | number | boolean | Number3 | Number2 | Vector2Like | ColorLike | Number4 | null | undefined;
}
declare class ObjectsCountExpression extends BaseMethod {
	static requiredArguments(): string[][];
	findDependency(args: BaseMethodFindDependencyArgs): MethodDependency | null;
	processArguments(args: any[]): Promise<any>;
}
declare class ObjectNameExpression extends BaseMethod {
	static requiredArguments(): string[][];
	findDependency(args: BaseMethodFindDependencyArgs): MethodDependency | null;
	processArguments(args: any[]): Promise<any>;
}
declare class ObjectNamesExpression extends BaseMethod {
	static requiredArguments(): string[][];
	findDependency(args: BaseMethodFindDependencyArgs): MethodDependency | null;
	processArguments(args: any[]): Promise<any>;
}
declare class OpdigitsExpression extends BaseMethod {
	static requiredArguments(): string[][];
	findDependency(args: BaseMethodFindDependencyArgs): MethodDependency | null;
	processArguments(args: any[]): Promise<any>;
}
declare class OpnameExpression extends BaseMethod {
	static requiredArguments(): string[][];
	findDependency(args: BaseMethodFindDependencyArgs): MethodDependency | null;
	processArguments(args: any[]): Promise<any>;
}
declare class PadzeroExpression extends BaseMethod {
	static requiredArguments(): string[][];
	processArguments(args: any[]): Promise<string>;
}
declare class PlayerModeExpression extends BaseMethod {
	static requiredArguments(): never[];
	processArguments(args: any[]): Promise<any>;
}
declare class PointExpression extends BaseMethod {
	static requiredArguments(): string[][];
	findDependency(args: BaseMethodFindDependencyArgs): MethodDependency | null;
	processArguments(args: any[]): Promise<any>;
	_get_value_from_container(
		container: GeometryContainer,
		attrib_name: string,
		point_index: number
	): string | number | boolean | Number3 | Number2 | Vector2Like | ColorLike | Number4 | null;
}
declare class PointsCountExpression extends BaseMethod {
	static requiredArguments(): string[][];
	findDependency(args: BaseMethodFindDependencyArgs): MethodDependency | null;
	processArguments(args: any[]): Promise<any>;
}
declare class SolverIterationExpression extends BaseMethod {
	static requiredArguments(): never[];
	static optionalArguments(): string[][];
	private _solverNode;
	findDependency(args: BaseMethodFindDependencyArgs): MethodDependency | null;
	processArguments(args: any[]): Promise<any>;
}
declare class StrCharsCountExpression extends BaseMethod {
	static requiredArguments(): string[][];
	processArguments(args: any[]): Promise<number>;
}
declare class StrConcatExpression extends BaseMethod {
	static requiredArguments(): any[];
	processArguments(args: any[]): Promise<string>;
}
declare class StrIndexExpression extends BaseMethod {
	static requiredArguments(): string[][];
	processArguments(args: any[]): Promise<number>;
}
declare class StrSubExpression extends BaseMethod {
	static requiredArguments(): string[][];
	processArguments(args: any[]): Promise<string>;
}
declare class WindowSizeExpression extends BaseMethod {
	static requiredArguments(): never[][];
	findDependency(indexOrPath: BaseMethodFindDependencyArgs): null;
	private _windowSize;
	processArguments(args: any[]): Promise<Vector2>;
}
export interface ExpressionMap extends PolyDictionary<typeof BaseMethod> {
	animationNames: typeof AnimationNamesExpression;
	arg: typeof ArgExpression;
	argc: typeof ArgcExpression;
	bbox: typeof BboxExpression;
	blob: typeof BlobExpression;
	cameraName: typeof CameraNameExpression;
	cameraNames: typeof CameraNamesExpression;
	camerasCount: typeof CamerasCountExpression;
	centroid: typeof CentroidExpression;
	ch: typeof ChExpression;
	chsop: typeof ChsopExpression;
	copy: typeof CopyExpression;
	copRes: typeof CopResExpression;
	isDeviceMobile: typeof isDeviceMobileExpression;
	isDeviceTouch: typeof isDeviceTouchExpression;
	join: typeof JoinExpression;
	js: typeof JsExpression;
	len: typeof LenExpression;
	object: typeof ObjectExpression;
	objectsCount: typeof ObjectsCountExpression;
	objectName: typeof ObjectNameExpression;
	objectNames: typeof ObjectNamesExpression;
	opdigits: typeof OpdigitsExpression;
	opname: typeof OpnameExpression;
	padzero: typeof PadzeroExpression;
	playerMode: typeof PlayerModeExpression;
	point: typeof PointExpression;
	pointsCount: typeof PointsCountExpression;
	solverIteration: typeof SolverIterationExpression;
	strCharsCount: typeof StrCharsCountExpression;
	strConcat: typeof StrConcatExpression;
	strIndex: typeof StrIndexExpression;
	strSub: typeof StrSubExpression;
	windowSize: typeof WindowSizeExpression;
}
declare class ExpressionRegister extends BaseExpressionRegister {
	getMethod<K extends keyof ExpressionMap>(name: K): ExpressionMap[K] | undefined;
}
declare enum AssemblerName {
	GL_MESH_BASIC = 'GL_MESH_BASIC',
	GL_MESH_LAMBERT = 'GL_MESH_LAMBERT',
	GL_MESH_STANDARD = 'GL_MESH_STANDARD',
	GL_MESH_PHONG = 'GL_MESH_PHONG',
	GL_MESH_PHYSICAL = 'GL_MESH_PHYSICAL',
	GL_MESH_DEPTH = 'GL_MESH_DEPTH',
	GL_MESH_DISTANCE = 'GL_MESH_DISTANCE',
	GL_PARTICLES = 'GL_PARTICLES',
	GL_POINTS = 'GL_POINTS',
	GL_LINE = 'GL_LINE',
	GL_POST = 'GL_POST',
	GL_RAYMARCHING = 'GL_RAYMARCHING',
	GL_TEXTURE = 'GL_TEXTURE',
	GL_TEXTURE_2D_ARRAY = 'GL_TEXTURE_2D_ARRAY',
	GL_VOLUME = 'GL_VOLUME',
	JS_ACTOR = 'JS_ACTOR',
	JS_SDF = 'JS_SDF',
}
export interface ControllerAssemblerPair {
	controller: any;
	assembler: any;
}
export declare type TraverseCallback = (pair: ControllerAssemblerPair, name: AssemblerName) => void;
declare class BaseAssemblersRegister {
	protected _controllerAssemblerByName: Map<AssemblerName, ControllerAssemblerPair>;
	register(name: AssemblerName, controller: any, assembler: any): void;
	unregister(name: AssemblerName): void;
	traverse(callback: TraverseCallback): void;
}
declare enum LineType {
	FUNCTION_DECLARATION = 'function_declaration',
	DEFINE = 'define',
	BODY = 'body',
}
declare enum ShaderName {
	VERTEX = 'vertex',
	FRAGMENT = 'fragment',
	LEAVES_FROM_NODES_SHADER = 'leaves_from_nodes_shader',
}
declare class ShaderConfig {
	private _name;
	private _input_names;
	private _dependencies;
	constructor(_name: ShaderName, _input_names: string[], _dependencies: ShaderName[]);
	name(): ShaderName;
	input_names(): string[];
	dependencies(): ShaderName[];
}
export interface VariableConfigOptions {
	default_from_attribute?: boolean;
	default?: string;
	if?: string;
	prefix?: string;
	suffix?: string;
	postLines?: string[];
}
declare class VariableConfig {
	private _name;
	private _options;
	constructor(_name: string, _options?: VariableConfigOptions);
	name(): string;
	default_from_attribute(): boolean;
	default(): string | undefined;
	if_condition(): string | undefined;
	prefix(): string;
	suffix(): string;
	postLines(): string[] | undefined;
}
declare class ParamConfigsController<PC extends ParamConfig> {
	private _param_configs;
	reset(): void;
	push(param_config: PC): void;
	list(): Readonly<PC[]>;
}
declare class TypedGLDefinitionCollection<T extends GLDefinitionType> {
	private _definitions;
	_errored: boolean;
	_error_message: string | undefined;
	constructor(_definitions?: TypedGLDefinition<T>[]);
	get errored(): boolean;
	get error_message(): string | undefined;
	uniq(): TypedGLDefinition<T>[];
}
declare enum GLDefinitionType {
	ATTRIBUTE = 'attribute',
	FUNCTION = 'function',
	PRECISION = 'precision',
	UNIFORM = 'uniform',
	VARYING = 'varying',
}
declare abstract class TypedGLDefinition<T extends GLDefinitionType> {
	protected _definition_type: T;
	protected _data_type: GlConnectionPointType;
	protected _node: BaseGlNodeType;
	protected _name: string;
	constructor(_definition_type: T, _data_type: GlConnectionPointType, _node: BaseGlNodeType, _name: string);
	get definition_type(): T;
	get data_type(): GlConnectionPointType;
	get node(): BaseGlNodeType;
	name(): string;
	abstract get line(): string;
	collection_instance(): TypedGLDefinitionCollection<T>;
}
declare class FunctionGLDefinition extends TypedGLDefinition<GLDefinitionType.FUNCTION> {
	protected _node: BaseGlNodeType;
	protected _name: string;
	constructor(_node: BaseGlNodeType, _name: string);
	get line(): string;
}
export declare type BaseGLDefinition = TypedGLDefinition<GLDefinitionType>;
export declare type DefinitionTraverseCallback = (definition: BaseGLDefinition) => void;
export interface AddBodyLinesOptions {
	makeUniq: boolean;
}
declare class LinesController {
	private _shader_name;
	private _definitionsByNodeId;
	private _bodyLinesByNodeId;
	constructor(_shader_name: ShaderName);
	get shader_name(): ShaderName;
	addDefinitions(node: BaseGlNodeType, definitions: BaseGLDefinition[]): void;
	private _addDefinitionsForNodeId;
	definitions(node: BaseGlNodeType): BaseGLDefinition[] | undefined;
	traverseDefinitions(callback: DefinitionTraverseCallback): void;
	addBodyLines(node: BaseGlNodeType, lines: string[], options?: AddBodyLinesOptions): void;
	private _addBodyLinesForNodeId;
	bodyLines(node: BaseGlNodeType): string[] | undefined;
}
declare abstract class TypedAssembler<NC extends NodeContext> {
	abstract shaderNames(): ShaderName[];
	abstract inputNamesForShaderName(node: BaseNodeByContextMap[NC], shaderName: ShaderName): string[];
	abstract rootNodesByShaderName(
		shaderName: ShaderName,
		rootNodes: BaseNodeByContextMap[NC][]
	): BaseNodeByContextMap[NC][];
}
declare class ShadersCollectionController {
	private _shaderNames;
	private _currentShaderName;
	private _assembler;
	private _linesControllerByShaderName;
	constructor(_shaderNames: ShaderName[], _currentShaderName: ShaderName, _assembler: TypedAssembler<NodeContext.GL>);
	assembler(): TypedAssembler<NodeContext.GL>;
	linesController(shaderName: ShaderName): LinesController | undefined;
	shaderNames(): ShaderName[];
	setCurrentShaderName(shaderName: ShaderName): void;
	currentShaderName(): ShaderName;
	addDefinitions(node: BaseGlNodeType, definitions: BaseGLDefinition[], shaderName?: ShaderName): void;
	definitions(shaderName: ShaderName, node: BaseGlNodeType): BaseGLDefinition[] | undefined;
	traverseDefinitions(shaderName: ShaderName, callback: DefinitionTraverseCallback): void;
	addBodyLines(node: BaseGlNodeType, lines: string[], shaderName?: ShaderName, options?: AddBodyLinesOptions): void;
	bodyLines(shaderName: ShaderName, node: BaseGlNodeType): string[] | undefined;
}
export declare type ParamInitValueSerialized = ParamInitValueSerializedTypeMap[keyof ParamInitValueSerializedTypeMap];
declare class BaseParamConfig<T extends ParamType> {
	protected _type: T;
	protected _name: string;
	protected _defaultValue: ParamInitValuesTypeMap[T];
	constructor(_type: T, _name: string, _defaultValue: ParamInitValuesTypeMap[T]);
	static fromParam<K extends ParamType>(param: TypedParam<K>): BaseParamConfig<K>;
	type(): T;
	name(): string;
	defaultValue(): ParamInitValuesTypeMap[T];
	paramOptions(): ParamOptions;
	applyToNode(node: BaseNodeType): void;
	executeCallback(node: BaseNodeType, param: BaseParamType): void;
	protected _callback(node: BaseNodeType, param: BaseParamType): void;
}
export interface GlParamConfigJSON<T extends ParamType> {
	type: T;
	name: string;
	defaultValue: ParamInitValuesTypeMap[T];
	uniformName: string;
}
declare class GlParamConfig<T extends ParamType> extends BaseParamConfig<T> {
	private _uniformName;
	private _uniform;
	constructor(_type: T, _name: string, _defaultValue: ParamInitValuesTypeMap[T], _uniformName: string);
	toJSON(): GlParamConfigJSON<T>;
	static fromJSON(json: GlParamConfigJSON<ParamType>): GlParamConfig<ParamType>;
	uniformName(): string;
	uniform(): IUniform<any>;
	private _createUniform;
	protected _callback(node: BaseNodeType, param: BaseParamType): void;
	static callback(param: BaseParamType, uniform: IUniform): void;
	static uniformByType(type: ParamType): IUniform;
	private static setUniformValueFromTextureFromNodePathParam;
}
declare class TypedGlNode<K extends NodeParamsConfig> extends TypedNode<NodeContext.GL, K> {
	static context(): NodeContext;
	protected _param_configs_controller: ParamConfigsController<GlParamConfig<ParamType>> | undefined;
	protected _assembler: BaseGlShaderAssembler | undefined;
	private _paramsEditableStatesController;
	initializeBaseNode(): void;
	cook(): void;
	protected _setMatToRecompile(): void;
	materialNode(): AssemblerControllerNode | undefined;
	glVarName(name: string): string;
	variableForInputParam(
		param: IntegerParam | FloatParam | Vector2Param | Vector3Param | Vector4Param | ColorParam | BooleanParam
	): string;
	variableForInput(inputName: string): string;
	setLines(shaders_collection_controller: ShadersCollectionController): void;
	reset_code(): void;
	setParamConfigs(): void;
	param_configs(): readonly GlParamConfig<ParamType>[] | undefined;
	paramsGenerating(): boolean;
	paramDefaultValue(name: string): ParamInitValueSerialized;
}
export declare type BaseGlNodeType = TypedGlNode<NodeParamsConfig>;
declare class ParamlessGlParamsConfig extends NodeParamsConfig {}
declare class ParamlessTypedGlNode extends TypedGlNode<ParamlessGlParamsConfig> {
	paramsConfig: ParamlessGlParamsConfig;
}
export declare type DisplayControllerCallback = () => void;
export interface DisplayNodeControllerCallbacks {
	onDisplayNodeRemove: DisplayControllerCallback;
	onDisplayNodeSet: DisplayControllerCallback;
	onDisplayNodeUpdate: DisplayControllerCallback;
}
export interface DisplayNodeControllerOptions {
	dependsOnDisplayNode: boolean;
}
declare class DisplayNodeController {
	protected node: BaseNodeType;
	private options;
	private _initialized;
	private _graphNode;
	private _displayNode;
	private _onDisplayNodeRemoveCallback;
	private _onDisplayNodeSetCallback;
	private _onDisplayNodeUpdateCallback;
	constructor(node: BaseNodeType, callbacks: DisplayNodeControllerCallbacks, options?: DisplayNodeControllerOptions);
	dispose(): void;
	displayNode(): BaseNodeClassWithDisplayFlag | undefined;
	initializeNode(): void;
	setDisplayNode(newDisplayNode: BaseNodeClassWithDisplayFlag | undefined): Promise<void>;
}
export declare type OnSopGroupUpdatedHook = () => void;
export interface BaseObjNodeClassWithDisplayNode extends BaseObjNodeClass {
	displayNodeController: DisplayNodeController;
}
declare class ChildrenDisplayController {
	protected node: BaseObjNodeClassWithDisplayNode;
	protected _childrenUuids: Set<string>;
	protected _sopGroup: Group;
	protected _newObjectsAreDifferent: boolean;
	protected _newSpecializedObjects: Object3D[];
	constructor(node: BaseObjNodeClassWithDisplayNode);
	private _createSopGroup;
	sopGroup(): Group;
	setSopGroupName(): void;
	dispose(): void;
	displayNodeControllerCallbacks(): DisplayNodeControllerCallbacks;
	initializeNode(): void;
	private _updateSopGroupHierarchy;
	usedInScene(): boolean;
	requestDisplayNodeContainer(): Promise<void>;
	private removeChildren;
	_setContentUnderSopGroup(): Promise<void>;
	private _notifyCamerasController;
	protected _addSpecializedObjects(displayNode: BaseSopNodeType, coreGroup: CoreGroup, newObjects: Object3D[]): void;
	private _onSopGroupUpdatedHookNames;
	private _onSopGroupUpdatedHooks;
	registerOnSopGroupUpdated(callbackName: string, callback: OnSopGroupUpdatedHook): void;
	private _clearHooks;
	deregisterOnSopGroupUpdated(callbackName: string): void;
	private _runOnSopGroupUpdatedHooks;
	onSopGroupUpdatedCallbackNames(): string[] | undefined;
}
declare const TransformedParamsConfig_base: {
	new (...args: any[]): {
		transform: ParamTemplate<ParamType.FOLDER>;
		/** @param toggle on to keep world position when adding a parent or removing from one */
		keepPosWhenParenting: ParamTemplate<ParamType.BOOLEAN>;
		/** @param rotation order */
		rotationOrder: ParamTemplate<ParamType.INTEGER>;
		/** @param translate */
		t: ParamTemplate<ParamType.VECTOR3>;
		/** @param rotation */
		r: ParamTemplate<ParamType.VECTOR3>;
		/** @param scale */
		s: ParamTemplate<ParamType.VECTOR3>;
		/** @param scale */
		scale: ParamTemplate<ParamType.FLOAT>;
		/** @param set for the matrix to be updated every frame */
		matrixAutoUpdate: ParamTemplate<ParamType.BOOLEAN>;
		updateTransformFromObject: ParamTemplate<ParamType.BUTTON>;
	};
} & typeof NodeParamsConfig;
declare class TransformedParamsConfig extends TransformedParamsConfig_base {}
declare class TransformedObjNode extends TypedObjNode<Object3D, TransformedParamsConfig> {
	readonly transformController: TransformController;
}
declare class TransformController {
	private node;
	constructor(node: TransformedObjNode);
	initializeNode(): void;
	private _cook_main_without_inputs_when_dirty_bound;
	private _cook_main_without_inputs_when_dirty;
	update(): void;
	update_transform_with_matrix(matrix?: Matrix4): void;
	private _core_transform;
	private _update_matrix_from_params_with_core_transform;
	private _apply_look_at;
	set_params_from_matrix(matrix: Matrix4, options?: SetParamsFromMatrixOptions): void;
	static update_node_transform_params_if_required(node: TransformedObjNode, new_parent_object: Object3D): void;
	private _keep_pos_when_parenting_m_object;
	private _keep_pos_when_parenting_m_new_parent_inv;
	update_node_transform_params_if_required(new_parent_object: Object3D): void;
	update_node_transform_params_from_object(update_matrix?: boolean): void;
	static PARAM_CALLBACK_update_transform_from_object(node: TransformedObjNode): void;
}
declare class HierarchyParamsConfig extends NodeParamsConfig {}
declare class HierarchyObjNode extends TypedObjNode<Object3D, HierarchyParamsConfig> {
	readonly hierarchyController: HierarchyController;
}
declare class HierarchyController {
	private node;
	constructor(node: HierarchyObjNode);
	initializeNode(): void;
	static on_input_updated(node: BaseObjNodeType): void;
	on_input_updated(): void;
}
declare class TypedObjNode<O extends Object3D, K extends NodeParamsConfig> extends TypedNode<NodeContext.OBJ, K> {
	static context(): NodeContext;
	static displayedInputNames(): string[];
	readonly renderOrder: number;
	readonly transformController: TransformController | undefined;
	readonly hierarchyController: HierarchyController | undefined;
	protected _children_group: Group;
	protected _object: O;
	private _create_children_group;
	protected _attachableToHierarchy: boolean;
	attachableToHierarchy(): boolean;
	protected _used_in_scene: boolean;
	usedInScene(): boolean;
	addObjectToParent(parent: Object3D): void;
	removeObjectFromParent(): void;
	readonly childrenDisplayController: ChildrenDisplayController | undefined;
	dispose(): void;
	initializeBaseNode(): void;
	childrenGroup(): Group;
	get object(): O;
	_create_object_with_attributes(): O;
	protected set_object_name(): void;
	createObject(): Object3D;
	isDisplayNodeCooking(): boolean;
	isDisplayed(): boolean;
}
export declare type BaseObjNodeType = TypedObjNode<Object3D, any>;
declare class BaseObjNodeClass extends TypedObjNode<Object3D, any> {}
declare class TypedJsDefinitionCollection<T extends JsDefinitionType> {
	private _definitions;
	_errored: boolean;
	_error_message: string | undefined;
	constructor(_definitions?: TypedJsDefinition<T>[]);
	get errored(): boolean;
	get error_message(): string | undefined;
	uniq(): TypedJsDefinition<T>[];
}
declare enum LineType {
	MEMBER = 'member',
	CONSTRUCTOR = 'constructor',
	DEFINE = 'define',
	BODY = 'body',
}
declare enum JsDefinitionType {
	LOCAL_FUNCTION = 'localFunction',
	COMPUTED = 'computed',
	CONSTANT = 'constant',
	REF = 'ref',
	WATCH = 'watch',
	INIT_FUNCTION = 'initFunction',
	TRIGGERING = 'triggering',
	TRIGGERABLE = 'triggerable',
}
declare abstract class TypedJsDefinition<T extends JsDefinitionType> {
	protected _definitionType: T;
	protected _node: BaseJsNodeType;
	protected _shaderCollectionController: ShadersCollectionController;
	protected _dataType: JsConnectionPointType;
	protected _name: string;
	constructor(
		_definitionType: T,
		_node: BaseJsNodeType,
		_shaderCollectionController: ShadersCollectionController,
		_dataType: JsConnectionPointType,
		_name: string
	);
	static gather(definitions: BaseJsDefinition[], linesForShader: Map<LineType, string[]>, lineType: LineType): void;
	definitionType(): T;
	dataType(): JsConnectionPointType;
	node(): BaseJsNodeType;
	name(): string;
	abstract line(): string;
	collectionInstance(): TypedJsDefinitionCollection<T>;
}
export interface TriggerableJsDefinitionOptions {
	async?: boolean;
	methodName?: string;
}
export declare type BaseJsDefinition = TypedJsDefinition<JsDefinitionType>;
export declare type DefinitionTraverseCallback = (definition: BaseJsDefinition) => void;
export interface AddBodyLinesOptions {
	makeUniq: boolean;
}
declare class JsLinesController {
	private _shader_name;
	private _definitionsByNodeId;
	private _bodyLinesByNodeId;
	constructor(_shader_name: ShaderName);
	get shader_name(): ShaderName;
	addDefinitions(node: BaseJsNodeType, definitions: BaseJsDefinition[]): void;
	private _addDefinitionsForNodeId;
	definitions(node: BaseJsNodeType): BaseJsDefinition[] | undefined;
	traverseDefinitions(callback: DefinitionTraverseCallback): void;
	addBodyLines(node: BaseJsNodeType, lines: string[], options?: AddBodyLinesOptions): void;
	private _addBodyLinesForNodeId;
	bodyLines(node: BaseJsNodeType): string[] | undefined;
}
export interface VariableConfigOptions {
	default_from_attribute?: boolean;
	default?: string;
	if?: string;
	prefix?: string;
	suffix?: string;
	postLines?: string[];
}
declare class VariableConfig {
	private _name;
	private _options;
	constructor(_name: string, _options?: VariableConfigOptions);
	name(): string;
	default_from_attribute(): boolean;
	default(): string | undefined;
	if_condition(): string | undefined;
	prefix(): string;
	suffix(): string;
	postLines(): string[] | undefined;
}
export interface JsParamConfigJSON<T extends ParamType> {
	type: T;
	name: string;
	defaultValue: ParamInitValuesTypeMap[T];
	uniformName: string;
}
declare class JsParamConfig<T extends ParamType> extends BaseParamConfig<T> {
	private _uniformName;
	constructor(_type: T, _name: string, _defaultValue: ParamInitValuesTypeMap[T], _uniformName: string);
	toJSON(): JsParamConfigJSON<T>;
	static fromJSON(json: JsParamConfigJSON<ParamType>): JsParamConfig<ParamType>;
	uniformName(): string;
	protected _callback(node: BaseNodeType, param: BaseParamType): void;
	static callback(node: BaseNodeType, paramName: string): void;
}
export declare type RootNodesForShaderMethod = (
	shader_name: ShaderName,
	rootNodes: BaseJsNodeType[]
) => BaseJsNodeType[];
export interface CodeBuilderSetCodeLinesOptions {
	otherFragmentShaderCollectionController?: ShadersCollectionController;
	actor: {
		triggeringNodes: Set<BaseJsNodeType>;
		triggerableNodes: Set<BaseJsNodeType>;
		functionNode: ActorBuilderNode;
	};
}
declare class CodeBuilder {
	private _nodeTraverser;
	private _rootNodesByShaderName;
	private _assembler;
	private _param_configs_controller;
	private _param_configs_set_allowed;
	private _shadersCollectionController;
	private _lines;
	constructor(
		_nodeTraverser: TypedNodeTraverser<NodeContext.JS>,
		_rootNodesByShaderName: RootNodesForShaderMethod,
		_assembler: BaseJsShaderAssembler
	);
	nodeTraverser(): TypedNodeTraverser<NodeContext.JS>;
	shaderNames(): ShaderName[];
	buildFromNodes(
		rootNodes: BaseJsNodeType[],
		paramNodes: BaseJsNodeType[],
		setCodeLinesOptions?: CodeBuilderSetCodeLinesOptions
	): void;
	shadersCollectionController(): ShadersCollectionController | undefined;
	disallow_new_param_configs(): void;
	allow_new_param_configs(): void;
	private reset;
	param_configs(): readonly JsParamConfig<ParamType>[];
	lines(shader_name: ShaderName, line_type: LineType): string[];
	all_lines(): Map<ShaderName, Map<LineType, string[]>>;
	setParamConfigs(nodes: BaseJsNodeType[]): void;
	private _setCodeLines;
	private _addCodeLines;
	private addDefinitions;
	add_code_line_for_nodes_and_line_type(nodes: BaseJsNodeType[], shader_name: ShaderName, line_type: LineType): void;
	add_code_line_for_node_and_line_type(
		node: BaseJsNodeType,
		shader_name: ShaderName,
		line_type: LineType,
		isLast: boolean
	): void;
}
declare class ShaderConfig {
	private _name;
	private _input_names;
	private _dependencies;
	constructor(_name: ShaderName, _input_names: string[], _dependencies: ShaderName[]);
	name(): ShaderName;
	input_names(): string[];
	dependencies(): ShaderName[];
}
declare class OutputJsParamsConfig extends NodeParamsConfig {}
declare class OutputJsNode extends TypedJsNode<OutputJsParamsConfig> {
	paramsConfig: OutputJsParamsConfig;
	static type(): JsType;
	initializeNode(): void;
	setLines(linesController: ShadersCollectionController): void;
}
declare class GlobalsJsParamsConfig extends NodeParamsConfig {}
declare class GlobalsJsNode extends TypedJsNode<GlobalsJsParamsConfig> {
	paramsConfig: GlobalsJsParamsConfig;
	static type(): JsType;
	initializeNode(): void;
	setLines(linesController: ShadersCollectionController): void;
}
declare class AttributeJsParamsConfig extends NodeParamsConfig {
	name: ParamTemplate<ParamType.STRING>;
	type: ParamTemplate<ParamType.INTEGER>;
	/** @param allows to export the attribute to a material (when used inside a particles system) */
	texportWhenConnected: ParamTemplate<ParamType.BOOLEAN>;
	/** @param allows to export the attribute to a material (when used inside a particles system) */
	exportWhenConnected: ParamTemplate<ParamType.BOOLEAN>;
}
declare class AttributeJsNode extends TypedJsNode<AttributeJsParamsConfig> {
	paramsConfig: AttributeJsParamsConfig;
	static type(): JsType;
	static readonly INPUT_NAME = 'export';
	static readonly OUTPUT_NAME = 'val';
	initializeNode(): void;
	inputName(): string;
	outputName(): string;
	setLines(linesController: ShadersCollectionController): void;
	attributeName(): string;
	glType(): JsConnectionPointType;
	setGlType(type: JsConnectionPointType): void;
	connected_input_node(): BaseJsNodeType | null;
	connected_input_connection_point(): BaseJsConnectionPoint | undefined;
	output_connection_point(): BaseJsConnectionPoint | undefined;
	isImporting(): boolean;
	isExporting(): boolean;
}
declare abstract class GlobalsBaseController {
	private static __next_id;
	private _id;
	constructor();
	id(): number;
	handle_globals_node(
		globals_node: GlobalsJsNode,
		output_name: string,
		linesController: ShadersCollectionController
	): void;
	handleGlobalVar(
		globals_node: BaseJsNodeType,
		output_name: string,
		glType: JsConnectionPointType,
		linesController: ShadersCollectionController
	): void;
	abstract readAttribute(
		node: BaseJsNodeType,
		gl_type: JsConnectionPointType,
		attrib_name: string,
		linesController: ShadersCollectionController
	): string | undefined;
}
declare enum GlType {
	ATTRIBUTE = 'attribute',
	GLOBALS = 'globals',
	NOISE = 'noise',
	OUTPUT = 'output',
	PARAM = 'param',
	SDF_CONTEXT = 'SDFContext',
	SDF_MATERIAL = 'SDFMaterial',
	VARYING_WRITE = 'varyingWrite',
}
declare class OutputGlParamsConfig extends NodeParamsConfig {}
declare class OutputGlNode extends TypedGlNode<OutputGlParamsConfig> {
	paramsConfig: OutputGlParamsConfig;
	static type(): GlType;
	initializeNode(): void;
	setLines(shaders_collection_controller: ShadersCollectionController): void;
}
declare class AttributeGlParamsConfig extends NodeParamsConfig {
	/** @param attribute name */
	name: ParamTemplate<ParamType.STRING>;
	/** @param attribute type (float, vec2, vec3, vec4) */
	type: ParamTemplate<ParamType.INTEGER>;
	/** @param allows to export the attribute to a material (when used inside a particles system) */
	texportWhenConnected: ParamTemplate<ParamType.BOOLEAN>;
	/** @param allows to export the attribute to a material (when used inside a particles system) */
	exportWhenConnected: ParamTemplate<ParamType.BOOLEAN>;
}
declare class AttributeGlNode extends TypedGlNode<AttributeGlParamsConfig> {
	paramsConfig: AttributeGlParamsConfig;
	static type(): Readonly<GlType.ATTRIBUTE>;
	static readonly INPUT_NAME = 'in';
	static readonly OUTPUT_NAME = 'val';
	initializeNode(): void;
	private _bound_setExportWhenConnectedStatus;
	private _setExportWhenConnectedStatus;
	setAttribSize(size: number): void;
	inputName(): string;
	outputName(): string;
	varyingName(): string;
	setLines(shadersCollectionController: ShadersCollectionController): void;
	attributeName(): string;
	glType(): GlConnectionPointType;
	setGlType(type: GlConnectionPointType): void;
	connected_input_node(): BaseGlNodeType | null;
	connected_input_connection_point(): BaseGlConnectionPoint | undefined;
	output_connection_point(): BaseGlConnectionPoint | undefined;
	isImporting(): boolean;
	isExporting(): boolean;
	private _setMatToRecompileIfIsExporting;
}
declare class GlobalsGlParamsConfig extends NodeParamsConfig {}
declare class GlobalsGlNode extends TypedGlNode<GlobalsGlParamsConfig> {
	paramsConfig: GlobalsGlParamsConfig;
	static type(): GlType;
	initializeNode(): void;
	setLines(shaders_collection_controller: ShadersCollectionController): void;
}
export interface IUniformN {
	value: number;
}
export interface IUniformTexture {
	value: Texture | null;
}
export interface OnBeforeCompileData {
	vertexShader: string;
	fragmentShader: string;
	paramConfigs: readonly GlParamConfig<ParamType>[];
	additionalTextureUniforms: PolyDictionary<IUniformTexture>;
	timeDependent: boolean;
	resolutionDependent: boolean;
	raymarchingLightsWorldCoordsDependent: boolean;
}
export declare type RemoveParamConfigField<Type> = {
	[Property in keyof Type as Exclude<Property, 'paramConfigs' | 'additionalTextureUniforms'>]: Type[Property];
};
export interface OnBeforeCompileDataJSON extends RemoveParamConfigField<OnBeforeCompileData> {
	paramConfigs: GlParamConfigJSON<ParamType>[];
}
export declare type CustomAssemblerMap = Map<CustomMaterialName, typeof ShaderAssemblerMaterial>;
export interface HandleGlobalsOutputOptions {
	globals_node: GlobalsGlNode;
	shaders_collection_controller: ShadersCollectionController;
	output_name: string;
	globals_shader_name: ShaderName;
	definitions_by_shader_name: Map<ShaderName, BaseGLDefinition[]>;
	body_lines: string[];
	var_name: string;
	shader_name: ShaderName;
	dependencies: ShaderName[];
	body_lines_by_shader_name: Map<ShaderName, string[]>;
}
export declare type CustomAssemblerCallback = (a: ShaderAssemblerMaterial, assemblerName: CustomMaterialName) => void;
declare class ShaderAssemblerMaterial extends BaseGlShaderAssembler {
	private _assemblersByCustomName;
	createMaterial(): Material;
	customAssemblerClassByCustomName(): CustomAssemblerMap | undefined;
	traverseCustomAssemblers(callback: CustomAssemblerCallback): void;
	protected _addCustomMaterials(material: Material): void;
	private _addCustomMaterial;
	compileCustomMaterials(material: MaterialWithCustomMaterials): void;
	private _filterFragmentShaderCallbacks;
	protected _resetFilterFragmentShaderCallbacks(): void;
	_addFilterFragmentShaderCallback(callbackName: string, callback: (s: string) => string): void;
	_removeFilterFragmentShaderCallback(callbackName: string): void;
	private _filterFragmentShaderMethodOwner;
	setFilterFragmentShaderMethodOwner(owner: ShaderAssemblerMaterial | undefined): void;
	filterFragmentShader(fragmentShader: string): string;
	processFilterFragmentShader(fragmentShader: string): string;
	private _onBeforeCompileData;
	onBeforeCompileData(): OnBeforeCompileData | undefined;
	private _additionalTextureUniforms;
	clearAdditionalTextureUniforms(): void;
	addAdditionalTextureUniforms(uniformName: string, uniform: IUniformTexture): void;
	private _setAdditionalTextureUniforms;
	compileMaterial(material: Material, codeBuilderOptions?: CodeBuilderSetCodeLinesOptions): void;
	prepareOnBeforeCompileData(material: Material): void;
	protected updateShaders(codeBuilderOptions?: CodeBuilderSetCodeLinesOptions): void;
	shadow_assembler_class_by_custom_name(): {};
	add_output_body_line(
		output_node: OutputGlNode,
		shaders_collection_controller: ShadersCollectionController,
		input_name: string
	): void;
	set_node_lines_output(output_node: OutputGlNode, shadersCollectionController: ShadersCollectionController): void;
	setNodeLinesAttribute(
		attribute_node: AttributeGlNode,
		shadersCollectionController: ShadersCollectionController
	): void;
	handle_globals_output_name(options: HandleGlobalsOutputOptions): void;
	handleTime(options: HandleGlobalsOutputOptions): void;
	handle_resolution(options: HandleGlobalsOutputOptions): void;
	handle_mvPosition(options: HandleGlobalsOutputOptions): void;
	handle_gl_Position(options: HandleGlobalsOutputOptions): void;
	handle_gl_FragCoord(options: HandleGlobalsOutputOptions): void;
	handle_gl_PointCoord(options: HandleGlobalsOutputOptions): void;
	set_node_lines_globals(
		globals_node: GlobalsGlNode,
		shaders_collection_controller: ShadersCollectionController
	): void;
	private used_output_names_for_shader;
}
declare class TypedBaseManagerNode<K extends NodeParamsConfig> extends TypedNode<NodeContext.MANAGER, K> {
	static context(): NodeContext;
}
export declare type BaseManagerNodeType = TypedBaseManagerNode<any>;
declare abstract class TypedLightObjNode<L extends Object3D, K extends NodeParamsConfig> extends TypedObjNode<
	Group,
	K
> {
	readonly flags: FlagsControllerD;
	readonly renderOrder: number;
	protected _color_with_intensity: Color;
	protected _light: L;
	get light(): L;
	protected abstract createLight(): L;
	protected _used_in_scene: boolean;
	initializeBaseNode(): void;
	private _cook_main_without_inputs_when_dirty_bound;
	private _cook_main_without_inputs_when_dirty;
	protected set_object_name(): void;
	private _updateLightAttachment;
	cook(): void;
	protected updateLightParams(): void;
	protected updateShadowParams(): void;
}
declare const AmbientLightObjParamsConfig_base: {
	new (...args: any[]): {
		color: ParamTemplate<ParamType.COLOR>;
		intensity: ParamTemplate<ParamType.FLOAT>;
		name: ParamTemplate<ParamType.STRING>;
	};
} & typeof NodeParamsConfig;
declare class AmbientLightObjParamsConfig extends AmbientLightObjParamsConfig_base {}
declare class AmbientLightObjNode extends TypedLightObjNode<AmbientLight, AmbientLightObjParamsConfig> {
	paramsConfig: AmbientLightObjParamsConfig;
	static type(): string;
	initializeNode(): void;
	private __operation__;
	private _operation;
	createLight(): AmbientLight;
	protected updateLightParams(): void;
}
declare const TransformedObjParamConfig_base: {
	new (...args: any[]): {
		transform: ParamTemplate<ParamType.FOLDER>;
		keepPosWhenParenting: ParamTemplate<ParamType.BOOLEAN>;
		rotationOrder: ParamTemplate<ParamType.INTEGER>;
		t: ParamTemplate<ParamType.VECTOR3>;
		r: ParamTemplate<ParamType.VECTOR3>;
		s: ParamTemplate<ParamType.VECTOR3>;
		scale: ParamTemplate<ParamType.FLOAT>;
		matrixAutoUpdate: ParamTemplate<ParamType.BOOLEAN>;
		updateTransformFromObject: ParamTemplate<ParamType.BUTTON>;
	};
} & typeof NodeParamsConfig;
declare class TransformedObjParamConfig extends TransformedObjParamConfig_base {}
declare abstract class BaseLightTransformedObjNode<
	L extends Object3D,
	K extends TransformedObjParamConfig
> extends TypedLightObjNode<L, K> {
	readonly flags: FlagsControllerD;
	readonly hierarchyController: HierarchyController;
	readonly transformController: TransformController;
	initializeBaseNode(): void;
	cook(): void;
}
declare enum LightType {
	AREA = 'areaLight',
	DIRECTIONAL = 'directionalLight',
	HEMISPHERE = 'hemisphereLight',
	POINT = 'pointLight',
	PROBE = 'lightProbe',
	SPOT = 'spotLight',
}
declare const AreaLightObjParamsConfig_base: {
	new (...args: any[]): {
		light: ParamTemplate<ParamType.FOLDER>;
		color: ParamTemplate<ParamType.COLOR>;
		intensity: ParamTemplate<ParamType.FLOAT>;
		width: ParamTemplate<ParamType.FLOAT>;
		height: ParamTemplate<ParamType.FLOAT>;
		showHelper: ParamTemplate<ParamType.BOOLEAN>;
		name: ParamTemplate<ParamType.STRING>;
	};
} & {
	new (...args: any[]): {
		transform: ParamTemplate<ParamType.FOLDER>;
		keepPosWhenParenting: ParamTemplate<ParamType.BOOLEAN>;
		rotationOrder: ParamTemplate<ParamType.INTEGER>;
		t: ParamTemplate<ParamType.VECTOR3>;
		r: ParamTemplate<ParamType.VECTOR3>;
		s: ParamTemplate<ParamType.VECTOR3>;
		scale: ParamTemplate<ParamType.FLOAT>;
		matrixAutoUpdate: ParamTemplate<ParamType.BOOLEAN>;
		updateTransformFromObject: ParamTemplate<ParamType.BUTTON>;
	};
} & typeof NodeParamsConfig;
declare class AreaLightObjParamsConfig extends AreaLightObjParamsConfig_base {}
declare class AreaLightObjNode extends BaseLightTransformedObjNode<RectAreaLight, AreaLightObjParamsConfig> {
	paramsConfig: AreaLightObjParamsConfig;
	static type(): LightType;
	private __operation__;
	private _operation;
	createLight(): RectAreaLight;
	protected updateLightParams(): void;
	private _helper;
}
export interface DirectionalLightContainerParams {
	showHelper: boolean;
}
declare class DirectionalLightContainer extends Group {
	readonly nodeName: string;
	private _light;
	private _target;
	showHelper: boolean;
	matrixAutoUpdate: boolean;
	constructor(options: DirectionalLightContainerParams, nodeName: string);
	light(): DirectionalLight;
	copy(source: this, recursive?: boolean): this;
	clone(recursive?: boolean): this;
	updateHelper(): void;
	private __helper__;
}
declare const DirectionalLightObjParamsConfig_base: {
	new (...args: any[]): {
		light: ParamTemplate<ParamType.FOLDER>;
		color: ParamTemplate<ParamType.COLOR>;
		intensity: ParamTemplate<ParamType.FLOAT>;
		distance: ParamTemplate<ParamType.FLOAT>;
		showHelper: ParamTemplate<ParamType.BOOLEAN>;
		name: ParamTemplate<ParamType.STRING>;
		shadow: ParamTemplate<ParamType.FOLDER>;
		castShadow: ParamTemplate<ParamType.BOOLEAN>;
		shadowAutoUpdate: ParamTemplate<ParamType.BOOLEAN>;
		shadowUpdateOnNextRender: ParamTemplate<ParamType.BOOLEAN>;
		shadowRes: ParamTemplate<ParamType.VECTOR2>;
		shadowSize: ParamTemplate<ParamType.VECTOR2>;
		shadowBias: ParamTemplate<ParamType.FLOAT>;
		shadowRadius: ParamTemplate<ParamType.FLOAT>;
		raymarching: ParamTemplate<ParamType.FOLDER>;
		raymarchingPenumbra: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		transform: ParamTemplate<ParamType.FOLDER>;
		keepPosWhenParenting: ParamTemplate<ParamType.BOOLEAN>;
		rotationOrder: ParamTemplate<ParamType.INTEGER>;
		t: ParamTemplate<ParamType.VECTOR3>;
		r: ParamTemplate<ParamType.VECTOR3>;
		s: ParamTemplate<ParamType.VECTOR3>;
		scale: ParamTemplate<ParamType.FLOAT>;
		matrixAutoUpdate: ParamTemplate<ParamType.BOOLEAN>;
		updateTransformFromObject: ParamTemplate<ParamType.BUTTON>;
	};
} & typeof NodeParamsConfig;
declare class DirectionalLightObjParamsConfig extends DirectionalLightObjParamsConfig_base {}
declare class DirectionalLightObjNode extends BaseLightTransformedObjNode<
	DirectionalLightContainer,
	DirectionalLightObjParamsConfig
> {
	paramsConfig: DirectionalLightObjParamsConfig;
	static type(): LightType;
	private __operation__;
	private _operation;
	createLight(): DirectionalLightContainer;
	protected updateLightParams(): void;
	protected updateShadowParams(): void;
}
declare const HemisphereLightObjParamsConfig_base: {
	new (...args: any[]): {
		skyColor: ParamTemplate<ParamType.COLOR>;
		groundColor: ParamTemplate<ParamType.COLOR>;
		intensity: ParamTemplate<ParamType.FLOAT>;
		position: ParamTemplate<ParamType.VECTOR3>;
		name: ParamTemplate<ParamType.STRING>;
	};
} & typeof NodeParamsConfig;
declare class HemisphereLightObjParamsConfig extends HemisphereLightObjParamsConfig_base {}
declare class HemisphereLightObjNode extends TypedLightObjNode<HemisphereLight, HemisphereLightObjParamsConfig> {
	paramsConfig: HemisphereLightObjParamsConfig;
	static type(): LightType;
	private __operation__;
	private _operation;
	createLight(): HemisphereLight;
	protected updateLightParams(): void;
}
declare const LightProbeObjParamsConfig_base: {
	new (...args: any[]): {
		cubeMap: ParamTemplate<ParamType.NODE_PATH>;
		intensity: ParamTemplate<ParamType.FLOAT>;
		name: ParamTemplate<ParamType.STRING>;
	};
} & typeof NodeParamsConfig;
declare class LightProbeObjParamsConfig extends LightProbeObjParamsConfig_base {}
declare class LightProbeObjNode extends TypedLightObjNode<LightProbe, LightProbeObjParamsConfig> {
	paramsConfig: LightProbeObjParamsConfig;
	static type(): LightType;
	private __operation__;
	private _operation;
	createLight(): LightProbe;
	protected updateLightParams(): Promise<void>;
}
declare const PointLightObjParamsConfig_base: {
	new (...args: any[]): {
		light: ParamTemplate<ParamType.FOLDER>;
		color: ParamTemplate<ParamType.COLOR>;
		intensity: ParamTemplate<ParamType.FLOAT>;
		decay: ParamTemplate<ParamType.FLOAT>;
		distance: ParamTemplate<ParamType.FLOAT>;
		showHelper: ParamTemplate<ParamType.BOOLEAN>;
		helperSize: ParamTemplate<ParamType.FLOAT>;
		name: ParamTemplate<ParamType.STRING>;
		shadow: ParamTemplate<ParamType.FOLDER>;
		castShadow: ParamTemplate<ParamType.BOOLEAN>;
		shadowAutoUpdate: ParamTemplate<ParamType.BOOLEAN>;
		shadowUpdateOnNextRender: ParamTemplate<ParamType.BOOLEAN>;
		shadowRes: ParamTemplate<ParamType.VECTOR2>;
		shadowBias: ParamTemplate<ParamType.FLOAT>;
		shadowNear: ParamTemplate<ParamType.FLOAT>;
		shadowFar: ParamTemplate<ParamType.FLOAT>;
		raymarching: ParamTemplate<ParamType.FOLDER>;
		raymarchingPenumbra: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		transform: ParamTemplate<ParamType.FOLDER>;
		keepPosWhenParenting: ParamTemplate<ParamType.BOOLEAN>;
		rotationOrder: ParamTemplate<ParamType.INTEGER>;
		t: ParamTemplate<ParamType.VECTOR3>;
		r: ParamTemplate<ParamType.VECTOR3>;
		s: ParamTemplate<ParamType.VECTOR3>;
		scale: ParamTemplate<ParamType.FLOAT>;
		matrixAutoUpdate: ParamTemplate<ParamType.BOOLEAN>;
		updateTransformFromObject: ParamTemplate<ParamType.BUTTON>;
	};
} & typeof NodeParamsConfig;
declare class PointLightObjParamsConfig extends PointLightObjParamsConfig_base {}
declare class PointLightObjNode extends BaseLightTransformedObjNode<PointLight, PointLightObjParamsConfig> {
	paramsConfig: PointLightObjParamsConfig;
	static type(): LightType;
	private _helperController;
	initializeNode(): void;
	private __operation__;
	private _operation;
	createLight(): PointLight;
	protected updateLightParams(): void;
	protected updateShadowParams(): void;
}
export interface CoreSpotLightHelperParams {
	helperSize: number;
}
export interface SpotLightContainerParams extends CoreSpotLightHelperParams {
	showHelper: boolean;
	tvolumetric: boolean;
	volAnglePower: number;
	volAttenuation: number;
}
declare class SpotLightContainer extends Group {
	readonly nodeName: string;
	private _light;
	private _target;
	matrixAutoUpdate: boolean;
	params: SpotLightContainerParams;
	constructor(params: Partial<SpotLightContainerParams>, nodeName: string);
	updateParams(params: Partial<SpotLightContainerParams>): void;
	light(): SpotLight;
	copy(source: this, recursive?: boolean): this;
	clone(recursive?: boolean): this;
	private __helper__;
	updateHelper(): void;
	private __volumetric__;
	updateVolumetric(): void;
}
declare const SpotLightObjParamsConfig_base: {
	new (...args: any[]): {
		light: ParamTemplate<ParamType.FOLDER>;
		color: ParamTemplate<ParamType.COLOR>;
		intensity: ParamTemplate<ParamType.FLOAT>;
		angle: ParamTemplate<ParamType.FLOAT>;
		penumbra: ParamTemplate<ParamType.FLOAT>;
		decay: ParamTemplate<ParamType.FLOAT>;
		distance: ParamTemplate<ParamType.FLOAT>;
		showHelper: ParamTemplate<ParamType.BOOLEAN>;
		helperSize: ParamTemplate<ParamType.FLOAT>;
		name: ParamTemplate<ParamType.STRING>;
		shadow: ParamTemplate<ParamType.FOLDER>;
		castShadow: ParamTemplate<ParamType.BOOLEAN>;
		shadowAutoUpdate: ParamTemplate<ParamType.BOOLEAN>;
		shadowUpdateOnNextRender: ParamTemplate<ParamType.BOOLEAN>;
		shadowRes: ParamTemplate<ParamType.VECTOR2>;
		shadowBias: ParamTemplate<ParamType.FLOAT>;
		shadowNear: ParamTemplate<ParamType.FLOAT>;
		shadowFar: ParamTemplate<ParamType.FLOAT>;
		shadowRadius: ParamTemplate<ParamType.FLOAT>;
		volumetric: ParamTemplate<ParamType.FOLDER>;
		tvolumetric: ParamTemplate<ParamType.BOOLEAN>;
		volAttenuation: ParamTemplate<ParamType.FLOAT>;
		volAnglePower: ParamTemplate<ParamType.FLOAT>;
		raymarching: ParamTemplate<ParamType.FOLDER>;
		raymarchingPenumbra: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		transform: ParamTemplate<ParamType.FOLDER>;
		keepPosWhenParenting: ParamTemplate<ParamType.BOOLEAN>;
		rotationOrder: ParamTemplate<ParamType.INTEGER>;
		t: ParamTemplate<ParamType.VECTOR3>;
		r: ParamTemplate<ParamType.VECTOR3>;
		s: ParamTemplate<ParamType.VECTOR3>;
		scale: ParamTemplate<ParamType.FLOAT>;
		matrixAutoUpdate: ParamTemplate<ParamType.BOOLEAN>;
		updateTransformFromObject: ParamTemplate<ParamType.BUTTON>;
	};
} & typeof NodeParamsConfig;
declare class SpotLightObjParamsConfig extends SpotLightObjParamsConfig_base {}
declare class SpotLightObjNode extends BaseLightTransformedObjNode<SpotLightContainer, SpotLightObjParamsConfig> {
	paramsConfig: SpotLightObjParamsConfig;
	static type(): LightType;
	private __operation__;
	private _operation;
	createLight(): SpotLightContainer;
	protected updateLightParams(): void;
	protected updateShadowParams(): void;
}
declare enum ObjType {
	GEO = 'geo',
	CUBE_CAMERA = 'cubeCamera',
	AUDIO_LISTENER = 'audioListener',
	POSITIONAL_AUDIO = 'positionalAudio',
	SCENE = 'scene',
}
declare enum DistanceModel {
	LINEAR = 'linear',
	INVERSE = 'inverse',
	EXPONENTIAL = 'exponential',
}
declare class CorePositionalAudio extends Object3D {
	private tonePanner;
	private pannerNode;
	listenerTransformAutoUpdate: boolean;
	constructor();
	disconnect(): void;
	private _currentAudioNode;
	setInput(audioNode: ToneAudioNode | undefined): void;
	connect(audioNode: ToneAudioNode): void;
	getRefDistance(): number;
	setRefDistance(value: number): this;
	getRolloffFactor(): number;
	setRolloffFactor(value: number): this;
	getDistanceModel(): DistanceModelType;
	setDistanceModel(value: DistanceModel): this;
	getMaxDistance(): number;
	setMaxDistance(value: number): this;
	setDirectionalCone(coneInnerAngle: number, coneOuterAngle: number, coneOuterGain: number): this;
	coneInnerAngle(): number;
	coneOuterAngle(): number;
	updateMatrixWorld(force: boolean): void;
}
declare class CoreAudioListener extends Object3D {
	private context;
	private timeDelta;
	private _clock;
	private gain;
	listenerTransformAutoUpdate: boolean;
	constructor();
	addInput(positionalAudioNode: CorePositionalAudio): Promise<void>;
	dispose(): void;
	setMasterVolume(value: number): this;
	masterVolume(): number;
	updateMatrixWorld(force: boolean): void;
}
declare const AudioListenerParamConfig_base: {
	new (...args: any[]): {
		transform: ParamTemplate<ParamType.FOLDER>;
		keepPosWhenParenting: ParamTemplate<ParamType.BOOLEAN>;
		rotationOrder: ParamTemplate<ParamType.INTEGER>;
		t: ParamTemplate<ParamType.VECTOR3>;
		r: ParamTemplate<ParamType.VECTOR3>;
		s: ParamTemplate<ParamType.VECTOR3>;
		scale: ParamTemplate<ParamType.FLOAT>;
		matrixAutoUpdate: ParamTemplate<ParamType.BOOLEAN>;
		updateTransformFromObject: ParamTemplate<ParamType.BUTTON>;
	};
} & typeof NodeParamsConfig;
declare class AudioListenerParamConfig extends AudioListenerParamConfig_base {
	audio: ParamTemplate<ParamType.FOLDER>;
	/** @param soundOn */
	soundOn: ParamTemplate<ParamType.BOOLEAN>;
	/** @param volume */
	masterVolume: ParamTemplate<ParamType.FLOAT>;
	/** @param ensures the transform of the audio listener is updated on very frame */
	listenerTransformAutoUpdate: ParamTemplate<ParamType.BOOLEAN>;
}
declare class AudioListenerObjNode extends TypedObjNode<CoreAudioListener, AudioListenerParamConfig> {
	paramsConfig: AudioListenerParamConfig;
	static type(): ObjType;
	readonly hierarchyController: HierarchyController;
	readonly transformController: TransformController;
	readonly flags: FlagsControllerD;
	createObject(): CoreAudioListener;
	initializeNode(): void;
	dispose(): void;
	toggleSound(): void;
	private _setPositionalAudioNodesDirty;
	cook(): void;
	private _validateUniq;
	private _updateAudioListener;
	private _updateViewers;
	private _updateListenerAndViewers;
	static PARAM_CALLBACK_update(node: AudioListenerObjNode): void;
	private static _eventsAdded;
	private static _audioActivated;
	private _onpointerdown;
	private _onkeypress;
	static soundActivated(): boolean;
	soundActivated(): boolean;
	activateSound(): Promise<void>;
	private _boundEvents;
	addAudioActivationEvents(): void;
	private _removeAudioActivationEvents;
}
declare class BlendObjParamConfig extends NodeParamsConfig {
	/** @param object to blend transform from */
	object0: ParamTemplate<ParamType.NODE_PATH>;
	/** @param object to blend transform to */
	object1: ParamTemplate<ParamType.NODE_PATH>;
	/** @param blend mode */
	mode: ParamTemplate<ParamType.INTEGER>;
	/** @param blend value */
	blend: ParamTemplate<ParamType.FLOAT>;
	/** @param blend translation value */
	blendT: ParamTemplate<ParamType.FLOAT>;
	/** @param blend rotation value */
	blendR: ParamTemplate<ParamType.FLOAT>;
	/** @param updateOnRender */
	updateOnRender: ParamTemplate<ParamType.BOOLEAN>;
}
declare class BlendObjNode extends TypedObjNode<Mesh, BlendObjParamConfig> {
	paramsConfig: BlendObjParamConfig;
	static type(): string;
	readonly hierarchyController: HierarchyController;
	readonly flags: FlagsControllerD;
	private _helper;
	createObject(): Mesh<BufferGeometry, Material | Material[]>;
	initializeNode(): void;
	private _updateHelperHierarchy;
	private _object0;
	private _object1;
	cook(): Promise<void>;
	private _onBeforeRender;
	private _computeBlendedMatrix;
	private _t0;
	private _q0;
	private _s0;
	private _t1;
	private _q1;
	private _s1;
	private _blendTogether;
	private _blendSeparately;
	private _decomposeMatrices;
	private _updateMatrix;
}
declare const ContactShadowObjParamConfig_base: {
	new (...args: any[]): {
		transform: ParamTemplate<ParamType.FOLDER>;
		keepPosWhenParenting: ParamTemplate<ParamType.BOOLEAN>;
		rotationOrder: ParamTemplate<ParamType.INTEGER>;
		t: ParamTemplate<ParamType.VECTOR3>;
		r: ParamTemplate<ParamType.VECTOR3>;
		s: ParamTemplate<ParamType.VECTOR3>;
		scale: ParamTemplate<ParamType.FLOAT>;
		matrixAutoUpdate: ParamTemplate<ParamType.BOOLEAN> /** @param blur amount */;
		updateTransformFromObject: ParamTemplate<ParamType.BUTTON>;
	};
} & typeof NodeParamsConfig;
declare class ContactShadowObjParamConfig extends ContactShadowObjParamConfig_base {
	shadow: ParamTemplate<ParamType.FOLDER>;
	/** @param distance from the ground up to which shadows are visible */
	dist: ParamTemplate<ParamType.FLOAT>;
	/** @param size of the plane on which shadows are rendered */
	planeSize: ParamTemplate<ParamType.VECTOR2>;
	/** @param shadow resolution */
	shadowRes: ParamTemplate<ParamType.VECTOR2>;
	/** @param blur amount */
	blur: ParamTemplate<ParamType.FLOAT>;
	/** @param toggle on to add a secondary blur, which may be useful to get rid of artefacts */
	tblur2: ParamTemplate<ParamType.BOOLEAN>;
	/** @param secondary blur amount */
	blur2: ParamTemplate<ParamType.FLOAT>;
	/** @param shadow darkness */
	darkness: ParamTemplate<ParamType.FLOAT>;
	/** @param shadow opacity */
	opacity: ParamTemplate<ParamType.FLOAT>;
	/** @param show helper */
	showHelper: ParamTemplate<ParamType.BOOLEAN>;
	/** @param set update mode, which can be to update on every frame, or manually only */
	updateMode: ParamTemplate<ParamType.INTEGER>;
	/** @param click to update shadow, when mode is manual */
	update: ParamTemplate<ParamType.BUTTON>;
	scene: ParamTemplate<ParamType.FOLDER>;
	renderAllObjects: ParamTemplate<ParamType.BOOLEAN>;
	include: ParamTemplate<ParamType.STRING>;
	exclude: ParamTemplate<ParamType.STRING>;
	updateObjectsList: ParamTemplate<ParamType.BUTTON>;
	printResolveObjectsList: ParamTemplate<ParamType.BUTTON>;
}
declare class ContactShadowObjNode extends TypedObjNode<Group, ContactShadowObjParamConfig> {
	paramsConfig: ContactShadowObjParamConfig;
	static type(): Readonly<'contactShadow'>;
	readonly hierarchyController: HierarchyController;
	readonly flags: FlagsControllerD;
	private _helper;
	private _renderTarget;
	private _coreRenderBlur;
	private _createRenderTarget;
	private _createCoreRenderBlur;
	private _shadowGroup;
	private _plane;
	private _planeMaterial;
	private _includedObjects;
	private _includedAncestors;
	private _excludedObjects;
	createObject(): Group;
	readonly transformController: TransformController;
	initializeNode(): void;
	cook(): Promise<void>;
	private _shadowCamera;
	private _createDepthCamera;
	private _depthMaterial;
	private _darknessUniform;
	private _createMaterials;
	private _emptyOnBeforeRender;
	private _renderShadow;
	private _updateShadowGroupVisibility;
	private _updateHelperVisibility;
	private _updateRenderHook;
	private _addRenderHook;
	private _emptyRenderHook;
	private _removeRenderHook;
	private _on_object_before_render_bound;
	private _update;
	private _updateManual;
	static PARAM_CALLBACK_update_updateMode(node: ContactShadowObjNode): void;
	static PARAM_CALLBACK_updateManual(node: ContactShadowObjNode): void;
	static PARAM_CALLBACK_updateObjectsList(node: ContactShadowObjNode): void;
	private _updateObjectsList;
	static PARAM_CALLBACK_printResolveObjectsList(node: ContactShadowObjNode): void;
	private _printResolveObjectsList;
	private _initialVisibilityState;
	private _initVisibility;
	private _storeObjectsVisibility;
	private _setObjectsVisibility;
	private _restoreVisibility;
	private _restoreObjectsVisibility;
}
declare enum SopType {
	ACTOR = 'actor',
	ADD = 'add',
	ATTRIB_ADD_MULT = 'attribAddMult',
	ATTRIB_COPY = 'attribCopy',
	ATTRIB_CREATE = 'attribCreate',
	AXES_HELPER = 'axesHelper',
	BLEND = 'blend',
	BOX = 'box',
	BOX_LINES = 'boxLines',
	CAD_BOOLEAN = 'CADBoolean',
	CAD_BOX = 'CADBox',
	CAD_CIRCLE = 'CADCircle',
	CAD_CIRCLE_2D = 'CADCircle2D',
	CAD_CIRCLE_3_POINTS = 'CADCircle3Points',
	CAD_CONE = 'CADCone',
	CAD_CONVERT_DIMENSION = 'CADConvertDimension',
	CAD_CURVE_2D_TO_SURFACE = 'CADCurve2DToSurface',
	CAD_CURVE_FROM_POINTS = 'CADCurveFromPoints',
	CAD_CURVE_FROM_POINTS_2D = 'CADCurveFromPoints2D',
	CAD_CURVE_TRIM = 'CADCurveTrim',
	CAD_ELLIPSE = 'CADEllipse',
	CAD_ELLIPSE_2D = 'CADEllipse2D',
	CAD_EXPORTER_STEP = 'CADExporterSTEP',
	CAD_EXTRUDE = 'CADExtrude',
	CAD_FILE_STEP = 'CADFileSTEP',
	CAD_FILLET = 'CADFillet',
	CAD_GROUP = 'CADGroup',
	CAD_LOFT = 'CADLoft',
	CAD_MIRROR = 'CADMirror',
	CAD_PIPE = 'CADPipe',
	CAD_POINT = 'CADPoint',
	CAD_POINT_2D = 'CADPoint2D',
	CAD_POINTS_FROM_CURVE = 'CADPointsFromCurve',
	CAD_RECTANGLE = 'CADRectangle',
	CAD_REVOLUTION = 'CADRevolution',
	CAD_SEGMENT = 'CADSegment',
	CAD_SPHERE = 'CADSphere',
	CAD_THICKNESS = 'CADThickness',
	CAD_TORUS = 'CADTorus',
	CAD_TRANSFORM = 'CADTransform',
	CAD_TRANSFORM_2D = 'CADTransform2D',
	CAD_TRIANGULATE = 'CADTriangulate',
	CAD_TUBE = 'CADTube',
	CAD_UNPACK = 'CADUnpack',
	CAD_WEDGE = 'CADWedge',
	CAPSULE = 'capsule',
	CIRCLE = 'circle',
	CIRCLE_3_POINTS = 'circle3Points',
	CONE = 'cone',
	COPY = 'copy',
	CURVE_FROM_POINTS = 'curveFromPoints',
	CSG_ARC = 'CSGArc',
	CSG_BOOLEAN = 'CSGBoolean',
	CSG_CENTER = 'CSGCenter',
	CSG_CIRCLE = 'CSGCircle',
	CSG_BOX = 'CSGBox',
	CSG_DODECAHEDRON = 'CSGDodecahedron',
	CSG_ELLIPSE = 'CSGEllipse',
	CSG_ELLIPSOID = 'CSGEllipsoid',
	CSG_EXPAND = 'CSGExpand',
	CSG_EXTRUDE_LINEAR = 'CSGExtrudeLinear',
	CSG_EXTRUDE_RECTANGULAR = 'CSGExtrudeRectangular',
	CSG_EXTRUDE_ROTATE = 'CSGExtrudeRotate',
	CSG_HULL = 'CSGHull',
	CSG_LINE = 'CSGLine',
	CSG_MIRROR = 'CSGMirror',
	CSG_OFFSET = 'CSGOffset',
	CSG_POLYGON = 'CSGPolygon',
	CSG_POLYHEDRON = 'CSGPolyhedron',
	CSG_PROJECT = 'CSGProject',
	CSG_RECTANGLE = 'CSGRectangle',
	CSG_SPHERE = 'CSGSphere',
	CSG_STAR = 'CSGStar',
	CSG_TORUS = 'CSGTorus',
	CSG_TRANSFORM_2D = 'CSGTransform2D',
	CSG_TRANSFORM_RESET = 'CSGTransformReset',
	CSG_TRIANGLE = 'CSGTriangle',
	CSG_TRIANGULATE = 'CSGTriangulate',
	CSG_TUBE = 'CSGTube',
	CSG_TUBE_ELLIPTIC = 'CSGTubeElliptic',
	CSS2D_OBJECT = 'CSS2DObject',
	CSS3D_OBJECT = 'CSS3DObject',
	DATA = 'data',
	DATA_URL = 'dataUrl',
	ICOSAHEDRON = 'icosahedron',
	INSTANCE = 'instance',
	MAPBOX_TRANSFORM = 'mapboxTransform',
	MATERIAL = 'material',
	NOISE = 'noise',
	PARTICLES_SYSTEM_GPU = 'particlesSystemGpu',
	PHYSICS_GROUND = 'physicsGround',
	PHYSICS_RBD_ATTRIBUTES = 'physicsRBDAttributes',
	PHYSICS_WORLD = 'physicsWorld',
	PHYSICS_PLAYER = 'physicsPlayer',
	PLANE = 'plane',
	POLAR_TRANSFORM = 'polarTransform',
	POLYWIRE = 'polywire',
	RAY = 'ray',
	RING = 'ring',
	ROUNDED_BOX = 'roundedBox',
	SDF_BUILDER = 'SDFBuilder',
	SHEAR = 'shear',
	SPHERE = 'sphere',
	SUBDIVIDE = 'subdivide',
	SWITCH = 'switch',
	TANGENT = 'tangent',
	TETRAHEDRON = 'tetrahedron',
	TEXT = 'text',
	TORUS = 'torus',
	TORUS_KNOT = 'torusKnot',
	TRANSFORM = 'transform',
	TUBE = 'tube',
	UV_LAYOUT = 'uvLayout',
	UV_TRANSFORM = 'uvTransform',
	UV_UNWRAP = 'uvUnwrap',
}
declare enum SopTypeFile {
	FILE_DRC = 'fileDRC',
	FILE_FBX = 'fileFBX',
	FILE_GEOJSON = 'fileGEOJSON',
	FILE_GLTF = 'fileGLTF',
	FILE_JSON = 'fileJSON',
	FILE_MPD = 'fileMPD',
	FILE_OBJ = 'fileOBJ',
	FILE_PDB = 'filePDB',
	FILE_PLY = 'filePLY',
	FILE_STL = 'fileSTL',
	FILE_SVG = 'fileSVG',
	FILE_USDZ = 'fileUSDZ',
}
declare enum SopTypeFileMulti {
	FILE_DRC = 'fileMultiDRC',
	FILE_FBX = 'fileMultiFBX',
	FILE_GLTF = 'fileMultiGLTF',
	FILE_JSON = 'fileMultiJSON',
	FILE_MPD = 'fileMultiMPD',
	FILE_OBJ = 'fileMultiOBJ',
	FILE_PDB = 'fileMultiPDB',
	FILE_PLY = 'fileMultiPLY',
	FILE_STL = 'fileMultiSTL',
	FILE_SVG = 'fileMultiSVG',
}
declare enum SopExporter {
	EXPORTER_GLTF = 'exporterGLTF',
	EXPORTER_OBJ = 'exporterOBJ',
	EXPORTER_PLY = 'exporterPLY',
	EXPORTER_STL = 'exporterSTL',
	EXPORTER_USDZ = 'exporterUSDZ',
}
declare class BaseJsMathFunctionParamsConfig extends NodeParamsConfig {}
declare abstract class BaseMathFunctionJsNode extends TypedJsNode<BaseJsMathFunctionParamsConfig> {
	paramsConfig: BaseJsMathFunctionParamsConfig;
	initializeNode(): void;
	protected _expectedInputTypes(): JsConnectionPointType[];
	protected _expectedOutputTypes(): JsConnectionPointType[];
	protected _expectedInputName(index: number): string;
	protected _expectedOutputName(index: number): string;
}
declare const AbsJsNode_base: typeof BaseMathFunctionJsNode;
declare class AbsJsNode extends AbsJsNode_base {}
declare const AcosJsNode_base: typeof BaseMathFunctionJsNode;
declare class AcosJsNode extends AcosJsNode_base {}
declare const AddJsNode_base: typeof BaseMathFunctionJsNode;
declare class AddJsNode extends AddJsNode_base {}
export declare type AllowedType = JsConnectionPointType.BOOLEAN | JsConnectionPointType.BOOLEAN_ARRAY;
declare abstract class BaseLogicOperationJsNode extends ParamlessTypedJsNode {
	initializeNode(): void;
	protected _expectedInputName(index: number): string;
	protected _expectedInputTypes(): AllowedType[];
	protected _expectedOutputTypes(): JsConnectionPointType[];
	protected abstract _expectedOutputName(index: number): string;
	protected abstract _functionName(firstType: AllowedType): 'orBooleans' | 'orArrays' | 'andBooleans' | 'andArrays';
	setLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class AndJsNode extends BaseLogicOperationJsNode {
	static type(): string;
	protected _expectedOutputName(): string;
	protected _functionName(firstType: AllowedType): 'andArrays' | 'andBooleans';
}
declare class AnimationActionJsParamsConfig extends NodeParamsConfig {
	clipName: ParamTemplate<ParamType.STRING>;
	autoPlay: ParamTemplate<ParamType.BOOLEAN>;
}
declare class AnimationActionJsNode extends TypedJsNode<AnimationActionJsParamsConfig> {
	readonly paramsConfig: AnimationActionJsParamsConfig;
	static type(): string;
	static readonly OUTPUT_NAME = 'val';
	initializeNode(): void;
	setLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class AnimationActionCrossFadeJsParamsConfig extends NodeParamsConfig {
	/** @param fadeIn duration */
	duration: ParamTemplate<ParamType.FLOAT>;
	/** @param additional warping (gradually changes of the time scales) will be applied */
	warp: ParamTemplate<ParamType.BOOLEAN>;
	/** @param starts cross fade when the from action ends */
	startOnFromActionEnd: ParamTemplate<ParamType.BOOLEAN>;
}
declare class AnimationActionCrossFadeJsNode extends TypedJsNode<AnimationActionCrossFadeJsParamsConfig> {
	readonly paramsConfig: AnimationActionCrossFadeJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	setTriggerableLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class AnimationActionFadeOutJsParamsConfig extends NodeParamsConfig {
	/** @param manual trigger */
	/** @param fadeIn duration */
	duration: ParamTemplate<ParamType.FLOAT>;
}
declare class AnimationActionFadeOutJsNode extends TypedJsNode<AnimationActionFadeOutJsParamsConfig> {
	readonly paramsConfig: AnimationActionFadeOutJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	setTriggerableLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class AnimationActionFadeInJsParamsConfig extends NodeParamsConfig {
	/** @param fadeIn duration */
	duration: ParamTemplate<ParamType.FLOAT>;
	/** @param fade out other actions */
	fadeOutOtherActions: ParamTemplate<ParamType.BOOLEAN>;
	/** @param additional warping (gradually changes of the time scales) will be applied */
	warp: ParamTemplate<ParamType.BOOLEAN>;
	/** @param starts cross fade when the from action ends */
	startOnFromActionEnd: ParamTemplate<ParamType.BOOLEAN>;
}
declare class AnimationActionFadeInJsNode extends TypedJsNode<AnimationActionFadeInJsParamsConfig> {
	readonly paramsConfig: AnimationActionFadeInJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	setTriggerableLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class AnimationActionPlayJsParamsConfig extends NodeParamsConfig {}
declare class AnimationActionPlayJsNode extends TypedJsNode<AnimationActionPlayJsParamsConfig> {
	readonly paramsConfig: AnimationActionPlayJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	setTriggerableLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class AnimationActionStopJsParamsConfig extends NodeParamsConfig {}
declare class AnimationActionStopJsNode extends TypedJsNode<AnimationActionStopJsParamsConfig> {
	readonly paramsConfig: AnimationActionStopJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	setTriggerableLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class AnimationMixerJsParamsConfig extends NodeParamsConfig {}
declare class AnimationMixerJsNode extends TypedJsNode<AnimationMixerJsParamsConfig> {
	readonly paramsConfig: AnimationMixerJsParamsConfig;
	static type(): string;
	static readonly OUTPUT_NAME = 'val';
	initializeNode(): void;
	setLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class AnimationMixerUpdateJsParamsConfig extends NodeParamsConfig {}
declare class AnimationMixerUpdateJsNode extends TypedJsNode<AnimationMixerUpdateJsParamsConfig> {
	readonly paramsConfig: AnimationMixerUpdateJsParamsConfig;
	static type(): string;
	static readonly OUTPUT_NAME = 'val';
	static readonly INPUT_NAMES: {
		TRIGGER: string;
		ANIMATION_MIXER: JsConnectionPointType;
	};
	initializeNode(): void;
	setTriggerableLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class AnyTriggerJsParamsConfig extends NodeParamsConfig {
	/** @param audio node */
	condition: ParamTemplate<ParamType.BOOLEAN>;
}
declare class AnyTriggerJsNode extends TypedJsNode<AnyTriggerJsParamsConfig> {
	readonly paramsConfig: AnyTriggerJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	protected _expectedInputTypes(): any[];
	protected _expectedOutputTypes(): JsConnectionPointType[];
	protected _expectedInputName(index: number): string;
	protected _expectedOutputName(index: number): string;
	setTriggerableLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class ArrayElementJsParamsConfig extends NodeParamsConfig {
	index: ParamTemplate<ParamType.INTEGER>;
}
declare class ArrayElementJsNode extends TypedJsNode<ArrayElementJsParamsConfig> {
	readonly paramsConfig: ArrayElementJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	protected _expectedInputTypes(): [JsConnectionPointTypeArray, JsConnectionPointType];
	protected _expectedInputName(index: number): string;
	protected _expectedOutputName(index: number): string;
	protected _expectedOutputTypes(): (
		| JsConnectionPointType.BOOLEAN
		| JsConnectionPointType.COLOR
		| JsConnectionPointType.FLOAT
		| JsConnectionPointType.INT
		| JsConnectionPointType.INTERSECTION
		| JsConnectionPointType.MATRIX4
		| JsConnectionPointType.QUATERNION
		| JsConnectionPointType.STRING
		| JsConnectionPointType.TEXTURE
		| JsConnectionPointType.VECTOR2
		| JsConnectionPointType.VECTOR3
		| JsConnectionPointType.VECTOR4
	)[];
	setLines(shadersCollectionController: ShadersCollectionController): void;
	private _setLinesAsPrimitive;
	private _setLinesAsVector;
	private _setLinesAsIntersection;
	private _setLinesAsTexture;
}
declare class ArrayLengthJsParamsConfig extends NodeParamsConfig {}
declare class ArrayLengthJsNode extends TypedJsNode<ArrayLengthJsParamsConfig> {
	readonly paramsConfig: ArrayLengthJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	protected _expectedInputTypes(): JsConnectionPointTypeArray[];
	protected _expectedInputName(index: number): string;
	protected _expectedOutputName(index: number): string;
	protected _expectedOutputTypes(): JsConnectionPointType[];
	setLines(shadersCollectionController: ShadersCollectionController): void;
}
declare const AsinJsNode_base: typeof BaseMathFunctionJsNode;
declare class AsinJsNode extends AsinJsNode_base {}
declare const AtanJsNode_base: typeof BaseMathFunctionJsNode;
declare class AtanJsNode extends AtanJsNode_base {}
declare class IntToBoolJsParamsConfig extends NodeParamsConfig {
	int: ParamTemplate<ParamType.INTEGER>;
}
declare class IntToBoolJsNode extends TypedJsNode<IntToBoolJsParamsConfig> {
	paramsConfig: IntToBoolJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class BoolToIntJsParamsConfig extends NodeParamsConfig {
	bool: ParamTemplate<ParamType.INTEGER>;
}
declare class BoolToIntJsNode extends TypedJsNode<BoolToIntJsParamsConfig> {
	paramsConfig: BoolToIntJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class IntToFloatJsParamsConfig extends NodeParamsConfig {
	int: ParamTemplate<ParamType.INTEGER>;
}
declare class IntToFloatJsNode extends TypedJsNode<IntToFloatJsParamsConfig> {
	paramsConfig: IntToFloatJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class FloatToIntJsParamsConfig extends NodeParamsConfig {
	float: ParamTemplate<ParamType.INTEGER>;
}
declare class FloatToIntJsNode extends TypedJsNode<FloatToIntJsParamsConfig> {
	paramsConfig: FloatToIntJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class Box3JsParamsConfig extends NodeParamsConfig {
	/** @param position representing the lower bound of the box */
	min: ParamTemplate<ParamType.VECTOR3>;
	/** @param position representing the upper bound of the box */
	max: ParamTemplate<ParamType.VECTOR3>;
}
declare class Box3JsNode extends TypedJsNode<Box3JsParamsConfig> {
	paramsConfig: Box3JsParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class CatmullRomCurve3GetPointJsParamsConfig extends NodeParamsConfig {
	t: ParamTemplate<ParamType.FLOAT>;
}
declare class CatmullRomCurve3GetPointJsNode extends TypedJsNode<CatmullRomCurve3GetPointJsParamsConfig> {
	paramsConfig: CatmullRomCurve3GetPointJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(shadersCollectionController: ShadersCollectionController): void;
}
declare const CeilJsNode_base: typeof BaseMathFunctionJsNode;
declare class CeilJsNode extends CeilJsNode_base {}
declare const ClampJsNode_base: typeof BaseMathFunctionJsNode;
declare class ClampJsNode extends ClampJsNode_base {
	protected _coreFunction(shadersCollectionController: ShadersCollectionController): string;
	paramDefaultValue(name: string): number;
	protected _expectedInputName(index: number): string;
	protected _expectedInputTypes(): JsConnectionPointType[];
}
declare class BaseCodeProcessor {
	protected node: BaseNodeType;
	constructor(node: BaseNodeType);
}
export declare type ParamsValueAccessorType<T extends NodeParamsConfig> = {
	// @ts-ignore
	// @ts-ignore
	// @ts-ignore
	// @ts-ignore
	// @ts-ignore
	// @ts-ignore
	// @ts-ignore
	// @ts-ignore
	// @ts-ignore
	readonly [P in keyof T]: T[P]['value_type'];
};
export declare type ParamsAccessorType<T extends NodeParamsConfig> = {
	// @ts-ignore
	// @ts-ignore
	// @ts-ignore
	// @ts-ignore
	// @ts-ignore
	// @ts-ignore
	// @ts-ignore
	// @ts-ignore
	// @ts-ignore
	readonly [P in keyof T]: T[P]['param_class'];
};
declare class BaseCodeJsProcessor extends BaseCodeProcessor {
	protected node: CodeJsNode;
	constructor(node: CodeJsNode);
	get pv(): ParamsValueAccessorType<CodeJsParamsConfig>;
	get p(): ParamsAccessorType<CodeJsParamsConfig>;
	get io(): IOController<NodeContext.JS>;
	initializeProcessor(): void;
	setTriggerableLines(shadersCollectionController: ShadersCollectionController): void;
	protected variableForInput(shadersCollectionController: ShadersCollectionController, inputName: string): string;
	protected addTriggerableLines(shadersCollectionController: ShadersCollectionController, bodyLines: string[]): void;
}
declare class CodeJsParamsConfig extends NodeParamsConfig {
	compile: ParamTemplate<ParamType.BUTTON>;
	codeTypescript: ParamTemplate<ParamType.STRING>;
	codeJavascript: ParamTemplate<ParamType.STRING>;
}
declare class CodeJsNode extends TypedJsNode<CodeJsParamsConfig> {
	paramsConfig: CodeJsParamsConfig;
	static BaseCodeJsProcessor: typeof BaseCodeJsProcessor;
	static type(): string;
	protected _processor: BaseCodeJsProcessor | undefined;
	initializeNode(): void;
	setTriggerableLines(shadersCollectionController: ShadersCollectionController): void;
	private _compile;
	static PARAM_CALLBACK_compile(node: CodeJsNode): void;
}
declare class VecToParamsJsConfig extends NodeParamsConfig {}
declare class BaseVecToJsNode extends TypedJsNode<VecToParamsJsConfig> {
	paramsConfig: VecToParamsJsConfig;
}
declare const Vec2ToFloatJsNode_base: typeof BaseVecToJsNode;
declare class Vec2ToFloatJsNode extends Vec2ToFloatJsNode_base {}
declare const Vec3ToFloatJsNode_base: typeof BaseVecToJsNode;
declare class Vec3ToFloatJsNode extends Vec3ToFloatJsNode_base {}
declare const Vec4ToFloatJsNode_base: typeof BaseVecToJsNode;
declare class Vec4ToFloatJsNode extends Vec4ToFloatJsNode_base {}
declare class Vec3ToVec2ParamsJsConfig extends NodeParamsConfig {
	vec3: ParamTemplate<ParamType.VECTOR3>;
}
declare class Vec3ToVec2JsNode extends TypedJsNode<Vec3ToVec2ParamsJsConfig> {
	paramsConfig: Vec3ToVec2ParamsJsConfig;
	static type(): string;
	static readonly OUTPUT_NAME_VEC2 = 'vec2';
	static readonly OUTPUT_NAME_Z = 'z';
	initializeNode(): void;
	setLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class Vec2ToVec3ParamsJsConfig extends NodeParamsConfig {
	Vector2: ParamTemplate<ParamType.VECTOR2>;
	z: ParamTemplate<ParamType.FLOAT>;
}
declare class Vec2ToVec3JsNode extends TypedJsNode<Vec2ToVec3ParamsJsConfig> {
	paramsConfig: Vec2ToVec3ParamsJsConfig;
	static type(): string;
	static readonly OUTPUT_NAME_VEC3 = 'vec3';
	initializeNode(): void;
	setLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class Vec3ToVec4ParamsJsConfig extends NodeParamsConfig {
	vec3: ParamTemplate<ParamType.VECTOR3>;
	w: ParamTemplate<ParamType.FLOAT>;
}
declare class Vec3ToVec4JsNode extends TypedJsNode<Vec3ToVec4ParamsJsConfig> {
	paramsConfig: Vec3ToVec4ParamsJsConfig;
	static type(): string;
	static readonly OUTPUT_NAME_VEC4 = 'vec4';
	initializeNode(): void;
	setLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class Vec3ToColorParamsJsConfig extends NodeParamsConfig {
	vec3: ParamTemplate<ParamType.VECTOR3>;
}
declare class Vec3ToColorJsNode extends TypedJsNode<Vec3ToColorParamsJsConfig> {
	paramsConfig: Vec3ToColorParamsJsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class ColorToVec3ParamsJsConfig extends NodeParamsConfig {
	color: ParamTemplate<ParamType.COLOR>;
}
declare class ColorToVec3JsNode extends TypedJsNode<ColorToVec3ParamsJsConfig> {
	paramsConfig: ColorToVec3ParamsJsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(shadersCollectionController: ShadersCollectionController): void;
}
declare enum JsCompareTestName {
	EQUAL = 'Equal',
	LESS_THAN = 'Less Than',
	GREATER_THAN = 'Greater Than',
	LESS_THAN_OR_EQUAL = 'Less Than Or Equal',
	GREATER_THAN_OR_EQUAL = 'Greater Than Or Equal',
	NOT_EQUAL = 'Not Equal',
}
declare enum JsCompareTestOperation {
	EQUAL = '==',
	LESS_THAN = '<',
	GREATER_THAN = '>',
	LESS_THAN_OR_EQUAL = '<=',
	GREATER_THAN_OR_EQUAL = '>=',
	NOT_EQUAL = '!=',
}
declare enum CompareInputName {
	VALUE0 = 'value0',
	VALUE1 = 'value1',
}
declare class CompareJsParamsConfig extends NodeParamsConfig {
	test: ParamTemplate<ParamType.INTEGER>;
}
declare class CompareJsNode extends TypedJsNode<CompareJsParamsConfig> {
	paramsConfig: CompareJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	setTestName(test: JsCompareTestName): void;
	testName(): JsCompareTestName;
	operator(): JsCompareTestOperation;
	protected _expectedInputName(index: number): CompareInputName;
	protected _expectedInputTypes(): JsConnectionPointType[];
	private _expectedOutputTypes;
	private _expectedOutputName;
	setLines(shadersCollectionController: ShadersCollectionController): void;
}
declare const ComplementJsNode_base: typeof BaseMathFunctionJsNode;
declare class ComplementJsNode extends ComplementJsNode_base {
	protected _coreFunction(shadersCollectionController: ShadersCollectionController): string;
}
declare class ConstantJsParamsConfig extends NodeParamsConfig {
	type: ParamTemplate<ParamType.INTEGER>;
	boolean: ParamTemplate<ParamType.BOOLEAN>;
	color: ParamTemplate<ParamType.COLOR>;
	float: ParamTemplate<ParamType.FLOAT>;
	int: ParamTemplate<ParamType.INTEGER>;
	string: ParamTemplate<ParamType.STRING>;
	vector2: ParamTemplate<ParamType.VECTOR2>;
	vector3: ParamTemplate<ParamType.VECTOR3>;
	vector4: ParamTemplate<ParamType.VECTOR4>;
}
declare class ConstantJsNode extends TypedJsNode<ConstantJsParamsConfig> {
	paramsConfig: ConstantJsParamsConfig;
	static type(): string;
	static readonly OUTPUT_NAME = 'val';
	initializeNode(): void;
	setLines(shadersCollectionController: ShadersCollectionController): void;
	private _currentConnectionType;
	currentParam():
		| StringParam
		| BooleanParam
		| ColorParam
		| FloatParam
		| IntegerParam
		| Vector2Param
		| Vector3Param
		| Vector4Param;
	private _currentVarName;
	currentValue(): string | undefined;
	setJsType(type: JsConnectionPointType): void;
}
declare class CookNodeJsParamsConfig extends NodeParamsConfig {
	/** @param  node to cook */
	node: ParamTemplate<ParamType.NODE_PATH>;
}
declare class CookNodeJsNode extends TypedJsNode<CookNodeJsParamsConfig> {
	readonly paramsConfig: CookNodeJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	setTriggerableLines(shadersCollectionController: ShadersCollectionController): void;
}
declare const CosJsNode_base: typeof BaseMathFunctionJsNode;
declare class CosJsNode extends CosJsNode_base {}
declare enum CrossJsNodeInputName {
	VALUE0 = 'v0',
	VALUE1 = 'v1',
}
declare class CrossJsNode extends ParamlessTypedJsNode {
	static type(): string;
	initializeNode(): void;
	setLines(shadersCollectionController: ShadersCollectionController): void;
	protected _expectedInputTypes(): JsConnectionPointType[];
	protected _expectedOutputTypes(): JsConnectionPointType[];
	protected _expectedInputName(index: number): CrossJsNodeInputName;
	protected _expectedOutputName(index: number): string;
	paramDefaultValue(name: string): number;
}
declare abstract class BaseUserInputJsNode<K extends NodeParamsConfig> extends TypedJsNode<K> {
	isTriggering(): boolean;
	eventEmitter(): CoreEventEmitter;
}
declare class CursorJsParamsConfig extends NodeParamsConfig {
	/** @param set which element triggers the event */
	element: ParamTemplate<ParamType.INTEGER>;
}
declare class CursorJsNode extends BaseUserInputJsNode<CursorJsParamsConfig> {
	paramsConfig: CursorJsParamsConfig;
	static type(): JsType.CURSOR;
	eventData(): EvaluatorEventData | undefined;
	eventEmitter(): CoreEventEmitter;
	setEventEmitter(emitter: CoreEventEmitter): void;
	initializeNode(): void;
	setLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class DebugJsParamsConfig extends NodeParamsConfig {}
declare class DebugJsNode extends TypedJsNode<DebugJsParamsConfig> {
	readonly paramsConfig: DebugJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	protected _expectedInputTypes(): [JsConnectionPointType];
	protected _expectedInputName(index: number): string;
	protected _expectedOutputName(index: number): string;
	protected _expectedOutputTypes(): [JsConnectionPointType];
	setLines(shadersCollectionController: ShadersCollectionController): void;
}
declare enum DistanceJsNodeInputName {
	VALUE0 = 'v0',
	VALUE1 = 'v1',
}
declare class DistanceJsNode extends ParamlessTypedJsNode {
	static type(): string;
	initializeNode(): void;
	setLines(shadersCollectionController: ShadersCollectionController): void;
	protected _expectedInputTypes(): JsConnectionPointType[];
	protected _expectedOutputTypes(): JsConnectionPointType[];
	protected _expectedInputName(index: number): DistanceJsNodeInputName;
	protected _expectedOutputName(index: number): string;
	paramDefaultValue(name: string): Number3;
}
declare const DivideJsNode_base: typeof BaseMathFunctionJsNode;
declare class DivideJsNode extends DivideJsNode_base {
	paramDefaultValue(name: string): number;
}
declare enum DotJsNodeInputName {
	VALUE0 = 'v0',
	VALUE1 = 'v1',
}
declare class DotJsNode extends ParamlessTypedJsNode {
	static type(): string;
	initializeNode(): void;
	setLines(shadersCollectionController: ShadersCollectionController): void;
	protected _expectedInputTypes(): JsConnectionPointType[];
	protected _expectedOutputTypes(): JsConnectionPointType[];
	protected _expectedInputName(index: number): DotJsNodeInputName;
	protected _expectedOutputName(index: number): string;
	paramDefaultValue(name: string): number;
}
declare class EasingJsParamsConfig extends NodeParamsConfig {
	type: ParamTemplate<ParamType.INTEGER>;
}
declare class EasingJsNode extends TypedJsNode<EasingJsParamsConfig> {
	readonly paramsConfig: EasingJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	private _expectedInputTypes;
	private _expectedOutputTypes;
	private _expectedInputName;
	private _expectedOutputName;
	setLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class ElementsToArrayJsParamsConfig extends NodeParamsConfig {}
declare class ElementsToArrayJsNode extends TypedJsNode<ElementsToArrayJsParamsConfig> {
	readonly paramsConfig: ElementsToArrayJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	protected _expectedInputTypes(): ArrayableConnectionPointType[];
	protected _expectedInputName(index: number): string;
	protected _expectedOutputName(index: number): string;
	protected _expectedOutputTypes(): (
		| JsConnectionPointType.BOOLEAN_ARRAY
		| JsConnectionPointType.COLOR_ARRAY
		| JsConnectionPointType.FLOAT_ARRAY
		| JsConnectionPointType.INT_ARRAY
		| JsConnectionPointType.INTERSECTION_ARRAY
		| JsConnectionPointType.MATRIX4_ARRAY
		| JsConnectionPointType.QUATERNION_ARRAY
		| JsConnectionPointType.STRING_ARRAY
		| JsConnectionPointType.TEXTURE_ARRAY
		| JsConnectionPointType.VECTOR2_ARRAY
		| JsConnectionPointType.VECTOR3_ARRAY
		| JsConnectionPointType.VECTOR4_ARRAY
	)[];
	setLines(shadersCollectionController: ShadersCollectionController): void;
	private _setLinesAsPrimitive;
	private _setLinesAsVector;
	private _setLinesAsIntersection;
	private _setLinesAsTexture;
}
declare const FitJsNode_base: typeof BaseMathFunctionJsNode;
declare class FitJsNode extends FitJsNode_base {
	protected _coreFunction(shadersCollectionController: ShadersCollectionController): string;
	protected _inputValuesCount(): number;
	paramDefaultValue(name: string): number;
	protected _expectedInputName(index: number): string;
	protected _expectedInputTypes(): JsConnectionPointType[];
}
declare class FloatToColorJsParamsConfig extends NodeParamsConfig {
	r: ParamTemplate<ParamType.FLOAT>;
	g: ParamTemplate<ParamType.FLOAT>;
	b: ParamTemplate<ParamType.FLOAT>;
}
declare class FloatToColorJsNode extends TypedJsNode<FloatToColorJsParamsConfig> {
	paramsConfig: FloatToColorJsParamsConfig;
	static type(): string;
	static readonly OUTPUT_NAME = 'Color';
	initializeNode(): void;
	setLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class FloatToVec2JsParamsConfig extends NodeParamsConfig {
	x: ParamTemplate<ParamType.FLOAT>;
	y: ParamTemplate<ParamType.FLOAT>;
}
declare class FloatToVec2JsNode extends TypedJsNode<FloatToVec2JsParamsConfig> {
	paramsConfig: FloatToVec2JsParamsConfig;
	static type(): string;
	static readonly OUTPUT_NAME = 'vec2';
	initializeNode(): void;
	setLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class FloatToVec3JsParamsConfig extends NodeParamsConfig {
	x: ParamTemplate<ParamType.FLOAT>;
	y: ParamTemplate<ParamType.FLOAT>;
	z: ParamTemplate<ParamType.FLOAT>;
}
declare class FloatToVec3JsNode extends TypedJsNode<FloatToVec3JsParamsConfig> {
	paramsConfig: FloatToVec3JsParamsConfig;
	static type(): string;
	static readonly OUTPUT_NAME = 'vec3';
	initializeNode(): void;
	setLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class FloatToVec4JsParamsConfig extends NodeParamsConfig {
	x: ParamTemplate<ParamType.FLOAT>;
	y: ParamTemplate<ParamType.FLOAT>;
	z: ParamTemplate<ParamType.FLOAT>;
	w: ParamTemplate<ParamType.FLOAT>;
}
declare class FloatToVec4JsNode extends TypedJsNode<FloatToVec4JsParamsConfig> {
	paramsConfig: FloatToVec4JsParamsConfig;
	static type(): string;
	static readonly OUTPUT_NAME = 'vec4';
	initializeNode(): void;
	setLines(shadersCollectionController: ShadersCollectionController): void;
}
declare const FloorJsNode_base: typeof BaseMathFunctionJsNode;
declare class FloorJsNode extends FloorJsNode_base {}
declare class GetBox3PropertyJsNode extends ParamlessTypedJsNode {
	static type(): string;
	initializeNode(): void;
	setLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class GetChildrenAttributesJsParamsConfig extends NodeParamsConfig {
	type: ParamTemplate<ParamType.INTEGER>;
}
declare class GetChildrenAttributesJsNode extends TypedJsNode<GetChildrenAttributesJsParamsConfig> {
	readonly paramsConfig: GetChildrenAttributesJsParamsConfig;
	static type(): string;
	static readonly OUTPUT_NAME = 'val';
	initializeNode(): void;
	private _currentConnectionType;
	setAttribType(type: ParamConvertibleJsType): void;
	attribType(): JsConnectionPointType;
	setAttribName(attribName: string): void;
	attributeName(): string;
	setLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class GetChildrenPhysicsRBDPropertiesJsNode extends ParamlessTypedJsNode {
	static type(): string;
	initializeNode(): void;
	setLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class GetChildrenPropertiesJsNode extends ParamlessTypedJsNode {
	static type(): string;
	initializeNode(): void;
	setLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class GetDefaultCameraJsParamsConfig extends NodeParamsConfig {}
declare class GetDefaultCameraJsNode extends TypedJsNode<GetDefaultCameraJsParamsConfig> {
	readonly paramsConfig: GetDefaultCameraJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class GetIntersectionPropertyJsNode extends ParamlessTypedJsNode {
	static type(): string;
	initializeNode(): void;
	setLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class GetMaterialJsParamsConfig extends NodeParamsConfig {
	/** @param the material node */
	node: ParamTemplate<ParamType.NODE_PATH>;
}
declare class GetMaterialJsNode extends TypedJsNode<GetMaterialJsParamsConfig> {
	readonly paramsConfig: GetMaterialJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class GetObjectJsParamsConfig extends NodeParamsConfig {
	/** @param use current object */
	getCurrentObject: ParamTemplate<ParamType.BOOLEAN>;
	/** @param object mask */
	mask: ParamTemplate<ParamType.STRING>;
}
declare class GetObjectJsNode extends TypedJsNode<GetObjectJsParamsConfig> {
	readonly paramsConfig: GetObjectJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class GetObjectAttributeJsParamsConfig extends NodeParamsConfig {
	type: ParamTemplate<ParamType.INTEGER>;
}
declare class GetObjectAttributeJsNode extends TypedJsNode<GetObjectAttributeJsParamsConfig> {
	readonly paramsConfig: GetObjectAttributeJsParamsConfig;
	static type(): string;
	static readonly OUTPUT_NAME = 'val';
	initializeNode(): void;
	private _currentConnectionType;
	setAttribType(type: ParamConvertibleJsType): void;
	setAttribName(attribName: string): void;
	attributeName(): string;
	setLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class GetObjectChildJsParamsConfig extends NodeParamsConfig {
	/** @param child index */
	index: ParamTemplate<ParamType.INTEGER>;
}
declare class GetObjectChildJsNode extends TypedJsNode<GetObjectChildJsParamsConfig> {
	readonly paramsConfig: GetObjectChildJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class GetObjectPropertyJsNode extends ParamlessTypedJsNode {
	static type(): string;
	initializeNode(): void;
	setLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class GetObjectUserDataJsParamsConfig extends NodeParamsConfig {
	type: ParamTemplate<ParamType.INTEGER>;
	name: ParamTemplate<ParamType.STRING>;
}
declare class GetObjectUserDataJsNode extends TypedJsNode<GetObjectUserDataJsParamsConfig> {
	readonly paramsConfig: GetObjectUserDataJsParamsConfig;
	static type(): string;
	static readonly OUTPUT_NAME = 'val';
	initializeNode(): void;
	private _currentConnectionType;
	setUserDataType(type: JsConnectionPointType): void;
	setLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class GetObjectWorldPositionJsNode extends ParamlessTypedJsNode {
	static type(): string;
	initializeNode(): void;
	setLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class GetParentJsParamsConfig extends NodeParamsConfig {}
declare class GetParentJsNode extends TypedJsNode<GetParentJsParamsConfig> {
	readonly paramsConfig: GetParentJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class GetPhysicsRBDConePropertyJsNode extends ParamlessTypedJsNode {
	static type(): string;
	initializeNode(): void;
	setLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class GetPhysicsRBDCapsulePropertyJsNode extends ParamlessTypedJsNode {
	static type(): string;
	initializeNode(): void;
	setLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class GetPhysicsRBDCylinderPropertyJsNode extends ParamlessTypedJsNode {
	static type(): string;
	initializeNode(): void;
	setLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class GetPhysicsRBDCuboidPropertyJsNode extends ParamlessTypedJsNode {
	static type(): string;
	initializeNode(): void;
	setLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class GetPhysicsRBDSpherePropertyJsNode extends ParamlessTypedJsNode {
	static type(): string;
	initializeNode(): void;
	setLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class GetPhysicsRBDPropertyJsNode extends ParamlessTypedJsNode {
	static type(): string;
	initializeNode(): void;
	setLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class GetPlanePropertyJsNode extends ParamlessTypedJsNode {
	static type(): string;
	initializeNode(): void;
	setLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class GetRayPropertyJsNode extends ParamlessTypedJsNode {
	static type(): string;
	initializeNode(): void;
	setLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class GetSibblingJsParamsConfig extends NodeParamsConfig {
	offset: ParamTemplate<ParamType.INTEGER>;
}
declare class GetSibblingJsNode extends TypedJsNode<GetSibblingJsParamsConfig> {
	readonly paramsConfig: GetSibblingJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class GetSpherePropertyJsNode extends ParamlessTypedJsNode {
	static type(): string;
	initializeNode(): void;
	setLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class GetTextureJsParamsConfig extends NodeParamsConfig {
	/** @param the material node */
	node: ParamTemplate<ParamType.NODE_PATH>;
}
declare class GetTextureJsNode extends TypedJsNode<GetTextureJsParamsConfig> {
	readonly paramsConfig: GetTextureJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class GetTrackedHandPropertyJsNode extends ParamlessTypedJsNode {
	static type(): string;
	initializeNode(): void;
	setLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class GetVideoPropertyJsParamsConfig extends NodeParamsConfig {
	node: ParamTemplate<ParamType.NODE_PATH>;
}
declare class GetVideoPropertyJsNode extends TypedJsNode<GetVideoPropertyJsParamsConfig> {
	paramsConfig: GetVideoPropertyJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class GetWebXRARSessionPropertyJsParamsConfig extends NodeParamsConfig {}
declare class GetWebXRARSessionPropertyJsNode extends TypedJsNode<GetWebXRARSessionPropertyJsParamsConfig> {
	paramsConfig: GetWebXRARSessionPropertyJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class GetWebXRControllerPropertyJsParamsConfig extends NodeParamsConfig {
	/** @param  controller index */
	controllerIndex: ParamTemplate<ParamType.INTEGER>;
}
declare class GetWebXRControllerPropertyJsNode extends TypedJsNode<GetWebXRControllerPropertyJsParamsConfig> {
	paramsConfig: GetWebXRControllerPropertyJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class GetWebXRTrackedMarkerJsParamsConfig extends NodeParamsConfig {}
declare class GetWebXRTrackedMarkerPropertyJsNode extends TypedJsNode<GetWebXRTrackedMarkerJsParamsConfig> {
	paramsConfig: GetWebXRTrackedMarkerJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(shadersCollectionController: ShadersCollectionController): void;
}
declare enum LengthJsNodeInputName {
	VALUE = 'v',
}
declare class LengthJsNode extends ParamlessTypedJsNode {
	static type(): string;
	initializeNode(): void;
	setLines(shadersCollectionController: ShadersCollectionController): void;
	protected _expectedInputTypes(): JsConnectionPointType[];
	protected _expectedOutputTypes(): JsConnectionPointType[];
	protected _expectedInputName(index: number): LengthJsNodeInputName;
	protected _expectedOutputName(index: number): string;
	paramDefaultValue(name: string): number;
}
declare abstract class BaseNamedFunction {
	readonly shadersCollectionController?: ShadersCollectionController | undefined;
	static type(): string;
	type(): string;
	readonly scene: PolyScene;
	readonly jsNode?: BaseJsNodeType;
	readonly functionNode: AssemblerControllerNode<BaseJsShaderAssembler>;
	protected timeController: TimeController;
	constructor(node: BaseNodeType, shadersCollectionController?: ShadersCollectionController | undefined);
	abstract func(...args: any): any;
	asString(...args: any): string;
}
declare abstract class NamedFunction<
	ARGS extends Array<any>,
	ARGS_STR extends Array<string>
> extends BaseNamedFunction {
	abstract func(...args: ARGS): any;
	asString(...args: ARGS_STR): string;
}
declare abstract class NamedFunction0 extends NamedFunction<[], []> {}
declare abstract class NamedFunction1<ARGS extends [any]> extends NamedFunction<ARGS, [string]> {}
declare abstract class NamedFunction2<ARGS extends [any, any]> extends NamedFunction<ARGS, [string, string]> {}
declare abstract class NamedFunction3<ARGS extends [any, any, any]> extends NamedFunction<
	ARGS,
	[string, string, string]
> {}
declare abstract class NamedFunction4<ARGS extends [any, any, any, any]> extends NamedFunction<
	ARGS,
	[string, string, string, string]
> {}
declare abstract class NamedFunction5<ARGS extends [any, any, any, any, any]> extends NamedFunction<
	ARGS,
	[string, string, string, string, string]
> {}
declare abstract class ObjectNamedFunction<
	ARGS extends Array<any>,
	ARGS_STR extends Array<string>
> extends BaseNamedFunction {
	abstract func(object: Object3D, ...args: ARGS): any;
	asString(...args: ARGS_STR): string;
}
declare abstract class ObjectNamedFunction0 extends ObjectNamedFunction<[], [string]> {}
declare abstract class ObjectNamedFunction1<ARGS extends [any]> extends ObjectNamedFunction<ARGS, [string, string]> {}
declare abstract class ObjectNamedFunction2<ARGS extends [any, any]> extends ObjectNamedFunction<
	ARGS,
	[string, string, string]
> {}
declare abstract class ObjectNamedFunction3<ARGS extends [any, any, any]> extends ObjectNamedFunction<
	ARGS,
	[string, string, string, string]
> {}
declare abstract class ObjectNamedFunction4<ARGS extends [any, any, any, any]> extends ObjectNamedFunction<
	ARGS,
	[string, string, string, string, string]
> {}
declare abstract class ObjectNamedFunction5<ARGS extends [any, any, any, any, any]> extends ObjectNamedFunction<
	ARGS,
	[string, string, string, string, string, string]
> {}
declare abstract class ObjectNamedFunction6<ARGS extends [any, any, any, any, any, any]> extends ObjectNamedFunction<
	ARGS,
	[string, string, string, string, string, string, string]
> {}
declare abstract class MathNamedFunction2<ARGS extends [any, any]> extends NamedFunction<ARGS, string[]> {}
declare abstract class MathNamedFunction3<ARGS extends [any, any, any]> extends NamedFunction<ARGS, string[]> {}
declare abstract class MathNamedFunction4<ARGS extends [any, any, any, any]> extends NamedFunction<ARGS, string[]> {}
declare abstract class MathNamedFunction5<ARGS extends [any, any, any, any, any]> extends NamedFunction<
	ARGS,
	string[]
> {}
declare abstract class MathNamedFunction6<ARGS extends [any, any, any, any, any, any]> extends NamedFunction<
	ARGS,
	string[]
> {}
declare abstract class MathNamedFunction7<ARGS extends [any, any, any, any, any, any, any]> extends NamedFunction<
	ARGS,
	string[]
> {}
declare abstract class MathNamedFunction8<ARGS extends [any, any, any, any, any, any, any, any]> extends NamedFunction<
	ARGS,
	string[]
> {}
export declare type MathFunction1 = (x: number) => number;
export declare type MathFunction2 = (x: number, arg1: number) => number;
export declare type MathFunction3 = (x: number, arg1: number, arg2: number) => number;
export declare type MathFunction4 = (x: number, arg1: number, arg2: number, arg3: number) => number;
export declare type MathFunction5 = (x: number, arg1: number, arg2: number, arg3: number, arg4: number) => number;
export declare type MathVectorFunction1 = 'mathColor_1' | 'mathVector2_1' | 'mathVector3_1' | 'mathVector4_1';
export declare type MathVectorFunction2 = 'mathColor_2' | 'mathVector2_2' | 'mathVector3_2' | 'mathVector4_2';
export declare type MathVectorFunction3 = 'mathColor_3' | 'mathVector2_3' | 'mathVector3_3' | 'mathVector4_3';
export declare type MathVectorFunction3vvf =
	| 'mathColor_3vvf'
	| 'mathVector2_3vvf'
	| 'mathVector3_3vvf'
	| 'mathVector4_3vvf';
export declare type MathVectorFunction4 = 'mathColor_4' | 'mathVector2_4' | 'mathVector3_4' | 'mathVector4_4';
export declare type MathVectorFunction5 = 'mathColor_5' | 'mathVector2_5' | 'mathVector3_5' | 'mathVector4_5';
export declare type MathVectorFunction =
	| MathVectorFunction1
	| MathVectorFunction2
	| MathVectorFunction3
	| MathVectorFunction3vvf
	| MathVectorFunction4
	| MathVectorFunction5;
export declare type MathFloat = 'mathFloat_1' | 'mathFloat_2' | 'mathFloat_3' | 'mathFloat_4' | 'mathFloat_5';
export declare type MathPrimArray =
	| 'mathPrimArray_1'
	| 'mathPrimArray_2'
	| 'mathPrimArray_3'
	| 'mathPrimArray_4'
	| 'mathPrimArray_5';
export declare type MathVectorArray =
	| 'mathVectorArray_1'
	| 'mathVectorArray_2'
	| 'mathVectorArray_3'
	| 'mathVectorArray_4'
	| 'mathVectorArray_5';
export declare type VectorFunctionName<T extends MathVectorFunction> = (
	inputType: JsConnectionPointType
) => T | undefined;
export declare type MathArrayVectorElement = Color | Vector2 | Vector3 | Vector4;
export declare type MathArrayVectorElementFunction1<T extends MathArrayVectorElement> = (
	func: MathFunction1,
	src: T,
	target: T
) => T;
export declare type MathArrayVectorElementFunction2<T extends MathArrayVectorElement> = (
	func: MathFunction2,
	src: T,
	arg1: T,
	target: T
) => T;
export declare type MathArrayVectorElementFunction3<T extends MathArrayVectorElement> = (
	func: MathFunction3,
	src: T,
	arg1: T,
	arg2: T,
	target: T
) => T;
export declare type MathArrayVectorElementFunction3VVF<T extends MathArrayVectorElement> = (
	func: MathFunction3,
	src: T,
	arg1: T,
	arg2: number,
	target: T
) => T;
export declare type MathArrayVectorElementFunction4<T extends MathArrayVectorElement> = (
	func: MathFunction4,
	src: T,
	arg1: T,
	arg2: T,
	arg3: T,
	target: T
) => T;
export declare type MathArrayVectorElementFunction5<T extends MathArrayVectorElement> = (
	func: MathFunction5,
	src: T,
	arg1: T,
	arg2: T,
	arg3: T,
	arg4: T,
	target: T
) => T;
declare class mathFloat_1 extends MathNamedFunction2<[MathFunction1, number]> {
	static type(): string;
	func(_func: MathFunction1, value: number): number;
}
declare class mathFloat_2 extends MathNamedFunction3<[MathFunction2, number, number]> {
	static type(): string;
	func(_func: MathFunction2, value: number, arg1: number): number;
}
declare class mathFloat_3 extends MathNamedFunction4<[MathFunction3, number, number, number]> {
	static type(): string;
	func(_func: MathFunction3, value: number, arg1: number, arg2: number): number;
}
declare class mathFloat_4 extends MathNamedFunction5<[MathFunction4, number, number, number, number]> {
	static type(): string;
	func(_func: MathFunction4, value: number, arg1: number, arg2: number, arg3: number): number;
}
declare class mathFloat_5 extends MathNamedFunction6<[MathFunction5, number, number, number, number, number]> {
	static type(): string;
	func(_func: MathFunction5, value: number, arg1: number, arg2: number, arg3: number, arg4: number): number;
}
declare class mathColor_1 extends MathNamedFunction3<[MathFunction1, Color, Color]> {
	static type(): string;
	func: MathArrayVectorElementFunction1<Color>;
}
declare class mathColor_2 extends MathNamedFunction4<[MathFunction2, Color, Color, Color]> {
	static type(): string;
	func: MathArrayVectorElementFunction2<Color>;
}
declare class mathColor_3 extends MathNamedFunction5<[MathFunction2, Color, Color, Color, Color]> {
	static type(): string;
	func: MathArrayVectorElementFunction3<Color>;
}
declare class mathColor_3vvf extends MathNamedFunction5<[MathFunction2, Color, Color, number, Color]> {
	static type(): string;
	func: MathArrayVectorElementFunction3VVF<Color>;
}
declare class mathColor_4 extends MathNamedFunction6<[MathFunction2, Color, Color, Color, Color, Color]> {
	static type(): string;
	func: MathArrayVectorElementFunction4<Color>;
}
declare class mathColor_5 extends MathNamedFunction7<[MathFunction2, Color, Color, Color, Color, Color, Color]> {
	static type(): string;
	func: MathArrayVectorElementFunction5<Color>;
}
declare class mathVector2_1 extends MathNamedFunction3<[MathFunction1, Vector2, Vector2]> {
	static type(): string;
	func: MathArrayVectorElementFunction1<Vector2>;
}
declare class mathVector2_2 extends MathNamedFunction4<[MathFunction1, Vector2, Vector2, Vector2]> {
	static type(): string;
	func: MathArrayVectorElementFunction2<Vector2>;
}
declare class mathVector2_3 extends MathNamedFunction5<[MathFunction1, Vector2, Vector2, Vector2, Vector2]> {
	static type(): string;
	func: MathArrayVectorElementFunction3<Vector2>;
}
declare class mathVector2_3vvf extends MathNamedFunction5<[MathFunction1, Vector2, Vector2, number, Vector2]> {
	static type(): string;
	func: MathArrayVectorElementFunction3VVF<Vector2>;
}
declare class mathVector2_4 extends MathNamedFunction6<[MathFunction1, Vector2, Vector2, Vector2, Vector2, Vector2]> {
	static type(): string;
	func: MathArrayVectorElementFunction4<Vector2>;
}
declare class mathVector2_5 extends MathNamedFunction7<
	[MathFunction1, Vector2, Vector2, Vector2, Vector2, Vector2, Vector2]
> {
	static type(): string;
	func: MathArrayVectorElementFunction5<Vector2>;
}
declare class mathVector3_1 extends MathNamedFunction3<[MathFunction1, Vector3, Vector3]> {
	static type(): string;
	func: MathArrayVectorElementFunction1<Vector3>;
}
declare class mathVector3_2 extends MathNamedFunction4<[MathFunction1, Vector3, Vector3, Vector3]> {
	static type(): string;
	func: MathArrayVectorElementFunction2<Vector3>;
}
declare class mathVector3_3 extends MathNamedFunction5<[MathFunction1, Vector3, Vector3, Vector3, Vector3]> {
	static type(): string;
	func: MathArrayVectorElementFunction3<Vector3>;
}
declare class mathVector3_3vvf extends MathNamedFunction5<[MathFunction1, Vector3, Vector3, number, Vector3]> {
	static type(): string;
	func: MathArrayVectorElementFunction3VVF<Vector3>;
}
declare class mathVector3_4 extends MathNamedFunction6<[MathFunction1, Vector3, Vector3, Vector3, Vector3, Vector3]> {
	static type(): string;
	func: MathArrayVectorElementFunction4<Vector3>;
}
declare class mathVector3_5 extends MathNamedFunction7<
	[MathFunction1, Vector3, Vector3, Vector3, Vector3, Vector3, Vector3]
> {
	static type(): string;
	func: MathArrayVectorElementFunction5<Vector3>;
}
declare class mathVector4_1 extends MathNamedFunction3<[MathFunction1, Vector4, Vector4]> {
	static type(): string;
	func: MathArrayVectorElementFunction1<Vector4>;
}
declare class mathVector4_2 extends MathNamedFunction4<[MathFunction1, Vector4, Vector4, Vector4]> {
	static type(): string;
	func: MathArrayVectorElementFunction2<Vector4>;
}
declare class mathVector4_3 extends MathNamedFunction5<[MathFunction1, Vector4, Vector4, Vector4, Vector4]> {
	static type(): string;
	func: MathArrayVectorElementFunction3<Vector4>;
}
declare class mathVector4_3vvf extends MathNamedFunction5<[MathFunction1, Vector4, Vector4, number, Vector4]> {
	static type(): string;
	func: MathArrayVectorElementFunction3VVF<Vector4>;
}
declare class mathVector4_4 extends MathNamedFunction6<[MathFunction1, Vector4, Vector4, Vector4, Vector4, Vector4]> {
	static type(): string;
	func: MathArrayVectorElementFunction4<Vector4>;
}
declare class mathVector4_5 extends MathNamedFunction7<
	[MathFunction1, Vector4, Vector4, Vector4, Vector4, Vector4, Vector4]
> {
	static type(): string;
	func: MathArrayVectorElementFunction5<Vector4>;
}
declare class mathPrimArray_1 extends MathNamedFunction3<[MathFunction1, number[], number[]]> {
	static type(): string;
	func(_func: MathFunction1, srcElements: number[], targetElements: number[]): number[];
}
declare class mathPrimArray_2 extends MathNamedFunction4<[MathFunction2, number[], number, number[]]> {
	static type(): string;
	func(_func: MathFunction2, srcElements: number[], arg1: number, targetElements: number[]): number[];
}
declare class mathPrimArray_3 extends MathNamedFunction5<[MathFunction3, number[], number, number, number[]]> {
	static type(): string;
	func(_func: MathFunction3, srcElements: number[], arg1: number, arg2: number, targetElements: number[]): number[];
}
declare class mathPrimArray_4 extends MathNamedFunction6<[MathFunction4, number[], number, number, number, number[]]> {
	static type(): string;
	func(
		_func: MathFunction4,
		srcElements: number[],
		arg1: number,
		arg2: number,
		arg3: number,
		targetElements: number[]
	): number[];
}
declare class mathPrimArray_5 extends MathNamedFunction7<
	[MathFunction5, number[], number, number, number, number, number[]]
> {
	static type(): string;
	func(
		_func: MathFunction5,
		srcElements: number[],
		arg1: number,
		arg2: number,
		arg3: number,
		arg4: number,
		targetElements: number[]
	): number[];
}
declare class mathVectorArray_1<T extends MathArrayVectorElement> extends MathNamedFunction4<
	[MathFunction1, MathArrayVectorElementFunction1<T>, T[], T[]]
> {
	static type(): string;
	func(
		_func: MathFunction1,
		vectorFunc: MathArrayVectorElementFunction1<T>,
		srcElements: T[],
		targetElements: T[]
	): T[];
}
declare class mathVectorArray_2<T extends MathArrayVectorElement> extends MathNamedFunction5<
	[MathFunction2, MathArrayVectorElementFunction2<T>, T[], T, T[]]
> {
	static type(): string;
	func(
		_func: MathFunction2,
		vectorFunc: MathArrayVectorElementFunction2<T>,
		srcElements: T[],
		arg1: T,
		targetElements: T[]
	): T[];
}
declare class mathVectorArray_3<T extends MathArrayVectorElement> extends MathNamedFunction6<
	[MathFunction3, MathArrayVectorElementFunction3<T>, T[], T, T, T[]]
> {
	static type(): string;
	func(
		_func: MathFunction3,
		vectorFunc: MathArrayVectorElementFunction3<T>,
		srcElements: T[],
		arg1: T,
		arg2: T,
		targetElements: T[]
	): T[];
}
declare class mathVectorArray_4<T extends MathArrayVectorElement> extends MathNamedFunction7<
	[MathFunction4, MathArrayVectorElementFunction4<T>, T[], T, T, T, T[]]
> {
	static type(): string;
	func(
		_func: MathFunction4,
		vectorFunc: MathArrayVectorElementFunction4<T>,
		srcElements: T[],
		arg1: T,
		arg2: T,
		arg3: T,
		targetElements: T[]
	): T[];
}
declare class mathVectorArray_5<T extends MathArrayVectorElement> extends MathNamedFunction8<
	[MathFunction5, MathArrayVectorElementFunction5<T>, T[], T, T, T, T, T[]]
> {
	static type(): string;
	func(
		_func: MathFunction5,
		vectorFunc: MathArrayVectorElementFunction5<T>,
		srcElements: T[],
		arg1: T,
		arg2: T,
		arg3: T,
		arg4: T,
		targetElements: T[]
	): T[];
}
export interface MathFunctionData<MVF extends MathVectorFunction> {
	vectorFunctionNameFunction: VectorFunctionName<MVF>;
	mathFloat: MathFloat;
	mathPrimArray: MathPrimArray;
	mathVectorArray: MathVectorArray;
}
declare const LerpJsNode_base: typeof BaseMathFunctionJsNode;
declare class LerpJsNode extends LerpJsNode_base {
	protected _coreFunction(shadersCollectionController: ShadersCollectionController): string;
	protected _functionData(): MathFunctionData<MathVectorFunction3vvf>;
	paramDefaultValue(name: string): number;
	protected _expectedInputName(index: number): string;
	protected _expectedInputTypes(): JsConnectionPointType[];
}
declare enum ManhattanDistanceJsNodeInputName {
	VALUE0 = 'v0',
	VALUE1 = 'v1',
}
declare class ManhattanDistanceJsNode extends ParamlessTypedJsNode {
	static type(): string;
	initializeNode(): void;
	setLines(shadersCollectionController: ShadersCollectionController): void;
	protected _expectedInputTypes(): JsConnectionPointType[];
	protected _expectedOutputTypes(): JsConnectionPointType[];
	protected _expectedInputName(index: number): ManhattanDistanceJsNodeInputName;
	protected _expectedOutputName(index: number): string;
	paramDefaultValue(name: string): number;
}
declare const MaxJsNode_base: typeof BaseMathFunctionJsNode;
declare class MaxJsNode extends MaxJsNode_base {
	paramDefaultValue(name: string): number;
	protected _expectedInputName(index: number): string;
	protected _expectedInputTypes(): JsConnectionPointType[];
}
declare enum MaxLengthJsNodeInputName {
	VALUE = 'value',
	MAX = 'max',
}
declare class MaxLengthJsNode extends ParamlessTypedJsNode {
	static type(): string;
	initializeNode(): void;
	setLines(shadersCollectionController: ShadersCollectionController): void;
	protected _expectedInputTypes(): JsConnectionPointType[];
	protected _expectedOutputTypes(): JsConnectionPointType[];
	protected _expectedInputName(index: number): MaxLengthJsNodeInputName;
	protected _expectedOutputName(index: number): string;
	paramDefaultValue(name: string): number;
}
declare const MinJsNode_base: typeof BaseMathFunctionJsNode;
declare class MinJsNode extends MinJsNode_base {
	paramDefaultValue(name: string): number;
	protected _expectedInputName(index: number): string;
	protected _expectedInputTypes(): JsConnectionPointType[];
}
declare const MixJsNode_base: typeof BaseMathFunctionJsNode;
declare class MixJsNode extends MixJsNode_base {
	protected _coreFunction(shadersCollectionController: ShadersCollectionController): string;
	protected _functionData(): MathFunctionData<MathVectorFunction3vvf>;
	paramDefaultValue(name: string): number;
	protected _expectedInputName(index: number): string;
	protected _expectedInputTypes(): JsConnectionPointType[];
}
declare const MultJsNode_base: typeof BaseMathFunctionJsNode;
declare class MultJsNode extends MultJsNode_base {
	paramDefaultValue(name: string): number;
}
declare const MultAddJsNode_base: typeof BaseMathFunctionJsNode;
declare class MultAddJsNode extends MultAddJsNode_base {
	protected _coreFunction(shadersCollectionController: ShadersCollectionController): string;
	paramDefaultValue(name: string): number;
	protected _expectedInputName(index: number): string;
	protected _expectedInputTypes(): JsConnectionPointType[];
}
declare enum MultScalarJsNodeInputName {
	VALUE = 'value',
	MULT = 'mult',
}
declare class MultScalarJsNode extends ParamlessTypedJsNode {
	static type(): string;
	initializeNode(): void;
	setLines(shadersCollectionController: ShadersCollectionController): void;
	protected _expectedInputTypes(): JsConnectionPointType[];
	protected _expectedOutputTypes(): JsConnectionPointType[];
	protected _expectedInputName(index: number): MultScalarJsNodeInputName;
	protected _expectedOutputName(index: number): string;
	paramDefaultValue(name: string): number;
}
declare class NearestPositionJsParamsConfig extends NodeParamsConfig {
	/** @param vector3 */
	Vector3: ParamTemplate<ParamType.VECTOR3>;
}
declare class NearestPositionJsNode extends TypedJsNode<NearestPositionJsParamsConfig> {
	paramsConfig: NearestPositionJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(shadersCollectionController: ShadersCollectionController): void;
}
declare const NegateJsNode_base: typeof BaseMathFunctionJsNode;
declare class NegateJsNode extends NegateJsNode_base {
	protected _coreFunction(shadersCollectionController: ShadersCollectionController): string;
}
declare enum NormalizeJsNodeInputName {
	VALUE = 'v',
}
declare class NormalizeJsNode extends ParamlessTypedJsNode {
	static type(): string;
	initializeNode(): void;
	setLines(shadersCollectionController: ShadersCollectionController): void;
	protected _expectedInputTypes(): JsConnectionPointType[];
	protected _expectedOutputTypes(): JsConnectionPointType[];
	protected _expectedInputName(index: number): NormalizeJsNodeInputName;
	protected _expectedOutputName(index: number): string;
	paramDefaultValue(name: string): number;
}
declare class NullJsParamsConfig extends NodeParamsConfig {}
declare class NullJsNode extends TypedJsNode<NullJsParamsConfig> {
	readonly paramsConfig: NullJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	protected _expectedInputTypes(): [JsConnectionPointType];
	protected _expectedInputName(index: number): string;
	protected _expectedOutputName(index: number): string;
	protected _expectedOutputTypes(): JsConnectionPointType[];
	setLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class Object3DLocalToWorldJsParamsConfig extends NodeParamsConfig {
	/** @param vector3 */
	Vector3: ParamTemplate<ParamType.VECTOR3>;
}
declare class Object3DLocalToWorldJsNode extends TypedJsNode<Object3DLocalToWorldJsParamsConfig> {
	paramsConfig: Object3DLocalToWorldJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class Object3DWorldToLocalJsParamsConfig extends NodeParamsConfig {
	/** @param vector3 */
	Vector3: ParamTemplate<ParamType.VECTOR3>;
}
declare class Object3DWorldToLocalJsNode extends TypedJsNode<Object3DWorldToLocalJsParamsConfig> {
	paramsConfig: Object3DWorldToLocalJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class Object3DUpdateMatrixJsParamsConfig extends NodeParamsConfig {}
declare class Object3DUpdateMatrixJsNode extends TypedJsNode<Object3DUpdateMatrixJsParamsConfig> {
	readonly paramsConfig: Object3DUpdateMatrixJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	setTriggerableLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class Object3DUpdateWorldMatrixJsParamsConfig extends NodeParamsConfig {
	/** @param updates the matrix of the parents */
	updateParents: ParamTemplate<ParamType.BOOLEAN>;
	/** @param updates the matrix of the children */
	updateChildren: ParamTemplate<ParamType.BOOLEAN>;
}
declare class Object3DUpdateWorldMatrixJsNode extends TypedJsNode<Object3DUpdateWorldMatrixJsParamsConfig> {
	readonly paramsConfig: Object3DUpdateWorldMatrixJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	setTriggerableLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class ObjectDispatchEventJsParamsConfig extends NodeParamsConfig {
	/** @param event name */
	eventName: ParamTemplate<ParamType.STRING>;
}
declare class ObjectDispatchEventJsNode extends TypedJsNode<ObjectDispatchEventJsParamsConfig> {
	readonly paramsConfig: ObjectDispatchEventJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	setTriggerableLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class OnChildAttributeUpdateJsParamsConfig extends NodeParamsConfig {
	type: ParamTemplate<ParamType.INTEGER>;
}
declare class OnChildAttributeUpdateJsNode extends TypedJsNode<OnChildAttributeUpdateJsParamsConfig> {
	readonly paramsConfig: OnChildAttributeUpdateJsParamsConfig;
	static type(): JsType;
	isTriggering(): boolean;
	static readonly OUTPUT_NEW_VALUES = 'newValues';
	static readonly OUTPUT_PREV_VALUES = 'previousValues';
	initializeNode(): void;
	private _currentConnectionType;
	setAttribType(type: ParamConvertibleJsType): void;
	attribType(): JsConnectionPointType;
	setAttribName(attribName: string): void;
	attributeName(): string;
	setLines(shadersCollectionController: ShadersCollectionController): void;
	setTriggeringLines(shadersCollectionController: ShadersCollectionController, triggeredMethods: string): void;
}
declare class BaseOnKeyEventJsParamsConfig extends NodeParamsConfig {
	/** @param set which element triggers the event */
	element: ParamTemplate<ParamType.INTEGER>;
	/** @param space separated list of accepted key codes. If this is empty then any key is accepted. */
	keyCodes: ParamTemplate<ParamType.STRING>;
	/** @param requires ctrlKey */
	ctrlKey: ParamTemplate<ParamType.INTEGER>;
	/** @param requires altKey */
	altKey: ParamTemplate<ParamType.INTEGER>;
	/** @param requires shiftKey */
	shiftKey: ParamTemplate<ParamType.INTEGER>;
	/** @param requires metaKey */
	metaKey: ParamTemplate<ParamType.INTEGER>;
}
declare abstract class BaseOnKeyEventJsNode extends BaseUserInputJsNode<BaseOnKeyEventJsParamsConfig> {
	readonly paramsConfig: BaseOnKeyEventJsParamsConfig;
	isTriggering(): boolean;
	initializeNode(): void;
	eventEmitter(): CoreEventEmitter;
	setEventEmitter(emitter: CoreEventEmitter): void;
	setTriggeringLines(shadersCollectionController: ShadersCollectionController, triggeredMethods: string): void;
}
declare class OnKeyJsNode extends BaseOnKeyEventJsNode {
	static type(): JsType;
	eventData(): EvaluatorEventData[] | undefined;
}
declare class OnKeydownJsNode extends BaseOnKeyEventJsNode {
	static type(): JsType;
	eventData(): EvaluatorEventData | undefined;
}
declare class OnKeypressJsNode extends BaseOnKeyEventJsNode {
	static type(): JsType;
	eventData(): EvaluatorEventData | undefined;
}
declare class OnKeyupJsNode extends BaseOnKeyEventJsNode {
	static type(): JsType;
	eventData(): EvaluatorEventData | undefined;
}
declare class OnManualTriggerJsParamsConfig extends NodeParamsConfig {
	trigger: ParamTemplate<ParamType.BUTTON>;
}
declare class OnManualTriggerJsNode extends TypedJsNode<OnManualTriggerJsParamsConfig> {
	readonly paramsConfig: OnManualTriggerJsParamsConfig;
	static type(): JsType;
	isTriggering(): boolean;
	initializeNode(): void;
	static PARAM_CALLBACK_sendTrigger(node: OnManualTriggerJsNode): void;
	setTriggeringLines(shadersCollectionController: ShadersCollectionController, triggeredMethods: string): void;
	private _triggerWithNode;
}
declare class OnMapboxCameraMoveJsParamsConfig extends NodeParamsConfig {}
declare class OnMapboxCameraMoveJsNode extends TypedJsNode<OnMapboxCameraMoveJsParamsConfig> {
	readonly paramsConfig: OnMapboxCameraMoveJsParamsConfig;
	static type(): JsType;
	isTriggering(): boolean;
	initializeNode(): void;
	setTriggeringLines(shadersCollectionController: ShadersCollectionController, triggeredMethods: string): void;
}
declare class OnMapboxCameraMoveEndJsParamsConfig extends NodeParamsConfig {}
declare class OnMapboxCameraMoveEndJsNode extends TypedJsNode<OnMapboxCameraMoveEndJsParamsConfig> {
	readonly paramsConfig: OnMapboxCameraMoveEndJsParamsConfig;
	static type(): JsType;
	isTriggering(): boolean;
	initializeNode(): void;
	setTriggeringLines(shadersCollectionController: ShadersCollectionController, triggeredMethods: string): void;
}
declare class OnMapboxCameraMoveStartJsParamsConfig extends NodeParamsConfig {}
declare class OnMapboxCameraMoveStartJsNode extends TypedJsNode<OnMapboxCameraMoveStartJsParamsConfig> {
	readonly paramsConfig: OnMapboxCameraMoveStartJsParamsConfig;
	static type(): JsType;
	isTriggering(): boolean;
	initializeNode(): void;
	setTriggeringLines(shadersCollectionController: ShadersCollectionController, triggeredMethods: string): void;
}
declare class OnObjectAttributeUpdateJsParamsConfig extends NodeParamsConfig {
	type: ParamTemplate<ParamType.INTEGER>;
}
declare class OnObjectAttributeUpdateJsNode extends TypedJsNode<OnObjectAttributeUpdateJsParamsConfig> {
	readonly paramsConfig: OnObjectAttributeUpdateJsParamsConfig;
	static type(): JsType;
	isTriggering(): boolean;
	static readonly OUTPUT_NEW_VAL = 'newValue';
	static readonly OUTPUT_PREV_VAL = 'previousValue';
	initializeNode(): void;
	private _currentConnectionType;
	setAttribType(type: ParamConvertibleJsType): void;
	attribType(): JsConnectionPointType;
	setAttribName(attribName: string): void;
	attributeName(): string;
	setLines(shadersCollectionController: ShadersCollectionController): void;
	setTriggeringLines(shadersCollectionController: ShadersCollectionController, triggeredMethods: string): void;
}
declare class OnObjectHoverJsParamsConfig extends NodeParamsConfig {
	/** @param include children */
	traverseChildren: ParamTemplate<ParamType.BOOLEAN>;
	/** @param pointsThreshold */
	pointsThreshold: ParamTemplate<ParamType.FLOAT>;
	/** @param lineThreshold */
	lineThreshold: ParamTemplate<ParamType.FLOAT>;
}
declare abstract class BaseOnObjectPointerEventJsNode extends BaseUserInputJsNode<OnObjectHoverJsParamsConfig> {
	readonly paramsConfig: OnObjectHoverJsParamsConfig;
	isTriggering(): boolean;
	eventEmitter(): CoreEventEmitter;
}
declare class OnObjectClickJsNode extends BaseOnObjectPointerEventJsNode {
	static type(): JsType;
	isTriggering(): boolean;
	eventData(): EvaluatorEventData | undefined;
	initializeNode(): void;
	setLines(shadersCollectionController: ShadersCollectionController): void;
	setTriggeringLines(shadersCollectionController: ShadersCollectionController, triggeredMethods: string): void;
	private _addIntersectionRef;
}
declare class OnObjectDispatchEventJsParamsConfig extends NodeParamsConfig {
	/** @param event names (space separated) */
	eventNames: ParamTemplate<ParamType.STRING>;
}
declare class OnObjectDispatchEventJsNode extends TypedJsNode<OnObjectDispatchEventJsParamsConfig> {
	readonly paramsConfig: OnObjectDispatchEventJsParamsConfig;
	static type(): JsType.ON_OBJECT_DISPATCH_EVENT;
	isTriggering(): boolean;
	initializeNode(): void;
	setTriggeringLines(shadersCollectionController: ShadersCollectionController, triggeredMethods: string): void;
}
declare class OnObjectHoverJsNode extends BaseOnObjectPointerEventJsNode {
	static type(): JsType;
	isTriggering(): boolean;
	eventData(): EvaluatorEventData | undefined;
	initializeNode(): void;
	setLines(shadersCollectionController: ShadersCollectionController): void;
	setTriggeringLines(shadersCollectionController: ShadersCollectionController, triggeredMethods: string): void;
	private _addIntersectionRef;
	private _addHoveredRef;
}
declare class OnObjectPointerdownJsNode extends BaseOnObjectPointerEventJsNode {
	static type(): JsType;
	eventData(): EvaluatorEventData | undefined;
	initializeNode(): void;
	setLines(shadersCollectionController: ShadersCollectionController): void;
	setTriggeringLines(shadersCollectionController: ShadersCollectionController, triggeredMethods: string): void;
	private _addIntersectionRef;
}
declare class OnObjectPointerupJsNode extends BaseOnObjectPointerEventJsNode {
	static type(): JsType;
	eventData(): EvaluatorEventData | undefined;
	initializeNode(): void;
	setLines(shadersCollectionController: ShadersCollectionController): void;
	setTriggeringLines(shadersCollectionController: ShadersCollectionController, triggeredMethods: string): void;
	private _addIntersectionRef;
}
declare class OnPerformanceChangeJsParamsConfig extends NodeParamsConfig {
	threshold: ParamTemplate<ParamType.FLOAT>;
}
declare class OnPerformanceChangeJsNode extends TypedJsNode<OnPerformanceChangeJsParamsConfig> {
	readonly paramsConfig: OnPerformanceChangeJsParamsConfig;
	static type(): JsType;
	isTriggering(): boolean;
	static OUTPUT_NAME_ABOVE: string;
	static OUTPUT_NAME_BELOW: string;
	initializeNode(): void;
	setTriggeringLines(shadersCollectionController: ShadersCollectionController, triggeredMethods: string): void;
}
declare class OnPointerdownJsParamsConfig extends NodeParamsConfig {
	/** @param set which element triggers the event */
	element: ParamTemplate<ParamType.INTEGER>;
}
declare class OnPointerdownJsNode extends BaseUserInputJsNode<OnPointerdownJsParamsConfig> {
	readonly paramsConfig: OnPointerdownJsParamsConfig;
	static type(): JsType;
	eventData(): EvaluatorEventData | undefined;
	eventEmitter(): CoreEventEmitter;
	setEventEmitter(emitter: CoreEventEmitter): void;
	initializeNode(): void;
	setTriggeringLines(shadersCollectionController: ShadersCollectionController, triggeredMethods: string): void;
}
declare class OnPointerupJsParamsConfig extends NodeParamsConfig {
	/** @param set which element triggers the event */
	element: ParamTemplate<ParamType.INTEGER>;
}
declare class OnPointerupJsNode extends BaseUserInputJsNode<OnPointerupJsParamsConfig> {
	readonly paramsConfig: OnPointerupJsParamsConfig;
	static type(): JsType;
	eventData(): EvaluatorEventData | undefined;
	eventEmitter(): CoreEventEmitter;
	setEventEmitter(emitter: CoreEventEmitter): void;
	initializeNode(): void;
	setTriggeringLines(shadersCollectionController: ShadersCollectionController, triggeredMethods: string): void;
}
declare class OnScenePauseJsParamsConfig extends NodeParamsConfig {}
declare class OnScenePauseJsNode extends TypedJsNode<OnScenePauseJsParamsConfig> {
	readonly paramsConfig: OnScenePauseJsParamsConfig;
	static type(): JsType;
	isTriggering(): boolean;
	initializeNode(): void;
	setTriggeringLines(shadersCollectionController: ShadersCollectionController, triggeredMethods: string): void;
}
declare class OnScenePlayJsParamsConfig extends NodeParamsConfig {}
declare class OnScenePlayJsNode extends TypedJsNode<OnScenePlayJsParamsConfig> {
	readonly paramsConfig: OnScenePlayJsParamsConfig;
	static type(): JsType;
	isTriggering(): boolean;
	initializeNode(): void;
	setTriggeringLines(shadersCollectionController: ShadersCollectionController, triggeredMethods: string): void;
}
declare class OnSceneResetJsParamsConfig extends NodeParamsConfig {}
declare class OnSceneResetJsNode extends TypedJsNode<OnSceneResetJsParamsConfig> {
	readonly paramsConfig: OnSceneResetJsParamsConfig;
	static type(): JsType;
	isTriggering(): boolean;
	initializeNode(): void;
	setTriggeringLines(shadersCollectionController: ShadersCollectionController, triggeredMethods: string): void;
}
declare class OnTickJsParamsConfig extends NodeParamsConfig {}
declare class OnTickJsNode extends TypedJsNode<OnTickJsParamsConfig> {
	readonly paramsConfig: OnTickJsParamsConfig;
	static type(): JsType;
	isTriggering(): boolean;
	initializeNode(): void;
	setTriggeringLines(shadersCollectionController: ShadersCollectionController, triggeredMethods: string): void;
	setLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class OnVideoEventJsParamsConfig extends NodeParamsConfig {
	/** @param video node */
	node: ParamTemplate<ParamType.NODE_PATH>;
}
declare class OnVideoEventJsNode extends TypedJsNode<OnVideoEventJsParamsConfig> {
	readonly paramsConfig: OnVideoEventJsParamsConfig;
	static type(): JsType.ON_VIDEO_EVENT;
	isTriggering(): boolean;
	initializeNode(): void;
	setTriggeringLines(shadersCollectionController: ShadersCollectionController, triggeredMethods: string): void;
}
declare class OnWebXRControllerEventJsParamsConfig extends NodeParamsConfig {
	/** @param  controller index */
	controllerIndex: ParamTemplate<ParamType.INTEGER>;
}
declare class OnWebXRControllerEventJsNode extends TypedJsNode<OnWebXRControllerEventJsParamsConfig> {
	readonly paramsConfig: OnWebXRControllerEventJsParamsConfig;
	static type(): JsType.ON_WEBXR_CONTROLLER_EVENT;
	isTriggering(): boolean;
	initializeNode(): void;
	initOnPlay(): void;
	disposeOnPause(): void;
	private _addEventListenersToObjects;
	private _listenerByObjectByControllerIndex;
	dispose(): void;
	private _removeWebXREventListener;
}
declare class OrJsNode extends BaseLogicOperationJsNode {
	static type(): string;
	protected _expectedOutputName(): string;
	protected _functionName(firstType: AllowedType): 'orArrays' | 'orBooleans';
}
declare class ParamJsParamsConfig extends NodeParamsConfig {
	name: ParamTemplate<ParamType.STRING>;
	type: ParamTemplate<ParamType.INTEGER>;
}
declare class ParamJsNode extends TypedJsNode<ParamJsParamsConfig> {
	paramsConfig: ParamJsParamsConfig;
	static type(): string;
	static readonly OUTPUT_NAME = 'val';
	initializeNode(): void;
	setLines(shadersCollectionController: ShadersCollectionController): void;
	setParamConfigs(): void;
	uniformName(): string;
	setJsType(type: ParamConvertibleJsType): void;
	paramsGenerating(): boolean;
}
declare class BaseTriggerAndObjectJsParamsConfig extends NodeParamsConfig {}
declare abstract class BaseTriggerAndObjectJsNode extends TypedJsNode<BaseTriggerAndObjectJsParamsConfig> {
	readonly paramsConfig: BaseTriggerAndObjectJsParamsConfig;
	initializeNode(): void;
}
declare class ParticlesSystemResetJsNode extends BaseTriggerAndObjectJsNode {
	static type(): string;
	setTriggerableLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class ParticlesSystemStepSimulationJsNode extends BaseTriggerAndObjectJsNode {
	static type(): string;
	setTriggerableLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class PauseAudioSourceJsParamsConfig extends NodeParamsConfig {
	/** @param audio node */
	node: ParamTemplate<ParamType.NODE_PATH>;
}
declare abstract class BaseAudioSourceJsNode extends TypedJsNode<PauseAudioSourceJsParamsConfig> {
	readonly paramsConfig: PauseAudioSourceJsParamsConfig;
	initializeNode(): void;
}
declare class PauseAudioSourceJsNode extends BaseAudioSourceJsNode {
	static type(): string;
	setTriggerableLines(shadersCollectionController: ShadersCollectionController): void;
	setTriggeringLines(shadersCollectionController: ShadersCollectionController, triggeredMethods: string): void;
}
declare class PhysicsPlayerUpdateJsParamsConfig extends NodeParamsConfig {
	/** @param travel speed */
	speed: ParamTemplate<ParamType.FLOAT>;
	/** @param run Allowed */
	runAllowed: ParamTemplate<ParamType.BOOLEAN>;
	/** @param jump Force */
	runSpeedMult: ParamTemplate<ParamType.FLOAT>;
	/** @param jump Allowed */
	jumpAllowed: ParamTemplate<ParamType.BOOLEAN>;
	/** @param jump Force */
	jumpStrength: ParamTemplate<ParamType.FLOAT>;
	/** @param reset if position is below a threshold */
	resetIfBelowThreshold: ParamTemplate<ParamType.BOOLEAN>;
	/** @param height under which the player gets reset */
	resetThreshold: ParamTemplate<ParamType.FLOAT>;
}
declare class PhysicsPlayerUpdateJsNode extends TypedJsNode<PhysicsPlayerUpdateJsParamsConfig> {
	readonly paramsConfig: PhysicsPlayerUpdateJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	setTriggerableLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class PhysicsRBDAddForceJsParamsConfig extends NodeParamsConfig {
	/** @param force */
	force: ParamTemplate<ParamType.VECTOR3>;
}
declare class PhysicsRBDAddForceJsNode extends TypedJsNode<PhysicsRBDAddForceJsParamsConfig> {
	readonly paramsConfig: PhysicsRBDAddForceJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	setTriggerableLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class PhysicsRBDAddForceAtPointJsParamsConfig extends NodeParamsConfig {
	/** @param force */
	force: ParamTemplate<ParamType.VECTOR3>;
	/** @param point */
	point: ParamTemplate<ParamType.VECTOR3>;
}
declare class PhysicsRBDAddForceAtPointJsNode extends TypedJsNode<PhysicsRBDAddForceAtPointJsParamsConfig> {
	readonly paramsConfig: PhysicsRBDAddForceAtPointJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	setTriggerableLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class PhysicsRBDAddTorqueJsParamsConfig extends NodeParamsConfig {
	/** @param torque */
	torque: ParamTemplate<ParamType.VECTOR3>;
}
declare class PhysicsRBDAddTorqueJsNode extends TypedJsNode<PhysicsRBDAddTorqueJsParamsConfig> {
	readonly paramsConfig: PhysicsRBDAddTorqueJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	setTriggerableLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class PhysicsRBDApplyImpulseJsParamsConfig extends NodeParamsConfig {
	/** @param impulse */
	impulse: ParamTemplate<ParamType.VECTOR3>;
}
declare class PhysicsRBDApplyImpulseJsNode extends TypedJsNode<PhysicsRBDApplyImpulseJsParamsConfig> {
	readonly paramsConfig: PhysicsRBDApplyImpulseJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	setTriggerableLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class PhysicsRBDApplyTorqueImpulseJsParamsConfig extends NodeParamsConfig {
	/** @param impulse */
	impulse: ParamTemplate<ParamType.VECTOR3>;
}
declare class PhysicsRBDApplyTorqueImpulseJsNode extends TypedJsNode<PhysicsRBDApplyTorqueImpulseJsParamsConfig> {
	readonly paramsConfig: PhysicsRBDApplyTorqueImpulseJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	setTriggerableLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class PhysicsRBDApplyImpulseAtPointJsParamsConfig extends NodeParamsConfig {
	/** @param impulse */
	impulse: ParamTemplate<ParamType.VECTOR3>;
	/** @param point */
	point: ParamTemplate<ParamType.VECTOR3>;
}
declare class PhysicsRBDApplyImpulseAtPointJsNode extends TypedJsNode<PhysicsRBDApplyImpulseAtPointJsParamsConfig> {
	readonly paramsConfig: PhysicsRBDApplyImpulseAtPointJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	setTriggerableLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class PhysicsRBDRemoveJsParamsConfig extends NodeParamsConfig {}
declare class PhysicsRBDRemoveJsNode extends TypedJsNode<PhysicsRBDRemoveJsParamsConfig> {
	readonly paramsConfig: PhysicsRBDRemoveJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	setTriggerableLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class PhysicsRBDResetAllJsParamsConfig extends NodeParamsConfig {
	/** @param wakeup */
	wakeup: ParamTemplate<ParamType.BOOLEAN>;
}
declare class PhysicsRBDResetAllJsNode extends TypedJsNode<PhysicsRBDResetAllJsParamsConfig> {
	readonly paramsConfig: PhysicsRBDResetAllJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	setTriggerableLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class PhysicsRBDResetForcesJsParamsConfig extends NodeParamsConfig {
	/** @param wakeup */
	wakeup: ParamTemplate<ParamType.BOOLEAN>;
}
declare class PhysicsRBDResetForcesJsNode extends TypedJsNode<PhysicsRBDResetForcesJsParamsConfig> {
	readonly paramsConfig: PhysicsRBDResetForcesJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	setTriggerableLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class PhysicsRBDResetTorquesJsParamsConfig extends NodeParamsConfig {
	/** @param wakeup */
	wakeup: ParamTemplate<ParamType.BOOLEAN>;
}
declare class PhysicsRBDResetTorquesJsNode extends TypedJsNode<PhysicsRBDResetTorquesJsParamsConfig> {
	readonly paramsConfig: PhysicsRBDResetTorquesJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	setTriggerableLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class PhysicsWorldResetJsNode extends BaseTriggerAndObjectJsNode {
	static type(): string;
	setTriggerableLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class PhysicsWorldStepSimulationJsNode extends BaseTriggerAndObjectJsNode {
	static type(): string;
	setTriggerableLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class PlaneJsParamsConfig extends NodeParamsConfig {
	/** @param a unit length vector defining the normal of the plane */
	normal: ParamTemplate<ParamType.VECTOR3>;
	/** @param the signed distance from the origin to the plane */
	constant: ParamTemplate<ParamType.FLOAT>;
}
declare class PlaneJsNode extends TypedJsNode<PlaneJsParamsConfig> {
	paramsConfig: PlaneJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class PlayAnimationJsParamsConfig extends NodeParamsConfig {
	/** @param include children */
	node: ParamTemplate<ParamType.NODE_PATH>;
}
declare class PlayAnimationJsNode extends TypedJsNode<PlayAnimationJsParamsConfig> {
	readonly paramsConfig: PlayAnimationJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	setTriggerableLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class PlayAudioSourceJsNode extends BaseAudioSourceJsNode {
	static type(): string;
	private _targetNodePath;
	setTriggerableLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class PlayerUpdateJsParamsConfig extends NodeParamsConfig {
	/** @param travel speed */
	speed: ParamTemplate<ParamType.FLOAT>;
	/** @param run Allowed */
	runAllowed: ParamTemplate<ParamType.BOOLEAN>;
	/** @param jump Force */
	runSpeedMult: ParamTemplate<ParamType.FLOAT>;
	/** @param jump Allowed */
	jumpAllowed: ParamTemplate<ParamType.BOOLEAN>;
	/** @param jump Force */
	jumpStrength: ParamTemplate<ParamType.FLOAT>;
	/** @param physics Steps */
	physicsSteps: ParamTemplate<ParamType.INTEGER>;
	/** @param gravity */
	gravity: ParamTemplate<ParamType.VECTOR3>;
	/** @param collision Capsule Radius */
	capsuleRadius: ParamTemplate<ParamType.FLOAT>;
	/** @param collision Capsule Height */
	capsuleHeight: ParamTemplate<ParamType.FLOAT>;
}
declare class PlayerUpdateJsNode extends TypedJsNode<PlayerUpdateJsParamsConfig> {
	readonly paramsConfig: PlayerUpdateJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	setTriggerableLines(shadersCollectionController: ShadersCollectionController): void;
	setLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class PlayInstrumentNoteJsParamsConfig extends NodeParamsConfig {
	/** @param audio node */
	node: ParamTemplate<ParamType.NODE_PATH>;
	/** @param note */
	note: ParamTemplate<ParamType.STRING>;
	/** @param duration */
	duration: ParamTemplate<ParamType.FLOAT>;
}
declare class PlayInstrumentNoteJsNode extends TypedJsNode<PlayInstrumentNoteJsParamsConfig> {
	readonly paramsConfig: PlayInstrumentNoteJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	setTriggerableLines(shadersCollectionController: ShadersCollectionController): void;
}
declare const PowJsNode_base: typeof BaseMathFunctionJsNode;
declare class PowJsNode extends PowJsNode_base {
	paramDefaultValue(name: string): number;
	protected _expectedInputName(index: number): string;
	protected _expectedInputTypes(): JsConnectionPointType[];
}
declare class PressButtonParamJsParamsConfig extends NodeParamsConfig {
	/** @param the parameter to update */
	param: ParamTemplate<ParamType.PARAM_PATH>;
}
declare class PressButtonParamJsNode extends TypedJsNode<PressButtonParamJsParamsConfig> {
	readonly paramsConfig: PressButtonParamJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	setTriggerableLines(shadersCollectionController: ShadersCollectionController): void;
}
declare const RandJsNode_base: typeof BaseMathFunctionJsNode;
declare class RandJsNode extends RandJsNode_base {
	protected _coreFunction(shadersCollectionController: ShadersCollectionController): string;
	paramDefaultValue(name: string): number;
	protected _expectedInputName(index: number): string;
	protected _expectedInputTypes(): JsConnectionPointType[];
}
declare class RandomJsParamsConfig extends NodeParamsConfig {}
declare class RandomJsNode extends TypedJsNode<RandomJsParamsConfig> {
	readonly paramsConfig: RandomJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class RayJsParamsConfig extends NodeParamsConfig {
	/** @param ray origin */
	origin: ParamTemplate<ParamType.VECTOR3>;
	/** @param ray direction */
	direction: ParamTemplate<ParamType.VECTOR3>;
}
declare class RayJsNode extends TypedJsNode<RayJsParamsConfig> {
	paramsConfig: RayJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class RayFromCameraJsParamsConfig extends NodeParamsConfig {
	/** @param x position in screen space  */
	x: ParamTemplate<ParamType.FLOAT>;
	/** @param y position in screen space */
	y: ParamTemplate<ParamType.FLOAT>;
}
declare class RayFromCameraJsNode extends TypedJsNode<RayFromCameraJsParamsConfig> {
	paramsConfig: RayFromCameraJsParamsConfig;
	static type(): JsType;
	initializeNode(): void;
	setLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class RayFromCursorJsParamsConfig extends NodeParamsConfig {
	/** @param set which element triggers the event */
	element: ParamTemplate<ParamType.INTEGER>;
}
declare class RayFromCursorJsNode extends BaseUserInputJsNode<RayFromCursorJsParamsConfig> {
	paramsConfig: RayFromCursorJsParamsConfig;
	static type(): JsType;
	eventData(): EvaluatorEventData | undefined;
	eventEmitter(): CoreEventEmitter;
	setEventEmitter(emitter: CoreEventEmitter): void;
	initializeNode(): void;
	setLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class BaseRayBox3JsParamsConfig extends NodeParamsConfig {}
declare abstract class BaseRayBox3JsNode extends TypedJsNode<BaseRayBox3JsParamsConfig> {
	paramsConfig: BaseRayBox3JsParamsConfig;
	initializeNode(): void;
}
declare class RayIntersectBoxJsNode extends BaseRayBox3JsNode {
	static type(): string;
	initializeNode(): void;
	setLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class RayIntersectsBoxJsNode extends BaseRayBox3JsNode {
	static type(): string;
	initializeNode(): void;
	setLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class BaseRayObjectJsParamsConfig extends NodeParamsConfig {}
declare abstract class BaseRayObjectJsNode extends TypedJsNode<BaseRayObjectJsParamsConfig> {
	paramsConfig: BaseRayObjectJsParamsConfig;
	initializeNode(): void;
}
declare class RayIntersectObjectJsNode extends BaseRayObjectJsNode {
	static type(): string;
	initializeNode(): void;
	setLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class RayIntersectsObjectJsNode extends BaseRayObjectJsNode {
	static type(): string;
	initializeNode(): void;
	setLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class BaseRayPlaneJsParamsConfig extends NodeParamsConfig {}
declare abstract class BaseRayPlaneJsNode extends TypedJsNode<BaseRayPlaneJsParamsConfig> {
	paramsConfig: BaseRayPlaneJsParamsConfig;
	initializeNode(): void;
}
declare class RayDistanceToPlaneJsNode extends BaseRayPlaneJsNode {
	static type(): string;
	initializeNode(): void;
	setLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class RayIntersectPlaneJsNode extends BaseRayPlaneJsNode {
	static type(): string;
	initializeNode(): void;
	setLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class RayIntersectsPlaneJsNode extends BaseRayPlaneJsNode {
	static type(): string;
	initializeNode(): void;
	setLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class BaseRaySphereJsParamsConfig extends NodeParamsConfig {}
declare abstract class BaseRaySphereJsNode extends TypedJsNode<BaseRaySphereJsParamsConfig> {
	paramsConfig: BaseRaySphereJsParamsConfig;
	initializeNode(): void;
}
declare class RayIntersectSphereJsNode extends BaseRaySphereJsNode {
	static type(): string;
	initializeNode(): void;
	setLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class RayIntersectsSphereJsNode extends BaseRaySphereJsNode {
	static type(): string;
	initializeNode(): void;
	setLines(shadersCollectionController: ShadersCollectionController): void;
}
declare const RoundJsNode_base: typeof BaseMathFunctionJsNode;
declare class RoundJsNode extends RoundJsNode_base {}
declare class BaseSDF2DJsParamsConfig extends NodeParamsConfig {
	position: ParamTemplate<ParamType.VECTOR2>;
}
declare class BaseSDF2DJsNode<K extends BaseSDF2DJsParamsConfig> extends TypedJsNode<K> {}
declare class SDF2DRoundedXJsParamsConfig extends NodeParamsConfig {
	position: ParamTemplate<ParamType.VECTOR2>;
	center: ParamTemplate<ParamType.VECTOR2>;
	length: ParamTemplate<ParamType.FLOAT>;
	radius: ParamTemplate<ParamType.FLOAT>;
}
declare class SDF2DRoundedXJsNode extends BaseSDF2DJsNode<SDF2DRoundedXJsParamsConfig> {
	paramsConfig: SDF2DRoundedXJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class BaseSDFJsParamsConfig extends NodeParamsConfig {
	position: ParamTemplate<ParamType.VECTOR3>;
}
declare class BaseSDFJsNode<K extends BaseSDFJsParamsConfig> extends TypedJsNode<K> {
	protected position(shadersCollectionController: ShadersCollectionController): string;
	private _defaultPosition;
}
declare class SDFBoxJsParamsConfig extends NodeParamsConfig {
	position: ParamTemplate<ParamType.VECTOR3>;
	center: ParamTemplate<ParamType.VECTOR3>;
	size: ParamTemplate<ParamType.FLOAT>;
	sizes: ParamTemplate<ParamType.VECTOR3>;
}
declare class SDFBoxJsNode extends BaseSDFJsNode<SDFBoxJsParamsConfig> {
	paramsConfig: SDFBoxJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class SDFIntersectJsParamsConfig extends NodeParamsConfig {
	sdf0: ParamTemplate<ParamType.FLOAT>;
	sdf1: ParamTemplate<ParamType.FLOAT>;
	smooth: ParamTemplate<ParamType.BOOLEAN>;
	smoothFactor: ParamTemplate<ParamType.FLOAT>;
}
declare class SDFIntersectJsNode extends TypedJsNode<SDFIntersectJsParamsConfig> {
	paramsConfig: SDFIntersectJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(shadersCollectionController: ShadersCollectionController): void;
}
declare enum SDFRevolutionAxis {
	X = 'X',
	Y = 'Y',
	Z = 'Z',
}
declare class SDFRevolutionGlParamsConfig extends NodeParamsConfig {
	position: ParamTemplate<ParamType.VECTOR3>;
	center: ParamTemplate<ParamType.VECTOR3>;
	radius: ParamTemplate<ParamType.FLOAT>;
	axis: ParamTemplate<ParamType.INTEGER>;
}
declare class SDFRevolutionJsNode extends BaseSDFJsNode<SDFRevolutionGlParamsConfig> {
	paramsConfig: SDFRevolutionGlParamsConfig;
	static type(): string;
	initializeNode(): void;
	setAxis(axis: SDFRevolutionAxis): void;
	setLines(shadersCollectionController: ShadersCollectionController): void;
	private _functionName;
}
declare class SDFSphereJsParamsConfig extends NodeParamsConfig {
	position: ParamTemplate<ParamType.VECTOR3>;
	center: ParamTemplate<ParamType.VECTOR3>;
	radius: ParamTemplate<ParamType.FLOAT>;
}
declare class SDFSphereJsNode extends BaseSDFJsNode<SDFSphereJsParamsConfig> {
	paramsConfig: SDFSphereJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class SDFSubtractJsParamsConfig extends NodeParamsConfig {
	sdf0: ParamTemplate<ParamType.FLOAT>;
	sdf1: ParamTemplate<ParamType.FLOAT>;
	smooth: ParamTemplate<ParamType.BOOLEAN>;
	smoothFactor: ParamTemplate<ParamType.FLOAT>;
}
declare class SDFSubtractJsNode extends TypedJsNode<SDFSubtractJsParamsConfig> {
	paramsConfig: SDFSubtractJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class SDFUnionJsParamsConfig extends NodeParamsConfig {
	sdf0: ParamTemplate<ParamType.FLOAT>;
	sdf1: ParamTemplate<ParamType.FLOAT>;
	smooth: ParamTemplate<ParamType.BOOLEAN>;
	smoothFactor: ParamTemplate<ParamType.FLOAT>;
}
declare class SDFUnionJsNode extends TypedJsNode<SDFUnionJsParamsConfig> {
	paramsConfig: SDFUnionJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class SetGeometryInstanceAttributeJsParamsConfig extends NodeParamsConfig {
	/** @param attribute name */
	attribName: ParamTemplate<ParamType.STRING>;
}
declare class SetGeometryInstanceAttributeJsNode extends TypedJsNode<SetGeometryInstanceAttributeJsParamsConfig> {
	readonly paramsConfig: SetGeometryInstanceAttributeJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	private _expectedInputTypes;
	paramDefaultValue(name: string): number | boolean;
	protected _expectedInputName(index: number): string;
	setTriggerableLines(shadersCollectionController: ShadersCollectionController): void;
	private _functionName;
}
declare class SetGeometryInstancePositionsJsParamsConfig extends NodeParamsConfig {}
declare class SetGeometryInstancePositionsJsNode extends TypedJsNode<SetGeometryInstancePositionsJsParamsConfig> {
	readonly paramsConfig: SetGeometryInstancePositionsJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	paramDefaultValue(name: string): number | boolean;
	expectedInputTypes(): JsConnectionPointType[];
	protected _expectedOutputTypes(): JsConnectionPointType[];
	protected _expectedInputName(index: number): string;
	setTriggerableLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class SetGeometryInstanceQuaternionsJsParamsConfig extends NodeParamsConfig {}
declare class SetGeometryInstanceQuaternionsJsNode extends TypedJsNode<SetGeometryInstanceQuaternionsJsParamsConfig> {
	readonly paramsConfig: SetGeometryInstanceQuaternionsJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	paramDefaultValue(name: string): number | boolean;
	expectedInputTypes(): JsConnectionPointType[];
	protected _expectedOutputTypes(): JsConnectionPointType[];
	protected _expectedInputName(index: number): string;
	setTriggerableLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class SetGeometryInstanceScalesJsParamsConfig extends NodeParamsConfig {}
declare class SetGeometryInstanceScalesJsNode extends TypedJsNode<SetGeometryInstanceScalesJsParamsConfig> {
	readonly paramsConfig: SetGeometryInstanceScalesJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	paramDefaultValue(name: string): number | boolean;
	expectedInputTypes(): JsConnectionPointType[];
	protected _expectedOutputTypes(): JsConnectionPointType[];
	protected _expectedInputName(index: number): string;
	setTriggerableLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class SetGeometryInstanceTransformsJsParamsConfig extends NodeParamsConfig {}
declare class SetGeometryInstanceTransformsJsNode extends TypedJsNode<SetGeometryInstanceTransformsJsParamsConfig> {
	readonly paramsConfig: SetGeometryInstanceTransformsJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	paramDefaultValue(name: string): number | boolean;
	expectedInputTypes(): JsConnectionPointType[];
	protected _expectedOutputTypes(): JsConnectionPointType[];
	protected _expectedInputName(index: number): string;
	setTriggerableLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class SetGeometryPositionsJsParamsConfig extends NodeParamsConfig {
	lerp: ParamTemplate<ParamType.FLOAT>;
	attributeNeedsUpdate: ParamTemplate<ParamType.BOOLEAN>;
	computeNormals: ParamTemplate<ParamType.BOOLEAN>;
	computeTangents: ParamTemplate<ParamType.BOOLEAN>;
}
declare class SetGeometryPositionsJsNode extends TypedJsNode<SetGeometryPositionsJsParamsConfig> {
	readonly paramsConfig: SetGeometryPositionsJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	paramDefaultValue(name: string): number | boolean;
	expectedInputTypes(): JsConnectionPointType[];
	protected _expectedInputName(index: number): string;
	protected _expectedOutputTypes(): JsConnectionPointType[];
	protected _expectedOutputNames(i: number): JsConnectionPointType;
	setTriggerableLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class BaseSetMaterialColorJsParamsConfig extends NodeParamsConfig {
	/** @param color */
	color: ParamTemplate<ParamType.COLOR>;
	/** @param lerp factor */
	lerp: ParamTemplate<ParamType.FLOAT>;
}
declare abstract class BaseSetMaterialColorJsNode extends TypedJsNode<BaseSetMaterialColorJsParamsConfig> {
	readonly paramsConfig: BaseSetMaterialColorJsParamsConfig;
	initializeNode(): void;
	setTriggerableLines(shadersCollectionController: ShadersCollectionController): void;
	abstract _functionName(): 'setMaterialColor' | 'setMaterialEmissiveColor';
}
declare class SetMaterialColorJsNode extends BaseSetMaterialColorJsNode {
	static type(): string;
	_functionName(): 'setMaterialColor';
}
declare class SetMaterialEmissiveColorJsNode extends BaseSetMaterialColorJsNode {
	static type(): string;
	_functionName(): 'setMaterialEmissiveColor';
}
declare class BaseSetMaterialFloatJsParamsConfig extends NodeParamsConfig {
	/** @param float */
	float: ParamTemplate<ParamType.FLOAT>;
	/** @param lerp factor */
	lerp: ParamTemplate<ParamType.FLOAT>;
}
declare abstract class BaseSetMaterialFloatJsNode extends TypedJsNode<BaseSetMaterialFloatJsParamsConfig> {
	readonly paramsConfig: BaseSetMaterialFloatJsParamsConfig;
	initializeNode(): void;
	setTriggerableLines(shadersCollectionController: ShadersCollectionController): void;
	abstract _functionName(): 'setMaterialOpacity';
}
declare class SetMaterialOpacityJsNode extends BaseSetMaterialFloatJsNode {
	static type(): string;
	_functionName(): 'setMaterialOpacity';
}
export declare type AvailableJsType =
	| JsConnectionPointType.COLOR
	| JsConnectionPointType.FLOAT
	| JsConnectionPointType.INT
	| JsConnectionPointType.VECTOR2
	| JsConnectionPointType.VECTOR3
	| JsConnectionPointType.VECTOR4;
declare class SetMaterialUniformJsParamsConfig extends NodeParamsConfig {
	/** @param add prefix */
	addPrefix: ParamTemplate<ParamType.BOOLEAN>;
	/** @param uniform name */
	/** @param uniform type */
	type: ParamTemplate<ParamType.INTEGER>;
}
declare class SetMaterialUniformJsNode extends TypedJsNode<SetMaterialUniformJsParamsConfig> {
	readonly paramsConfig: SetMaterialUniformJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	private _expectedInputType;
	paramDefaultValue(name: 'lerp'): number;
	uniformType(): AvailableJsType;
	setUniformType(type: AvailableJsType): void;
	setTriggerableLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class SetObjectAttributeJsParamsConfig extends NodeParamsConfig {
	/** @param manual trigger */
	/** @param attribute name */
	/** @param attribute type */
	type: ParamTemplate<ParamType.INTEGER>;
}
declare class SetObjectAttributeJsNode extends TypedJsNode<SetObjectAttributeJsParamsConfig> {
	readonly paramsConfig: SetObjectAttributeJsParamsConfig;
	static type(): string;
	static INPUT_NAME_VAL: string;
	initializeNode(): void;
	private _currentConnectionType;
	setAttribType(type: ParamConvertibleJsType): void;
	setAttribName(attribName: string): void;
	setTriggerableLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class SetObjectCastShadowJsParamsConfig extends NodeParamsConfig {
	/** @param target castShadow state */
	castShadow: ParamTemplate<ParamType.BOOLEAN>;
}
declare class SetObjectCastShadowJsNode extends TypedJsNode<SetObjectCastShadowJsParamsConfig> {
	readonly paramsConfig: SetObjectCastShadowJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	setTriggerableLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class SetObjectFrustumCulledJsParamsConfig extends NodeParamsConfig {
	/** @param target FrustumCulled state */
	frustumCulled: ParamTemplate<ParamType.BOOLEAN>;
}
declare class SetObjectFrustumCulledJsNode extends TypedJsNode<SetObjectFrustumCulledJsParamsConfig> {
	readonly paramsConfig: SetObjectFrustumCulledJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	setTriggerableLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class SetObjectLookAtJsParamsConfig extends NodeParamsConfig {
	/** @param targetPosition */
	targetPosition: ParamTemplate<ParamType.VECTOR3>;
	/** @param up */
	up: ParamTemplate<ParamType.VECTOR3>;
	/** @param lerp factor */
	lerp: ParamTemplate<ParamType.FLOAT>;
	/** @param invertDirection */
	invertDirection: ParamTemplate<ParamType.BOOLEAN>;
	/** @param sets if the matrix should be updated as the animation progresses */
	updateMatrix: ParamTemplate<ParamType.BOOLEAN>;
}
declare class SetObjectLookAtJsNode extends TypedJsNode<SetObjectLookAtJsParamsConfig> {
	readonly paramsConfig: SetObjectLookAtJsParamsConfig;
	static type(): JsType;
	initializeNode(): void;
	setTriggerableLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class SetObjectMaterialJsNode extends ParamlessTypedJsNode {
	static type(): string;
	initializeNode(): void;
	setTriggerableLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class SetObjectMaterialColorJsParamsConfig extends NodeParamsConfig {
	/** @param color */
	color: ParamTemplate<ParamType.COLOR>;
	/** @param lerp factor */
	lerp: ParamTemplate<ParamType.FLOAT>;
}
declare class SetObjectMaterialColorJsNode extends TypedJsNode<SetObjectMaterialColorJsParamsConfig> {
	readonly paramsConfig: SetObjectMaterialColorJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	setTriggerableLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class SetObjectMatrixJsParamsConfig extends NodeParamsConfig {}
declare class SetObjectMatrixJsNode extends TypedJsNode<SetObjectMatrixJsParamsConfig> {
	readonly paramsConfig: SetObjectMatrixJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	setTriggerableLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class SetObjectMatrixAutoUpdateJsParamsConfig extends NodeParamsConfig {
	/** @param target MatrixAutoUpdate state */
	matrixAutoUpdate: ParamTemplate<ParamType.BOOLEAN>;
}
declare class SetObjectMatrixAutoUpdateJsNode extends TypedJsNode<SetObjectMatrixAutoUpdateJsParamsConfig> {
	readonly paramsConfig: SetObjectMatrixAutoUpdateJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	setTriggerableLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class SetObjectPositionJsParamsConfig extends NodeParamsConfig {
	/** @param target position */
	position: ParamTemplate<ParamType.VECTOR3>;
	/** @param lerp factor */
	lerp: ParamTemplate<ParamType.FLOAT>;
	/** @param sets if the matrix should be updated as the animation progresses */
	updateMatrix: ParamTemplate<ParamType.BOOLEAN>;
}
declare class SetObjectPositionJsNode extends TypedJsNode<SetObjectPositionJsParamsConfig> {
	readonly paramsConfig: SetObjectPositionJsParamsConfig;
	static type(): JsType;
	initializeNode(): void;
	setTriggerableLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class SetObjectReceiveShadowJsParamsConfig extends NodeParamsConfig {
	/** @param target ReceiveShadow state */
	receiveShadow: ParamTemplate<ParamType.BOOLEAN>;
}
declare class SetObjectReceiveShadowJsNode extends TypedJsNode<SetObjectReceiveShadowJsParamsConfig> {
	readonly paramsConfig: SetObjectReceiveShadowJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	setTriggerableLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class SetObjectRotationJsParamsConfig extends NodeParamsConfig {
	/** @param rotation order */
	rotationOrder: ParamTemplate<ParamType.INTEGER>;
	/** @param rotation */
	rotation: ParamTemplate<ParamType.VECTOR3>;
	/** @param lerp factor */
	lerp: ParamTemplate<ParamType.FLOAT>;
	/** @param sets if the matrix should be updated as the animation progresses */
	updateMatrix: ParamTemplate<ParamType.BOOLEAN>;
}
declare class SetObjectRotationJsNode extends TypedJsNode<SetObjectRotationJsParamsConfig> {
	readonly paramsConfig: SetObjectRotationJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	setTriggerableLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class SetObjectPolarTransformJsParamsConfig extends NodeParamsConfig {
	/** @param center of the transform */
	center: ParamTemplate<ParamType.VECTOR3>;
	/** @param moves the objects along the longitude, which is equivalent to a rotation on the y axis */
	longitude: ParamTemplate<ParamType.FLOAT>;
	/** @param moves the objects along the latitude, which is equivalent to a rotation on the z or x axis */
	latitude: ParamTemplate<ParamType.FLOAT>;
	/** @param moves the point aways from the center */
	depth: ParamTemplate<ParamType.FLOAT>;
}
declare class SetObjectPolarTransformJsNode extends TypedJsNode<SetObjectPolarTransformJsParamsConfig> {
	readonly paramsConfig: SetObjectPolarTransformJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	setTriggerableLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class SetObjectScaleJsParamsConfig extends NodeParamsConfig {
	/** @param target scale */
	scale: ParamTemplate<ParamType.VECTOR3>;
	/** @param target scale */
	mult: ParamTemplate<ParamType.FLOAT>;
	/** @param lerp factor */
	lerp: ParamTemplate<ParamType.FLOAT>;
	/** @param sets if the matrix should be updated as the animation progresses */
	updateMatrix: ParamTemplate<ParamType.BOOLEAN>;
}
declare class SetObjectScaleJsNode extends TypedJsNode<SetObjectScaleJsParamsConfig> {
	readonly paramsConfig: SetObjectScaleJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	setTriggerableLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class SetObjectVisibleJsParamsConfig extends NodeParamsConfig {
	/** @param target visible state */
	visible: ParamTemplate<ParamType.BOOLEAN>;
}
declare class SetObjectVisibleJsNode extends TypedJsNode<SetObjectVisibleJsParamsConfig> {
	readonly paramsConfig: SetObjectVisibleJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	setTriggerableLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class SetParamJsParamsConfig extends NodeParamsConfig {
	/** @param  parameter to update */
	param: ParamTemplate<ParamType.PARAM_PATH>;
	/** @param type of the parameter to update */
	type: ParamTemplate<ParamType.INTEGER>;
}
declare class SetParamJsNode extends TypedJsNode<SetParamJsParamsConfig> {
	readonly paramsConfig: SetParamJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	private _currentConnectionType;
	setParamType(paramType: ParamConvertibleJsType): void;
	setTriggerableLines(shadersCollectionController: ShadersCollectionController): void;
	private _bodyLine;
	private _setBoolean;
	private _setColor;
	private _setFloat;
	private _setInt;
	private _setString;
	private _setVector2;
	private _setVector3;
	private _setVector4;
}
declare class SetPerspectiveCameraFovJsParamsConfig extends NodeParamsConfig {
	/** @param focal length */
	fov: ParamTemplate<ParamType.FLOAT>;
	/** @param lerp factor */
	lerp: ParamTemplate<ParamType.FLOAT>;
	/** @param sets if the projection matrix should be updated as the animation progresses */
	updateProjectionMatrix: ParamTemplate<ParamType.BOOLEAN>;
}
declare class SetPerspectiveCameraFovJsNode extends TypedJsNode<SetPerspectiveCameraFovJsParamsConfig> {
	readonly paramsConfig: SetPerspectiveCameraFovJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	setTriggerableLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class SetPerspectiveCameraNearFarJsParamsConfig extends NodeParamsConfig {
	/** @param near */
	near: ParamTemplate<ParamType.FLOAT>;
	/** @param far */
	far: ParamTemplate<ParamType.FLOAT>;
	/** @param lerp factor */
	lerp: ParamTemplate<ParamType.FLOAT>;
	/** @param sets if the projection matrix should be updated as the animation progresses */
	updateProjectionMatrix: ParamTemplate<ParamType.BOOLEAN>;
}
declare class SetPerspectiveCameraNearFarJsNode extends TypedJsNode<SetPerspectiveCameraNearFarJsParamsConfig> {
	readonly paramsConfig: SetPerspectiveCameraNearFarJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	setTriggerableLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class SetPhysicsRBDAngularVelocityJsParamsConfig extends NodeParamsConfig {
	/** @param target velocity */
	velocity: ParamTemplate<ParamType.VECTOR3>;
	/** @param lerp factor */
	lerp: ParamTemplate<ParamType.FLOAT>;
}
declare class SetPhysicsRBDAngularVelocityJsNode extends TypedJsNode<SetPhysicsRBDAngularVelocityJsParamsConfig> {
	readonly paramsConfig: SetPhysicsRBDAngularVelocityJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	setTriggerableLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class SetPhysicsRBDLinearVelocityJsParamsConfig extends NodeParamsConfig {
	/** @param target position */
	velocity: ParamTemplate<ParamType.VECTOR3>;
	/** @param lerp factor */
	lerp: ParamTemplate<ParamType.FLOAT>;
}
declare class SetPhysicsRBDLinearVelocityJsNode extends TypedJsNode<SetPhysicsRBDLinearVelocityJsParamsConfig> {
	readonly paramsConfig: SetPhysicsRBDLinearVelocityJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	setTriggerableLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class SetPhysicsRBDPositionJsParamsConfig extends NodeParamsConfig {
	/** @param target position */
	position: ParamTemplate<ParamType.VECTOR3>;
	/** @param lerp factor */
	lerp: ParamTemplate<ParamType.FLOAT>;
}
declare class SetPhysicsRBDPositionJsNode extends TypedJsNode<SetPhysicsRBDPositionJsParamsConfig> {
	readonly paramsConfig: SetPhysicsRBDPositionJsParamsConfig;
	static type(): JsType;
	initializeNode(): void;
	setTriggerableLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class SetPhysicsRBDRotationJsParamsConfig extends NodeParamsConfig {
	/** @param target rotation */
	quaternion: ParamTemplate<ParamType.VECTOR4>;
	/** @param lerp factor */
	lerp: ParamTemplate<ParamType.FLOAT>;
}
declare class SetPhysicsRBDRotationJsNode extends TypedJsNode<SetPhysicsRBDRotationJsParamsConfig> {
	readonly paramsConfig: SetPhysicsRBDRotationJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	setTriggerableLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class SetPhysicsRBDCapsulePropertyJsParamsConfig extends NodeParamsConfig {
	/** @param target scale */
	scale: ParamTemplate<ParamType.FLOAT>;
	/** @param lerp factor */
	lerp: ParamTemplate<ParamType.FLOAT>;
	/** @param sets if the matrix should be updated as the animation progresses */
	updateMatrix: ParamTemplate<ParamType.BOOLEAN>;
}
declare class SetPhysicsRBDCapsulePropertyJsNode extends TypedJsNode<SetPhysicsRBDCapsulePropertyJsParamsConfig> {
	readonly paramsConfig: SetPhysicsRBDCapsulePropertyJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	setTriggerableLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class SetPhysicsRBDConePropertyJsParamsConfig extends NodeParamsConfig {
	/** @param target radius */
	radius: ParamTemplate<ParamType.FLOAT>;
	/** @param target height */
	height: ParamTemplate<ParamType.FLOAT>;
	/** @param lerp factor */
	lerp: ParamTemplate<ParamType.FLOAT>;
	/** @param sets if the matrix should be updated as the animation progresses */
	updateMatrix: ParamTemplate<ParamType.BOOLEAN>;
}
declare class SetPhysicsRBDConePropertyJsNode extends TypedJsNode<SetPhysicsRBDConePropertyJsParamsConfig> {
	readonly paramsConfig: SetPhysicsRBDConePropertyJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	setTriggerableLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class SetPhysicsRBDCylinderPropertyJsParamsConfig extends NodeParamsConfig {
	/** @param target radius */
	radius: ParamTemplate<ParamType.FLOAT>;
	/** @param target height */
	height: ParamTemplate<ParamType.FLOAT>;
	/** @param lerp factor */
	lerp: ParamTemplate<ParamType.FLOAT>;
	/** @param sets if the matrix should be updated as the animation progresses */
	updateMatrix: ParamTemplate<ParamType.BOOLEAN>;
}
declare class SetPhysicsRBDCylinderPropertyJsNode extends TypedJsNode<SetPhysicsRBDCylinderPropertyJsParamsConfig> {
	readonly paramsConfig: SetPhysicsRBDCylinderPropertyJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	setTriggerableLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class SetPhysicsRBDCuboidPropertyJsParamsConfig extends NodeParamsConfig {
	/** @param target sizes */
	sizes: ParamTemplate<ParamType.VECTOR3>;
	/** @param target size */
	size: ParamTemplate<ParamType.FLOAT>;
	/** @param lerp factor */
	lerp: ParamTemplate<ParamType.FLOAT>;
	/** @param sets if the matrix should be updated as the animation progresses */
	updateMatrix: ParamTemplate<ParamType.BOOLEAN>;
}
declare class SetPhysicsRBDCuboidPropertyJsNode extends TypedJsNode<SetPhysicsRBDCuboidPropertyJsParamsConfig> {
	readonly paramsConfig: SetPhysicsRBDCuboidPropertyJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	setTriggerableLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class SetPhysicsRBDSpherePropertyJsParamsConfig extends NodeParamsConfig {
	/** @param target radois */
	radius: ParamTemplate<ParamType.FLOAT>;
	/** @param lerp factor */
	lerp: ParamTemplate<ParamType.FLOAT>;
	/** @param sets if the matrix should be updated as the animation progresses */
	updateMatrix: ParamTemplate<ParamType.BOOLEAN>;
}
declare class SetPhysicsRBDSpherePropertyJsNode extends TypedJsNode<SetPhysicsRBDSpherePropertyJsParamsConfig> {
	readonly paramsConfig: SetPhysicsRBDSpherePropertyJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	setTriggerableLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class SetPhysicsWorldGravityJsParamsConfig extends NodeParamsConfig {
	gravity: ParamTemplate<ParamType.VECTOR3>;
	lerp: ParamTemplate<ParamType.FLOAT>;
}
declare class SetPhysicsWorldGravityJsNode extends TypedJsNode<SetPhysicsWorldGravityJsParamsConfig> {
	readonly paramsConfig: SetPhysicsWorldGravityJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	setTriggerableLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class SetPlayerInputJsNode extends ParamlessTypedJsNode {
	static type(): JsType;
	initializeNode(): void;
	setTriggerableLines(shadersCollectionController: ShadersCollectionController): void;
	setLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class SetSpotLightIntensityJsParamsConfig extends NodeParamsConfig {
	/** @param intensity */
	intensity: ParamTemplate<ParamType.FLOAT>;
	/** @param lerp factor */
	lerp: ParamTemplate<ParamType.FLOAT>;
}
declare class SetSpotLightIntensityJsNode extends TypedJsNode<SetSpotLightIntensityJsParamsConfig> {
	readonly paramsConfig: SetSpotLightIntensityJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	setTriggerableLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class SetViewerJsParamsConfig extends NodeParamsConfig {
	/** @param sets the class of the viewer */
	className: ParamTemplate<ParamType.STRING>;
	/** @param set or unset */
	set: ParamTemplate<ParamType.BOOLEAN>;
}
declare class SetViewerJsNode extends TypedJsNode<SetViewerJsParamsConfig> {
	readonly paramsConfig: SetViewerJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	setTriggerableLines(shadersCollectionController: ShadersCollectionController): void;
}
declare const SignJsNode_base: typeof BaseMathFunctionJsNode;
declare class SignJsNode extends SignJsNode_base {}
declare const SinJsNode_base: typeof BaseMathFunctionJsNode;
declare class SinJsNode extends SinJsNode_base {}
declare const SmoothstepJsNode_base: typeof BaseMathFunctionJsNode;
declare class SmoothstepJsNode extends SmoothstepJsNode_base {
	protected _coreFunction(shadersCollectionController: ShadersCollectionController): string;
	paramDefaultValue(name: string): number;
	protected _expectedInputName(index: number): string;
	protected _expectedInputTypes(): JsConnectionPointType[];
}
declare class SphereJsParamsConfig extends NodeParamsConfig {
	/** @param sphere center */
	center: ParamTemplate<ParamType.VECTOR3>;
	/** @param sphere radius */
	radius: ParamTemplate<ParamType.FLOAT>;
}
declare class SphereJsNode extends TypedJsNode<SphereJsParamsConfig> {
	paramsConfig: SphereJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(shadersCollectionController: ShadersCollectionController): void;
}
declare const SqrtJsNode_base: typeof BaseMathFunctionJsNode;
declare class SqrtJsNode extends SqrtJsNode_base {}
declare class CoreNodeSelection {
	private _node;
	private _nodeIds;
	constructor(_node: BaseNodeType);
	node(): BaseNodeType;
	nodeIds(): number[];
	nodes(): BaseNodeType[];
	contains(node: BaseNodeType): boolean;
	equals(nodes: BaseNodeType[]): boolean;
	clear(): void;
	set(nodes: BaseNodeType[]): void;
	add(nodesToAdd: BaseNodeType[]): void;
	remove(nodesToRemove: BaseNodeType[]): void;
	private _checkValidity;
	private _sendUpdateEvent;
	private _json;
	toJSON(): number[];
}
declare class OperationInputsController<NC extends NodeContext> {
	private operationContainer;
	constructor(operationContainer: BaseOperationContainer<NC>);
	inputsCount(): number;
	private _clonedStatesController;
	initInputsClonedState(states: InputCloneMode | InputCloneMode[]): void;
	cloneRequired(index: number): boolean;
	override_cloned_state(state: boolean): void;
}
declare class BaseOperationContainer<NC extends NodeContext> {
	protected operation: BaseOperation<NC>;
	protected name: string;
	protected params: DefaultOperationParams;
	private _path_params;
	constructor(operation: BaseOperation<NC>, name: string, init_params: ParamsInitData);
	pathParamResolveRequired(): boolean;
	resolvePathParams(node_start: BaseNodeType): void;
	private _applyDefaultParams;
	private _applyInitParams;
	private _convertParamData;
	protected _inputs: BaseOperationContainer<NC>[] | undefined;
	setInput(index: number, input: BaseOperationContainer<NC>): void;
	inputsCount(): number;
	private _inputsController;
	protected inputsController(): OperationInputsController<NC>;
	private _initClonedStates;
	inputCloneRequired(index: number): boolean;
	overrideInputCloneState(state: boolean): void;
	cook(input_contents: any[]): any;
}
export declare type OutputNodeFindMethod = (() => BaseNodeType) | undefined;
export declare type TraverseNodeCallback = (node: BaseNodeType) => void;
export declare type TraverseNodeConditionCallback = (node: BaseNodeType) => boolean;
export interface NodeCreateOptions {
	paramsInitValueOverrides?: ParamsInitData;
	nodeName?: string;
}
declare class HierarchyChildrenController {
	protected node: BaseNodeType;
	private _context;
	private _childrenByName;
	private _childrenIdByType;
	private _childrenByType;
	private _childrenAndGrandchildrenByContext;
	private _selection;
	get selection(): CoreNodeSelection;
	constructor(node: BaseNodeType, _context: NodeContext);
	dispose(): void;
	get context(): NodeContext;
	private _output_node_find_method;
	setOutputNodeFindMethod(method: OutputNodeFindMethod): void;
	outputNode(): BaseNodeType | undefined;
	setChildName(node: BaseNodeType, newName: string): void;
	private _nextAvailableChildName;
	nodeContextSignature(): string;
	availableChildrenClasses(): PolyDictionary<typeof BaseNodeClass>;
	isValidChildType(node_type: string): boolean;
	createNode<K extends BaseNodeType>(nodeClassOrString: string | Constructor<K>, options?: NodeCreateOptions): K;
	private _createAndInitNode;
	private _findNodeClass;
	createOperationContainer(
		operation_type: string,
		operation_container_name: string,
		options?: NodeCreateOptions
	): BaseOperationContainer<any>;
	private _addNode;
	removeNode(childNode: BaseNodeType): void;
	private _addToNodesByType;
	private _removeFromNodesByType;
	private _addToChildrenAndGrandchildrenByContext;
	private _removeFromChildrenAndGrandchildrenByContext;
	nodesByType(type: string, target?: BaseNodeType[]): BaseNodeType[];
	childByName(name: string): BaseNodeType | null;
	hasChildrenAndGrandchildrenWithContext(context: NodeContext): boolean;
	private _childrenCount;
	private _children;
	private _childrenNames;
	private _updateCache;
	children(target?: BaseNodeType[]): BaseNodeType[];
	childrenNames(target?: string[]): string[];
	traverseChildren(callback: TraverseNodeCallback, conditionCallback?: TraverseNodeConditionCallback): void;
}
declare const TypedSubnetJsParamsConfig_base: {
	new (...args: any[]): {
		inputs: ParamTemplate<ParamType.FOLDER>;
		inputsCount: ParamTemplate<ParamType.INTEGER>;
		inputType0: ParamTemplate<ParamType.INTEGER>;
		inputName0: ParamTemplate<ParamType.STRING>;
		inputType1: ParamTemplate<ParamType.INTEGER>;
		inputName1: ParamTemplate<ParamType.STRING>;
		inputType2: ParamTemplate<ParamType.INTEGER>;
		inputName2: ParamTemplate<ParamType.STRING>;
		inputType3: ParamTemplate<ParamType.INTEGER>;
		inputName3: ParamTemplate<ParamType.STRING>;
		inputType4: ParamTemplate<ParamType.INTEGER>;
		inputName4: ParamTemplate<ParamType.STRING>;
		inputType5: ParamTemplate<ParamType.INTEGER>;
		inputName5: ParamTemplate<ParamType.STRING>;
		inputType6: ParamTemplate<ParamType.INTEGER>;
		inputName6: ParamTemplate<ParamType.STRING>;
		inputType7: ParamTemplate<ParamType.INTEGER>;
		inputName7: ParamTemplate<ParamType.STRING>;
		inputType8: ParamTemplate<ParamType.INTEGER>;
		inputName8: ParamTemplate<ParamType.STRING>;
		inputType9: ParamTemplate<ParamType.INTEGER>;
		inputName9: ParamTemplate<ParamType.STRING>;
		spare: ParamTemplate<ParamType.FOLDER>;
	};
} & typeof NodeParamsConfig;
declare class TypedSubnetJsParamsConfig extends TypedSubnetJsParamsConfig_base {}
declare class AbstractTypedSubnetJsNode<K extends NodeParamsConfig> extends TypedJsNode<K> {
	protected _childrenControllerContext: NodeContext;
	initializeNode(): void;
	protected _expectedInputTypes(): JsConnectionPointType[];
	protected _expectedInputName(index: number): string;
	protected _expectedOutputTypes(): JsConnectionPointType[];
	protected _expectedOutputName(index: number): string;
	childExpectedInputConnectionPointTypes(): JsConnectionPointType[];
	childExpectedOutputConnectionPointTypes(): JsConnectionPointType[];
	childExpectedInputConnectionPointName(index: number): string;
	childExpectedOutputConnectionPointName(index: number): string;
	createNode<S extends keyof JsNodeChildrenMap>(node_class: S, options?: NodeCreateOptions): JsNodeChildrenMap[S];
	createNode<K extends valueof<JsNodeChildrenMap>>(node_class: Constructor<K>, options?: NodeCreateOptions): K;
	children(): BaseJsNodeType[];
	nodesByType<K extends keyof JsNodeChildrenMap>(type: K): JsNodeChildrenMap[K][];
}
declare class TypedSubnetJsNode<K extends TypedSubnetJsParamsConfig> extends AbstractTypedSubnetJsNode<K> {
	initializeNode(): void;
	protected _inputTypeParams(): IntegerParam[];
	protected _inputNameParams(): StringParam[];
	setInputType(index: number, type: JsConnectionPointType): void;
	setInputName(index: number, inputName: string): void;
	protected _expectedInputsCount(): number;
	protected _expectedInputTypes(): JsConnectionPointType[];
	protected _expectedInputName(index: number): string;
	protected _expectedOutputTypes(): JsConnectionPointType[];
	protected _expectedOutputName(index: number): string;
}
declare const SubnetJsParamsConfig_base: {
	new (...args: any[]): {
		inputs: ParamTemplate<ParamType.FOLDER>;
		inputsCount: ParamTemplate<ParamType.INTEGER>;
		inputType0: ParamTemplate<ParamType.INTEGER>;
		inputName0: ParamTemplate<ParamType.STRING>;
		inputType1: ParamTemplate<ParamType.INTEGER>;
		inputName1: ParamTemplate<ParamType.STRING>;
		inputType2: ParamTemplate<ParamType.INTEGER>;
		inputName2: ParamTemplate<ParamType.STRING>;
		inputType3: ParamTemplate<ParamType.INTEGER>;
		inputName3: ParamTemplate<ParamType.STRING>;
		inputType4: ParamTemplate<ParamType.INTEGER>;
		inputName4: ParamTemplate<ParamType.STRING>;
		inputType5: ParamTemplate<ParamType.INTEGER>;
		inputName5: ParamTemplate<ParamType.STRING>;
		inputType6: ParamTemplate<ParamType.INTEGER>;
		inputName6: ParamTemplate<ParamType.STRING>;
		inputType7: ParamTemplate<ParamType.INTEGER>;
		inputName7: ParamTemplate<ParamType.STRING>;
		inputType8: ParamTemplate<ParamType.INTEGER>;
		inputName8: ParamTemplate<ParamType.STRING>;
		inputType9: ParamTemplate<ParamType.INTEGER>;
		inputName9: ParamTemplate<ParamType.STRING>;
		spare: ParamTemplate<ParamType.FOLDER>;
	};
} & typeof NodeParamsConfig;
declare class SubnetJsParamsConfig extends SubnetJsParamsConfig_base {}
declare class SubnetJsNode extends TypedSubnetJsNode<SubnetJsParamsConfig> {
	paramsConfig: SubnetJsParamsConfig;
	static type(): NetworkNodeType;
	inputNameForSubnetInput(index: number): string;
	outputNameForSubnetOutput(index: number): string;
}
declare class SubnetInputJsParamsConfig extends NodeParamsConfig {}
declare class SubnetInputJsNode extends TypedJsNode<SubnetInputJsParamsConfig> {
	paramsConfig: SubnetInputJsParamsConfig;
	static type(): NetworkChildNodeType;
	initializeNode(): void;
	parent(): SubnetJsNode | null;
	private _expectedOutputNames;
	protected _expectedOutputTypes(): JsConnectionPointType[];
	setLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class SubnetOutputJsParamsConfig extends NodeParamsConfig {}
declare class SubnetOutputJsNode extends TypedJsNode<SubnetOutputJsParamsConfig> {
	paramsConfig: SubnetOutputJsParamsConfig;
	static type(): Readonly<NetworkChildNodeType.OUTPUT>;
	initializeNode(): void;
	parent(): SubnetJsNode | null;
	protected _expectedInputName(index: number): string;
	protected _expectedInputTypes(): JsConnectionPointType[];
	setLines(shadersCollectionController: ShadersCollectionController): void;
}
declare const SubtractJsNode_base: typeof BaseMathFunctionJsNode;
declare class SubtractJsNode extends SubtractJsNode_base {}
declare class SwitchJsNode extends ParamlessTypedJsNode {
	static type(): string;
	static INPUT_INDEX_NAME: string;
	static OUTPUT_NAME: string;
	initializeNode(): void;
	protected _expectedInputName(index: number): string;
	protected _expectedOutputName(): string;
	protected _expectedInputTypes(): JsConnectionPointType[];
	protected _expectedOutputTypes(): JsConnectionPointType[];
	setLines(shadersCollectionController: ShadersCollectionController): void;
}
declare const TanJsNode_base: typeof BaseMathFunctionJsNode;
declare class TanJsNode extends TanJsNode_base {}
declare class TrackFaceJsParamsConfig extends NodeParamsConfig {
	faceIndex: ParamTemplate<ParamType.INTEGER>;
}
declare class TrackFaceJsNode extends TypedJsNode<TrackFaceJsParamsConfig> {
	readonly paramsConfig: TrackFaceJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	setTriggerableLines(shadersCollectionController: ShadersCollectionController): void;
	setLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class TrackHandJsParamsConfig extends NodeParamsConfig {
	handIndex: ParamTemplate<ParamType.INTEGER>;
}
declare class TrackHandJsNode extends TypedJsNode<TrackHandJsParamsConfig> {
	readonly paramsConfig: TrackHandJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	setTriggerableLines(shadersCollectionController: ShadersCollectionController): void;
	setLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class TriggerDelayJsParamsConfig extends NodeParamsConfig {
	/** @param delay (in milliseconds) */
	delay: ParamTemplate<ParamType.FLOAT>;
}
declare class TriggerDelayJsNode extends TypedJsNode<TriggerDelayJsParamsConfig> {
	readonly paramsConfig: TriggerDelayJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	setTriggerableLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class TriggerFilterJsParamsConfig extends NodeParamsConfig {
	/** @param If true, the trigger will be forwarded. If false, it will not be. */
	condition: ParamTemplate<ParamType.BOOLEAN>;
}
declare class TriggerFilterJsNode extends TypedJsNode<TriggerFilterJsParamsConfig> {
	readonly paramsConfig: TriggerFilterJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	setTriggerableLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class TriggerTwoWaySwitchJsParamsConfig extends NodeParamsConfig {
	/** @param if true, trigger will be forward through the 1st output. If false, it will be forwarded through the 2nd output. */
	condition: ParamTemplate<ParamType.BOOLEAN>;
}
declare class TriggerTwoWaySwitchJsNode extends TypedJsNode<TriggerTwoWaySwitchJsParamsConfig> {
	readonly paramsConfig: TriggerTwoWaySwitchJsParamsConfig;
	static type(): string;
	static OUTPUT_NAME_IF_TRUE: string;
	static OUTPUT_NAME_IF_FALSE: string;
	initializeNode(): void;
	setTriggerableLines(shadersCollectionController: ShadersCollectionController): void;
}
declare enum TwoWaySwitchJsNodeInputName {
	CONDITION = 'condition',
	IF_TRUE = 'ifTrue',
	IF_FALSE = 'ifFalse',
}
declare class TwoWaySwitchJsNode extends ParamlessTypedJsNode {
	static type(): string;
	initializeNode(): void;
	protected _expectedInputName(index: number): TwoWaySwitchJsNodeInputName;
	protected _expectedOutputName(): string;
	protected _expectedInputTypes(): JsConnectionPointType[];
	protected _expectedOutputTypes(): JsConnectionPointType[];
	setLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class Vector3AngleToJsParamsConfig extends NodeParamsConfig {
	/** @param vector 1 */
	v1: ParamTemplate<ParamType.VECTOR3>;
	/** @param vector 2 */
	v2: ParamTemplate<ParamType.VECTOR3>;
}
declare class Vector3AngleToJsNode extends TypedJsNode<Vector3AngleToJsParamsConfig> {
	paramsConfig: Vector3AngleToJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class Vector3ProjectJsParamsConfig extends NodeParamsConfig {
	/** @param vector3 */
	Vector3: ParamTemplate<ParamType.VECTOR3>;
}
declare class Vector3ProjectJsNode extends TypedJsNode<Vector3ProjectJsParamsConfig> {
	paramsConfig: Vector3ProjectJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class Vector3ProjectOnPlaneJsParamsConfig extends NodeParamsConfig {
	/** @param vector3 */
	Vector3: ParamTemplate<ParamType.VECTOR3>;
	/** @param planeNormal */
	planeNormal: ParamTemplate<ParamType.VECTOR3>;
}
declare class Vector3ProjectOnPlaneJsNode extends TypedJsNode<Vector3ProjectOnPlaneJsParamsConfig> {
	paramsConfig: Vector3ProjectOnPlaneJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class Vector3UnprojectJsParamsConfig extends NodeParamsConfig {
	/** @param vector3 */
	Vector3: ParamTemplate<ParamType.VECTOR3>;
}
declare class Vector3UnprojectJsNode extends TypedJsNode<Vector3UnprojectJsParamsConfig> {
	paramsConfig: Vector3UnprojectJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(shadersCollectionController: ShadersCollectionController): void;
}
export declare type AllowedType = JsConnectionPointType.VECTOR4 | JsConnectionPointType.VECTOR4_ARRAY;
declare class Vec4ToVec3ParamsJsConfig extends NodeParamsConfig {
	Vector4: ParamTemplate<ParamType.VECTOR4>;
}
declare class Vec4ToVec3JsNode extends TypedJsNode<Vec4ToVec3ParamsJsConfig> {
	paramsConfig: Vec4ToVec3ParamsJsConfig;
	static type(): string;
	initializeNode(): void;
	_expectedInputName(index: number): string;
	_expectedOutputName(index: number): string;
	protected _expectedInputTypes(): AllowedType[];
	protected _expectedOutputTypes(): JsConnectionPointType[];
	setLines(shadersCollectionController: ShadersCollectionController): void;
	private _setLinesAsVector4;
	private _setLinesAsVector4Array;
}
declare class Vector2JsParamsConfig extends NodeParamsConfig {
	/** @param vector value */
	Vector2: ParamTemplate<ParamType.VECTOR2>;
}
declare class Vector2JsNode extends TypedJsNode<Vector2JsParamsConfig> {
	paramsConfig: Vector2JsParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class Vector3JsParamsConfig extends NodeParamsConfig {
	/** @param vector value */
	Vector3: ParamTemplate<ParamType.VECTOR3>;
}
declare class Vector3JsNode extends TypedJsNode<Vector3JsParamsConfig> {
	paramsConfig: Vector3JsParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class Vector4JsParamsConfig extends NodeParamsConfig {
	/** @param vector value */
	Vector4: ParamTemplate<ParamType.VECTOR4>;
}
declare class Vector4JsNode extends TypedJsNode<Vector4JsParamsConfig> {
	paramsConfig: Vector4JsParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(shadersCollectionController: ShadersCollectionController): void;
}
export interface JsNodeChildrenMap {
	abs: AbsJsNode;
	add: AddJsNode;
	acos: AcosJsNode;
	and: AndJsNode;
	animationAction: AnimationActionJsNode;
	animationActionCrossFade: AnimationActionCrossFadeJsNode;
	animationActionFadeOut: AnimationActionFadeOutJsNode;
	animationActionFadeIn: AnimationActionFadeInJsNode;
	animationActionPlay: AnimationActionPlayJsNode;
	animationActionStop: AnimationActionStopJsNode;
	animationMixer: AnimationMixerJsNode;
	animationMixerUpdate: AnimationMixerUpdateJsNode;
	anyTrigger: AnyTriggerJsNode;
	arrayElement: ArrayElementJsNode;
	arrayLength: ArrayLengthJsNode;
	asin: AsinJsNode;
	atan: AtanJsNode;
	attribute: AttributeJsNode;
	boolToInt: BoolToIntJsNode;
	box3: Box3JsNode;
	catmullRomCurve3GetPoint: CatmullRomCurve3GetPointJsNode;
	ceil: CeilJsNode;
	clamp: ClampJsNode;
	code: CodeJsNode;
	compare: CompareJsNode;
	complement: ComplementJsNode;
	cookNode: CookNodeJsNode;
	cos: CosJsNode;
	cross: CrossJsNode;
	cursor: CursorJsNode;
	colorToVec3: ColorToVec3JsNode;
	constant: ConstantJsNode;
	debug: DebugJsNode;
	dot: DotJsNode;
	distance: DistanceJsNode;
	divide: DivideJsNode;
	easing: EasingJsNode;
	elementsToArray: ElementsToArrayJsNode;
	fit: FitJsNode;
	floatToColor: FloatToColorJsNode;
	floatToInt: FloatToIntJsNode;
	floatToVec2: FloatToVec2JsNode;
	floatToVec3: FloatToVec3JsNode;
	floatToVec4: FloatToVec4JsNode;
	floor: FloorJsNode;
	getBox3Property: GetBox3PropertyJsNode;
	getChildrenAttributes: GetChildrenAttributesJsNode;
	getChildrenPhysicsRBDProperties: GetChildrenPhysicsRBDPropertiesJsNode;
	getChildrenProperties: GetChildrenPropertiesJsNode;
	getDefaultCamera: GetDefaultCameraJsNode;
	getIntersectionProperty: GetIntersectionPropertyJsNode;
	getMaterial: GetMaterialJsNode;
	getObject: GetObjectJsNode;
	getObjectAttribute: GetObjectAttributeJsNode;
	getObjectChild: GetObjectChildJsNode;
	getObjectProperty: GetObjectPropertyJsNode;
	getObjectUserData: GetObjectUserDataJsNode;
	getObjectWorldPosition: GetObjectWorldPositionJsNode;
	getParent: GetParentJsNode;
	getPlaneProperty: GetPlanePropertyJsNode;
	getPhysicsRBDCapsuleProperty: GetPhysicsRBDCapsulePropertyJsNode;
	getPhysicsRBDConeProperty: GetPhysicsRBDConePropertyJsNode;
	getPhysicsRBDCylinderProperty: GetPhysicsRBDCylinderPropertyJsNode;
	getPhysicsRBDCuboidProperty: GetPhysicsRBDCuboidPropertyJsNode;
	getPhysicsRBDSphereProperty: GetPhysicsRBDSpherePropertyJsNode;
	getPhysicsRBDProperty: GetPhysicsRBDPropertyJsNode;
	getRayProperty: GetRayPropertyJsNode;
	getSibbling: GetSibblingJsNode;
	getSphereProperty: GetSpherePropertyJsNode;
	getTexture: GetTextureJsNode;
	getTrackedHandProperty: GetTrackedHandPropertyJsNode;
	getVideoProperty: GetVideoPropertyJsNode;
	getWebXRARSessionProperty: GetWebXRARSessionPropertyJsNode;
	getWebXRControllerProperty: GetWebXRControllerPropertyJsNode;
	getWebXRTrackedMarkerProperty: GetWebXRTrackedMarkerPropertyJsNode;
	globals: GlobalsJsNode;
	intToBool: IntToBoolJsNode;
	intToFloat: IntToFloatJsNode;
	length: LengthJsNode;
	lerp: LerpJsNode;
	manhattanDistance: ManhattanDistanceJsNode;
	max: MaxJsNode;
	maxLength: MaxLengthJsNode;
	min: MinJsNode;
	mix: MixJsNode;
	mult: MultJsNode;
	multAdd: MultAddJsNode;
	multScalar: MultScalarJsNode;
	nearestPosition: NearestPositionJsNode;
	negate: NegateJsNode;
	normalize: NormalizeJsNode;
	null: NullJsNode;
	object3DLocalToWorld: Object3DLocalToWorldJsNode;
	object3DWorldToLocal: Object3DWorldToLocalJsNode;
	object3DUpdateMatrix: Object3DUpdateMatrixJsNode;
	object3DUpdateWorldMatrix: Object3DUpdateWorldMatrixJsNode;
	objectDispatchEvent: ObjectDispatchEventJsNode;
	onChildAttributeUpdate: OnChildAttributeUpdateJsNode;
	onKey: OnKeyJsNode;
	onKeydown: OnKeydownJsNode;
	onKeypress: OnKeypressJsNode;
	onKeyup: OnKeyupJsNode;
	onManualTrigger: OnManualTriggerJsNode;
	onMapboxCameraMove: OnMapboxCameraMoveJsNode;
	onMapboxCameraMoveEnd: OnMapboxCameraMoveEndJsNode;
	onMapboxCameraMoveStart: OnMapboxCameraMoveStartJsNode;
	onObjectAttributeUpdate: OnObjectAttributeUpdateJsNode;
	onObjectClick: OnObjectClickJsNode;
	onObjectDispatchEvent: OnObjectDispatchEventJsNode;
	onObjectHover: OnObjectHoverJsNode;
	onObjectPointerdown: OnObjectPointerdownJsNode;
	onObjectPointerup: OnObjectPointerupJsNode;
	onPerformanceChange: OnPerformanceChangeJsNode;
	onPointerdown: OnPointerdownJsNode;
	onPointerup: OnPointerupJsNode;
	onScenePause: OnScenePauseJsNode;
	onScenePlay: OnScenePlayJsNode;
	onSceneReset: OnSceneResetJsNode;
	onTick: OnTickJsNode;
	onVideoEvent: OnVideoEventJsNode;
	onWebXRControllerEvent: OnWebXRControllerEventJsNode;
	or: OrJsNode;
	output: OutputJsNode;
	param: ParamJsNode;
	particlesSystemReset: ParticlesSystemResetJsNode;
	particlesSystemStepSimulation: ParticlesSystemStepSimulationJsNode;
	pauseAudioSource: PauseAudioSourceJsNode;
	physicsPlayerUpdate: PhysicsPlayerUpdateJsNode;
	physicsRBDAddForce: PhysicsRBDAddForceJsNode;
	physicsRBDAddForceAtPoint: PhysicsRBDAddForceAtPointJsNode;
	physicsRBDAddTorque: PhysicsRBDAddTorqueJsNode;
	physicsRBDApplyImpulse: PhysicsRBDApplyImpulseJsNode;
	physicsRBDApplyTorqueImpulse: PhysicsRBDApplyTorqueImpulseJsNode;
	physicsRBDApplyImpulseAtPoint: PhysicsRBDApplyImpulseAtPointJsNode;
	physicsRBDRemove: PhysicsRBDRemoveJsNode;
	physicsRBDResetAll: PhysicsRBDResetAllJsNode;
	physicsRBDResetForces: PhysicsRBDResetForcesJsNode;
	physicsRBDResetTorques: PhysicsRBDResetTorquesJsNode;
	physicsWorldReset: PhysicsWorldResetJsNode;
	physicsWorldStepSimulation: PhysicsWorldStepSimulationJsNode;
	plane: PlaneJsNode;
	playAnimation: PlayAnimationJsNode;
	playAudioSource: PlayAudioSourceJsNode;
	playInstrumentNote: PlayInstrumentNoteJsNode;
	playerUpdate: PlayerUpdateJsNode;
	pow: PowJsNode;
	pressButtonParam: PressButtonParamJsNode;
	rand: RandJsNode;
	random: RandomJsNode;
	ray: RayJsNode;
	rayFromCamera: RayFromCameraJsNode;
	rayFromCursor: RayFromCursorJsNode;
	rayIntersectBox: RayIntersectBoxJsNode;
	rayIntersectsBox: RayIntersectsBoxJsNode;
	rayIntersectObject: RayIntersectObjectJsNode;
	rayIntersectsObject: RayIntersectsObjectJsNode;
	rayDistanceToPlane: RayDistanceToPlaneJsNode;
	rayIntersectPlane: RayIntersectPlaneJsNode;
	rayIntersectsPlane: RayIntersectsPlaneJsNode;
	rayIntersectSphere: RayIntersectSphereJsNode;
	rayIntersectsSphere: RayIntersectsSphereJsNode;
	round: RoundJsNode;
	SDF2DRoundedX: SDF2DRoundedXJsNode;
	SDFBox: SDFBoxJsNode;
	SDFIntersect: SDFIntersectJsNode;
	SDFRevolution: SDFRevolutionJsNode;
	SDFSphere: SDFSphereJsNode;
	SDFSubtract: SDFSubtractJsNode;
	SDFUnion: SDFUnionJsNode;
	setGeometryInstanceAttribute: SetGeometryInstanceAttributeJsNode;
	setGeometryInstancePositions: SetGeometryInstancePositionsJsNode;
	setGeometryInstanceQuaternions: SetGeometryInstanceQuaternionsJsNode;
	setGeometryInstanceScales: SetGeometryInstanceScalesJsNode;
	setGeometryInstanceTransforms: SetGeometryInstanceTransformsJsNode;
	setGeometryPositions: SetGeometryPositionsJsNode;
	setMaterialColor: SetMaterialColorJsNode;
	setMaterialEmissiveColor: SetMaterialEmissiveColorJsNode;
	setMaterialOpacity: SetMaterialOpacityJsNode;
	setMaterialUniform: SetMaterialUniformJsNode;
	setObjectAttribute: SetObjectAttributeJsNode;
	setObjectCastShadow: SetObjectCastShadowJsNode;
	setObjectFrustumCulled: SetObjectFrustumCulledJsNode;
	setObjectLookAt: SetObjectLookAtJsNode;
	setObjectMaterial: SetObjectMaterialJsNode;
	setObjectMaterialColor: SetObjectMaterialColorJsNode;
	setObjectMatrix: SetObjectMatrixJsNode;
	setObjectMatrixAutoUpdate: SetObjectMatrixAutoUpdateJsNode;
	setObjectPosition: SetObjectPositionJsNode;
	setObjectPolarTransform: SetObjectPolarTransformJsNode;
	setObjectRotation: SetObjectRotationJsNode;
	setObjectReceiveShadow: SetObjectReceiveShadowJsNode;
	setObjectScale: SetObjectScaleJsNode;
	setObjectVisible: SetObjectVisibleJsNode;
	setParam: SetParamJsNode;
	setPerspectiveCameraFov: SetPerspectiveCameraFovJsNode;
	setPerspectiveCameraNearFar: SetPerspectiveCameraNearFarJsNode;
	setPhysicsRBDAngularVelocity: SetPhysicsRBDAngularVelocityJsNode;
	setPhysicsRBDLinearVelocity: SetPhysicsRBDLinearVelocityJsNode;
	setPhysicsRBDPosition: SetPhysicsRBDPositionJsNode;
	setPhysicsRBDRotation: SetPhysicsRBDRotationJsNode;
	setPhysicsRBDCapsuleProperty: SetPhysicsRBDCapsulePropertyJsNode;
	setPhysicsRBDConeProperty: SetPhysicsRBDConePropertyJsNode;
	setPhysicsRBDCylinderProperty: SetPhysicsRBDCylinderPropertyJsNode;
	setPhysicsRBDCuboidProperty: SetPhysicsRBDCuboidPropertyJsNode;
	setPhysicsRBDSphereProperty: SetPhysicsRBDSpherePropertyJsNode;
	setPhysicsWorldGravity: SetPhysicsWorldGravityJsNode;
	setPlayerInput: SetPlayerInputJsNode;
	setSpotLightIntensity: SetSpotLightIntensityJsNode;
	setViewer: SetViewerJsNode;
	sign: SignJsNode;
	sin: SinJsNode;
	smoothstep: SmoothstepJsNode;
	sphere: SphereJsNode;
	sqrt: SqrtJsNode;
	subnet: SubnetJsNode;
	subnetInput: SubnetInputJsNode;
	subnetOutput: SubnetOutputJsNode;
	subtract: SubtractJsNode;
	switch: SwitchJsNode;
	tan: TanJsNode;
	trackFace: TrackFaceJsNode;
	trackHand: TrackHandJsNode;
	triggerDelay: TriggerDelayJsNode;
	triggerFilter: TriggerFilterJsNode;
	triggerTwoWaySwitch: TriggerTwoWaySwitchJsNode;
	twoWaySwitch: TwoWaySwitchJsNode;
	vector3AngleTo: Vector3AngleToJsNode;
	vector3Project: Vector3ProjectJsNode;
	vector3ProjectOnPlane: Vector3ProjectOnPlaneJsNode;
	vector3Unproject: Vector3UnprojectJsNode;
	vec2ToFloat: Vec2ToFloatJsNode;
	vec2ToVec3: Vec2ToVec3JsNode;
	vec3ToColor: Vec3ToColorJsNode;
	vec3ToFloat: Vec3ToFloatJsNode;
	vec3ToVec2: Vec3ToVec2JsNode;
	vec3ToVec4: Vec3ToVec4JsNode;
	vec4ToFloat: Vec4ToFloatJsNode;
	vec4ToVec3: Vec4ToVec3JsNode;
	vector2: Vector2JsNode;
	vector3: Vector3JsNode;
	vector4: Vector4JsNode;
}
export interface MaterialData {
	color?: boolean;
	lights?: boolean;
}
export interface ToJsonOptions {
	node: BaseNodeType;
	suffix: string;
}
export interface DataObjectWithoutShaders {}
export interface PersistedConfigWithShaders extends DataObjectWithoutShaders {
	shaders?: PolyDictionary<string>;
	functionBody?: string;
}
declare abstract class BasePersistedConfig {
	protected node: BaseNodeType;
	constructor(node: BaseNodeType);
	abstract toData(): Promise<PersistedConfigWithShaders | void>;
	load(data: object): void;
	toDataWithoutShaders(): Promise<DataObjectWithoutShaders | void>;
	protected _materialToJson(material: Material, options: ToJsonOptions): object | undefined;
	private _withPreparedMaterial;
	private _withUnassignedOnBeforeCompileData;
	private _withUnassignedUniformTextures;
	private _withUnassignedBasePropertyTextures;
	protected _loadMaterial(data: MaterialData): ShaderMaterialWithCustomMaterials | undefined;
	private mat4ToMat3;
}
export declare type RegisterableVariable =
	| Box3
	| Color
	| Plane
	| Quaternion
	| Matrix4
	| Ray
	| Sphere
	| Vector2
	| Vector3
	| Vector4
	| PrimitiveArray<PrimitiveArrayElement>
	| VectorArray<VectorArrayElement>;
declare class PrimitiveArray<V extends PrimitiveArrayElement> {
	protected _elements: V[];
	constructor(_elements: V[]);
	elements(): V[];
	clone(): V[];
}
declare class VectorArray<V extends VectorArrayElement> {
	protected _elements: V[];
	constructor(_elements: V[]);
	elements(): V[];
	clone(): V[];
}
declare enum SerializedVariableType {
	Box3 = 'Box3',
	Color = 'Color',
	Matrix4 = 'Matrix4',
	Plane = 'Plane',
	Quaternion = 'Quaternion',
	Ray = 'Ray',
	Sphere = 'Sphere',
	Vector2 = 'Vector2',
	Vector3 = 'Vector3',
	Vector4 = 'Vector4',
	boolean_Array = 'boolean[]',
	number_Array = 'number[]',
	string_Array = 'string[]',
	Color_Array = 'Color[]',
	Matrix4_Array = 'Matrix4[]',
	Quaternion_Array = 'Quaternion[]',
	Vector2_Array = 'Vector2[]',
	Vector3_Array = 'Vector3[]',
	Vector4_Array = 'Vector4[]',
}
export interface SerializedDataByType {
	[SerializedVariableType.Box3]: {
		min: Number3;
		max: Number3;
	};
	[SerializedVariableType.Color]: Number3;
	[SerializedVariableType.Matrix4]: Number16;
	[SerializedVariableType.Plane]: {
		normal: Number3;
		constant: number;
	};
	[SerializedVariableType.Quaternion]: Number4;
	[SerializedVariableType.Ray]: {
		origin: Number3;
		direction: Number3;
	};
	[SerializedVariableType.Sphere]: {
		center: Number3;
		radius: number;
	};
	[SerializedVariableType.Vector2]: Number2;
	[SerializedVariableType.Vector3]: Number3;
	[SerializedVariableType.Vector4]: Number4;
	[SerializedVariableType.boolean_Array]: boolean[];
	[SerializedVariableType.number_Array]: number[];
	[SerializedVariableType.string_Array]: string[];
	[SerializedVariableType.Color_Array]: Number3[];
	[SerializedVariableType.Matrix4_Array]: Number16[];
	[SerializedVariableType.Quaternion_Array]: Number4[];
	[SerializedVariableType.Vector2_Array]: Number2[];
	[SerializedVariableType.Vector3_Array]: Number3[];
	[SerializedVariableType.Vector4_Array]: Number4[];
}
export interface SerializedVariable<T extends SerializedVariableType> {
	type: SerializedVariableType;
	data: SerializedDataByType[T];
}
export declare type Listener = () => void;
declare class addAudioStopEventListener extends NamedFunction3<[string, Listener, ActorEvaluator]> {
	static type(): string;
	func(nodePath: string, listener: Listener, evaluator: ActorEvaluator): void;
}
declare class playAudioSource extends ObjectNamedFunction1<[string]> {
	static type(): string;
	func(object3D: Object3D, nodePath: string): void;
}
declare class pauseAudioSource extends ObjectNamedFunction1<[string]> {
	static type(): string;
	func(object3D: Object3D, nodePath: string): void;
}
declare class playInstrumentNote extends ObjectNamedFunction3<[string, string, number]> {
	static type(): string;
	func(object3D: Object3D, nodePath: string, note: string, duration: number): void;
}
declare class addNumber extends NamedFunction<Array<number>, Array<string>> {
	static type(): string;
	func(...args: Array<number>): number;
}
export declare type AvailableItem = Vector2 | Vector3 | Vector4;
declare class addVector<V extends AvailableItem> extends NamedFunction<Array<V>, Array<string>> {
	static type(): string;
	func(...args: Array<V>): V;
}
declare class addVectorNumber<V extends AvailableItem> extends NamedFunction2<[V, number]> {
	static type(): string;
	func(vector: V, number: number): V;
}
declare enum VideoEvent {
	PLAY = 'play',
	PAUSE = 'pause',
	TIME_UPDATE = 'timeupdate',
	VOLUME_CHANGE = 'volumechange',
}
export declare type CallbackByVideoEvent = Record<VideoEvent, NodeEventListener>;
declare class addVideoEventListener extends NamedFunction3<[string, CallbackByVideoEvent, ActorEvaluator]> {
	static type(): string;
	func(nodePath: string, listeners: CallbackByVideoEvent, evaluator: ActorEvaluator): void;
}
declare class getVideoPropertyCurrentTime extends NamedFunction1<[string]> {
	static type(): string;
	func(nodePath: string): number;
}
declare class getVideoPropertyDuration extends NamedFunction1<[string]> {
	static type(): string;
	func(nodePath: string): number;
}
declare class getVideoPropertyPlaying extends NamedFunction1<[string]> {
	static type(): string;
	func(nodePath: string): boolean;
}
declare class getVideoPropertyMuted extends NamedFunction1<[string]> {
	static type(): string;
	func(nodePath: string): boolean;
}
declare class andArrays extends NamedFunction1<[Array<boolean[]>]> {
	static type(): string;
	func(arrays: Array<boolean[]>): boolean;
}
declare class andBooleans extends NamedFunction1<[boolean[]]> {
	static type(): string;
	func(arrays: boolean[]): boolean;
}
declare class orArrays extends NamedFunction1<[Array<boolean[]>]> {
	static type(): string;
	func(arrays: Array<boolean[]>): boolean;
}
declare class orBooleans extends NamedFunction1<[boolean[]]> {
	static type(): string;
	func(arrays: boolean[]): boolean;
}
export declare type GetAnimationAction = () => AnimationAction;
declare class getAnimationMixer extends ObjectNamedFunction0 {
	static type(): string;
	func(object3D: Object3D): AnimationMixer;
}
declare class animationMixerUpdate extends ObjectNamedFunction0 {
	static type(): string;
	func(object3D: Object3D): void;
}
declare class getAnimationAction extends NamedFunction3<[AnimationMixer, string, boolean]> {
	static type(): string;
	func(mixer: AnimationMixer, clipName: string, autoPlay: boolean): AnimationAction;
}
declare class animationActionPlay extends NamedFunction1<[AnimationAction]> {
	static type(): string;
	func(action: AnimationAction): void;
}
declare class animationActionStop extends NamedFunction1<[AnimationAction]> {
	static type(): string;
	func(action: AnimationAction): void;
}
declare class animationActionFadeIn extends NamedFunction5<[AnimationAction, number, boolean, boolean, boolean]> {
	static type(): string;
	func(
		action: AnimationAction,
		duration: number,
		fadeOutOtherActions: boolean,
		warp: boolean,
		startOnFromActionEnd: boolean
	): void;
}
declare class animationActionFadeOut extends NamedFunction2<[AnimationAction, number]> {
	static type(): string;
	func(action: AnimationAction, duration: number): void;
}
declare class animationActionCrossFade extends NamedFunction5<
	[AnimationAction, GetAnimationAction, number, boolean, boolean]
> {
	static type(): string;
	func(
		actionFrom: AnimationAction,
		actionToGet: GetAnimationAction,
		duration: number,
		warp: boolean,
		startOnFromActionEnd: boolean
	): void;
}
declare class arrayLength extends BaseNamedFunction {
	static type(): string;
	func(array: Array<any>): number;
	asString(elements: string): string;
}
declare class elementsToArrayPrimitive<T extends PrimitiveArrayElement> extends BaseNamedFunction {
	static type(): string;
	func(src: Array<T>, target: Array<T>): Array<T>;
	asString(elements: string, target: string): string;
}
declare class elementsToArrayVector<T extends VectorArrayElement> extends BaseNamedFunction {
	static type(): string;
	func(src: Array<T>, target: Array<T>): Array<T>;
	asString(elements: string, target: string): string;
}
declare class arrayElementPrimitive<T extends PrimitiveArrayElement> extends BaseNamedFunction {
	static type(): string;
	func(src: Array<T>, index: number): T;
	asString(src: string, index: string): string;
}
declare class arrayElementVector extends BaseNamedFunction {
	static type(): string;
	func<T extends VectorArrayElement>(src: Array<T>, index: number, target: T): T;
	asString(src: string, index: string, target: string): string;
}
declare class boolToInt extends NamedFunction1<[boolean]> {
	static type(): string;
	func(b: boolean): number;
}
declare class intToBool extends NamedFunction1<[number]> {
	static type(): string;
	func(v: number): boolean;
}
declare class floatToInt extends NamedFunction1<[number]> {
	static type(): string;
	func(v: number): number;
}
declare class intToFloat extends NamedFunction1<[number]> {
	static type(): string;
	func(v: number): number;
}
declare class floatToColor extends NamedFunction4<[number, number, number, Color]> {
	static type(): string;
	func(r: number, g: number, b: number, target: Color): Color;
}
declare class floatToVec2 extends NamedFunction3<[number, number, Vector2]> {
	static type(): string;
	func(x: number, y: number, target: Vector2): Vector2;
}
declare class floatToVec3 extends NamedFunction4<[number, number, number, Vector3]> {
	static type(): string;
	func(x: number, y: number, z: number, target: Vector3): Vector3;
}
declare class floatToVec4 extends NamedFunction5<[number, number, number, number, Vector4]> {
	static type(): string;
	func(x: number, y: number, z: number, w: number, target: Vector4): Vector4;
}
declare class vec2ToVec3 extends NamedFunction3<[Vector2, number, Vector3]> {
	static type(): string;
	func(src: Vector2, z: number, target: Vector3): Vector3;
}
declare class vec3ToVec4 extends NamedFunction3<[Vector3, number, Vector4]> {
	static type(): string;
	func(src: Vector3, w: number, target: Vector4): Vector4;
}
declare class vec3ToColor extends NamedFunction2<[Vector3, Color]> {
	static type(): string;
	func(src: Vector3, target: Color): Color;
}
declare class colorToVec3 extends NamedFunction2<[Color, Vector3]> {
	static type(): string;
	func(src: Color, target: Vector3): Vector3;
}
declare class box3Set extends NamedFunction3<[Vector3, Vector3, Box3]> {
	static type(): string;
	func(min: Vector3, max: Vector3, target: Box3): Box3;
}
declare class getBox3Min extends NamedFunction2<[Box3, Vector3]> {
	static type(): string;
	func(box3: Box3, target: Vector3): Vector3;
}
declare class getBox3Max extends NamedFunction2<[Box3, Vector3]> {
	static type(): string;
	func(box3: Box3, target: Vector3): Vector3;
}
declare class catmullRomCurve3GetPoint extends NamedFunction3<[CatmullRomCurve3, number, Vector3]> {
	static type(): string;
	func(curve: CatmullRomCurve3, t: number, target: Vector3): Vector3;
}
declare class clamp extends NamedFunction3<[number, number, number]> {
	static type(): string;
	func(value: number, min: number, max: number): number;
}
declare class complement extends NamedFunction1<[number]> {
	static type(): string;
	func(value: number): number;
}
declare class fit extends NamedFunction5<[number, number, number, number, number]> {
	static type(): string;
	func(value: number, srcMin: number, srcMax: number, destMin: number, destMax: number): number;
}
declare class fitClamp extends NamedFunction5<[number, number, number, number, number]> {
	static type(): string;
	func(value: number, srcMin: number, srcMax: number, destMin: number, destMax: number): number;
}
declare class mix extends NamedFunction3<[number, number, number]> {
	static type(): string;
	func(value0: number, value1: number, blend: number): number;
}
declare class multAdd extends NamedFunction4<[number, number, number, number]> {
	static type(): string;
	func(value: number, preAdd: number, mult: number, postAdd: number): number;
}
declare class negate<T extends number | boolean> extends NamedFunction1<[T]> {
	static type(): string;
	func(value: T): T;
}
declare class rand extends NamedFunction2<[number, number]> {
	static type(): string;
	func(value0: number, value1: number): number;
}
declare class random extends NamedFunction0 {
	static type(): string;
	func(): number;
}
declare class smoothstep extends NamedFunction3<[number, number, number]> {
	static type(): string;
	func(value: number, min: number, max: number): number;
}
declare class colorSetRGB extends NamedFunction4<[Color, number, number, number]> {
	static type(): string;
	func(color: Color, r: number, g: number, b: number): Color;
}
declare class cookNode extends NamedFunction1<[string]> {
	static type(): string;
	func(nodePath: string): void;
}
declare class crossVector2 extends NamedFunction2<[Vector2, Vector2]> {
	static type(): string;
	func(v1: Vector2, v2: Vector2): number;
}
declare class crossVector3 extends NamedFunction3<[Vector3, Vector3, Vector3]> {
	static type(): string;
	func(v1: Vector3, v2: Vector3, target: Vector3): Vector3;
}
declare enum SceneEvent {
	MAX_FRAME_UPDATED = 'scene_maxFrameUpdated',
	REALTIME_STATUS_UPDATED = 'scene_realtime_status_updated',
	FRAME_UPDATED = 'scene_frame_updated',
	PLAY_STATE_UPDATED = 'scene_play_state_updated',
}
declare enum NodeEvent {
	CREATED = 'node_created',
	DELETED = 'node_deleted',
	NAME_UPDATED = 'node_name_update',
	OVERRIDE_CLONABLE_STATE_UPDATE = 'node_override_clonable_state_update',
	NAMED_OUTPUTS_UPDATED = 'node_named_outputs_updated',
	NAMED_INPUTS_UPDATED = 'node_named_inputs_updated',
	INPUTS_UPDATED = 'node_inputs_updated',
	PARAMS_UPDATED = 'node_params_updated',
	UI_DATA_POSITION_UPDATED = 'node_ui_data_position_updated',
	UI_DATA_COMMENT_UPDATED = 'node_ui_data_comment_updated',
	ERROR_UPDATED = 'node_error_updated',
	FLAG_BYPASS_UPDATED = 'bypass_flag_updated',
	FLAG_DISPLAY_UPDATED = 'display_flag_updated',
	FLAG_OPTIMIZE_UPDATED = 'optimize_flag_updated',
	SELECTION_UPDATED = 'selection_updated',
	POLY_NODE_LOCK_STATE_UPDATED = 'lock_state_updated',
}
export interface ActorEvaluatorDebugOptions {
	object3D: Object3D;
	nodePath: string;
	value: JsDataType;
}
export interface EventsListener {
	processEvents: (emitter: CoreGraphNode, event: SceneEvent | NodeEvent | ParamEvent, data?: any) => void;
	processActorEvaluator(evaluator: ActorEvaluator): ActorEvaluator;
	actorEvaluatorDebug(options: ActorEvaluatorDebugOptions): void;
}
export declare type OnAddListenerCallback = () => void;
declare class DispatchController {
	private scene;
	private _onAddListenerCallbacks;
	constructor(scene: PolyScene);
	private _eventsListener;
	setListener(eventsListener: EventsListener): void;
	onAddListener(callback: OnAddListenerCallback): void;
	private _runOnAddListenerCallbacks;
	dispatch(emitter: CoreGraphNode, event: SceneEvent | NodeEvent | ParamEvent, data?: any): void;
	emitAllowed(): boolean;
	processActorEvaluator(evaluator: ActorEvaluator): ActorEvaluator | undefined;
	actorEvaluatorDebug(options: ActorEvaluatorDebugOptions): void | undefined;
}
declare class debug<T extends JsDataType> extends ObjectNamedFunction2<[string, T]> {
	static type(): string;
	func(object3D: Object3D, nodePath: string, input: T): T;
}
declare class distanceVector2 extends NamedFunction2<[Vector2, Vector2]> {
	static type(): string;
	func(v1: Vector2, v2: Vector2): number;
}
declare class distanceVector3 extends NamedFunction2<[Vector3, Vector3]> {
	static type(): string;
	func(v1: Vector3, v2: Vector3): number;
}
declare class divideNumber extends NamedFunction<Array<number>, Array<string>> {
	static type(): string;
	func(...args: Array<number>): number;
}
export declare type AvailableItem = Vector2 | Vector3 | Vector4;
declare class divideVectorNumber<V extends AvailableItem> extends NamedFunction2<[V, number]> {
	static type(): string;
	func(vector: V, number: number): V;
}
declare class dotVector2 extends NamedFunction2<[Vector2, Vector2]> {
	static type(): string;
	func(v1: Vector2, v2: Vector2): number;
}
declare class dotVector3 extends NamedFunction2<[Vector3, Vector3]> {
	static type(): string;
	func(v1: Vector3, v2: Vector3): number;
}
declare class easeI2 extends NamedFunction1<[number]> {
	static type(): string;
	func: (num: number) => number;
}
declare class easeO2 extends NamedFunction1<[number]> {
	static type(): string;
	func: (num: number) => number;
}
declare class easeIO2 extends NamedFunction1<[number]> {
	static type(): string;
	func: (num: number) => number;
}
declare class easeI3 extends NamedFunction1<[number]> {
	static type(): string;
	func: (num: number) => number;
}
declare class easeO3 extends NamedFunction1<[number]> {
	static type(): string;
	func: (num: number) => number;
}
declare class easeIO3 extends NamedFunction1<[number]> {
	static type(): string;
	func: (num: number) => number;
}
declare class easeI4 extends NamedFunction1<[number]> {
	static type(): string;
	func: (num: number) => number;
}
declare class easeO4 extends NamedFunction1<[number]> {
	static type(): string;
	func: (num: number) => number;
}
declare class easeIO4 extends NamedFunction1<[number]> {
	static type(): string;
	func: (num: number) => number;
}
declare class easeSinI extends NamedFunction1<[number]> {
	static type(): string;
	func: (num: number) => number;
}
declare class easeSinO extends NamedFunction1<[number]> {
	static type(): string;
	func: (num: number) => number;
}
declare class easeSinIO extends NamedFunction1<[number]> {
	static type(): string;
	func: (num: number) => number;
}
declare class easeElasticI extends NamedFunction1<[number]> {
	static type(): string;
	func: (num: number) => number;
}
declare class easeElasticO extends NamedFunction1<[number]> {
	static type(): string;
	func: (num: number) => number;
}
declare class easeElasticIO extends NamedFunction1<[number]> {
	static type(): string;
	func: (num: number) => number;
}
declare class getActorNodeParamValue extends NamedFunction1<[string]> {
	static type(): string;
	func(
		paramName: string
	):
		| string
		| number
		| boolean
		| Color
		| TypedParamPathParamValue
		| TypedNodePathParamValue
		| RampValue
		| Vector2
		| Vector3
		| Vector4
		| null
		| undefined;
}
declare class getChildrenAttributes extends ObjectNamedFunction3<[string, string, Array<AttribValue>]> {
	static type(): string;
	func(object3D: Object3D, attribName: string, type: ParamConvertibleJsType, values: AttribValue[]): AttribValue[];
}
declare class getChildrenAttributesPrevious extends ObjectNamedFunction3<[string, string, Array<AttribValue>]> {
	static type(): string;
	func(object3D: Object3D, attribName: string, type: ParamConvertibleJsType, values: AttribValue[]): AttribValue[];
}
declare class getChildrenAttributesRef extends ObjectNamedFunction3<[string, string, Array<Ref<AttribValue>>]> {
	static type(): string;
	func(
		object3D: Object3D,
		attribName: string,
		type: ParamConvertibleJsType,
		values: Ref<AttribValue>[]
	): Ref<AttribValue>[];
}
declare class physicsWorldReset extends ObjectNamedFunction0 {
	static type(): string;
	func(object3D: Object3D): void;
}
declare class physicsWorldStepSimulation extends ObjectNamedFunction0 {
	constructor(node: BaseNodeType, shadersCollectionController?: ShadersCollectionController);
	static type(): string;
	func(object3D: Object3D): void;
}
declare class setPhysicsWorldGravity extends ObjectNamedFunction2<[Vector3, number]> {
	static type(): string;
	func(object3D: Object3D, gravity: Vector3, lerp: number): void;
}
declare class getPhysicsRBDCapsuleRadius extends ObjectNamedFunction0 {
	static type(): string;
	func(object3D: Object3D): number;
}
declare class getPhysicsRBDCapsuleHeight extends ObjectNamedFunction0 {
	static type(): string;
	func(object3D: Object3D): number;
}
declare class getPhysicsRBDConeHeight extends ObjectNamedFunction0 {
	static type(): string;
	func(object3D: Object3D): number;
}
declare class getPhysicsRBDConeRadius extends ObjectNamedFunction0 {
	static type(): string;
	func(object3D: Object3D): number;
}
declare class getPhysicsRBDCuboidSizes extends ObjectNamedFunction1<[Vector3]> {
	static type(): string;
	func(object3D: Object3D, target: Vector3): Vector3;
}
declare class getPhysicsRBDCylinderHeight extends ObjectNamedFunction0 {
	static type(): string;
	func(object3D: Object3D): number;
}
declare class getPhysicsRBDCylinderRadius extends ObjectNamedFunction0 {
	static type(): string;
	func(object3D: Object3D): number;
}
declare class getPhysicsRBDSphereRadius extends ObjectNamedFunction0 {
	static type(): string;
	func(object3D: Object3D): number;
}
declare class setPhysicsRBDCapsuleProperty extends ObjectNamedFunction3<[number, number, boolean]> {
	static type(): string;
	func(object3D: Object3D, scale: number, lerp: number, updateMatrix: boolean): void;
}
declare class setPhysicsRBDConeProperty extends ObjectNamedFunction4<[number, number, number, boolean]> {
	static type(): string;
	func(object3D: Object3D, radius: number, height: number, lerp: number, updateMatrix: boolean): void;
}
declare class setPhysicsRBDCuboidProperty extends ObjectNamedFunction4<[Vector3, number, number, boolean]> {
	static type(): string;
	func(object3D: Object3D, sizes: Vector3, size: number, lerp: number, updateMatrix: boolean): void;
}
declare class setPhysicsRBDCylinderProperty extends ObjectNamedFunction4<[number, number, number, boolean]> {
	static type(): string;
	func(object3D: Object3D, radius: number, height: number, lerp: number, updateMatrix: boolean): void;
}
declare class setPhysicsRBDSphereProperty extends ObjectNamedFunction3<[number, number, boolean]> {
	static type(): string;
	func(object3D: Object3D, radius: number, lerp: number, updateMatrix: boolean): void;
}
declare class getPhysicsRBDAngularVelocity extends ObjectNamedFunction1<[Vector3]> {
	static type(): string;
	func(object3D: Object3D, target: Vector3): Vector3;
}
declare class getChildrenPhysicsRBDPropertiesAngularVelocity extends ObjectNamedFunction1<[Array<Vector3>]> {
	static type(): string;
	func(object3D: Object3D, values: Vector3[]): Vector3[];
}
declare class getPhysicsRBDLinearVelocity extends ObjectNamedFunction1<[Vector3]> {
	static type(): string;
	func(object3D: Object3D, target: Vector3): Vector3;
}
declare class getChildrenPhysicsRBDPropertiesLinearVelocity extends ObjectNamedFunction1<[Array<Vector3>]> {
	static type(): string;
	func(object3D: Object3D, values: Vector3[]): Vector3[];
}
declare class getPhysicsRBDAngularDamping extends ObjectNamedFunction0 {
	static type(): string;
	func(object3D: Object3D): number;
}
declare class getChildrenPhysicsRBDPropertiesAngularDamping extends ObjectNamedFunction1<[Array<number>]> {
	static type(): string;
	func(object3D: Object3D, values: number[]): number[];
}
declare class getPhysicsRBDLinearDamping extends ObjectNamedFunction0 {
	static type(): string;
	func(object3D: Object3D): number;
}
declare class getChildrenPhysicsRBDPropertiesLinearDamping extends ObjectNamedFunction1<[Array<number>]> {
	static type(): string;
	func(object3D: Object3D, values: number[]): number[];
}
declare class getPhysicsRBDIsSleeping extends ObjectNamedFunction0 {
	static type(): string;
	func(object3D: Object3D): boolean;
}
declare class getChildrenPhysicsRBDPropertiesIsSleeping extends ObjectNamedFunction1<[Array<boolean>]> {
	static type(): string;
	func(object3D: Object3D, values: boolean[]): boolean[];
}
declare class getPhysicsRBDIsMoving extends ObjectNamedFunction0 {
	static type(): string;
	func(object3D: Object3D): boolean;
}
declare class getChildrenPhysicsRBDPropertiesIsMoving extends ObjectNamedFunction1<[Array<boolean>]> {
	static type(): string;
	func(object3D: Object3D, values: boolean[]): boolean[];
}
declare class setPhysicsRBDPosition extends ObjectNamedFunction2<[Vector3, number]> {
	static type(): string;
	func(object3D: Object3D, position: Vector3, lerp: number): void;
}
declare class setPhysicsRBDRotation extends ObjectNamedFunction2<[Quaternion, number]> {
	static type(): string;
	func(object3D: Object3D, quat: Quaternion, lerp: number): void;
}
declare class setPhysicsRBDAngularVelocity extends ObjectNamedFunction2<[Vector3, number]> {
	static type(): string;
	func(object3D: Object3D, velocity: Vector3, lerp: number): void;
}
declare class setPhysicsRBDLinearVelocity extends ObjectNamedFunction2<[Vector3, number]> {
	static type(): string;
	func(object3D: Object3D, velocity: Vector3, lerp: number): void;
}
declare class physicsRBDAddForce extends ObjectNamedFunction1<[Vector3]> {
	static type(): string;
	func(object3D: Object3D, force: Vector3): void;
}
declare class physicsRBDAddForceAtPoint extends ObjectNamedFunction2<[Vector3, Vector3]> {
	static type(): string;
	func(object3D: Object3D, force: Vector3, point: Vector3): void;
}
declare class physicsRBDAddTorque extends ObjectNamedFunction1<[Vector3]> {
	static type(): string;
	func(object3D: Object3D, force: Vector3): void;
}
declare class physicsRBDApplyTorqueImpulse extends ObjectNamedFunction1<[Vector3]> {
	static type(): string;
	func(object3D: Object3D, impulse: Vector3): void;
}
declare class physicsRBDApplyImpulse extends ObjectNamedFunction1<[Vector3]> {
	static type(): string;
	func(object3D: Object3D, impulse: Vector3): void;
}
declare class physicsRBDApplyImpulseAtPoint extends ObjectNamedFunction2<[Vector3, Vector3]> {
	static type(): string;
	func(object3D: Object3D, impulse: Vector3, point: Vector3): void;
}
declare class physicsRBDRemove extends ObjectNamedFunction0 {
	static type(): string;
	func(object3D: Object3D): void;
}
declare class physicsRBDResetAll extends ObjectNamedFunction1<[boolean]> {
	static type(): string;
	func(object3D: Object3D, wakeup: boolean): void;
}
declare class physicsRBDResetForces extends ObjectNamedFunction1<[boolean]> {
	static type(): string;
	func(object3D: Object3D, wakeup: boolean): void;
}
declare class physicsRBDResetTorques extends ObjectNamedFunction1<[boolean]> {
	static type(): string;
	func(object3D: Object3D, wakeup: boolean): void;
}
export interface PropertyType {
	position: Vector3;
	quaternion: Quaternion;
	scale: Vector3;
	matrix: Matrix4;
	visible: boolean;
	castShadow: boolean;
	receiveShadow: boolean;
	frustumCulled: boolean;
	up: Vector3;
	matrixAutoUpdate: boolean;
	material: Material;
}
declare class getObjectProperty extends ObjectNamedFunction1<[string]> {
	static type(): string;
	func<K extends keyof PropertyType>(object3D: Object3D, propertyName: K): PropertyType[K];
}
declare class getObjectWorldPosition extends ObjectNamedFunction1<[Vector3]> {
	static type(): string;
	func(object3D: Object3D, target: Vector3): Vector3;
}
declare class object3DLocalToWorld extends ObjectNamedFunction2<[Vector3, Vector3]> {
	static type(): string;
	func(object3D: Object3D, position: Vector3, target: Vector3): Vector3;
}
declare class object3DWorldToLocal extends ObjectNamedFunction2<[Vector3, Vector3]> {
	static type(): string;
	func(object3D: Object3D, position: Vector3, target: Vector3): Vector3;
}
declare class getChildrenPropertiesPosition extends ObjectNamedFunction1<[Array<Vector3>]> {
	static type(): string;
	func: (object3D: Object3D<Event>, targets: Vector3[]) => Vector3[];
}
declare class getChildrenPropertiesQuaternion extends ObjectNamedFunction1<[Array<Quaternion>]> {
	static type(): string;
	func: (object3D: Object3D<Event>, targets: Quaternion[]) => Quaternion[];
}
declare class getChildrenPropertiesScale extends ObjectNamedFunction1<[Array<Vector3>]> {
	static type(): string;
	func: (object3D: Object3D<Event>, targets: Vector3[]) => Vector3[];
}
declare class getChildrenPropertiesUp extends ObjectNamedFunction1<[Array<Vector3>]> {
	static type(): string;
	func: (object3D: Object3D<Event>, targets: Vector3[]) => Vector3[];
}
declare class getChildrenPropertiesVisible extends ObjectNamedFunction1<[Array<boolean>]> {
	static type(): string;
	func: (object3D: Object3D<Event>, targets: boolean[]) => boolean[];
}
declare class getChildrenPropertiesMatrixAutoUpdate extends ObjectNamedFunction1<[Array<boolean>]> {
	static type(): string;
	func: (object3D: Object3D<Event>, targets: boolean[]) => boolean[];
}
declare class getChildrenPropertiesCastShadow extends ObjectNamedFunction1<[Array<boolean>]> {
	static type(): string;
	func: (object3D: Object3D<Event>, targets: boolean[]) => boolean[];
}
declare class getChildrenPropertiesReceiveShadow extends ObjectNamedFunction1<[Array<boolean>]> {
	static type(): string;
	func: (object3D: Object3D<Event>, targets: boolean[]) => boolean[];
}
declare class getChildrenPropertiesFrustumCulled extends ObjectNamedFunction1<[Array<boolean>]> {
	static type(): string;
	func: (object3D: Object3D<Event>, targets: boolean[]) => boolean[];
}
declare class setPerspectiveCameraFov extends ObjectNamedFunction3<[number, number, boolean]> {
	static type(): string;
	func(object3D: Object3D, fov: number, lerp: number, updateProjectionMatrix: boolean): void;
}
declare class setPerspectiveCameraNearFar extends ObjectNamedFunction4<[number, number, number, boolean]> {
	static type(): string;
	func(object3D: Object3D, near: number, far: number, lerp: number, updateProjectionMatrix: boolean): void;
}
declare class getDefaultCamera extends NamedFunction0 {
	static type(): string;
	func(): Camera;
}
declare class getIntersectionPropertyDistance extends NamedFunction1<[Intersection | undefined]> {
	static type(): string;
	func(intersection: Intersection | undefined): number;
}
declare class getIntersectionPropertyObject extends ObjectNamedFunction1<[Intersection | undefined]> {
	static type(): string;
	func(object3D: Object3D, intersection: Intersection | undefined): Object3D;
}
declare class getIntersectionPropertyPoint extends NamedFunction2<[Intersection | undefined, Vector3]> {
	static type(): string;
	func(intersection: Intersection | undefined, target: Vector3): Vector3;
}
declare class getIntersectionPropertyNormal extends NamedFunction2<[Intersection | undefined, Vector3]> {
	static type(): string;
	func(intersection: Intersection | undefined, target: Vector3): Vector3;
}
declare class getIntersectionPropertyUv extends NamedFunction2<[Intersection | undefined, Vector2]> {
	static type(): string;
	func(intersection: Intersection | undefined, target: Vector2): Vector2;
}
declare class getTexture extends NamedFunction1<[string]> {
	static type(): string;
	func(nodePath: string): Texture | undefined;
}
declare class getMaterial extends NamedFunction1<[string]> {
	static type(): string;
	func(nodePath: string): Material | undefined;
}
declare class getObject extends ObjectNamedFunction2<[boolean, string]> {
	static type(): string;
	func(object3D: Object3D, getCurrentObject: boolean, mask: string): Object3D<Event>;
}
declare class getObjectAttribute extends ObjectNamedFunction2<[string, ParamConvertibleJsType]> {
	static type(): string;
	func(object3D: Object3D, attribName: string, type: ParamConvertibleJsType): AttribValue;
}
declare class getObjectAttributePrevious extends ObjectNamedFunction2<[string, ParamConvertibleJsType]> {
	static type(): string;
	func(object3D: Object3D, attribName: string, type: ParamConvertibleJsType): AttribValue;
}
declare class getObjectAttributeRef extends ObjectNamedFunction2<[string, ParamConvertibleJsType]> {
	static type(): string;
	func(object3D: Object3D, attribName: string, type: ParamConvertibleJsType): Ref<AttribValue>;
}
declare class getObjectChild extends ObjectNamedFunction1<[number]> {
	static type(): string;
	func(object3D: Object3D, index: number): Object3D;
}
declare class getObjectHoveredIntersection extends ObjectNamedFunction0 {
	static type(): string;
	func(object3D: Object3D): Intersection;
}
declare class getObjectHoveredState extends ObjectNamedFunction4<[boolean, number, number, Ref<Intersection | null>]> {
	static type(): string;
	func(
		object3D: Object3D,
		traverseChildren: boolean,
		pointsThreshold: number,
		lineThreshold: number,
		intersectionRef: Ref<Intersection | null>
	): boolean;
}
export declare type Listener = () => void;
declare class objectDispatchEvent extends ObjectNamedFunction1<[string]> {
	static type(): string;
	func(object3D: Object3D, eventName: string): void;
}
declare class getObjectLastDispatchedEventName extends ObjectNamedFunction0 {
	static type(): string;
	func(object3D: Object3D): string;
}
declare class objectAddEventListeners extends ObjectNamedFunction3<[string, ActorEvaluator, Listener]> {
	static type(): string;
	func(object3D: Object3D, eventNamesList: string, evaluator: ActorEvaluator, boundListener: Listener): string;
}
declare class getObjectUserData extends ObjectNamedFunction1<[string]> {
	static type(): string;
	func(object3D: Object3D, userDataName: string): any;
}
declare class getParent extends ObjectNamedFunction0 {
	static type(): string;
	func(object3D: Object3D): Object3D<Event>;
}
declare class planeSet extends NamedFunction3<[Vector3, number, Plane]> {
	static type(): string;
	func(normal: Vector3, constant: number, target: Plane): Plane;
}
declare class getPlaneNormal extends NamedFunction2<[Plane, Vector3]> {
	static type(): string;
	func(plane: Plane, target: Vector3): Vector3;
}
declare class getPlaneConstant extends NamedFunction1<[Plane]> {
	static type(): string;
	func(plane: Plane): number;
}
declare class setPlayerInput extends ObjectNamedFunction0 {
	static type(): string;
	func(object3D: Object3D): void;
}
declare class getPlayerInputDataLeft extends ObjectNamedFunction0 {
	static type(): string;
	func(object3D: Object3D): boolean;
}
declare class getPlayerInputDataRight extends ObjectNamedFunction0 {
	static type(): string;
	func(object3D: Object3D): boolean;
}
declare class getPlayerInputDataForward extends ObjectNamedFunction0 {
	static type(): string;
	func(object3D: Object3D): boolean;
}
declare class getPlayerInputDataBackward extends ObjectNamedFunction0 {
	static type(): string;
	func(object3D: Object3D): boolean;
}
declare class getPlayerInputDataRun extends ObjectNamedFunction0 {
	static type(): string;
	func(object3D: Object3D): boolean;
}
declare class getPlayerInputDataJump extends ObjectNamedFunction0 {
	static type(): string;
	func(object3D: Object3D): boolean;
}
export interface PlayerUpdateOptions {
	collider: Object3D;
	speed: number;
	runAllowed: boolean;
	runSpeedMult: number;
	jumpAllowed: boolean;
	jumpStrength: number;
	physicsSteps: number;
	gravity: Vector3;
	capsuleRadius: number;
	capsuleHeight: number;
	left: boolean;
	right: boolean;
	backward: boolean;
	forward: boolean;
	run: boolean;
	jump: boolean;
}
declare class playerSimpleUpdate extends ObjectNamedFunction1<[PlayerUpdateOptions]> {
	static type(): string;
	func(object3D: Object3D, options: PlayerUpdateOptions): void;
}
declare class getPlayerSimplePropertyOnGround extends ObjectNamedFunction0 {
	static type(): string;
	func(object3D: Object3D): boolean;
}
declare class getPlayerSimplePropertyVelocity extends ObjectNamedFunction1<[Vector3]> {
	static type(): string;
	func(object3D: Object3D, target: Vector3): Vector3;
}
declare class raySet extends NamedFunction3<[Vector3, Vector3, Ray]> {
	static type(): string;
	func(origin: Vector3, direction: Vector3, target: Ray): Ray;
}
declare class rayFromCamera extends ObjectNamedFunction3<[number, number, Ray]> {
	static type(): string;
	func(object3D: Object3D, x: number, y: number, target: Ray): Ray;
}
declare class getRayOrigin extends NamedFunction2<[Ray, Vector3]> {
	static type(): string;
	func(ray: Ray, target: Vector3): Vector3;
}
declare class getRayDirection extends NamedFunction2<[Ray, Vector3]> {
	static type(): string;
	func(ray: Ray, target: Vector3): Vector3;
}
declare class rayIntersectBox3 extends NamedFunction3<[Ray, Box3, Vector3]> {
	static type(): string;
	func(ray: Ray, box: Box3, target: Vector3): Vector3;
}
declare class rayIntersectsBox3 extends NamedFunction2<[Ray, Box3]> {
	static type(): string;
	func(ray: Ray, box: Box3): boolean;
}
declare class rayIntersectObject3D extends NamedFunction2<[Ray, Object3D]> {
	static type(): string;
	func(ray: Ray, object3D: Object3D): Intersection;
}
declare class rayIntersectsObject3D extends NamedFunction2<[Ray, Object3D]> {
	static type(): string;
	func(ray: Ray, object3D: Object3D): boolean;
}
declare class rayIntersectPlane extends NamedFunction3<[Ray, Plane, Vector3]> {
	static type(): string;
	func(ray: Ray, plane: Plane, target: Vector3): Vector3;
}
declare class rayIntersectsPlane extends NamedFunction2<[Ray, Plane]> {
	static type(): string;
	func(ray: Ray, plane: Plane): boolean;
}
declare class rayDistanceToPlane extends NamedFunction2<[Ray, Plane]> {
	static type(): string;
	func(ray: Ray, plane: Plane): number;
}
declare class rayIntersectSphere extends NamedFunction3<[Ray, Sphere, Vector3]> {
	static type(): string;
	func(ray: Ray, sphere: Sphere, target: Vector3): Vector3;
}
declare class rayIntersectsSphere extends NamedFunction2<[Ray, Sphere]> {
	static type(): string;
	func(ray: Ray, sphere: Sphere): boolean;
}
declare class getSibbling extends ObjectNamedFunction1<[number]> {
	static type(): string;
	func(object3D: Object3D, offset: number): Object3D<Event>;
}
declare class sphereSet extends NamedFunction3<[Vector3, number, Sphere]> {
	static type(): string;
	func(center: Vector3, radius: number, target: Sphere): Sphere;
}
declare class getSphereCenter extends NamedFunction2<[Sphere, Vector3]> {
	static type(): string;
	func(sphere: Sphere, target: Vector3): Vector3;
}
declare class getSphereRadius extends NamedFunction1<[Sphere]> {
	static type(): string;
	func(sphere: Sphere): number;
}
declare class trackHand extends ObjectNamedFunction1<[Texture]> {
	static type(): string;
	func(object3D: Object3D, texture: Texture): void;
}
declare class trackHandGetNormalizedLandmarks extends ObjectNamedFunction2<[number, Vector4[]]> {
	static type(): string;
	func(object3D: Object3D, handIndex: number, target: Vector4[]): Vector4[];
}
declare class trackHandGetWorldLandmarks extends ObjectNamedFunction2<[number, Vector4[]]> {
	static type(): string;
	func(object3D: Object3D, handIndex: number, target: Vector4[]): Vector4[];
}
declare class getTrackedHandThumbDirection extends NamedFunction2<[Vector4[], Vector3]> {
	static type(): string;
	func(values: Vector4[], target: Vector3): Vector3;
}
declare class getTrackedHandIndexDirection extends NamedFunction2<[Vector4[], Vector3]> {
	static type(): string;
	func(values: Vector4[], target: Vector3): Vector3;
}
declare class getTrackedHandMiddleDirection extends NamedFunction2<[Vector4[], Vector3]> {
	static type(): string;
	func(values: Vector4[], target: Vector3): Vector3;
}
declare class getTrackedHandRingDirection extends NamedFunction2<[Vector4[], Vector3]> {
	static type(): string;
	func(values: Vector4[], target: Vector3): Vector3;
}
declare class getTrackedHandPinkyDirection extends NamedFunction2<[Vector4[], Vector3]> {
	static type(): string;
	func(values: Vector4[], target: Vector3): Vector3;
}
declare class getWebXRARHitDetected extends NamedFunction0 {
	static type(): string;
	func(): boolean;
}
declare class getWebXRARHitMatrix extends NamedFunction1<[Matrix4]> {
	static type(): string;
	func(target: Matrix4): Matrix4;
}
declare class getWebXRARHitPosition extends NamedFunction1<[Vector3]> {
	static type(): string;
	func(target: Vector3): Vector3;
}
declare class getWebXRARHitQuaternion extends NamedFunction1<[Quaternion]> {
	static type(): string;
	func(target: Quaternion): Quaternion;
}
declare class getWebXRControllerObject extends ObjectNamedFunction1<[number]> {
	static type(): string;
	func(object3D: Object3D, controllerIndex: number): Object3D;
}
declare class getWebXRControllerRay extends ObjectNamedFunction2<[number, Ray]> {
	static type(): string;
	func(object3D: Object3D, controllerIndex: number, target: Ray): Ray;
}
declare class getWebXRControllerHasAngularVelocity extends ObjectNamedFunction1<[number]> {
	static type(): string;
	func(object3D: Object3D, controllerIndex: number): boolean;
}
declare class getWebXRControllerAngularVelocity extends ObjectNamedFunction2<[number, Vector3]> {
	static type(): string;
	func(object3D: Object3D, controllerIndex: number, target: Vector3): Vector3;
}
declare class getWebXRControllerHasLinearVelocity extends ObjectNamedFunction1<[number]> {
	static type(): string;
	func(object3D: Object3D, controllerIndex: number): boolean;
}
declare class getWebXRControllerLinearVelocity extends ObjectNamedFunction2<[number, Vector3]> {
	static type(): string;
	func(object3D: Object3D, controllerIndex: number, target: Vector3): Vector3;
}
declare class getWebXRTrackedMarkerMatrix extends NamedFunction1<[Matrix4]> {
	static type(): string;
	func(target: Matrix4): Matrix4;
}
declare abstract class GlobalsTimeFunction0 extends NamedFunction0 {
	constructor(node: BaseNodeType, shadersCollectionController?: ShadersCollectionController);
}
declare abstract class PointerEventsTimeFunction0 extends NamedFunction0 {
	protected pointerEventsController: PointerEventsController;
	constructor(node: BaseNodeType, shadersCollectionController?: ShadersCollectionController);
}
declare class globalsTime extends GlobalsTimeFunction0 {
	static type(): string;
	func(): number;
}
declare class globalsTimeDelta extends GlobalsTimeFunction0 {
	static type(): string;
	func(): number;
}
declare class globalsRaycaster extends PointerEventsTimeFunction0 {
	static type(): string;
	func(): Raycaster;
}
declare class globalsRayFromCursor extends PointerEventsTimeFunction0 {
	static type(): string;
	func(): Ray;
}
declare class globalsCursor extends PointerEventsTimeFunction0 {
	static type(): string;
	func(): Vector2;
}
declare class keyboardEventMatchesConfig extends NamedFunction5<[string, number, number, number, number]> {
	static type(): string;
	func(keyCodes: string, _ctrlKey: number, _shiftKey: number, _altKey: number, _metaKey: number): boolean;
}
declare class lengthVector<V extends Vector2 | Vector3 | Vector4> extends NamedFunction1<[V]> {
	static type(): string;
	func(src: V): number;
}
declare class lengthVectorArray<V extends Vector2 | Vector3 | Vector4> extends NamedFunction2<
	[Array<V>, Array<number>]
> {
	static type(): string;
	func(src: V[], target: number[]): number[];
}
declare class lerpNumber extends NamedFunction3<[number, number, number]> {
	static type(): string;
	func(v1: number, v2: number, lerp: number): number;
}
declare class lerpColor extends NamedFunction4<[Color, Color, number, Color]> {
	static type(): string;
	func(v1: Color, v2: Color, lerp: number, target: Color): Color;
}
declare class lerpQuaternion extends NamedFunction4<[Quaternion, Quaternion, number, Quaternion]> {
	static type(): string;
	func(v1: Quaternion, v2: Quaternion, lerp: number, target: Quaternion): Quaternion;
}
declare class lerpVector2 extends NamedFunction4<[Vector2, Vector2, number, Vector2]> {
	static type(): string;
	func(v1: Vector2, v2: Vector2, lerp: number, target: Vector2): Vector2;
}
declare class lerpVector3 extends NamedFunction4<[Vector3, Vector3, number, Vector3]> {
	static type(): string;
	func(v1: Vector3, v2: Vector3, lerp: number, target: Vector3): Vector3;
}
declare class lerpVector4 extends NamedFunction4<[Vector4, Vector4, number, Vector4]> {
	static type(): string;
	func(v1: Vector4, v2: Vector4, lerp: number, target: Vector4): Vector4;
}
declare class manhattanDistanceVector2 extends NamedFunction2<[Vector2, Vector2]> {
	static type(): string;
	func(v1: Vector2, v2: Vector2): number;
}
declare class manhattanDistanceVector3 extends NamedFunction2<[Vector3, Vector3]> {
	static type(): string;
	func(v1: Vector3, v2: Vector3): number;
}
declare class maxLengthVector2 extends NamedFunction3<[Vector2, number, Vector2]> {
	static type(): string;
	func(src: Vector2, maxLength: number, target: Vector2): Vector2;
}
declare class maxLengthVector3 extends NamedFunction3<[Vector3, number, Vector3]> {
	static type(): string;
	func(src: Vector3, maxLength: number, target: Vector3): Vector3;
}
declare class maxLengthVector4 extends NamedFunction3<[Vector4, number, Vector4]> {
	static type(): string;
	func(src: Vector4, maxLength: number, target: Vector4): Vector4;
}
declare class multNumber extends NamedFunction<Array<number>, Array<string>> {
	static type(): string;
	func(...args: Array<number>): number;
}
export declare type AvailableItem = Vector2 | Vector3 | Vector4;
declare class multVector<V extends AvailableItem> extends NamedFunction<Array<V>, Array<string>> {
	static type(): string;
	func(...args: Array<V>): V;
}
declare class multVectorNumber<V extends AvailableItem> extends NamedFunction2<[V, number]> {
	static type(): string;
	func(vector: V, number: number): V;
}
declare class multScalarColor extends NamedFunction3<[Color, number, Color]> {
	static type(): string;
	func(src: Color, scalar: number, target: Color): Color;
}
declare class multScalarVector2 extends NamedFunction3<[Vector2, number, Vector2]> {
	static type(): string;
	func(src: Vector2, scalar: number, target: Vector2): Vector2;
}
declare class multScalarVector3 extends NamedFunction3<[Vector3, number, Vector3]> {
	static type(): string;
	func(src: Vector3, scalar: number, target: Vector3): Vector3;
}
declare class multScalarVector4 extends NamedFunction3<[Vector4, number, Vector4]> {
	static type(): string;
	func(src: Vector4, scalar: number, target: Vector4): Vector4;
}
declare class multScalarVectorArray<V extends Color | Vector2 | Vector3 | Vector4> extends NamedFunction3<
	[Array<V>, number, Array<V>]
> {
	static type(): string;
	func(src: V[], scalar: number, target: V[]): V[];
}
declare class multScalarArrayVectorArray<V extends Color | Vector2 | Vector3 | Vector4> extends NamedFunction3<
	[Array<V>, number[], Array<V>]
> {
	static type(): string;
	func(src: V[], scalar: number[], target: V[]): V[];
}
declare class nearestPosition extends NamedFunction3<[Vector3, Array<Vector3>, Vector3]> {
	static type(): string;
	func(v3: Vector3, positions: Vector3[], target: Vector3): Vector3;
}
declare class normalizeVector2 extends NamedFunction2<[Vector2, Vector2]> {
	static type(): string;
	func(src: Vector2, target: Vector2): Vector2;
}
declare class normalizeVector3 extends NamedFunction2<[Vector3, Vector3]> {
	static type(): string;
	func(src: Vector3, target: Vector3): Vector3;
}
declare class normalizeVector4 extends NamedFunction2<[Vector4, Vector4]> {
	static type(): string;
	func(src: Vector4, target: Vector4): Vector4;
}
declare class setObjectCastShadow extends ObjectNamedFunction1<[boolean]> {
	static type(): string;
	func(object3D: Object3D, castShadow: boolean): void;
}
declare class setObjectReceiveShadow extends ObjectNamedFunction1<[boolean]> {
	static type(): string;
	func(object3D: Object3D, receiveShadow: boolean): void;
}
declare class setObjectFrustumCulled extends ObjectNamedFunction1<[boolean]> {
	static type(): string;
	func(object3D: Object3D, frustumCulled: boolean): void;
}
declare class setObjectMatrix extends ObjectNamedFunction1<[Matrix4]> {
	static type(): string;
	func(object3D: Object3D, matrix: Matrix4): void;
}
declare class setObjectMatrixAutoUpdate extends ObjectNamedFunction1<[boolean]> {
	static type(): string;
	func(object3D: Object3D, matrixAutoUpdate: boolean): void;
}
declare class setObjectVisible extends ObjectNamedFunction1<[boolean]> {
	static type(): string;
	func(object3D: Object3D, visible: boolean): void;
}
declare class objectUpdateMatrix extends ObjectNamedFunction0 {
	static type(): string;
	func(object3D: Object3D): void;
}
declare class objectUpdateWorldMatrix extends ObjectNamedFunction2<[boolean, boolean]> {
	static type(): string;
	func(object3D: Object3D, updateParents: boolean, updateChildren: boolean): void;
}
declare enum PerformanceChangeEvent {
	aboveThreshold = 'aboveThreshold',
	belowThreshold = 'belowThreshold',
}
export declare type CallbackByPerformanceEvent = Record<PerformanceChangeEvent, Function>;
declare class onPerformanceChange extends NamedFunction3<[number, CallbackByPerformanceEvent, ActorEvaluator]> {
	static type(): string;
	func(threshold: number, callbacks: CallbackByPerformanceEvent, evaluator: ActorEvaluator): void;
}
declare class particlesSystemReset extends ObjectNamedFunction0 {
	static type(): string;
	func(object3D: Object3D): void;
}
declare class particlesSystemStepSimulation extends ObjectNamedFunction0 {
	static type(): string;
	func(object3D: Object3D): void;
}
declare class playAnimation extends ObjectNamedFunction1<[string]> {
	static type(): string;
	func(object3D: Object3D, nodePath: string): Promise<void>;
}
export interface PlayerUpdateOptions {
	speed: number;
	runAllowed: boolean;
	runSpeedMult: number;
	jumpAllowed: boolean;
	jumpStrength: number;
	resetIfBelowThreshold: boolean;
	resetThreshold: number;
	left: boolean;
	right: boolean;
	backward: boolean;
	forward: boolean;
	run: boolean;
	jump: boolean;
}
declare class playerPhysicsUpdate extends ObjectNamedFunction1<[PlayerUpdateOptions]> {
	static type(): string;
	func(object3D: Object3D, options: PlayerUpdateOptions): void;
}
declare class setParamBoolean extends NamedFunction3<[string, string, boolean]> {
	static type(): string;
	func(nodePath: string, paramName: string, value: boolean): void;
}
declare class setParamBooleanToggle extends NamedFunction2<[string, string]> {
	static type(): string;
	func(nodePath: string, paramName: string): void;
}
declare class setParamColor extends NamedFunction4<[string, string, Color, number]> {
	static type(): string;
	func(nodePath: string, paramName: string, value: Color, lerp: number): void;
}
declare class setParamFloat extends NamedFunction4<[string, string, number, number]> {
	static type(): string;
	func(nodePath: string, paramName: string, value: number, lerp: number): void;
}
declare class setParamInteger extends NamedFunction4<[string, string, number, number]> {
	static type(): string;
	func(nodePath: string, paramName: string, value: number, lerp: number): void;
}
declare class setParamString extends NamedFunction3<[string, string, string]> {
	static type(): string;
	func(nodePath: string, paramName: string, value: string): void;
}
declare class setParamVector2 extends NamedFunction4<[string, string, Vector2, number]> {
	static type(): string;
	func(nodePath: string, paramName: string, value: Vector2, lerp: number): void;
}
declare class setParamVector3 extends NamedFunction4<[string, string, Vector3, number]> {
	static type(): string;
	func(nodePath: string, paramName: string, value: Vector3, lerp: number): void;
}
declare class setParamVector4 extends NamedFunction4<[string, string, Vector4, number]> {
	static type(): string;
	func(nodePath: string, paramName: string, value: Vector4, lerp: number): void;
}
declare class pressButtonParam extends NamedFunction2<[string, string]> {
	static type(): string;
	func(nodePath: string, paramName: string): void;
}
declare class SDFSphere extends NamedFunction3<[Vector3, Vector3, number]> {
	static type(): string;
	func(p: Vector3, center: Vector3, s: number): number;
}
declare class SDFBox extends NamedFunction4<[Vector3, Vector3, Vector3, number]> {
	static type(): string;
	func(p: Vector3, center: Vector3, sizes: Vector3, size: number): number;
}
declare class SDFUnion extends NamedFunction2<[number, number]> {
	static type(): string;
	func(d1: number, d2: number): number;
}
declare class SDFSubtract extends NamedFunction2<[number, number]> {
	static type(): string;
	func(d1: number, d2: number): number;
}
declare class SDFIntersect extends NamedFunction2<[number, number]> {
	static type(): string;
	func(d1: number, d2: number): number;
}
declare class SDFSmoothUnion extends NamedFunction3<[number, number, number]> {
	static type(): string;
	func(d1: number, d2: number, k: number): number;
}
declare class SDFSmoothSubtract extends NamedFunction3<[number, number, number]> {
	static type(): string;
	func(d1: number, d2: number, k: number): number;
}
declare class SDFSmoothIntersect extends NamedFunction3<[number, number, number]> {
	static type(): string;
	func(d1: number, d2: number, k: number): number;
}
declare class SDFRevolutionX extends NamedFunction4<[Vector3, Vector3, number, Vector2]> {
	static type(): string;
	func(p: Vector3, center: Vector3, o: number, target: Vector2): void;
}
declare class SDFRevolutionY extends NamedFunction4<[Vector3, Vector3, number, Vector2]> {
	static type(): string;
	func(p: Vector3, center: Vector3, o: number, target: Vector2): void;
}
declare class SDFRevolutionZ extends NamedFunction4<[Vector3, Vector3, number, Vector2]> {
	static type(): string;
	func(p: Vector3, center: Vector3, o: number, target: Vector2): void;
}
declare class SDFRoundedX extends NamedFunction4<[Vector2, Vector2, number, number]> {
	static type(): string;
	func(p: Vector2, center: Vector2, w: number, r: number): number;
}
declare class setGeometryInstancePositions extends ObjectNamedFunction3<[Array<Vector3>, number, boolean]> {
	static type(): string;
	func(object3D: Object3D, newValues: Vector3[], lerp: number, attributeNeedsUpdate: boolean): void;
}
declare class setGeometryInstanceQuaternions extends ObjectNamedFunction3<[Array<Quaternion>, number, boolean]> {
	static type(): string;
	func(object3D: Object3D, newValues: Quaternion[], lerp: number, attributeNeedsUpdate: boolean): void;
}
declare class setGeometryInstanceScales extends ObjectNamedFunction4<[Array<Vector3>, number[], number, boolean]> {
	static type(): string;
	func(
		object3D: Object3D,
		scaleValues: Vector3[],
		multValues: number[],
		lerp: number,
		attributeNeedsUpdate: boolean
	): void;
}
declare class setGeometryInstanceTransforms extends ObjectNamedFunction6<
	[Array<Vector3>, Array<Quaternion>, Array<Vector3>, number[], number, boolean]
> {
	static type(): string;
	func(
		object3D: Object3D,
		positions: Vector3[],
		quaternions: Quaternion[],
		scaleValues: Vector3[],
		multValues: number[],
		lerp: number,
		attributeNeedsUpdate: boolean
	): void;
}
declare class setGeometryInstanceAttributeFloat extends ObjectNamedFunction4<[string, Array<number>, number, boolean]> {
	static type(): string;
	func(
		object3D: Object3D,
		attribName: string,
		newValues: number[],
		lerp: number,
		attributeNeedsUpdate: boolean
	): void;
}
declare class setGeometryInstanceAttributeColor extends ObjectNamedFunction4<[string, Array<Color>, number, boolean]> {
	static type(): string;
	func(object3D: Object3D, attribName: string, newValues: Color[], lerp: number, attributeNeedsUpdate: boolean): void;
}
declare class setGeometryInstanceAttributeQuaternion extends ObjectNamedFunction4<
	[string, Array<Quaternion>, number, boolean]
> {
	static type(): string;
	func(
		object3D: Object3D,
		attribName: string,
		newValues: Quaternion[],
		lerp: number,
		attributeNeedsUpdate: boolean
	): void;
}
declare class setGeometryInstanceAttributeVector2 extends ObjectNamedFunction4<
	[string, Array<Vector2>, number, boolean]
> {
	static type(): string;
	func(
		object3D: Object3D,
		attribName: string,
		newValues: Vector2[],
		lerp: number,
		attributeNeedsUpdate: boolean
	): void;
}
declare class setGeometryInstanceAttributeVector3 extends ObjectNamedFunction4<
	[string, Array<Vector3>, number, boolean]
> {
	static type(): string;
	func(
		object3D: Object3D,
		attribName: string,
		newValues: Vector3[],
		lerp: number,
		attributeNeedsUpdate: boolean
	): void;
}
declare class setGeometryInstanceAttributeVector4 extends ObjectNamedFunction4<
	[string, Array<Vector4>, number, boolean]
> {
	static type(): string;
	func(
		object3D: Object3D,
		attribName: string,
		newValues: Vector4[],
		lerp: number,
		attributeNeedsUpdate: boolean
	): void;
}
declare class setGeometryPositions extends ObjectNamedFunction5<[Vector3[], number, boolean, boolean, boolean]> {
	static type(): string;
	func(
		object3D: Object3D,
		values: Vector3[],
		lerp: number,
		attributeNeedsUpdate: boolean,
		computeNormals: boolean,
		computeTangents: boolean
	): void;
}
declare class setObjectMaterial extends ObjectNamedFunction1<[Material]> {
	static type(): string;
	func(object3D: Object3D, material: Material): void;
}
declare class setObjectMaterialColor extends ObjectNamedFunction2<[Color, number]> {
	static type(): string;
	func(object3D: Object3D, color: Color, lerp: number): void;
}
declare class setMaterialColor extends NamedFunction3<[Material, Color, number]> {
	static type(): string;
	func(material: Material, color: Color, lerp: number): void;
}
declare class setMaterialEmissiveColor extends NamedFunction3<[Material, Color, number]> {
	static type(): string;
	func(material: Material, color: Color, lerp: number): void;
}
declare class setMaterialOpacity extends NamedFunction3<[Material, number, number]> {
	static type(): string;
	func(material: Material, opacity: number, lerp: number): void;
}
declare class setMaterialUniformNumber extends NamedFunction5<[Material, string, number, number, boolean]> {
	static type(): string;
	func(material: Material, uniformName: string, value: number, lerp: number, addPrefix: boolean): void;
}
export declare type VectorColorUniform = Color | Vector2 | Vector3 | Vector4;
declare class setMaterialUniformVectorColor extends NamedFunction5<
	[Material, string, VectorColorUniform, number, boolean]
> {
	static type(): string;
	func(material: Material, uniformName: string, value: VectorColorUniform, lerp: number, addPrefix: boolean): void;
}
declare class setObjectAttribute extends ObjectNamedFunction4<[string, number, AttribValue, ParamConvertibleJsType]> {
	static type(): string;
	func(
		object3D: Object3D,
		attribName: string,
		lerp: number,
		newValue: AttribValue,
		type: ParamConvertibleJsType
	): void;
}
declare class setObjectLookAt extends ObjectNamedFunction5<[Vector3, Vector3, number, boolean, boolean]> {
	static type(): string;
	func(
		object3D: Object3D,
		targetPosition: Vector3,
		up: Vector3,
		lerp: number,
		invertDirection: boolean,
		updateMatrix: boolean
	): void;
}
declare class setObjectPolarTransform extends ObjectNamedFunction4<[Vector3, number, number, number]> {
	static type(): string;
	func(object3D: Object3D, center: Vector3, longitude: number, latitude: number, depth: number): void;
}
declare class setObjectPosition extends ObjectNamedFunction3<[Vector3, number, boolean]> {
	static type(): string;
	func(object3D: Object3D, position: Vector3, lerp: number, updateMatrix: boolean): void;
}
declare class setObjectRotation extends ObjectNamedFunction4<[Vector3, number, number, boolean]> {
	static type(): string;
	func(object3D: Object3D, rotation: Vector3, rotationOrder: number, lerp: number, updateMatrix: boolean): void;
}
declare class setObjectScale extends ObjectNamedFunction4<[Vector3, number, number, boolean]> {
	static type(): string;
	func(object3D: Object3D, scale: Vector3, mult: number, lerp: number, updateMatrix: boolean): void;
}
declare class setSpotLightIntensity extends ObjectNamedFunction2<[number, number]> {
	static type(): string;
	func(object3D: Object3D, intensity: number, lerp: number): void;
}
declare class setViewer extends NamedFunction2<[string, boolean]> {
	static type(): string;
	func(className: string, addClass: boolean): void;
}
declare function _sizzleVec3XY(src: Vector3, target: Vector2): Vector2;
declare class sizzleVec3XY extends NamedFunction2<[Vector3, Vector2]> {
	static type(): string;
	func: typeof _sizzleVec3XY;
}
declare function _sizzleVec3XZ(src: Vector3, target: Vector2): Vector2;
declare class sizzleVec3XZ extends NamedFunction2<[Vector3, Vector2]> {
	static type(): string;
	func: typeof _sizzleVec3XZ;
}
declare function _sizzleVec3YZ(src: Vector3, target: Vector2): Vector2;
declare class sizzleVec3YZ extends NamedFunction2<[Vector3, Vector2]> {
	static type(): string;
	func: typeof _sizzleVec3YZ;
}
declare class sizzleVec4XYZ extends NamedFunction2<[Vector4, Vector3]> {
	static type(): string;
	func(src: Vector4, target: Vector3): Vector3;
}
declare class sizzleVec4XYZArray extends NamedFunction2<[Vector4[], Vector3[]]> {
	static type(): string;
	func(src: Vector4[], target: Vector3[]): Vector3[];
}
declare class sizzleVec4WArray extends NamedFunction2<[Vector4[], number[]]> {
	static type(): string;
	func(src: Vector4[], target: number[]): number[];
}
declare class sleep extends NamedFunction1<[number]> {
	static type(): string;
	func(delay: number): Promise<void>;
	asString(delay: string): string;
}
declare class subtractNumber extends NamedFunction<Array<number>, Array<string>> {
	static type(): string;
	func(...args: Array<number>): number;
}
export declare type AvailableItem = Vector2 | Vector3 | Vector4;
declare class subtractVector<V extends AvailableItem> extends NamedFunction<Array<V>, Array<string>> {
	static type(): string;
	func(...args: Array<V>): V;
}
declare class subtractVectorNumber<V extends AvailableItem> extends NamedFunction2<[V, number]> {
	static type(): string;
	func(vector: V, number: number): V;
}
declare class trackFace extends ObjectNamedFunction1<[Texture]> {
	static type(): string;
	func(object3D: Object3D, texture: Texture): void;
}
declare class trackFaceGetLandmarks extends ObjectNamedFunction2<[number, Vector4[]]> {
	static type(): string;
	func(object3D: Object3D, faceIndex: number, target: Vector4[]): Vector4[];
}
declare class triggerFilter extends NamedFunction1<[boolean]> {
	static type(): string;
	func(condition: boolean): boolean;
	asString(condition: string): string;
}
declare class triggerTwoWaySwitch extends NamedFunction3<[boolean, Function, Function]> {
	static type(): string;
	func(condition: boolean, _func0: Function, _func1: Function): void;
}
declare class vector3AngleTo extends NamedFunction2<[Vector3, Vector3]> {
	static type(): string;
	func(v1: Vector3, v2: Vector3): number;
}
declare class vector3ProjectOnPlane extends NamedFunction3<[Vector3, Vector3, Vector3]> {
	static type(): string;
	func(src: Vector3, planeNormal: Vector3, target: Vector3): Vector3;
}
declare class vector3Project extends NamedFunction3<[Vector3, Object3D, Vector3]> {
	static type(): string;
	func(src: Vector3, object3D: Object3D, target: Vector3): Vector3;
}
declare class vector3Unproject extends NamedFunction3<[Vector3, Object3D, Vector3]> {
	static type(): string;
	func(src: Vector3, object3D: Object3D, target: Vector3): Vector3;
}
export interface NamedFunctionMap {
	addAudioStopEventListener: addAudioStopEventListener;
	addNumber: addNumber;
	addVector: addVector<Vector2 | Vector3 | Vector4>;
	addVectorNumber: addVectorNumber<Vector2 | Vector3 | Vector4>;
	addVideoEventListener: addVideoEventListener;
	andArrays: andArrays;
	andBooleans: andBooleans;
	animationActionCrossFade: animationActionCrossFade;
	animationActionFadeIn: animationActionFadeIn;
	animationActionFadeOut: animationActionFadeOut;
	animationActionPlay: animationActionPlay;
	animationActionStop: animationActionStop;
	animationMixerUpdate: animationMixerUpdate;
	arrayElementPrimitive: arrayElementPrimitive<PrimitiveArrayElement>;
	arrayElementVector: arrayElementVector;
	arrayLength: arrayLength;
	boolToInt: boolToInt;
	box3Set: box3Set;
	catmullRomCurve3GetPoint: catmullRomCurve3GetPoint;
	clamp: clamp;
	colorSetRGB: colorSetRGB;
	colorToVec3: colorToVec3;
	complement: complement;
	cookNode: cookNode;
	crossVector2: crossVector2;
	crossVector3: crossVector3;
	debug: debug<any>;
	distanceVector2: distanceVector2;
	distanceVector3: distanceVector3;
	divideNumber: divideNumber;
	divideVectorNumber: divideVectorNumber<Vector2 | Vector3 | Vector4>;
	dotVector2: dotVector2;
	dotVector3: dotVector3;
	easeElasticI: easeElasticI;
	easeElasticIO: easeElasticIO;
	easeElasticO: easeElasticO;
	easeI2: easeI2;
	easeI3: easeI3;
	easeI4: easeI4;
	easeIO2: easeIO2;
	easeIO3: easeIO3;
	easeIO4: easeIO4;
	easeO2: easeO2;
	easeO3: easeO3;
	easeO4: easeO4;
	easeSinI: easeSinI;
	easeSinIO: easeSinIO;
	easeSinO: easeSinO;
	elementsToArrayPrimitive: elementsToArrayPrimitive<PrimitiveArrayElement>;
	elementsToArrayVector: elementsToArrayVector<VectorArrayElement>;
	fit: fit;
	fitClamp: fitClamp;
	floatToColor: floatToColor;
	floatToInt: floatToInt;
	floatToVec2: floatToVec2;
	floatToVec3: floatToVec3;
	floatToVec4: floatToVec4;
	getActorNodeParamValue: getActorNodeParamValue;
	getAnimationAction: getAnimationAction;
	getAnimationMixer: getAnimationMixer;
	getBox3Max: getBox3Max;
	getBox3Min: getBox3Min;
	getChildrenAttributes: getChildrenAttributes;
	getChildrenAttributesPrevious: getChildrenAttributesPrevious;
	getChildrenAttributesRef: getChildrenAttributesRef;
	getChildrenPhysicsRBDPropertiesAngularDamping: getChildrenPhysicsRBDPropertiesAngularDamping;
	getChildrenPhysicsRBDPropertiesAngularVelocity: getChildrenPhysicsRBDPropertiesAngularVelocity;
	getChildrenPhysicsRBDPropertiesIsMoving: getChildrenPhysicsRBDPropertiesIsMoving;
	getChildrenPhysicsRBDPropertiesIsSleeping: getChildrenPhysicsRBDPropertiesIsSleeping;
	getChildrenPhysicsRBDPropertiesLinearDamping: getChildrenPhysicsRBDPropertiesLinearDamping;
	getChildrenPhysicsRBDPropertiesLinearVelocity: getChildrenPhysicsRBDPropertiesLinearVelocity;
	getChildrenPropertiesCastShadow: getChildrenPropertiesCastShadow;
	getChildrenPropertiesFrustumCulled: getChildrenPropertiesFrustumCulled;
	getChildrenPropertiesMatrixAutoUpdate: getChildrenPropertiesMatrixAutoUpdate;
	getChildrenPropertiesPosition: getChildrenPropertiesPosition;
	getChildrenPropertiesQuaternion: getChildrenPropertiesQuaternion;
	getChildrenPropertiesReceiveShadow: getChildrenPropertiesReceiveShadow;
	getChildrenPropertiesScale: getChildrenPropertiesScale;
	getChildrenPropertiesUp: getChildrenPropertiesUp;
	getChildrenPropertiesVisible: getChildrenPropertiesVisible;
	getDefaultCamera: getDefaultCamera;
	getIntersectionPropertyDistance: getIntersectionPropertyDistance;
	getIntersectionPropertyNormal: getIntersectionPropertyNormal;
	getIntersectionPropertyObject: getIntersectionPropertyObject;
	getIntersectionPropertyPoint: getIntersectionPropertyPoint;
	getIntersectionPropertyUv: getIntersectionPropertyUv;
	getMaterial: getMaterial;
	getObject: getObject;
	getObjectAttribute: getObjectAttribute;
	getObjectAttributePrevious: getObjectAttributePrevious;
	getObjectAttributeRef: getObjectAttributeRef;
	getObjectChild: getObjectChild;
	getObjectHoveredIntersection: getObjectHoveredIntersection;
	getObjectHoveredState: getObjectHoveredState;
	getObjectLastDispatchedEventName: getObjectLastDispatchedEventName;
	getObjectProperty: getObjectProperty;
	getObjectUserData: getObjectUserData;
	getObjectWorldPosition: getObjectWorldPosition;
	getParent: getParent;
	getPhysicsRBDAngularDamping: getPhysicsRBDAngularDamping;
	getPhysicsRBDAngularVelocity: getPhysicsRBDAngularVelocity;
	getPhysicsRBDCapsuleHeight: getPhysicsRBDCapsuleHeight;
	getPhysicsRBDCapsuleRadius: getPhysicsRBDCapsuleRadius;
	getPhysicsRBDConeHeight: getPhysicsRBDConeHeight;
	getPhysicsRBDConeRadius: getPhysicsRBDConeRadius;
	getPhysicsRBDCuboidSizes: getPhysicsRBDCuboidSizes;
	getPhysicsRBDCylinderHeight: getPhysicsRBDCylinderHeight;
	getPhysicsRBDCylinderRadius: getPhysicsRBDCylinderRadius;
	getPhysicsRBDIsMoving: getPhysicsRBDIsMoving;
	getPhysicsRBDIsSleeping: getPhysicsRBDIsSleeping;
	getPhysicsRBDLinearDamping: getPhysicsRBDLinearDamping;
	getPhysicsRBDLinearVelocity: getPhysicsRBDLinearVelocity;
	getPhysicsRBDSphereRadius: getPhysicsRBDSphereRadius;
	getPlaneConstant: getPlaneConstant;
	getPlaneNormal: getPlaneNormal;
	getPlayerInputDataBackward: getPlayerInputDataBackward;
	getPlayerInputDataForward: getPlayerInputDataForward;
	getPlayerInputDataJump: getPlayerInputDataJump;
	getPlayerInputDataLeft: getPlayerInputDataLeft;
	getPlayerInputDataRight: getPlayerInputDataRight;
	getPlayerInputDataRun: getPlayerInputDataRun;
	getPlayerSimplePropertyOnGround: getPlayerSimplePropertyOnGround;
	getPlayerSimplePropertyVelocity: getPlayerSimplePropertyVelocity;
	getRayDirection: getRayDirection;
	getRayOrigin: getRayOrigin;
	getSibbling: getSibbling;
	getSphereCenter: getSphereCenter;
	getSphereRadius: getSphereRadius;
	getTexture: getTexture;
	getTrackedHandIndexDirection: getTrackedHandIndexDirection;
	getTrackedHandMiddleDirection: getTrackedHandMiddleDirection;
	getTrackedHandPinkyDirection: getTrackedHandPinkyDirection;
	getTrackedHandRingDirection: getTrackedHandRingDirection;
	getTrackedHandThumbDirection: getTrackedHandThumbDirection;
	getVideoPropertyCurrentTime: getVideoPropertyCurrentTime;
	getVideoPropertyDuration: getVideoPropertyDuration;
	getVideoPropertyMuted: getVideoPropertyMuted;
	getVideoPropertyPlaying: getVideoPropertyPlaying;
	getWebXRARHitDetected: getWebXRARHitDetected;
	getWebXRARHitMatrix: getWebXRARHitMatrix;
	getWebXRARHitPosition: getWebXRARHitPosition;
	getWebXRARHitQuaternion: getWebXRARHitQuaternion;
	getWebXRControllerAngularVelocity: getWebXRControllerAngularVelocity;
	getWebXRControllerHasAngularVelocity: getWebXRControllerHasAngularVelocity;
	getWebXRControllerHasLinearVelocity: getWebXRControllerHasLinearVelocity;
	getWebXRControllerLinearVelocity: getWebXRControllerLinearVelocity;
	getWebXRControllerObject: getWebXRControllerObject;
	getWebXRControllerRay: getWebXRControllerRay;
	getWebXRTrackedMarkerMatrix: getWebXRTrackedMarkerMatrix;
	globalsCursor: globalsCursor;
	globalsRaycaster: globalsRaycaster;
	globalsRayFromCursor: globalsRayFromCursor;
	globalsTime: globalsTime;
	globalsTimeDelta: globalsTimeDelta;
	intToBool: intToBool;
	intToFloat: intToFloat;
	keyboardEventMatchesConfig: keyboardEventMatchesConfig;
	lengthVector: lengthVector<Vector2 | Vector3 | Vector4>;
	lengthVectorArray: lengthVectorArray<Vector2 | Vector3 | Vector4>;
	lerpColor: lerpColor;
	lerpNumber: lerpNumber;
	lerpQuaternion: lerpQuaternion;
	lerpVector2: lerpVector2;
	lerpVector3: lerpVector3;
	lerpVector4: lerpVector4;
	manhattanDistanceVector2: manhattanDistanceVector2;
	manhattanDistanceVector3: manhattanDistanceVector3;
	mathColor_1: mathColor_1;
	mathColor_2: mathColor_2;
	mathColor_3: mathColor_3;
	mathColor_3vvf: mathColor_3vvf;
	mathColor_4: mathColor_4;
	mathColor_5: mathColor_5;
	mathFloat_1: mathFloat_1;
	mathFloat_2: mathFloat_2;
	mathFloat_3: mathFloat_3;
	mathFloat_4: mathFloat_4;
	mathFloat_5: mathFloat_5;
	mathPrimArray_1: mathPrimArray_1;
	mathPrimArray_2: mathPrimArray_2;
	mathPrimArray_3: mathPrimArray_3;
	mathPrimArray_4: mathPrimArray_4;
	mathPrimArray_5: mathPrimArray_5;
	mathVector2_1: mathVector2_1;
	mathVector2_2: mathVector2_2;
	mathVector2_3: mathVector2_3;
	mathVector2_3vvf: mathVector2_3vvf;
	mathVector2_4: mathVector2_4;
	mathVector2_5: mathVector2_5;
	mathVector3_1: mathVector3_1;
	mathVector3_2: mathVector3_2;
	mathVector3_3: mathVector3_3;
	mathVector3_3vvf: mathVector3_3vvf;
	mathVector3_4: mathVector3_4;
	mathVector3_5: mathVector3_5;
	mathVector4_1: mathVector4_1;
	mathVector4_2: mathVector4_2;
	mathVector4_3: mathVector4_3;
	mathVector4_3vvf: mathVector4_3vvf;
	mathVector4_4: mathVector4_4;
	mathVector4_5: mathVector4_5;
	mathVectorArray_1: mathVectorArray_1<MathArrayVectorElement>;
	mathVectorArray_2: mathVectorArray_2<MathArrayVectorElement>;
	mathVectorArray_3: mathVectorArray_3<MathArrayVectorElement>;
	mathVectorArray_4: mathVectorArray_4<MathArrayVectorElement>;
	mathVectorArray_5: mathVectorArray_5<MathArrayVectorElement>;
	maxLengthVector2: maxLengthVector2;
	maxLengthVector3: maxLengthVector3;
	maxLengthVector4: maxLengthVector4;
	mix: mix;
	multAdd: multAdd;
	multNumber: multNumber;
	multScalarArrayVectorArray: multScalarArrayVectorArray<Color | Vector2 | Vector3 | Vector4>;
	multScalarColor: multScalarColor;
	multScalarVector2: multScalarVector2;
	multScalarVector3: multScalarVector3;
	multScalarVector4: multScalarVector4;
	multScalarVectorArray: multScalarVectorArray<Color | Vector2 | Vector3 | Vector4>;
	multVector: multVector<Vector2 | Vector3 | Vector4>;
	multVectorNumber: multVectorNumber<Vector2 | Vector3 | Vector4>;
	nearestPosition: nearestPosition;
	negate: negate<boolean | number>;
	normalizeVector2: normalizeVector2;
	normalizeVector3: normalizeVector3;
	normalizeVector4: normalizeVector4;
	object3DLocalToWorld: object3DLocalToWorld;
	object3DWorldToLocal: object3DWorldToLocal;
	objectAddEventListeners: objectAddEventListeners;
	objectDispatchEvent: objectDispatchEvent;
	objectUpdateMatrix: objectUpdateMatrix;
	objectUpdateWorldMatrix: objectUpdateWorldMatrix;
	onPerformanceChange: onPerformanceChange;
	orArrays: orArrays;
	orBooleans: orBooleans;
	particlesSystemReset: particlesSystemReset;
	particlesSystemStepSimulation: particlesSystemStepSimulation;
	pauseAudioSource: pauseAudioSource;
	physicsRBDAddForce: physicsRBDAddForce;
	physicsRBDAddForceAtPoint: physicsRBDAddForceAtPoint;
	physicsRBDAddTorque: physicsRBDAddTorque;
	physicsRBDApplyImpulse: physicsRBDApplyImpulse;
	physicsRBDApplyImpulseAtPoint: physicsRBDApplyImpulseAtPoint;
	physicsRBDApplyTorqueImpulse: physicsRBDApplyTorqueImpulse;
	physicsRBDRemove: physicsRBDRemove;
	physicsRBDResetAll: physicsRBDResetAll;
	physicsRBDResetForces: physicsRBDResetForces;
	physicsRBDResetTorques: physicsRBDResetTorques;
	physicsWorldReset: physicsWorldReset;
	physicsWorldStepSimulation: physicsWorldStepSimulation;
	planeSet: planeSet;
	playAnimation: playAnimation;
	playAudioSource: playAudioSource;
	playerPhysicsUpdate: playerPhysicsUpdate;
	playerSimpleUpdate: playerSimpleUpdate;
	playInstrumentNote: playInstrumentNote;
	pressButtonParam: pressButtonParam;
	rand: rand;
	random: random;
	rayDistanceToPlane: rayDistanceToPlane;
	rayFromCamera: rayFromCamera;
	rayIntersectBox3: rayIntersectBox3;
	rayIntersectObject3D: rayIntersectObject3D;
	rayIntersectPlane: rayIntersectPlane;
	rayIntersectsBox3: rayIntersectsBox3;
	rayIntersectsObject3D: rayIntersectsObject3D;
	rayIntersectSphere: rayIntersectSphere;
	rayIntersectsPlane: rayIntersectsPlane;
	rayIntersectsSphere: rayIntersectsSphere;
	raySet: raySet;
	SDFBox: SDFBox;
	SDFIntersect: SDFIntersect;
	SDFRevolutionX: SDFRevolutionX;
	SDFRevolutionY: SDFRevolutionY;
	SDFRevolutionZ: SDFRevolutionZ;
	SDFRoundedX: SDFRoundedX;
	SDFSmoothIntersect: SDFSmoothIntersect;
	SDFSmoothSubtract: SDFSmoothSubtract;
	SDFSmoothUnion: SDFSmoothUnion;
	SDFSphere: SDFSphere;
	SDFSubtract: SDFSubtract;
	SDFUnion: SDFUnion;
	setGeometryInstanceAttributeColor: setGeometryInstanceAttributeColor;
	setGeometryInstanceAttributeFloat: setGeometryInstanceAttributeFloat;
	setGeometryInstanceAttributeQuaternion: setGeometryInstanceAttributeQuaternion;
	setGeometryInstanceAttributeVector2: setGeometryInstanceAttributeVector2;
	setGeometryInstanceAttributeVector3: setGeometryInstanceAttributeVector3;
	setGeometryInstanceAttributeVector4: setGeometryInstanceAttributeVector4;
	setGeometryInstancePositions: setGeometryInstancePositions;
	setGeometryInstanceQuaternions: setGeometryInstanceQuaternions;
	setGeometryInstanceScales: setGeometryInstanceScales;
	setGeometryInstanceTransforms: setGeometryInstanceTransforms;
	setGeometryPositions: setGeometryPositions;
	setMaterialColor: setMaterialColor;
	setMaterialEmissiveColor: setMaterialEmissiveColor;
	setMaterialOpacity: setMaterialOpacity;
	setMaterialUniformNumber: setMaterialUniformNumber;
	setMaterialUniformVectorColor: setMaterialUniformVectorColor;
	setObjectAttribute: setObjectAttribute;
	setObjectCastShadow: setObjectCastShadow;
	setObjectFrustumCulled: setObjectFrustumCulled;
	setObjectLookAt: setObjectLookAt;
	setObjectMaterial: setObjectMaterial;
	setObjectMaterialColor: setObjectMaterialColor;
	setObjectMatrix: setObjectMatrix;
	setObjectMatrixAutoUpdate: setObjectMatrixAutoUpdate;
	setObjectPolarTransform: setObjectPolarTransform;
	setObjectPosition: setObjectPosition;
	setObjectReceiveShadow: setObjectReceiveShadow;
	setObjectRotation: setObjectRotation;
	setObjectScale: setObjectScale;
	setObjectVisible: setObjectVisible;
	setParamBoolean: setParamBoolean;
	setParamBooleanToggle: setParamBooleanToggle;
	setParamColor: setParamColor;
	setParamFloat: setParamFloat;
	setParamInteger: setParamInteger;
	setParamString: setParamString;
	setParamVector2: setParamVector2;
	setParamVector3: setParamVector3;
	setParamVector4: setParamVector4;
	setPerspectiveCameraFov: setPerspectiveCameraFov;
	setPerspectiveCameraNearFar: setPerspectiveCameraNearFar;
	setPhysicsRBDAngularVelocity: setPhysicsRBDAngularVelocity;
	setPhysicsRBDCapsuleProperty: setPhysicsRBDCapsuleProperty;
	setPhysicsRBDConeProperty: setPhysicsRBDConeProperty;
	setPhysicsRBDCuboidProperty: setPhysicsRBDCuboidProperty;
	setPhysicsRBDCylinderProperty: setPhysicsRBDCylinderProperty;
	setPhysicsRBDLinearVelocity: setPhysicsRBDLinearVelocity;
	setPhysicsRBDPosition: setPhysicsRBDPosition;
	setPhysicsRBDRotation: setPhysicsRBDRotation;
	setPhysicsRBDSphereProperty: setPhysicsRBDSphereProperty;
	setPhysicsWorldGravity: setPhysicsWorldGravity;
	setPlayerInput: setPlayerInput;
	setSpotLightIntensity: setSpotLightIntensity;
	setViewer: setViewer;
	sizzleVec3XY: sizzleVec3XY;
	sizzleVec3XZ: sizzleVec3XZ;
	sizzleVec3YZ: sizzleVec3YZ;
	sizzleVec4WArray: sizzleVec4WArray;
	sizzleVec4XYZ: sizzleVec4XYZ;
	sizzleVec4XYZArray: sizzleVec4XYZArray;
	sleep: sleep;
	smoothstep: smoothstep;
	sphereSet: sphereSet;
	subtractNumber: subtractNumber;
	subtractVector: subtractVector<Vector2 | Vector3 | Vector4>;
	subtractVectorNumber: subtractVectorNumber<Vector2 | Vector3 | Vector4>;
	trackFace: trackFace;
	trackFaceGetLandmarks: trackFaceGetLandmarks;
	trackHand: trackHand;
	trackHandGetNormalizedLandmarks: trackHandGetNormalizedLandmarks;
	trackHandGetWorldLandmarks: trackHandGetWorldLandmarks;
	triggerFilter: triggerFilter;
	triggerTwoWaySwitch: triggerTwoWaySwitch;
	vec2ToVec3: vec2ToVec3;
	vec3ToColor: vec3ToColor;
	vec3ToVec4: vec3ToVec4;
	vector3AngleTo: vector3AngleTo;
	vector3Project: vector3Project;
	vector3ProjectOnPlane: vector3ProjectOnPlane;
	vector3Unproject: vector3Unproject;
}
export interface PersistedConfigBaseJsData extends PersistedConfigWithShaders {
	functionBody: string;
	variableNames: string[];
	variables: SerializedVariable<SerializedVariableType>[];
	functionNames: Array<keyof NamedFunctionMap>;
	serializedParamConfigs: JsParamConfigJSON<ParamType>[];
}
export interface ActorFunctionData extends FunctionData {
	eventDatas: EvaluatorEventData[];
}
export interface ActorPersistedConfigBaseJsData extends PersistedConfigBaseJsData {
	functionBody: string;
	variableNames: string[];
	variables: SerializedVariable<SerializedVariableType>[];
	functionNames: Array<keyof NamedFunctionMap>;
	serializedParamConfigs: JsParamConfigJSON<ParamType>[];
	eventDatas: EvaluatorEventData[];
}
declare class ActorPersistedConfig extends BasePersistedConfig {
	protected node: ActorBuilderNode;
	constructor(node: ActorBuilderNode);
	toData(): Promise<ActorPersistedConfigBaseJsData | undefined>;
	load(data: ActorPersistedConfigBaseJsData): void;
}
declare class JsAssemblerActor extends BaseJsShaderAssembler {
	templateShader(): {
		fragmentShader: string;
		vertexShader: undefined;
		uniforms: undefined;
	};
	inputNamesForShaderName(rootNode: BaseJsNodeType, shaderName: ShaderName): string[];
	computedVariablesAllowed(): boolean;
	spareParamsOptions(): ParamOptions;
	createFunctionData(additionalRootNodes: BaseJsNodeType[]): ActorFunctionData | undefined;
	private _createFunctionData;
	rootNodesByShaderName(shaderName: ShaderName, rootNodes: BaseJsNodeType[]): BaseJsNodeType[];
	create_shader_configs(): ShaderConfig[];
	create_variable_configs(): never[];
}
declare class ActorCompilationController {
	protected node: ActorBuilderNode;
	constructor(node: ActorBuilderNode);
	compileIfRequired(): void;
	private _evaluatorGenerator;
	evaluatorGenerator(): ActorEvaluatorGenerator;
	private _functionData;
	functionData(): ActorFunctionData | undefined;
	updateFromFunctionData(functionData: ActorFunctionData): void;
	private _setEvaluatorGenerator;
	compile(): void;
}
declare class TypedActorSopNode<K extends NodeParamsConfig> extends TypedSopNode<K> {
	protected _childrenControllerContext: NodeContext;
	createNode<S extends keyof JsNodeChildrenMap>(node_class: S, options?: NodeCreateOptions): JsNodeChildrenMap[S];
	createNode<K extends valueof<JsNodeChildrenMap>>(node_class: Constructor<K>, options?: NodeCreateOptions): K;
	children(): BaseJsNodeType[];
	nodesByType<K extends keyof JsNodeChildrenMap>(type: K): JsNodeChildrenMap[K][];
	childrenAllowed(): boolean;
	sceneReadonly(): boolean;
	readonly persisted_config: ActorPersistedConfig;
	assemblerController(): JsAssemblerController<JsAssemblerActor> | undefined;
	usedAssembler(): Readonly<AssemblerName.JS_ACTOR>;
	protected _assemblerController: JsAssemblerController<JsAssemblerActor> | undefined;
	private _createAssemblerController;
	readonly compilationController: ActorCompilationController;
	compile(): void;
}
declare class ActorSopParamsConfig extends NodeParamsConfig {
	/** @param select which objects this applies the actor behavior to */
	objectsMask: ParamTemplate<ParamType.STRING>;
	/** @param build actor from child nodes */
	useThisNode: ParamTemplate<ParamType.BOOLEAN>;
	/** @param actor node */
	node: ParamTemplate<ParamType.NODE_PATH>;
}
declare class ActorSopNode extends TypedActorSopNode<ActorSopParamsConfig> {
	readonly paramsConfig: ActorSopParamsConfig;
	static type(): SopType;
	protected initializeNode(): void;
	cook(inputCoreGroups: CoreGroup[]): Promise<void>;
	private _findActorNode;
}
declare class AddSopParamsConfig extends NodeParamsConfig {
	/** @param toggle to create points */
	createPoint: ParamTemplate<ParamType.BOOLEAN>;
	/** @param define the number of points to create */
	pointsCount: ParamTemplate<ParamType.INTEGER>;
	/** @param the position of the created points */
	position: ParamTemplate<ParamType.VECTOR3>;
	/** @param toggle on to connect the points from the input geometry */
	connectInputPoints: ParamTemplate<ParamType.BOOLEAN>;
	/** @param check if the last point is connected */
	connectToLastPoint: ParamTemplate<ParamType.BOOLEAN>;
}
declare class AddSopNode extends TypedSopNode<AddSopParamsConfig> {
	paramsConfig: AddSopParamsConfig;
	static type(): SopType;
	static displayedInputNames(): string[];
	initializeNode(): void;
	private _operation;
	cook(input_contents: CoreGroup[]): void;
}
declare const AmbientLightSopParamsConfig_base: {
	new (...args: any[]): {
		color: ParamTemplate<ParamType.COLOR>;
		intensity: ParamTemplate<ParamType.FLOAT>;
		name: ParamTemplate<ParamType.STRING>;
	};
} & typeof NodeParamsConfig;
declare class AmbientLightSopParamsConfig extends AmbientLightSopParamsConfig_base {}
declare class AmbientLightSopNode extends TypedSopNode<AmbientLightSopParamsConfig> {
	paramsConfig: AmbientLightSopParamsConfig;
	static type(): string;
	initializeNode(): void;
	private _operation;
	cook(input_contents: CoreGroup[]): void;
}
declare class AnimationCopySopParamsConfig extends NodeParamsConfig {}
declare class AnimationCopySopNode extends TypedSopNode<AnimationCopySopParamsConfig> {
	paramsConfig: AnimationCopySopParamsConfig;
	static type(): string;
	static displayedInputNames(): string[];
	initializeNode(): void;
	cook(input_contents: CoreGroup[]): void;
}
declare const AreaLightSopParamsConfig_base: {
	new (...args: any[]): {
		light: ParamTemplate<ParamType.FOLDER>;
		color: ParamTemplate<ParamType.COLOR>;
		intensity: ParamTemplate<ParamType.FLOAT>;
		width: ParamTemplate<ParamType.FLOAT>;
		height: ParamTemplate<ParamType.FLOAT>;
		showHelper: ParamTemplate<ParamType.BOOLEAN>;
		name: ParamTemplate<ParamType.STRING>;
	};
} & typeof NodeParamsConfig;
declare class AreaLightSopParamsConfig extends AreaLightSopParamsConfig_base {}
declare class AreaLightSopNode extends TypedSopNode<AreaLightSopParamsConfig> {
	paramsConfig: AreaLightSopParamsConfig;
	static type(): LightType;
	initializeNode(): void;
	private _operation;
	cook(input_contents: CoreGroup[]): void;
}
declare class AttribAddMultSopParamsConfig extends NodeParamsConfig {
	/** @param attribute name */
	name: ParamTemplate<ParamType.STRING>;
	/** @param value to add before the multiplication */
	preAdd: ParamTemplate<ParamType.FLOAT>;
	/** @param value to multiply */
	mult: ParamTemplate<ParamType.FLOAT>;
	/** @param value to add after the multiplication */
	postAdd: ParamTemplate<ParamType.FLOAT>;
}
declare class AttribAddMultSopNode extends TypedSopNode<AttribAddMultSopParamsConfig> {
	paramsConfig: AttribAddMultSopParamsConfig;
	static type(): SopType;
	initializeNode(): void;
	private _operation;
	cook(input_contents: CoreGroup[]): void;
}
declare class IndexCastSopParamsConfig extends NodeParamsConfig {
	/** @param toggle on to cast attributes */
	castAttributes: ParamTemplate<ParamType.BOOLEAN>;
	/** @param attrib mask */
	mask: ParamTemplate<ParamType.STRING>;
	/** @param toggle on to cast index */
	castIndex: ParamTemplate<ParamType.BOOLEAN>;
	/** @param type of attribute to cast to */
	type: ParamTemplate<ParamType.INTEGER>;
}
declare class AttribCastSopNode extends TypedSopNode<IndexCastSopParamsConfig> {
	paramsConfig: IndexCastSopParamsConfig;
	static type(): string;
	initializeNode(): void;
	private _operation;
	cook(input_contents: CoreGroup[]): void;
}
declare class AttribCopySopParamsConfig extends NodeParamsConfig {
	/** @param name of the attribute to copy */
	name: ParamTemplate<ParamType.STRING>;
	/** @param toggle if you want to copy to another name */
	tnewName: ParamTemplate<ParamType.BOOLEAN>;
	/** @param the new name of the attribute */
	newName: ParamTemplate<ParamType.STRING>;
	/** @param this defines which component the copy starts from. If you want to copy the whole attribute, leave it at 0. If you want to copy only the y component, set it to 1. If you want to copy the z component, set it to 2. Note that this only makes sense if you copy from an attribute that has enough components to copy from. So setting it to 2 (for z) to copy from a vector2 attribute will raise an error. */
	srcOffset: ParamTemplate<ParamType.INTEGER>;
	/** @param this defines which component the attribute is copied to */
	destOffset: ParamTemplate<ParamType.INTEGER>;
}
declare class AttribCopySopNode extends TypedSopNode<AttribCopySopParamsConfig> {
	paramsConfig: AttribCopySopParamsConfig;
	static type(): SopType;
	static displayedInputNames(): string[];
	initializeNode(): void;
	private _operation;
	cook(input_contents: CoreGroup[]): void;
}
declare class AttribCreateSopParamsConfig extends NodeParamsConfig {
	/** @param the group this applies to */
	group: ParamTemplate<ParamType.STRING>;
	/** @param the attribute class (geometry or object) */
	class: ParamTemplate<ParamType.INTEGER>;
	/** @param the attribute type (numeric or string) */
	type: ParamTemplate<ParamType.INTEGER>;
	/** @param the attribute name */
	name: ParamTemplate<ParamType.STRING>;
	/** @param the attribute size (1 for float, 2 for vector2, 3 for vector3, 4 for vector4) */
	size: ParamTemplate<ParamType.INTEGER>;
	/** @param the value for a float attribute */
	value1: ParamTemplate<ParamType.FLOAT>;
	/** @param the value for a vector2 */
	value2: ParamTemplate<ParamType.VECTOR2>;
	/** @param the value for a vector3 */
	value3: ParamTemplate<ParamType.VECTOR3>;
	/** @param the value for a vector4 */
	value4: ParamTemplate<ParamType.VECTOR4>;
	/** @param the value for a string attribute */
	string: ParamTemplate<ParamType.STRING>;
}
declare class AttribCreateSopNode extends TypedSopNode<AttribCreateSopParamsConfig> {
	paramsConfig: AttribCreateSopParamsConfig;
	static type(): SopType;
	private _arraysByGeoUuid;
	initializeNode(): void;
	private _operation;
	cook(inputCoreGroups: CoreGroup[]): void;
	private _addAttribute;
	private _addPointAttribute;
	private _addObjectAttribute;
	private _addCoreGroupAttribute;
	private _addNumericAttributeToPoints;
	private _addNumericAttributeToObject;
	private _addNumericAttributeToCoreGroup;
	private _addStringAttributeToPoints;
	private _addStringAttributeToObject;
	private _addStringAttributeToCoreGroup;
	private _initArrayIfRequired;
	private _isUsingExpression;
	setAttribClass(attribClass: AttribClass): void;
	attribClass(): AttribClass;
	setAttribType(type: AttribType): void;
	attribType(): AttribType;
	private _hasGroup;
	private _vectorByAttribSize;
}
declare class AttribDeleteSopParamsConfig extends NodeParamsConfig {
	/** @param attribute class (geometry or object) */
	class: ParamTemplate<ParamType.INTEGER>;
	/** @param attribute name to delete */
	name: ParamTemplate<ParamType.STRING>;
}
declare class AttribDeleteSopNode extends TypedSopNode<AttribDeleteSopParamsConfig> {
	paramsConfig: AttribDeleteSopParamsConfig;
	static type(): string;
	static displayedInputNames(): string[];
	initializeNode(): void;
	setAttribClass(attribClass: AttribClass): void;
	cook(inputCoreGroups: CoreGroup[]): void;
	private _attribNames;
	private _deleteAttrib;
	private _deleteVertexAttribute;
	private _deleteObjectAttribute;
	private _deleteCoreGroupAttribute;
}
declare class AttribFromTextureSopParamsConfig extends NodeParamsConfig {
	/** @param texture node */
	texture: ParamTemplate<ParamType.NODE_PATH>;
	/** @param uv attribute */
	uvAttrib: ParamTemplate<ParamType.STRING>;
	/** @param attribute to set the value to */
	attrib: ParamTemplate<ParamType.STRING>;
	/** @param target attribute size */
	attribSize: ParamTemplate<ParamType.INTEGER>;
	/** @param value to add to the attribute */
	add: ParamTemplate<ParamType.FLOAT>;
	/** @param value to multiply the attribute with */
	mult: ParamTemplate<ParamType.FLOAT>;
}
declare class AttribFromTextureSopNode extends TypedSopNode<AttribFromTextureSopParamsConfig> {
	paramsConfig: AttribFromTextureSopParamsConfig;
	static type(): string;
	initializeNode(): void;
	private _operation;
	cook(input_contents: CoreGroup[]): Promise<void>;
}
declare class AttribIdSopParamsConfig extends NodeParamsConfig {
	/** @param the attribute class (geometry or object) */
	class: ParamTemplate<ParamType.INTEGER>;
	/** @param sets to true to create the id attribute */
	id: ParamTemplate<ParamType.BOOLEAN>;
	/** @param name of id attribute */
	idName: ParamTemplate<ParamType.STRING>;
	/** @param sets to true to create the id attribute */
	idn: ParamTemplate<ParamType.BOOLEAN>;
	/** @param name of the position attribute */
	/** @param name of idn attribute */
	idnName: ParamTemplate<ParamType.STRING>;
}
declare class AttribIdSopNode extends TypedSopNode<AttribIdSopParamsConfig> {
	paramsConfig: AttribIdSopParamsConfig;
	static type(): string;
	initializeNode(): void;
	private _operation;
	cook(input_contents: CoreGroup[]): void;
	setAttribClass(attribClass: AttribClass): void;
	attribClass(): AttribClass;
}
declare class BaseSopOperation extends BaseOperation<NodeContext.SOP> {
	static context(): NodeContext;
	cook(input_contents: CoreGroup[], params: any): CoreGroup | Promise<CoreGroup> | void;
	protected createCoreGroupFromObjects(objects: ObjectContent<CoreObjectType>[]): CoreGroup;
	protected createCoreGroupFromGeometry(geometry: BufferGeometry, type?: ObjectType): CoreGroup;
	protected createObject<OT extends ObjectType>(
		geometry: BufferGeometry,
		type: OT,
		material?: Material
	): ObjectByObjectType[OT];
	static createObject<OT extends ObjectType>(
		geometry: BufferGeometry,
		type: OT,
		material?: Material
	): ObjectByObjectType[OT];
	static applyObjectDefault(object: Object3D): void;
	protected createIndexIfNone(geometry: BufferGeometry): void;
	static createIndexIfNone(geometry: BufferGeometry): void;
}
declare enum NormalizeMode {
	MIN_MAX_TO_01 = 'min/max to 0/1',
	VECTOR_TO_LENGTH_1 = 'vectors to length 1',
}
declare class AttribNormalizeSopParamsConfig extends NodeParamsConfig {
	/** @param defines if the value should be normalized between 0 and 1, or for vectors if the length should be 1 */
	mode: ParamTemplate<ParamType.INTEGER>;
	/** @param attribute to normalize */
	name: ParamTemplate<ParamType.STRING>;
	/** @param toggle to change the name of the attribute */
	changeName: ParamTemplate<ParamType.BOOLEAN>;
	/** @param new attribute name */
	newName: ParamTemplate<ParamType.STRING>;
}
declare class AttribNormalizeSopNode extends TypedSopNode<AttribNormalizeSopParamsConfig> {
	paramsConfig: AttribNormalizeSopParamsConfig;
	static type(): string;
	initializeNode(): void;
	set_mode(mode: NormalizeMode): void;
	private _operation;
	cook(input_contents: CoreGroup[]): void;
}
declare enum AttribPromoteMode {
	MIN = 'min',
	MAX = 'max',
	FIRST_FOUND = 'first_round',
}
declare class AttribPromoteSopParamsConfig extends NodeParamsConfig {
	/** @param class the attribute is from (object or geometry) */
	classFrom: ParamTemplate<ParamType.INTEGER>;
	/** @param class the attribute should be promoted to (object or geometry) */
	classTo: ParamTemplate<ParamType.INTEGER>;
	/** @param mode used to promote the attribute (min, max or first_found) */
	mode: ParamTemplate<ParamType.INTEGER>;
	/** @param name of the attribute to promote */
	name: ParamTemplate<ParamType.STRING>;
}
declare class AttribPromoteSopNode extends TypedSopNode<AttribPromoteSopParamsConfig> {
	paramsConfig: AttribPromoteSopParamsConfig;
	static type(): string;
	initializeNode(): void;
	private _operation;
	cook(inputCoreGroups: CoreGroup[]): void;
	setAttribClassFrom(attribClass: AttribClass): void;
	setAttribClassTo(attribClass: AttribClass): void;
	setPromoteMode(mode: AttribPromoteMode): void;
}
declare class AttribRemapSopParamsConfig extends NodeParamsConfig {
	/** @param name of the attribute to remap */
	name: ParamTemplate<ParamType.STRING>;
	/** @param ramp used to remap */
	ramp: ParamTemplate<ParamType.RAMP>;
	/** @param toggle if you want to create a new attribute */
	changeName: ParamTemplate<ParamType.BOOLEAN>;
	/** @param new attribute name */
	newName: ParamTemplate<ParamType.STRING>;
}
declare class AttribRemapSopNode extends TypedSopNode<AttribRemapSopParamsConfig> {
	paramsConfig: AttribRemapSopParamsConfig;
	static type(): string;
	initializeNode(): void;
	cook(input_contents: CoreGroup[]): void;
	private _remap_attribute;
	private _get_remaped_values;
	private _getNormalizedFloat;
	private _getNormalizedVector2;
	private _getNormalizedVector3;
	private _getNormalizedVector4;
}
declare class AttribRenameSopParamsConfig extends NodeParamsConfig {
	/** @param class of the attribute to rename (object or geometry) */
	class: ParamTemplate<ParamType.INTEGER>;
	/** @param old attribute name */
	oldName: ParamTemplate<ParamType.STRING>;
	/** @param new attribute name */
	newName: ParamTemplate<ParamType.STRING>;
}
declare class AttribRenameSopNode extends TypedSopNode<AttribRenameSopParamsConfig> {
	paramsConfig: AttribRenameSopParamsConfig;
	static type(): string;
	initializeNode(): void;
	private _operation;
	cook(input_contents: CoreGroup[]): void;
}
declare class AttribSetAtIndexSopParamsConfig extends NodeParamsConfig {
	/** @param the point or object index this applies to */
	index: ParamTemplate<ParamType.INTEGER>;
	/** @param the attribute class (geometry or object) */
	class: ParamTemplate<ParamType.INTEGER>;
	/** @param the attribute type (numeric or string) */
	type: ParamTemplate<ParamType.INTEGER>;
	/** @param the attribute name */
	name: ParamTemplate<ParamType.STRING>;
	/** @param the attribute size (1 for float, 2 for vector2, 3 for vector3, 4 for vector4) */
	size: ParamTemplate<ParamType.INTEGER>;
	/** @param the value for a float attribute */
	value1: ParamTemplate<ParamType.FLOAT>;
	/** @param the value for a vector2 */
	value2: ParamTemplate<ParamType.VECTOR2>;
	/** @param the value for a vector3 */
	value3: ParamTemplate<ParamType.VECTOR3>;
	/** @param the value for a vector4 */
	value4: ParamTemplate<ParamType.VECTOR4>;
	/** @param the value for a string attribute */
	string: ParamTemplate<ParamType.STRING>;
}
declare class AttribSetAtIndexSopNode extends TypedSopNode<AttribSetAtIndexSopParamsConfig> {
	paramsConfig: AttribSetAtIndexSopParamsConfig;
	static type(): string;
	initializeNode(): void;
	private _operation;
	cook(inputCoreGroups: CoreGroup[]): void;
	private _addAttribute;
	private _addPointAttribute;
	private _addObjectAttribute;
	private _addCoreGroupAttribute;
	private _addNumericAttributeToPoints;
	private _addNumericAttributeToObject;
	private _addNumericAttributeToCoreGroup;
	private _addStringAttributeToPoints;
	private _addStringAttributeToObject;
	private _addStringAttributeToCoreGroup;
	private _isUsingExpression;
	setAttribClass(attribClass: AttribClass): void;
	attribClass(): AttribClass;
	setAttribType(type: AttribType): void;
	attribType(): AttribType;
}
export declare type OctreeNodeTraverseCallback = (node: OctreeNode) => void;
declare class OctreeNode {
	private _bbox;
	private _level;
	_leaves_by_octant: PolyDictionary<OctreeNode>;
	_points_by_octant_id: PolyDictionary<CorePoint[]>;
	_leaves: OctreeNode[];
	_center: Vector3;
	_bounding_boxes_by_octant: PolyDictionary<Box3>;
	_bounding_boxes_by_octant_prepared: boolean;
	constructor(_bbox: Box3, _level?: number);
	level(): number;
	traverse(callback: OctreeNodeTraverseCallback): void;
	intersects_sphere(sphere: Sphere): boolean;
	points_in_sphere(sphere: Sphere, accumulated_points: CorePoint[]): void;
	bounding_box(): Box3 | undefined;
	set_points(points: CorePoint[]): void;
	create_leaf(octant_id: string): void;
	add_point(point: CorePoint): void;
	private _octant_id;
	_leaf_bbox(octant_id: string): Box3;
	private _bbox_center;
	private _prepare_leaves_bboxes;
}
declare class CoreOctree {
	private _root;
	constructor(bbox: Box3);
	set_points(points: CorePoint[]): void;
	traverse(callback: OctreeNodeTraverseCallback): void;
	find_points(position: Vector3, distance: number, max_points_count?: number): CorePoint[];
}
declare class AttribTransferSopParamsConfig extends NodeParamsConfig {
	/** @param source group to transfer from (right input, or input 1) */
	srcGroup: ParamTemplate<ParamType.STRING>;
	/** @param dest group to transfer to (left input, or input 0) */
	destGroup: ParamTemplate<ParamType.STRING>;
	/** @param name of the attribute to transfer */
	name: ParamTemplate<ParamType.STRING>;
	/** @param max number of samples to use */
	maxSamplesCount: ParamTemplate<ParamType.INTEGER>;
	/** @param max distance to search points to transfer from */
	distanceThreshold: ParamTemplate<ParamType.FLOAT>;
	/** @param blend width */
	blendWidth: ParamTemplate<ParamType.FLOAT>;
}
declare class AttribTransferSopNode extends TypedSopNode<AttribTransferSopParamsConfig> {
	paramsConfig: AttribTransferSopParamsConfig;
	static type(): string;
	_core_group_dest: CoreGroup;
	_core_group_src: CoreGroup;
	_attrib_names: string[];
	_octree_timestamp: number | undefined;
	_prev_param_srcGroup: string | undefined;
	_octree: CoreOctree | undefined;
	static displayedInputNames(): string[];
	initializeNode(): void;
	cook(input_contents: CoreGroup[]): Promise<void>;
	_error_if_attribute_not_found_on_second_input(): void;
	private _build_octree_if_required;
	private _add_attribute_if_required;
	private _transfer_attributes;
	private _transfer_attributes_for_point;
	private _interpolate_points;
}
declare class AudioNotesSopParamsConfig extends NodeParamsConfig {
	/** @param the attribute class (geometry or object) */
	class: ParamTemplate<ParamType.INTEGER>;
	/** @param attribute name */
	name: ParamTemplate<ParamType.STRING>;
	/** @param adds an octave attribute */
	toctave: ParamTemplate<ParamType.BOOLEAN>;
	/** @param octave attribute name */
	octaveName: ParamTemplate<ParamType.STRING>;
	/** @param octave to start iterating the notes from */
	startOctave: ParamTemplate<ParamType.INTEGER>;
	/** @param last octave up to which the nodes will be added */
	endOctave: ParamTemplate<ParamType.INTEGER>;
	/** @param behavior if there are more objects than notes within the selected octave range */
	outOfRangeBehavior: ParamTemplate<ParamType.INTEGER>;
}
declare class AudioNotesSopNode extends TypedSopNode<AudioNotesSopParamsConfig> {
	paramsConfig: AudioNotesSopParamsConfig;
	static type(): string;
	initializeNode(): void;
	private _operation;
	cook(input_contents: CoreGroup[]): void;
	setClass(attribClass: AttribClass): void;
}
declare class AxesHelperSopParamsConfig extends NodeParamsConfig {
	/** @param center of the geometry */
	center: ParamTemplate<ParamType.VECTOR3>;
}
declare class AxesHelperSopNode extends TypedSopNode<AxesHelperSopParamsConfig> {
	paramsConfig: AxesHelperSopParamsConfig;
	static type(): SopType;
	initializeNode(): void;
	private _operation;
	cook(input_contents: CoreGroup[]): void;
}
declare class BboxScatterSopParamsConfig extends NodeParamsConfig {
	/** @param the smaller the step size, the more points this will create */
	stepSize: ParamTemplate<ParamType.FLOAT>;
}
declare class BboxScatterSopNode extends TypedSopNode<BboxScatterSopParamsConfig> {
	paramsConfig: BboxScatterSopParamsConfig;
	static type(): string;
	static displayedInputNames(): string[];
	initializeNode(): void;
	private _operation;
	cook(input_contents: CoreGroup[]): void;
}
declare class BlendSopParamsConfig extends NodeParamsConfig {
	/** @param name of the attribute to blend */
	attribName: ParamTemplate<ParamType.STRING>;
	/** @param blend value. 0 means the result will equal the left input, 1 will equal the right input, and 0.5 will be an average of both. */
	blend: ParamTemplate<ParamType.FLOAT>;
	/** @param update normals */
	updateNormals: ParamTemplate<ParamType.BOOLEAN>;
}
declare class BlendSopNode extends TypedSopNode<BlendSopParamsConfig> {
	paramsConfig: BlendSopParamsConfig;
	static type(): SopType;
	static displayedInputNames(): string[];
	initializeNode(): void;
	cook(inputCoreGroups: CoreGroup[]): void;
	private blend;
}
declare enum BooleanOperation {
	INTERSECT = 'intersect',
	SUBTRACT = 'subtract',
	ADD = 'add',
	DIFFERENCE = 'difference',
}
declare class BooleanSopParamsConfig extends NodeParamsConfig {
	/** @param url to load the geometry from */
	operation: ParamTemplate<ParamType.INTEGER>;
	/** @param preserves the color attribute of both input */
	keepVertexColor: ParamTemplate<ParamType.BOOLEAN>;
	/** @param add any additional attribute to be preserved */
	additionalAttributes: ParamTemplate<ParamType.STRING>;
	/** @param defines if only the material from the first input is used, or if the ones from both inputs should be used */
	keepMaterials: ParamTemplate<ParamType.BOOLEAN>;
	/** @param if one of the input has multiple material for a single object, and you'd like to preserve those, toggle this on */
	useInputGroups: ParamTemplate<ParamType.BOOLEAN>;
	/** @param intersectionEdgesOnly */
	intersectionEdgesOnly: ParamTemplate<ParamType.BOOLEAN>;
}
declare class BooleanSopNode extends TypedSopNode<BooleanSopParamsConfig> {
	paramsConfig: BooleanSopParamsConfig;
	static type(): string;
	initializeNode(): void;
	setOperation(operation: BooleanOperation): void;
	private _operation;
	cook(inputCoreGroups: CoreGroup[]): void;
}
declare class BoxSopParamsConfig extends NodeParamsConfig {
	/** @param size of the box */
	size: ParamTemplate<ParamType.FLOAT>;
	/** @param sizes on each axis */
	sizes: ParamTemplate<ParamType.VECTOR3>;
	/** @param number of segments on each axis */
	divisions: ParamTemplate<ParamType.INTEGER>;
	/** @param center of the geometry */
	center: ParamTemplate<ParamType.VECTOR3>;
}
declare class BoxSopNode extends TypedSopNode<BoxSopParamsConfig> {
	readonly paramsConfig: BoxSopParamsConfig;
	static type(): SopType;
	static displayedInputNames(): string[];
	protected initializeNode(): void;
	private _operation;
	cook(inputCoreGroups: CoreGroup[]): void;
}
declare class BoxLinesSopParamsConfig extends NodeParamsConfig {
	/** @param size of the box */
	size: ParamTemplate<ParamType.FLOAT>;
	/** @param sizes on each axis */
	sizes: ParamTemplate<ParamType.VECTOR3>;
	/** @param divisions on each axis */
	divisions: ParamTemplate<ParamType.VECTOR3>;
	/** @param center of the geometry */
	center: ParamTemplate<ParamType.VECTOR3>;
}
declare class BoxLinesSopNode extends TypedSopNode<BoxLinesSopParamsConfig> {
	readonly paramsConfig: BoxLinesSopParamsConfig;
	static type(): SopType;
	static displayedInputNames(): string[];
	protected initializeNode(): void;
	private _operation;
	cook(inputCoreGroups: CoreGroup[]): void;
}
declare class BVHSopParamsConfig extends NodeParamsConfig {
	strategy: ParamTemplate<ParamType.INTEGER>;
	maxDepth: ParamTemplate<ParamType.INTEGER>;
	maxLeafTris: ParamTemplate<ParamType.INTEGER>;
	verbose: ParamTemplate<ParamType.BOOLEAN>;
	keepOnlyPosition: ParamTemplate<ParamType.BOOLEAN>;
}
declare class BVHSopNode extends TypedSopNode<BVHSopParamsConfig> {
	paramsConfig: BVHSopParamsConfig;
	static type(): string;
	static displayedInputNames(): string[];
	initializeNode(): void;
	private _operation;
	cook(input_contents: CoreGroup[]): void;
}
declare class BVHVisualizerSopParamsConfig extends NodeParamsConfig {
	/** @param depth */
	depth: ParamTemplate<ParamType.INTEGER>;
	/** @param opacity */
	opacity: ParamTemplate<ParamType.FLOAT>;
	/** @param depth */
	displayEdges: ParamTemplate<ParamType.BOOLEAN>;
	/** @param depth */
	displayParents: ParamTemplate<ParamType.BOOLEAN>;
}
declare class BVHVisualizerSopNode extends TypedSopNode<BVHVisualizerSopParamsConfig> {
	paramsConfig: BVHVisualizerSopParamsConfig;
	static type(): string;
	static displayedInputNames(): string[];
	initializeNode(): void;
	private _operation;
	cook(input_contents: CoreGroup[]): void;
}
declare class CacheSopParamsConfig extends NodeParamsConfig {
	/** @param content of the cache (hidden) */
	cache: ParamTemplate<ParamType.STRING>;
	/** @param clears the cache */
	reset: ParamTemplate<ParamType.BUTTON>;
}
declare class CacheSopNode extends TypedSopNode<CacheSopParamsConfig> {
	paramsConfig: CacheSopParamsConfig;
	static type(): string;
	static displayedInputNames(): string[];
	initializeNode(): void;
	cook(inputCoreGroups: CoreGroup[]): void;
	static PARAM_CALLBACK_reset(node: CacheSopNode, param: BaseParamType): void;
	param_callback_PARAM_CALLBACK_reset(): Promise<void>;
}
declare class CADSopNode<K extends NodeParamsConfig> extends TypedSopNode<K> {
	dataType(): string;
	requiredModules(): ModuleName[];
	setCADGeom2dCurve(curve: Geom2d_Curve): void;
	setCADShape(shape: TopoDS_Shape): void;
	setCADShapes(shapes: TopoDS_Shape[]): void;
	setCADObjects(cadObjects: CadObject<CadGeometryType>[]): void;
	setCADObject(cadObject: CadObject<CadGeometryType>): void;
	protected _setContainerCadObjects(objects: CadObject<CadGeometryType>[]): void;
	processError(e: unknown): string;
}
declare enum BooleanCadOperationType {
	INTERSECT = 'intersect',
	SECTION = 'section',
	SUBTRACT = 'subtract',
	UNION = 'union',
}
declare class CADBooleanSopParamsConfig extends NodeParamsConfig {
	/** @param operation */
	operation: ParamTemplate<ParamType.INTEGER>;
	/** @param mode */
	mode: ParamTemplate<ParamType.INTEGER>;
}
declare class CADBooleanSopNode extends CADSopNode<CADBooleanSopParamsConfig> {
	paramsConfig: CADBooleanSopParamsConfig;
	static type(): SopType;
	protected initializeNode(): void;
	setOperation(operation: BooleanCadOperationType): void;
	cook(inputCoreGroups: CoreGroup[]): void;
	private _createBooleansAllInSequence;
	private _createBooleansOneToOne;
	private _createBooleansOneToMany;
}
declare class CADBoxSopParamsConfig extends NodeParamsConfig {
	/** @param size */
	size: ParamTemplate<ParamType.FLOAT>;
	/** @param sizes */
	sizes: ParamTemplate<ParamType.VECTOR3>;
	/** @param center */
	center: ParamTemplate<ParamType.VECTOR3>;
}
declare class CADBoxSopNode extends CADSopNode<CADBoxSopParamsConfig> {
	readonly paramsConfig: CADBoxSopParamsConfig;
	static type(): SopType;
	cook(): Promise<void>;
}
declare class CADCircleSopParamsConfig extends NodeParamsConfig {
	/** @param radius */
	radius: ParamTemplate<ParamType.FLOAT>;
	/** @param axis */
	axis: ParamTemplate<ParamType.VECTOR3>;
	/** @param center */
	center: ParamTemplate<ParamType.VECTOR3>;
}
declare class CADCircleSopNode extends CADSopNode<CADCircleSopParamsConfig> {
	paramsConfig: CADCircleSopParamsConfig;
	static type(): SopType;
	cook(inputCoreGroups: CoreGroup[]): Promise<void>;
}
declare class CADCircle2DSopParamsConfig extends NodeParamsConfig {
	/** @param radius */
	radius: ParamTemplate<ParamType.FLOAT>;
	/** @param center */
	center: ParamTemplate<ParamType.VECTOR2>;
}
declare class CADCircle2DSopNode extends CADSopNode<CADCircle2DSopParamsConfig> {
	paramsConfig: CADCircle2DSopParamsConfig;
	static type(): SopType;
	cook(inputCoreGroups: CoreGroup[]): Promise<void>;
}
declare class CADCircle3PointsSopParamsConfig extends NodeParamsConfig {}
declare class CADCircle3PointsSopNode extends CADSopNode<CADCircle3PointsSopParamsConfig> {
	paramsConfig: CADCircle3PointsSopParamsConfig;
	static type(): SopType;
	protected initializeNode(): void;
	cook(inputCoreGroups: CoreGroup[]): Promise<void>;
}
declare class CADConeSopParamsConfig extends NodeParamsConfig {
	/** @param base radius */
	baseRadius: ParamTemplate<ParamType.FLOAT>;
	/** @param top radius */
	topRadius: ParamTemplate<ParamType.FLOAT>;
	/** @param height */
	height: ParamTemplate<ParamType.FLOAT>;
	/** @param center */
	center: ParamTemplate<ParamType.VECTOR3>;
	/** @param axis */
	axis: ParamTemplate<ParamType.VECTOR3>;
	/** @param closed */
	closed: ParamTemplate<ParamType.BOOLEAN>;
	/** @param phi */
	phi: ParamTemplate<ParamType.FLOAT>;
}
declare class CADConeSopNode extends CADSopNode<CADConeSopParamsConfig> {
	paramsConfig: CADConeSopParamsConfig;
	static type(): SopType;
	cook(inputCoreGroups: CoreGroup[]): Promise<void>;
}
declare enum ConversionMode {
	TO_2D = 'to 2D',
	TO_3D = 'to 3D',
}
declare class CADConvertDimensionSopParamsConfig extends NodeParamsConfig {
	/** @param mode */
	mode: ParamTemplate<ParamType.INTEGER>;
}
declare class CADConvertDimensionSopNode extends CADSopNode<CADConvertDimensionSopParamsConfig> {
	paramsConfig: CADConvertDimensionSopParamsConfig;
	static type(): SopType;
	protected initializeNode(): void;
	setMode(mode: ConversionMode): void;
	cook(inputCoreGroups: CoreGroup[]): void;
}
declare class CADCurve2DToSurfaceSopParamsConfig extends NodeParamsConfig {}
declare class CADCurve2DToSurfaceSopNode extends CADSopNode<CADCurve2DToSurfaceSopParamsConfig> {
	paramsConfig: CADCurve2DToSurfaceSopParamsConfig;
	static type(): SopType;
	protected initializeNode(): void;
	cook(inputCoreGroups: CoreGroup[]): void;
}
declare class CADCurveFromPointsSopParamsConfig extends NodeParamsConfig {}
declare class CADCurveFromPointsSopNode extends CADSopNode<CADCurveFromPointsSopParamsConfig> {
	paramsConfig: CADCurveFromPointsSopParamsConfig;
	static type(): SopType;
	protected initializeNode(): void;
	cook(inputCoreGroups: CoreGroup[]): void;
}
declare class CADCurveFromPoints2DSopParamsConfig extends NodeParamsConfig {}
declare class CADCurveFromPoints2DSopNode extends CADSopNode<CADCurveFromPoints2DSopParamsConfig> {
	paramsConfig: CADCurveFromPoints2DSopParamsConfig;
	static type(): SopType;
	protected initializeNode(): void;
	cook(inputCoreGroups: CoreGroup[]): void;
}
declare class CADCurveTrimSopParamsConfig extends NodeParamsConfig {
	/** @param min */
	min: ParamTemplate<ParamType.FLOAT>;
	/** @param max */
	max: ParamTemplate<ParamType.FLOAT>;
}
declare class CADCurveTrimSopNode extends CADSopNode<CADCurveTrimSopParamsConfig> {
	paramsConfig: CADCurveTrimSopParamsConfig;
	static type(): SopType;
	protected initializeNode(): void;
	cook(inputCoreGroups: CoreGroup[]): void;
}
declare class CADEllipseSopParamsConfig extends NodeParamsConfig {
	/** @param major radius */
	majorRadius: ParamTemplate<ParamType.FLOAT>;
	/** @param minor radius */
	minorRadius: ParamTemplate<ParamType.FLOAT>;
	/** @param axis */
	axis: ParamTemplate<ParamType.VECTOR3>;
	/** @param center */
	center: ParamTemplate<ParamType.VECTOR3>;
}
declare class CADEllipseSopNode extends CADSopNode<CADEllipseSopParamsConfig> {
	paramsConfig: CADEllipseSopParamsConfig;
	static type(): SopType;
	cook(inputCoreGroups: CoreGroup[]): Promise<void>;
}
declare class CADEllipse2DSopParamsConfig extends NodeParamsConfig {
	/** @param major radius */
	majorRadius: ParamTemplate<ParamType.FLOAT>;
	/** @param minor radius */
	minorRadius: ParamTemplate<ParamType.FLOAT>;
	/** @param axis */
	/** @param center */
	center: ParamTemplate<ParamType.VECTOR2>;
}
declare class CADEllipse2DSopNode extends CADSopNode<CADEllipse2DSopParamsConfig> {
	paramsConfig: CADEllipse2DSopParamsConfig;
	static type(): SopType;
	cook(inputCoreGroups: CoreGroup[]): Promise<void>;
}
export declare type Result = ArrayBuffer | string | object;
declare class BaseExporterSopParamsConfig extends NodeParamsConfig {
	/** @param fileName */
	fileName: ParamTemplate<ParamType.STRING>;
	/** @param export */
	download: ParamTemplate<ParamType.BUTTON>;
}
declare abstract class ExporterSopNode<K extends BaseExporterSopParamsConfig> extends TypedSopNode<K> {
	abstract fileExtension(): string;
	abstract createBlob(): Promise<Blob>;
	initializeNode(): void;
	cook(inputCoreGroups: CoreGroup[]): Promise<void>;
	static PARAM_CALLBACK_download(node: ExporterSopNode<BaseExporterSopParamsConfig>): void;
	fileName(): Promise<string>;
	_paramCallbackDownload(): Promise<void>;
	protected _prepareScene(): Promise<
		| {
				scene: Scene;
				objects: Object3D<Event>[];
		  }
		| undefined
	>;
	protected _handleResult(result: Result, objects: Object3D[], resolve: (blob: Blob) => void): void;
}
declare abstract class CADExporterSopNode<K extends BaseExporterSopParamsConfig> extends CADSopNode<K> {
	abstract fileExtension(): string;
	abstract createBlob(): Promise<Blob>;
	initializeNode(): void;
	cook(inputCoreGroups: CoreGroup[]): Promise<void>;
	static PARAM_CALLBACK_download(node: CADExporterSopNode<BaseExporterSopParamsConfig>): void;
	fileName(): Promise<string>;
	_paramCallbackDownload(): Promise<void>;
	protected _prepareScene(): Promise<
		| {
				cadObjects: CadObject<CadGeometryType>[];
		  }
		| undefined
	>;
}
declare class ExporterSTEPSopParamsConfig extends BaseExporterSopParamsConfig {}
declare class CADExporterSTEPSopNode extends CADExporterSopNode<ExporterSTEPSopParamsConfig> {
	paramsConfig: ExporterSTEPSopParamsConfig;
	static type(): SopType;
	fileExtension(): string;
	createBlob(): Promise<Blob>;
}
declare class CADExtrudeSopParamsConfig extends NodeParamsConfig {
	/** @param direction */
	dir: ParamTemplate<ParamType.VECTOR3>;
	/** @param height */
	height: ParamTemplate<ParamType.FLOAT>;
	/** @param create caps */
	cap: ParamTemplate<ParamType.BOOLEAN>;
	/** @param convert caps to faces */
	capsAsFaces: ParamTemplate<ParamType.BOOLEAN>;
}
declare class CADExtrudeSopNode extends CADSopNode<CADExtrudeSopParamsConfig> {
	paramsConfig: CADExtrudeSopParamsConfig;
	static type(): SopType;
	protected initializeNode(): void;
	cook(inputCoreGroups: CoreGroup[]): void;
	private _processObject;
	private _processVertexObject;
	private _processEdgeObject;
	private _processWireObject;
	private _processWire;
	private _processFaceObject;
	private _processFace;
	private _processShellObject;
}
declare class DRACOLoader extends Loader {
	constructor(manager?: LoadingManager);
	load(
		url: string,
		onLoad: (geometry: BufferGeometry) => void,
		onProgress?: (event: ProgressEvent) => void,
		onError?: (event: ErrorEvent) => void
	): void;
	loadAsync(url: string, onProgress?: (event: ProgressEvent) => void): Promise<BufferGeometry>;
	setDecoderPath(path: string): DRACOLoader;
	setDecoderConfig(config: object): DRACOLoader;
	setWorkerLimit(workerLimit: number): DRACOLoader;
	preload(): DRACOLoader;
	dispose(): DRACOLoader;
}
declare class KTX2Loader extends CompressedTextureLoader {
	constructor(manager?: LoadingManager);
	setTranscoderPath(path: string): KTX2Loader;
	setWorkerLimit(limit: number): KTX2Loader;
	detectSupport(renderer: WebGLRenderer): KTX2Loader;
	dispose(): KTX2Loader;
	parse(
		buffer: ArrayBuffer,
		onLoad: (texture: CompressedTexture) => void,
		onError?: (event: ErrorEvent) => void
	): KTX2Loader;
}
export interface GLTF {
	animations: AnimationClip[];
	scene: Group;
	scenes: Group[];
	cameras: Camera[];
	asset: {
		copyright?: string | undefined;
		generator?: string | undefined;
		version?: string | undefined;
		minVersion?: string | undefined;
		extensions?: any;
		extras?: any;
	};
	parser: GLTFParser;
	userData: any;
}
declare class GLTFLoader extends Loader {
	constructor(manager?: LoadingManager);
	dracoLoader: DRACOLoader | null;
	load(
		url: string,
		onLoad: (gltf: GLTF) => void,
		onProgress?: (event: ProgressEvent) => void,
		onError?: (event: ErrorEvent) => void
	): void;
	loadAsync(url: string, onProgress?: (event: ProgressEvent) => void): Promise<GLTF>;
	setDRACOLoader(dracoLoader: DRACOLoader): GLTFLoader;
	register(callback: (parser: GLTFParser) => GLTFLoaderPlugin): GLTFLoader;
	unregister(callback: (parser: GLTFParser) => GLTFLoaderPlugin): GLTFLoader;
	setKTX2Loader(ktx2Loader: KTX2Loader): GLTFLoader;
	setMeshoptDecoder(meshoptDecoder: any): GLTFLoader;
	parse(
		data: ArrayBuffer | string,
		path: string,
		onLoad: (gltf: GLTF) => void,
		onError?: (event: ErrorEvent) => void
	): void;
	parseAsync(data: ArrayBuffer | string, path: string): Promise<GLTF>;
}
export interface GLTFReference {
	materials?: number;
	nodes?: number;
	textures?: number;
	meshes?: number;
}
declare class GLTFParser {
	json: any;
	options: {
		path: string;
		manager: LoadingManager;
		ktx2Loader: KTX2Loader;
		meshoptDecoder: any;
		crossOrigin: string;
		requestHeader: {
			[header: string]: string;
		};
	};
	fileLoader: FileLoader;
	textureLoader: TextureLoader | ImageBitmapLoader;
	plugins: {
		[name: string]: GLTFLoaderPlugin;
	};
	extensions: {
		[name: string]: any;
	};
	associations: Map<Object3D | Material | Texture, GLTFReference>;
	setExtensions(extensions: {[name: string]: any}): void;
	setPlugins(plugins: {[name: string]: GLTFLoaderPlugin}): void;
	parse(onLoad: (gltf: GLTF) => void, onError?: (event: ErrorEvent) => void): void;
	getDependency: (type: string, index: number) => Promise<any>;
	getDependencies: (type: string) => Promise<any[]>;
	loadBuffer: (bufferIndex: number) => Promise<ArrayBuffer>;
	loadBufferView: (bufferViewIndex: number) => Promise<ArrayBuffer>;
	loadAccessor: (accessorIndex: number) => Promise<BufferAttribute | InterleavedBufferAttribute>;
	loadTexture: (textureIndex: number) => Promise<Texture>;
	loadTextureImage: (textureIndex: number, sourceIndex: number, loader: Loader) => Promise<Texture>;
	loadImageSource: (sourceIndex: number, loader: Loader) => Promise<Texture>;
	assignTexture: (
		materialParams: {
			[key: string]: any;
		},
		mapName: string,
		mapDef: {
			index: number;
			texCoord?: number | undefined;
			extensions?: any;
		}
	) => Promise<void>;
	assignFinalMaterial: (object: Mesh) => void;
	getMaterialType: () => typeof MeshStandardMaterial;
	loadMaterial: (materialIndex: number) => Promise<Material>;
	createUniqueName: (originalName: string) => string;
	createNodeMesh: (nodeIndex: number) => Promise<Group | Mesh | SkinnedMesh>;
	loadGeometries: (
		/**
		 * GLTF.Primitive[]
		 * See: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/schema/mesh.primitive.schema.json
		 */
		primitives: Array<{
			[key: string]: any;
		}>
	) => Promise<BufferGeometry[]>;
	loadMesh: (meshIndex: number) => Promise<Group | Mesh | SkinnedMesh>;
	loadCamera: (cameraIndex: number) => Promise<Camera>;
	loadSkin: (skinIndex: number) => Promise<{
		joints: number[];
		inverseBindMatrices?: BufferAttribute | InterleavedBufferAttribute | undefined;
	}>;
	loadAnimation: (animationIndex: number) => Promise<AnimationClip>;
	loadNode: (nodeIndex: number) => Promise<Object3D>;
	loadScene: () => Promise<Group>;
}
export interface GLTFLoaderPlugin {
	beforeRoot?: (() => Promise<void> | null) | undefined;
	afterRoot?: ((result: GLTF) => Promise<void> | null) | undefined;
	loadNode?: ((nodeIndex: number) => Promise<Object3D> | null) | undefined;
	loadMesh?: ((meshIndex: number) => Promise<Group | Mesh | SkinnedMesh> | null) | undefined;
	loadBufferView?: ((bufferViewIndex: number) => Promise<ArrayBuffer> | null) | undefined;
	loadMaterial?: ((materialIndex: number) => Promise<Material> | null) | undefined;
	loadTexture?: ((textureIndex: number) => Promise<Texture> | null) | undefined;
	getMaterialType?: ((materialIndex: number) => typeof Material | null) | undefined;
	extendMaterialParams?:
		| ((
				materialIndex: number,
				materialParams: {
					[key: string]: any;
				}
		  ) => Promise<any> | null)
		| undefined;
	createNodeMesh?: ((nodeIndex: number) => Promise<Group | Mesh | SkinnedMesh> | null) | undefined;
	createNodeAttachment?: ((nodeIndex: number) => Promise<Object3D> | null) | undefined;
}
export interface PDB {
	geometryAtoms: BufferGeometry;
	geometryBonds: BufferGeometry;
	json: {
		atoms: any[][];
	};
}
export declare type BaseGeoLoaderOutput = Object3D | BufferGeometry | PDB | GLTF | Array<ObjectContent<CoreObjectType>>;
export declare type OnSuccess<O extends BaseGeoLoaderOutput> = (o: O) => void;
export declare type OnProgress = (n: ProgressEvent<EventTarget>) => void;
export declare type OnError = (event: any) => void;
export interface BaseLoaderLoadOptions {
	node: BaseNodeType;
}
export interface MultipleDependenciesLoadFileOptions {
	fullUrl: string;
}
export interface MultipleDependenciesLoadOptions {
	files: MultipleDependenciesLoadFileOptions[];
	error: string;
	node?: BaseNodeType;
}
export declare type OnAssetLoadedCallback = (url: string, asset?: BaseGeoLoaderOutput | Texture) => void;
declare class CoreBaseLoader<U extends string | Array<string>> {
	protected _url: U;
	protected _node?: BaseNodeType | undefined;
	blobOptions: BlobsControllerFetchNodeOptions;
	static readonly loadingManager: LoadingManager;
	readonly loadingManager: LoadingManager;
	constructor(_url: U, _node?: BaseNodeType | undefined, blobOptions?: BlobsControllerFetchNodeOptions);
	static extension(url: string): string;
	extension(): string;
	protected _urlToLoad(): Promise<U>;
	protected static _loadMultipleBlobGlobal(options: MultipleDependenciesLoadOptions): Promise<void>;
	private static _onAssetLoadedCallbacks;
	static onAssetLoaded(callback: OnAssetLoadedCallback): void;
	static _runOnAssetLoadedCallbacks(url: string, asset?: BaseGeoLoaderOutput | Texture): void;
}
declare abstract class BaseGeoLoader<O extends BaseGeoLoaderOutput> {
	abstract load: (url: string, onSuccess: OnSuccess<O>, onProgress?: OnProgress, onError?: OnError) => void;
}
declare abstract class BaseLoaderHandler<
	O extends BaseGeoLoaderOutput,
	OC extends ObjectContent<CoreObjectType>
> extends CoreBaseLoader<string> {
	protected _loader: BaseGeoLoader<O> | undefined;
	reset(): void;
	load(options: BaseLoaderLoadOptions): Promise<OC[] | undefined>;
	protected _errorMessage(url: string, event: ErrorEvent): string;
	protected abstract _getLoader(options: BaseLoaderLoadOptions): Promise<BaseGeoLoader<O>>;
	protected abstract _onLoadSuccess(o: O): OC[];
}
declare abstract class BaseObject3DLoaderHandler<O extends BaseGeoLoaderOutput> extends BaseLoaderHandler<O, Object3D> {
	protected _onLoadSuccess(o: O): Object3D[];
}
export declare type TypedCadObject = CadObject<CadGeometryType>;
export declare type CadObjectArray = Array<TypedCadObject>;
declare class STEPLoaderHandler extends BaseLoaderHandler<CadObjectArray, TypedCadObject> {
	protected _getLoader(options: BaseLoaderLoadOptions): Promise<BaseGeoLoader<CadObjectArray>>;
	protected _onLoadSuccess(o: CadObjectArray): CadObjectArray;
}
declare class CADFileSTEPSopParamsConfig extends NodeParamsConfig {
	/** @param url to load the geometry from */
	url: ParamTemplate<ParamType.STRING>;
	/** @param sets the matrixAutoUpdate attribute for the objects loaded */
	matrixAutoUpdate: ParamTemplate<ParamType.BOOLEAN>;
	/** @param reload the geometry */
	reload: ParamTemplate<ParamType.BUTTON>;
}
declare class CADFileSTEPSopNode extends CADSopNode<CADFileSTEPSopParamsConfig> {
	readonly paramsConfig: CADFileSTEPSopParamsConfig;
	static type(): SopType;
	dispose(): void;
	cook(inputCoreGroups: CoreGroup[]): Promise<void>;
	protected _createGeoLoaderHandler(url: string): STEPLoaderHandler;
	static PARAM_CALLBACK_reload(node: CADFileSTEPSopNode): void;
	private _paramCallbackReload;
}
declare class CADFilletSopParamsConfig extends NodeParamsConfig {
	/** @param edges group */
	group: ParamTemplate<ParamType.STRING>;
	/** @param mode */
	mode: ParamTemplate<ParamType.INTEGER>;
	/** @param radius */
	radius: ParamTemplate<ParamType.FLOAT>;
}
declare class CADFilletSopNode extends CADSopNode<CADFilletSopParamsConfig> {
	paramsConfig: CADFilletSopParamsConfig;
	static type(): SopType;
	protected initializeNode(): void;
	cook(inputCoreGroups: CoreGroup[]): void;
}
declare class GroupByExpressionHelper {
	private node;
	constructor(node: CADGroupSopNode);
	evalForEntities(allEntities: CoreEntity[], selectionStates: CoreEntitySelectionState): Promise<void>;
	private _evalEntityDependentExpression;
	private _evalExpressionsWithoutEntityDependentExpression;
}
declare class GroupByBoundingBoxHelper {
	private node;
	constructor(node: CADGroupSopNode);
	evalForEntities(allEntities: CoreEntity[], selectionStates: CoreEntitySelectionState): void;
}
declare class GroupByBoundingObjectHelper {
	evalForEntities(
		allEntities: CoreEntity[],
		selectionStates: CoreEntitySelectionState,
		boundingCoreGroup: CoreGroup
	): void;
}
declare class CADGroupSopParamsConfig extends NodeParamsConfig {
	/** @param group name */
	name: ParamTemplate<ParamType.STRING>;
	/** @param group type */
	type: ParamTemplate<ParamType.INTEGER>;
	/** @param mode */
	operation: ParamTemplate<ParamType.INTEGER>;
	/** @param deletes objects by an expression */
	byExpression: ParamTemplate<ParamType.BOOLEAN>;
	/** @param sets the expression to select what should be deleted */
	expression: ParamTemplate<ParamType.BOOLEAN>;
	/** @param deletes objects that are inside a bounding box */
	byBoundingBox: ParamTemplate<ParamType.BOOLEAN>;
	/** @param the bounding box size */
	boundingBoxSize: ParamTemplate<ParamType.VECTOR3>;
	/** @param the bounding box center */
	boundingBoxCenter: ParamTemplate<ParamType.VECTOR3>;
	/** @param deletes objects that are inside an object. This uses the object from the 2nd input */
	byBoundingObject: ParamTemplate<ParamType.BOOLEAN>;
	/** @param invert */
	invert: ParamTemplate<ParamType.BOOLEAN>;
}
declare class CADGroupSopNode extends CADSopNode<CADGroupSopParamsConfig> {
	readonly paramsConfig: CADGroupSopParamsConfig;
	static type(): SopType;
	static displayedInputNames(): string[];
	readonly byExpressionHelper: GroupByExpressionHelper;
	readonly byBoundingBoxHelper: GroupByBoundingBoxHelper;
	readonly byBoundingObjectHelper: GroupByBoundingObjectHelper;
	initializeNode(): void;
	setGroupType(groupType: EntityGroupType): void;
	groupType(): EntityGroupType;
	groupName(): string;
	cook(inputCoreGroups: CoreGroup[]): Promise<void>;
	private selectedStates;
	private _evalEdges;
}
declare class CADLoftSopParamsConfig extends NodeParamsConfig {
	/** @param create solid */
	solid: ParamTemplate<ParamType.BOOLEAN>;
}
declare class CADLoftSopNode extends CADSopNode<CADLoftSopParamsConfig> {
	readonly paramsConfig: CADLoftSopParamsConfig;
	static type(): SopType;
	static displayedInputNames(): string[];
	protected initializeNode(): void;
	cook(inputCoreGroups: CoreGroup[]): void;
}
declare class CADMirrorSopParamsConfig extends NodeParamsConfig {
	/** @param origin */
	/** @param axis */
	axis: ParamTemplate<ParamType.VECTOR3>;
}
declare class CADMirrorSopNode extends CADSopNode<CADMirrorSopParamsConfig> {
	paramsConfig: CADMirrorSopParamsConfig;
	static type(): SopType;
	protected initializeNode(): void;
	cook(inputCoreGroups: CoreGroup[]): void;
}
declare class CADPipeSopParamsConfig extends NodeParamsConfig {
	/** @param create caps */
	cap: ParamTemplate<ParamType.BOOLEAN>;
	/** @param convert caps to faces */
	capsAsFaces: ParamTemplate<ParamType.BOOLEAN>;
}
declare class CADPipeSopNode extends CADSopNode<CADPipeSopParamsConfig> {
	readonly paramsConfig: CADPipeSopParamsConfig;
	static type(): SopType;
	static displayedInputNames(): string[];
	protected initializeNode(): void;
	cook(inputCoreGroups: CoreGroup[]): void;
}
declare class CADPointSopParamsConfig extends NodeParamsConfig {
	/** @param translate */
	center: ParamTemplate<ParamType.VECTOR3>;
}
declare class CADPointSopNode extends CADSopNode<CADPointSopParamsConfig> {
	paramsConfig: CADPointSopParamsConfig;
	static type(): SopType;
	cook(inputCoreGroups: CoreGroup[]): Promise<void>;
}
declare class CADPoint2DSopParamsConfig extends NodeParamsConfig {
	/** @param center */
	center: ParamTemplate<ParamType.VECTOR2>;
}
declare class CADPoint2DSopNode extends CADSopNode<CADPoint2DSopParamsConfig> {
	paramsConfig: CADPoint2DSopParamsConfig;
	static type(): SopType;
	cook(): Promise<void>;
}
declare class CADPointsFromCurveSopParamsConfig extends NodeParamsConfig {
	/** @param points count */
	count: ParamTemplate<ParamType.INTEGER>;
	/** @param min */
	min: ParamTemplate<ParamType.FLOAT>;
	/** @param max */
	max: ParamTemplate<ParamType.FLOAT>;
}
declare class CADPointsFromCurveSopNode extends CADSopNode<CADPointsFromCurveSopParamsConfig> {
	paramsConfig: CADPointsFromCurveSopParamsConfig;
	static type(): SopType;
	protected initializeNode(): void;
	cook(inputCoreGroups: CoreGroup[]): void;
}
declare class CADRectangleSopParamsConfig extends NodeParamsConfig {
	/** @param size */
	size: ParamTemplate<ParamType.VECTOR2>;
	/** @param center */
	center: ParamTemplate<ParamType.VECTOR3>;
	/** @param fillet radius */
	filletRadius: ParamTemplate<ParamType.FLOAT>;
}
declare class CADRectangleSopNode extends CADSopNode<CADRectangleSopParamsConfig> {
	paramsConfig: CADRectangleSopParamsConfig;
	static type(): SopType;
	cook(inputCoreGroups: CoreGroup[]): Promise<void>;
}
declare class CADRevolutionSopParamsConfig extends NodeParamsConfig {
	/** @param axis */
	axis: ParamTemplate<ParamType.VECTOR3>;
	/** @param closed */
	closed: ParamTemplate<ParamType.BOOLEAN>;
	/** @param thetaMin */
	/** @param thetaMax */
	/** @param phi */
	phi: ParamTemplate<ParamType.FLOAT>;
}
declare class CADRevolutionSopNode extends CADSopNode<CADRevolutionSopParamsConfig> {
	paramsConfig: CADRevolutionSopParamsConfig;
	static type(): SopType;
	protected initializeNode(): void;
	cook(inputCoreGroups: CoreGroup[]): void;
}
declare class CADSegmentSopParamsConfig extends NodeParamsConfig {
	/** @param mode */
	mode: ParamTemplate<ParamType.INTEGER>;
}
declare class CADSegmentSopNode extends CADSopNode<CADSegmentSopParamsConfig> {
	paramsConfig: CADSegmentSopParamsConfig;
	static type(): SopType;
	protected initializeNode(): void;
	cook(inputCoreGroups: CoreGroup[]): Promise<void>;
	private _createSegmentsFromPairs;
	private _createSegmentsFromAll;
}
declare class CADSphereSopParamsConfig extends NodeParamsConfig {
	/** @param radius */
	radius: ParamTemplate<ParamType.FLOAT>;
	/** @param center */
	center: ParamTemplate<ParamType.VECTOR3>;
	/** @param axis */
	axis: ParamTemplate<ParamType.VECTOR3>;
	/** @param closed */
	closed: ParamTemplate<ParamType.BOOLEAN>;
	/** @param thetaMin */
	thetaMin: ParamTemplate<ParamType.FLOAT>;
	/** @param thetaMax */
	thetaMax: ParamTemplate<ParamType.FLOAT>;
	/** @param phi */
	phi: ParamTemplate<ParamType.FLOAT>;
}
declare class CADSphereSopNode extends CADSopNode<CADSphereSopParamsConfig> {
	paramsConfig: CADSphereSopParamsConfig;
	static type(): SopType;
	cook(inputCoreGroups: CoreGroup[]): Promise<void>;
}
declare class CADThicknessSopParamsConfig extends NodeParamsConfig {
	/** @param faces group */
	facesGroupToDelete: ParamTemplate<ParamType.STRING>;
	/** @param offset */
	offset: ParamTemplate<ParamType.FLOAT>;
}
declare class CADThicknessSopNode extends CADSopNode<CADThicknessSopParamsConfig> {
	paramsConfig: CADThicknessSopParamsConfig;
	static type(): SopType;
	protected initializeNode(): void;
	cook(inputCoreGroups: CoreGroup[]): void;
	private _makeSolidByJoin;
}
declare class CADTorusSopParamsConfig extends NodeParamsConfig {
	/** @param outer radius */
	outerRadius: ParamTemplate<ParamType.FLOAT>;
	/** @param inner radius */
	innerRadius: ParamTemplate<ParamType.FLOAT>;
	/** @param center */
	center: ParamTemplate<ParamType.VECTOR3>;
	/** @param axis */
	axis: ParamTemplate<ParamType.VECTOR3>;
	/** @param closed */
	closed: ParamTemplate<ParamType.BOOLEAN>;
	/** @param phi */
	phi: ParamTemplate<ParamType.FLOAT>;
}
declare class CADTorusSopNode extends CADSopNode<CADTorusSopParamsConfig> {
	paramsConfig: CADTorusSopParamsConfig;
	static type(): SopType;
	cook(inputCoreGroups: CoreGroup[]): Promise<void>;
}
declare class CADTransformSopParamConfig extends NodeParamsConfig {
	/** @param translate */
	t: ParamTemplate<ParamType.VECTOR3>;
	/** @param rotation */
	r: ParamTemplate<ParamType.VECTOR3>;
	/** @param scale (as a float) */
	s: ParamTemplate<ParamType.FLOAT>;
	/** @param pivot */
	pivot: ParamTemplate<ParamType.VECTOR3>;
}
declare class CADTransformSopNode extends CADSopNode<CADTransformSopParamConfig> {
	paramsConfig: CADTransformSopParamConfig;
	static type(): SopType;
	static displayedInputNames(): string[];
	initializeNode(): void;
	cook(inputCoreGroups: CoreGroup[]): void;
}
declare class CADTransform2DSopParamsConfig extends NodeParamsConfig {
	/** @param translate */
	t: ParamTemplate<ParamType.VECTOR2>;
	/** @param rotation */
	r: ParamTemplate<ParamType.FLOAT>;
	/** @param scale (as a float) */
	s: ParamTemplate<ParamType.FLOAT>;
	/** @param pivot */
	pivot: ParamTemplate<ParamType.VECTOR2>;
}
declare class CADTransform2DSopNode extends CADSopNode<CADTransform2DSopParamsConfig> {
	paramsConfig: CADTransform2DSopParamsConfig;
	static type(): SopType.CAD_TRANSFORM_2D;
	protected initializeNode(): void;
	cook(inputCoreGroups: CoreGroup[]): Promise<void>;
}
declare const CADTriangulateSopParamsConfig_base: {
	new (...args: any[]): {
		linearTolerance: ParamTemplate<ParamType.FLOAT>;
		angularTolerance: ParamTemplate<ParamType.FLOAT>;
		curveAbscissa: ParamTemplate<ParamType.FLOAT>;
		curveTolerance: ParamTemplate<ParamType.FLOAT>;
		displayEdges: ParamTemplate<ParamType.BOOLEAN>;
		edgesColor: ParamTemplate<ParamType.COLOR>;
		displayMeshes: ParamTemplate<ParamType.BOOLEAN>;
		meshesColor: ParamTemplate<ParamType.COLOR>;
		wireframe: ParamTemplate<ParamType.BOOLEAN>;
	};
} & typeof NodeParamsConfig;
declare class CADTriangulateSopParamsConfig extends CADTriangulateSopParamsConfig_base {}
declare class CADTriangulateSopNode extends CADSopNode<CADTriangulateSopParamsConfig> {
	readonly paramsConfig: CADTriangulateSopParamsConfig;
	static type(): SopType;
	protected initializeNode(): void;
	cook(inputCoreGroups: CoreGroup[]): Promise<void>;
}
declare class CADTubeSopParamsConfig extends NodeParamsConfig {
	/** @param radius */
	radius: ParamTemplate<ParamType.FLOAT>;
	/** @param height */
	height: ParamTemplate<ParamType.FLOAT>;
	/** @param center */
	center: ParamTemplate<ParamType.VECTOR3>;
	/** @param axis */
	axis: ParamTemplate<ParamType.VECTOR3>;
	/** @param closed */
	closed: ParamTemplate<ParamType.BOOLEAN>;
	/** @param angle */
	angle: ParamTemplate<ParamType.FLOAT>;
}
declare class CADTubeSopNode extends CADSopNode<CADTubeSopParamsConfig> {
	paramsConfig: CADTubeSopParamsConfig;
	static type(): SopType;
	cook(inputCoreGroups: CoreGroup[]): Promise<void>;
}
declare class CADUnpackSopParamsConfig extends NodeParamsConfig {}
declare class CADUnpackSopNode extends CADSopNode<CADUnpackSopParamsConfig> {
	paramsConfig: CADUnpackSopParamsConfig;
	static type(): SopType;
	protected initializeNode(): void;
	cook(inputCoreGroups: CoreGroup[]): void;
}
declare class CADWedgeSopParamsConfig extends NodeParamsConfig {
	/** @param size */
	size: ParamTemplate<ParamType.FLOAT>;
	/** @param sizes */
	sizes: ParamTemplate<ParamType.VECTOR3>;
	/** @param center */
	center: ParamTemplate<ParamType.VECTOR3>;
	/** @param end width */
	endWidth: ParamTemplate<ParamType.FLOAT>;
}
declare class CADWedgeSopNode extends CADSopNode<CADWedgeSopParamsConfig> {
	readonly paramsConfig: CADWedgeSopParamsConfig;
	static type(): SopType;
	cook(): Promise<void>;
}
declare class AnimationEventParamsConfig extends NodeParamsConfig {
	/** @parm animation node */
	animation: ParamTemplate<ParamType.NODE_PATH>;
	/** @parm presses to play the animation */
	play: ParamTemplate<ParamType.BUTTON>;
	/** @parm presses to pause the animation */
	pause: ParamTemplate<ParamType.BUTTON>;
	/** @param stops previous animations still in progress started by this node */
	stopsPreviousAnim: ParamTemplate<ParamType.BOOLEAN>;
}
declare class AnimationEventNode extends TypedEventNode<AnimationEventParamsConfig> {
	paramsConfig: AnimationEventParamsConfig;
	static type(): string;
	private _timelineBuilder;
	private _timeline;
	initializeNode(): void;
	processEvent(event_context: EventContext<Event>): void;
	static PARAM_CALLBACK_play(node: AnimationEventNode): void;
	static PARAM_CALLBACK_pause(node: AnimationEventNode): void;
	private _play;
	private _pause;
	private _triggerAnimationStarted;
	private _triggerAnimationCompleted;
}
declare class AnyEventParamsConfig extends NodeParamsConfig {
	/** @param toggle on to ensure events are transfered */
	active: ParamTemplate<ParamType.BOOLEAN>;
	/** @param number of possible events */
	inputsCount: ParamTemplate<ParamType.INTEGER>;
}
declare class AnyEventNode extends TypedEventNode<AnyEventParamsConfig> {
	paramsConfig: AnyEventParamsConfig;
	static type(): string;
	initializeNode(): void;
	private _expected_input_types;
	protected _input_name(index: number): string;
	processEvent(event_context: EventContext<Event>): Promise<void>;
}
declare class AudioEventParamsConfig extends NodeParamsConfig {
	/** @parm audio node */
	audio: ParamTemplate<ParamType.NODE_PATH>;
	/** @param note */
	note: ParamTemplate<ParamType.STRING>;
	/** @param duration */
	duration: ParamTemplate<ParamType.FLOAT>;
	/** @param button to presse to trigger the event */
	play: ParamTemplate<ParamType.BUTTON>;
}
declare class AudioEventNode extends TypedEventNode<AudioEventParamsConfig> {
	paramsConfig: AudioEventParamsConfig;
	static type(): string;
	initializeNode(): void;
	private _sourcePlayer;
	private _triggerPlay;
	private _play;
	dispose(): void;
	private _addPlayerEvent;
	private _removePlayerEvent;
	private _onSourcePlayerStopBound;
	private _onSourcePlayerStop;
	private _getPlayable;
	static PARAM_CALLBACK_play(node: AudioEventNode): void;
}
declare class BlockParamsConfig extends NodeParamsConfig {
	/** @param toggle on to block incoming events */
	blocking: ParamTemplate<ParamType.BOOLEAN>;
}
declare class BlockEventNode extends TypedEventNode<BlockParamsConfig> {
	paramsConfig: BlockParamsConfig;
	static type(): string;
	static readonly OUTPUT = 'output';
	initializeNode(): void;
	private trigger_output;
	private _process_incoming_event;
}
declare class ButtonEventParamsConfig extends NodeParamsConfig {
	/** @param button to presse to trigger the event */
	dispatch: ParamTemplate<ParamType.BUTTON>;
}
declare class ButtonEventNode extends TypedEventNode<ButtonEventParamsConfig> {
	paramsConfig: ButtonEventParamsConfig;
	static type(): string;
	initializeNode(): void;
	processEvent(event_context: EventContext<Event>): void;
	private process_event_execute;
	static PARAM_CALLBACK_execute(node: ButtonEventNode): void;
}
declare class OrbitControls {
	constructor(object: Camera, domElement?: HTMLElement);
	object: Camera;
	domElement: HTMLElement | HTMLDocument;
	// API
	enabled: boolean;
	target: Vector3;
	// deprecated
	center: Vector3;
	minDistance: number;
	maxDistance: number;
	minZoom: number;
	maxZoom: number;
	minPolarAngle: number;
	maxPolarAngle: number;
	minAzimuthAngle: number;
	maxAzimuthAngle: number;
	enableDamping: boolean;
	dampingFactor: number;
	enableZoom: boolean;
	zoomSpeed: number;
	enableRotate: boolean;
	rotateSpeed: number;
	enablePan: boolean;
	panSpeed: number;
	screenSpacePanning: boolean;
	keyPanSpeed: number;
	keyRotateSpeedVertical: number;
	keyRotateSpeedHorizontal: number;
	autoRotate: boolean;
	autoRotateSpeed: number;
	enableKeys: boolean;
	keyMode: string;
	keys: {
		LEFT: string;
		UP: string;
		RIGHT: string;
		BOTTOM: string;
	};
	mouseButtons: {
		LEFT: MOUSE;
		MIDDLE: MOUSE;
		RIGHT: MOUSE;
	};
	touches: {
		ONE: TOUCH;
		TWO: TOUCH;
	};
	update(): boolean;
	listenToKeyEvents(domElement: HTMLElement): void;
	saveState(): void;
	reset(): void;
	dispose(): void;
	getPolarAngle(): number;
	getAzimuthalAngle(): number;
	// EventDispatcher mixins
	addEventListener(type: string, listener: (event: any) => void): void;
	hasEventListener(type: string, listener: (event: any) => void): boolean;
	removeEventListener(type: string, listener: (event: any) => void): void;
	dispatchEvent(event: {type: string; target: any}): void;
}
declare class MapControls extends OrbitControls {
	constructor(object: Camera, domElement?: HTMLElement);
}
declare class CameraOrbitEventParamsConfig extends NodeParamsConfig {
	/** @param enable/disable */
	enabled: ParamTemplate<ParamType.BOOLEAN>;
	/** @param toggle on to allow pan */
	allowPan: ParamTemplate<ParamType.BOOLEAN>;
	/** @param toggle on to allow rotate */
	allowRotate: ParamTemplate<ParamType.BOOLEAN>;
	/** @param toggle on to allow zoom */
	allowZoom: ParamTemplate<ParamType.BOOLEAN>;
	/** @param toggle on to have damping */
	tdamping: ParamTemplate<ParamType.BOOLEAN>;
	/** @param damping value */
	damping: ParamTemplate<ParamType.FLOAT>;
	/** @param toggle on to have the pan in screen space */
	screenSpacePanning: ParamTemplate<ParamType.BOOLEAN>;
	/** @param rotation speed */
	rotateSpeed: ParamTemplate<ParamType.FLOAT>;
	/** @param smallest distance the camera can go to the target */
	minDistance: ParamTemplate<ParamType.FLOAT>;
	/** @param max distance the camera can go away the target */
	maxDistance: ParamTemplate<ParamType.FLOAT>;
	/** @param toggle on to limit the azimuth (up-down) angle */
	limitAzimuthAngle: ParamTemplate<ParamType.BOOLEAN>;
	/** @param azimuth angle range */
	azimuthAngleRange: ParamTemplate<ParamType.VECTOR2>;
	/** @param polar (left-right) angle range */
	polarAngleRange: ParamTemplate<ParamType.VECTOR2>;
	/** @param target position. This is updated automatically as the camera is controlled by user events */
	target: ParamTemplate<ParamType.VECTOR3>;
}
declare class CameraOrbitControlsEventNode extends TypedCameraControlsEventNode<CameraOrbitEventParamsConfig> {
	paramsConfig: CameraOrbitEventParamsConfig;
	static type(): CameraControlsNodeType;
	endEventName(): string;
	initializeNode(): void;
	private _controlsByElementId;
	private _firstControls;
	protected _createControls(camera: Camera, element: HTMLElement): OrbitControls;
	createControlsInstance(camera: Camera, element: HTMLElement): Promise<OrbitControls>;
	protected _bind_listeners_to_controls_instance(controls: OrbitControls): void;
	setupControls(controls: OrbitControls): void;
	private _set_azimuth_angle;
	updateRequired(): boolean;
	private _target_array;
	private _on_controls_end;
	static PARAM_CALLBACK_updateTarget(node: CameraOrbitControlsEventNode): void;
	private _updateTarget;
	target(target: Vector3): void;
	setTarget(newTarget: Vector3): void;
	disposeControlsForHtmlElementId(html_element_id: string): void;
	private _updateCache;
}
declare class CameraMapControlsEventNode extends CameraOrbitControlsEventNode {
	static type(): CameraControlsNodeType;
	protected _createControls(camera: Camera, element: HTMLElement): MapControls;
}
declare class DebounceEventParamsConfig extends NodeParamsConfig {
	/** @param max wait time between each event, in milliseconds */
	maxwait: ParamTemplate<ParamType.INTEGER>;
	/** @param defines if event is dispatched on the leading edge of the timeout */
	leading: ParamTemplate<ParamType.BOOLEAN>;
	/** @param defines if event is trailing on the leading edge of the timeout */
	trailing: ParamTemplate<ParamType.BOOLEAN>;
}
declare class DebounceEventNode extends TypedEventNode<DebounceEventParamsConfig> {
	paramsConfig: DebounceEventParamsConfig;
	static type(): string;
	static readonly OUTPUT_NAME = 'output';
	initializeNode(): void;
	private _debouncedFunc;
	private _lastEventContextReceived;
	processEvent(eventContext: EventContext<Event>): void;
	private _buildDebouncedFunc;
	private _resetDebouncedFunc;
	static PARAM_CALLBACK_resetDebouncedFunc(node: DebounceEventNode): void;
}
declare class DelayEventParamsConfig extends NodeParamsConfig {
	/** @param delay before dispatching (in milliseconds) */
	delay: ParamTemplate<ParamType.INTEGER>;
}
declare class DelayEventNode extends TypedEventNode<DelayEventParamsConfig> {
	paramsConfig: DelayEventParamsConfig;
	static type(): string;
	initializeNode(): void;
	private _process_input;
}
declare class BaseCodeEventProcessor extends BaseCodeProcessor {
	protected node: CodeEventNode;
	constructor(node: CodeEventNode);
	get pv(): ParamsValueAccessorType<CodeEventParamsConfig>;
	get p(): ParamsAccessorType<CodeEventParamsConfig>;
	get io(): IOController<NodeContext.EVENT>;
	initializeProcessor(): void;
	processTrigger0(eventContext: EventContext<Event>): void;
	processTrigger1(eventContext: EventContext<Event>): void;
	processTrigger2(eventContext: EventContext<Event>): void;
	processTrigger3(eventContext: EventContext<Event>): void;
	processTrigger4(eventContext: EventContext<Event>): void;
	dispatchEventToOutput(outputName: string, eventContext: EventContext<Event>): void;
}
declare class CodeEventParamsConfig extends NodeParamsConfig {
	codeTypescript: ParamTemplate<ParamType.STRING>;
	codeJavascript: ParamTemplate<ParamType.STRING>;
}
declare class CodeEventNode extends TypedEventNode<CodeEventParamsConfig> {
	paramsConfig: CodeEventParamsConfig;
	static BaseCodeEventProcessor: typeof BaseCodeEventProcessor;
	static type(): string;
	private _lastCompiledCode;
	private _processor;
	initializeNode(): void;
	private _processTrigger0;
	private _processTrigger1;
	private _processTrigger2;
	private _processTrigger3;
	private _processTrigger4;
	_dispatchEventToOutputFromProcessor(outputName: string, eventContext: EventContext<Event>): void;
	private _compileIfRequired;
	private _compile;
}
declare class DragEventParamsConfig extends NodeParamsConfig {
	/** @param toggle on to allow any event to be listened to */
	active: ParamTemplate<ParamType.BOOLEAN>;
	/** @param set which element triggers the event */
	element: ParamTemplate<ParamType.INTEGER>;
	/** @param toggle on to listen to dragover events */
	dragover: ParamTemplate<ParamType.BOOLEAN>;
	/** @param requires ctrlKey */
	ctrlKey: ParamTemplate<ParamType.BOOLEAN>;
	/** @param requires altKey */
	altKey: ParamTemplate<ParamType.BOOLEAN>;
	/** @param requires shiftKey */
	shiftKey: ParamTemplate<ParamType.BOOLEAN>;
	/** @param requires metaKey */
	metaKey: ParamTemplate<ParamType.BOOLEAN>;
}
declare class DragEventNode extends TypedInputEventNode<DragEventParamsConfig> {
	paramsConfig: DragEventParamsConfig;
	static type(): EventInputType;
	protected acceptedEventTypes(): Set<DragEventType>;
	initializeNode(): void;
	processEvent(eventContext: EventContext<DragEvent>): void;
}
export interface BufferGeometry {
	boundsTree?: MeshBVH;
	computeBoundsTree: typeof computeBoundsTree;
	disposeBoundsTree: typeof disposeBoundsTree;
}
export interface Raycaster {
	firstHitOnly?: boolean;
}
export interface BufferGeometryWithBVH extends BufferGeometry {
	boundsTree: MeshBVH;
}
export interface MeshWithBVH extends Mesh {
	geometry: BufferGeometryWithBVH;
}
export interface CapsuleOptions {
	radius: number;
	height: number;
	divisions: number;
	center: Vector3;
}
export interface CorePlayerOptions {
	object: Object3D;
	collider: MeshWithBVH;
}
export declare type ResetRequiredCallback = () => boolean;
declare class CorePlayer {
	private _pressed;
	private _onGround;
	private _velocity;
	readonly capsuleInfo: {
		radius: number;
		segment: Line3;
	};
	object: Object3D;
	collider: MeshWithBVH;
	startPosition: Vector3;
	startRotation: Vector3;
	jumpAllowed: boolean;
	jumpStrength: number;
	runAllowed: boolean;
	runSpeedMult: number;
	private _running;
	speed: number;
	physicsSteps: number;
	gravity: Vector3;
	private _azimuthalAngle;
	private _resetYMax;
	private _resetRequiredCallback;
	constructor(options: CorePlayerOptions);
	setOptions(options: CorePlayerOptions): void;
	private _setObject;
	setCollider(collider: MeshWithBVH): void;
	setCapsule(capsuleOptions: CapsuleOptions): void;
	reset(): void;
	stop(): void;
	setResetRequiredCallback(callback: ResetRequiredCallback): void;
	setAzimuthalAngle(angle: number): void;
	update(delta: number): void;
	private _updateStep;
	setForward(state: boolean): void;
	setBackward(state: boolean): void;
	setLeft(state: boolean): void;
	setRight(state: boolean): void;
	jump(): void;
	setRun(state: boolean): void;
	running(): boolean;
}
export interface PointerLockControlsOptions {
	lockHTMLElement?: HTMLElement;
}
declare class PointerLockControls extends EventDispatcher {
	private camera;
	readonly domElement: HTMLElement;
	private options;
	private player?;
	private isLocked;
	minPolarAngle: number;
	maxPolarAngle: number;
	rotateSpeed: number;
	private euler;
	private boundMethods;
	private _azimuthalAngle;
	private _corePlayerKeyEvents;
	constructor(
		camera: Camera,
		domElement: HTMLElement,
		options: PointerLockControlsOptions,
		player?: CorePlayer | undefined
	);
	onMouseMove(event: MouseEvent): void;
	private _computeAzimuthalAngle;
	onPointerlockChange(): void;
	onPointerlockError(): void;
	connect(): void;
	disconnect(): void;
	dispose(): void;
	getObject(): Camera;
	lock(): void;
	unlock(): void;
	update(delta: number): void;
	private __unlockHTMLElement;
	private _unlockHTMLElementParent;
	private _unlockHTMLElement;
	private _showUnlockHTMLElement;
	private _getUnlockHTMLElement;
	private _createUnlockHTMLElement;
	private _removeHTMLElement;
}
declare const ColliderParamsConfig_base: {
	new (...args: any[]): {
		colliderObject: ParamTemplate<ParamType.NODE_PATH>;
	};
} & typeof NodeParamsConfig;
declare class ColliderParamsConfig extends ColliderParamsConfig_base {}
declare abstract class ColliderEventNode extends TypedEventNode<ColliderParamsConfig> {
	abstract player(): CorePlayer | undefined;
	abstract collisionController(): CollisionController;
	static PARAM_CALLBACK_updateCollider(node: ColliderEventNode): void;
}
declare class CollisionController {
	protected node: ColliderEventNode;
	constructor(node: ColliderEventNode);
	private _colliderNode;
	private __colliderNodeGraphNode;
	private _colliderNodeGraphNode;
	getCollider(): Promise<MeshWithBVH | undefined>;
	updateCollider(): Promise<void>;
}
export declare type PointerLockControlsMap = Map<string, PointerLockControls>;
declare class FirstPersonEventParamsConfig extends NodeParamsConfig {
	main: ParamTemplate<ParamType.FOLDER>;
	/** @param collider object */
	colliderObject: ParamTemplate<ParamType.NODE_PATH>;
	/** @param click to lock controls */
	lock: ParamTemplate<ParamType.BUTTON>;
	/** @param click to unlock controls */
	unlock: ParamTemplate<ParamType.BUTTON>;
	/** @param collision Capsule Radius */
	capsuleRadius: ParamTemplate<ParamType.FLOAT>;
	/** @param collision Capsule Height */
	capsuleHeight: ParamTemplate<ParamType.FLOAT>;
	physics: ParamTemplate<ParamType.FOLDER>;
	/** @param physics Steps */
	physicsSteps: ParamTemplate<ParamType.INTEGER>;
	/** @param gravity */
	gravity: ParamTemplate<ParamType.VECTOR3>;
	/** @param translate speed */
	translateSpeed: ParamTemplate<ParamType.FLOAT>;
	/** @param rotate speed */
	rotateSpeed: ParamTemplate<ParamType.FLOAT>;
	/** @param jump Allowed */
	jumpAllowed: ParamTemplate<ParamType.BOOLEAN>;
	/** @param jump Force */
	jumpStrength: ParamTemplate<ParamType.FLOAT>;
	/** @param run Allowed */
	runAllowed: ParamTemplate<ParamType.BOOLEAN>;
	/** @param run speed mult */
	runSpeedMult: ParamTemplate<ParamType.FLOAT>;
	/** @param recompute colliding geo */
	updateCollider: ParamTemplate<ParamType.BUTTON>;
	init: ParamTemplate<ParamType.FOLDER>;
	/** @param start Position */
	startPosition: ParamTemplate<ParamType.VECTOR3>;
	/** @param start Position */
	startRotation: ParamTemplate<ParamType.VECTOR3>;
	/** @param reset */
	reset: ParamTemplate<ParamType.BUTTON>;
	/** @param min rotation angle */
	minPolarAngle: ParamTemplate<ParamType.FLOAT>;
	/** @param max rotation angle */
	maxPolarAngle: ParamTemplate<ParamType.FLOAT>;
	html: ParamTemplate<ParamType.FOLDER>;
	/** @param specify a custom HTML element */
	customLockCursorElement: ParamTemplate<ParamType.BOOLEAN>;
	/** @param jump HTML element selector */
	lockCursorElementSelector: ParamTemplate<ParamType.STRING>;
}
declare class FirstPersonControlsEventNode extends TypedCameraControlsEventNode<FirstPersonEventParamsConfig> {
	paramsConfig: FirstPersonEventParamsConfig;
	static type(): CameraControlsNodeType;
	endEventName(): string;
	static readonly INPUT_UPDATE_COLLIDER = 'updateCollider';
	static readonly INPUT_RESET = 'reset';
	private _collisionController;
	collisionController(): CollisionController;
	initializeNode(): void;
	protected _controls_by_element_id: PointerLockControlsMap;
	private _player;
	createControlsInstance(camera: Camera, element: HTMLElement): Promise<PointerLockControls>;
	private _initPlayer;
	private _playerOptions;
	player(): CorePlayer | undefined;
	private _updatePlayerParams;
	private _resetPlayer;
	private _updateCollider;
	protected _bind_listeners_to_controls_instance(controls: PointerLockControls): void;
	updateRequired(): boolean;
	setupControls(controls: PointerLockControls): void;
	disposeControlsForHtmlElementId(htmlElementId: string): void;
	unlockControls(): void;
	private lockControls;
	private _firstControls;
	static PARAM_CALLBACK_lockControls(node: FirstPersonControlsEventNode): void;
	static PARAM_CALLBACK_unlockControls(node: FirstPersonControlsEventNode): void;
	static PARAM_CALLBACK_updateCollider(node: FirstPersonControlsEventNode): void;
	static PARAM_CALLBACK_updatePlayerParams(node: FirstPersonControlsEventNode): void;
	static PARAM_CALLBACK_resetPlayer(node: FirstPersonControlsEventNode): void;
}
declare class IntersectDataParamsConfig extends NodeParamsConfig {
	/** @param geometry vertex attribute to read */
	attributeName: ParamTemplate<ParamType.STRING>;
	/** @param type of attribute */
	attributeType: ParamTemplate<ParamType.INTEGER>;
	/** @param attribute value for float */
	attributeValue1: ParamTemplate<ParamType.FLOAT>;
	/** @param attribute value that attributeValue1 is set to when no object is intersected */
	resetValue1: ParamTemplate<ParamType.FLOAT>;
	/** @param attribute value for string */
	attributeValues: ParamTemplate<ParamType.STRING>;
	/** @param attribute value that attributeValues is set to when no object is intersected */
	resetValues: ParamTemplate<ParamType.STRING>;
}
declare class IntersectDataEventNode extends TypedEventNode<IntersectDataParamsConfig> {
	paramsConfig: IntersectDataParamsConfig;
	static type(): string;
	static readonly INPUT_HIT = 'hit';
	static readonly INPUT_MISS = 'miss';
	initializeNode(): void;
	private _processHit;
	private _processMiss;
	private _resolveIntersectAttribute;
	static resolveObjectAttribute(intersection: Intersection, attribName: string): string | number | undefined;
	static resolveGeometryAttribute(
		intersection: Intersection,
		attribName: string,
		attribType: AttribType
	): string | number | undefined;
	private static _vA;
	private static _vB;
	private static _vC;
	private static _uvA;
	private static _uvB;
	private static _uvC;
	private static _hitUV;
	static resolveGeometryAttributeForMesh(
		intersection: Intersection,
		attribName: string,
		attribType: AttribType
	): string | number | undefined;
	static resolveGeometryAttributeForPoint(
		intersection: Intersection,
		attribName: string,
		attribType: AttribType
	): string | number | undefined;
}
declare class LimitEventParamsConfig extends NodeParamsConfig {
	/** @param max number of events that can be processed */
	maxCount: ParamTemplate<ParamType.INTEGER>;
	/** @param resets the count */
	reset: ParamTemplate<ParamType.BUTTON>;
}
declare class LimitEventNode extends TypedEventNode<LimitEventParamsConfig> {
	paramsConfig: LimitEventParamsConfig;
	static type(): string;
	private _process_count;
	private _last_dispatched;
	initializeNode(): void;
	processEvent(event_context: EventContext<Event>): void;
	private processEventTrigger;
	private process_event_reset;
	static PARAM_CALLBACK_reset(node: LimitEventNode): void;
}
declare class MessageParamsConfig extends NodeParamsConfig {
	/** @param toggle on for the message to be displayed in a popup */
	alert: ParamTemplate<ParamType.BOOLEAN>;
	/** @param toggle on for the message to be printed in the console */
	console: ParamTemplate<ParamType.BOOLEAN>;
}
declare class MessageEventNode extends TypedEventNode<MessageParamsConfig> {
	paramsConfig: MessageParamsConfig;
	static type(): string;
	static readonly OUTPUT = 'output';
	initializeNode(): void;
	private trigger_output;
	private _process_trigger_event;
}
declare class Capsule {
	constructor(start?: Vector3, end?: Vector3, radius?: number);
	start: Vector3;
	end: Vector3;
	radius: number;
	set(start: Vector3, end: Vector3, radius: number): this;
	clone(): Capsule;
	copy(capsule: Capsule): this;
	getCenter(target: Vector3): Vector3;
	translate(v: Vector3): this;
	checkAABBAxis(
		p1x: number,
		p1y: number,
		p2x: number,
		p2y: number,
		minx: number,
		maxx: number,
		miny: number,
		maxy: number,
		radius: number
	): boolean;
	intersectsBox(box: Box3): boolean;
	lineLineMinimumPoints(line1: Line3, line2: Line3): Vector3[];
}
export interface CapsuleCollisionResult {
	normal: Vector3;
	point: Vector3;
	depth: number;
}
declare class PlayerCollisionController {
	private _object;
	private _octree;
	private _capsuleHeight;
	private _capsule;
	constructor(_object: Object3D);
	setCapsule(capsule: Capsule): void;
	testPosition(position: Vector3): CapsuleCollisionResult | false;
}
declare class Capsule {
	constructor(start?: Vector3, end?: Vector3, radius?: number);
	start: Vector3;
	end: Vector3;
	radius: number;
	set(start: Vector3, end: Vector3, radius: number): this;
	clone(): Capsule;
	copy(capsule: Capsule): this;
	getCenter(target: Vector3): Vector3;
	translate(v: Vector3): this;
	checkAABBAxis(
		p1x: number,
		p1y: number,
		p2x: number,
		p2y: number,
		minx: number,
		maxx: number,
		miny: number,
		maxy: number,
		radius: number
	): boolean;
	intersectsBox(box: Box3): boolean;
	lineLineMinimumPoints(line1: Line3, line2: Line3): Vector3[];
}
export interface JumpParams {
	duration: number;
	force: number;
}
declare class BaseCollisionHandler extends EventDispatcher {
	protected _playerCollisionController: PlayerCollisionController | undefined;
	setCheckCollisions(collisionObject?: Object3D): void;
	setCollisionCapsule(capsule: Capsule): void;
	setJumpParams(params: JumpParams): void;
	setGravity(gravity: Vector3): void;
	setPlayerMass(mass: number): void;
}
export interface RotationRange {
	min: number;
	max: number;
}
export interface MobileJoystickControlsOptions {
	translateDomElement?: HTMLElement;
	jumpDomElement?: HTMLElement;
	runDomElement?: HTMLElement;
}
declare class MobileJoystickControls extends BaseCollisionHandler {
	private _camera;
	private domElement;
	private options;
	private player?;
	private translationData;
	private rotationData;
	private _boundMethods;
	private _startCameraRotation;
	private _rotationSpeed;
	private _rotationRange;
	private _azimuthalAngle;
	private _translateDomElement;
	private _translateDomElementRect;
	private _jumpDomElement;
	private _runDomElement;
	constructor(
		_camera: Camera,
		domElement: HTMLElement,
		options: MobileJoystickControlsOptions,
		player?: CorePlayer | undefined
	);
	dispose(): void;
	private _createTranslateDomElement;
	private _jumpDomElementSize;
	private _createJumpDomElement;
	private _createRunDomElement;
	private _addElements;
	private _removeElements;
	updateElements(): void;
	private _addEvents;
	private _removeEvents;
	setRotationSpeed(speed: number): void;
	setRotationRange(range: RotationRange): void;
	private vLeft;
	private vRight;
	private vTop;
	private vBottom;
	private angleY;
	private angleX;
	private _rotationStartPosition;
	private _rotationMovePosition;
	private _rotationDelta;
	private _onRotateStart;
	private _onRotateMove;
	private _onRotateEnd;
	private _rotateCamera;
	private _computeAzimuthalAngle;
	private _startCameraPosition;
	private _translationStartPosition;
	private _translationMovePosition;
	private _translationDelta;
	private _onTranslateStart;
	private _onTranslateMove;
	private _onTranslateEnd;
	private _updatePlayerTranslate;
	private _onJump;
	private _onRunToggle;
	update(delta: number): void;
	private _getTouch;
}
declare class MobileJoystickEventParamsConfig extends NodeParamsConfig {
	main: ParamTemplate<ParamType.FOLDER>;
	/** @param collider object */
	colliderObject: ParamTemplate<ParamType.NODE_PATH>;
	/** @param collision Capsule Radius */
	capsuleRadius: ParamTemplate<ParamType.FLOAT>;
	/** @param collision Capsule Height */
	capsuleHeight: ParamTemplate<ParamType.FLOAT>;
	physics: ParamTemplate<ParamType.FOLDER>;
	/** @param physics Steps */
	physicsSteps: ParamTemplate<ParamType.INTEGER>;
	/** @param gravity */
	gravity: ParamTemplate<ParamType.VECTOR3>;
	/** @param translation speed */
	translateSpeed: ParamTemplate<ParamType.FLOAT>;
	/** @param rotation speed */
	rotateSpeed: ParamTemplate<ParamType.FLOAT>;
	/** @param specify a custom HTML element */
	customTranslateElement: ParamTemplate<ParamType.BOOLEAN>;
	/** @param jump HTML element selector */
	translateElementSelector: ParamTemplate<ParamType.STRING>;
	/** @param jump Allowed */
	jumpAllowed: ParamTemplate<ParamType.BOOLEAN>;
	/** @param jump Force */
	jumpStrength: ParamTemplate<ParamType.FLOAT>;
	/** @param specify a custom HTML element */
	customJumpElement: ParamTemplate<ParamType.BOOLEAN>;
	/** @param jump HTML element selector */
	jumpElementSelector: ParamTemplate<ParamType.STRING>;
	/** @param run Allowed */
	runAllowed: ParamTemplate<ParamType.BOOLEAN>;
	/** @param run speed mult */
	runSpeedMult: ParamTemplate<ParamType.FLOAT>;
	/** @param specify a custom HTML element */
	customRunElement: ParamTemplate<ParamType.BOOLEAN>;
	/** @param jump HTML element selector */
	runElementSelector: ParamTemplate<ParamType.STRING>;
	/** @param recompute colliding geo */
	updateCollider: ParamTemplate<ParamType.BUTTON>;
	init: ParamTemplate<ParamType.FOLDER>;
	/** @param start Position */
	startPosition: ParamTemplate<ParamType.VECTOR3>;
	/** @param start Position */
	startRotation: ParamTemplate<ParamType.VECTOR3>;
	/** @param reset */
	reset: ParamTemplate<ParamType.BUTTON>;
	/** @param min polar angle */
	minPolarAngle: ParamTemplate<ParamType.FLOAT>;
	/** @param max polar angle */
	maxPolarAngle: ParamTemplate<ParamType.FLOAT>;
}
declare class MobileJoystickControlsEventNode extends TypedCameraControlsEventNode<MobileJoystickEventParamsConfig> {
	paramsConfig: MobileJoystickEventParamsConfig;
	static type(): CameraControlsNodeType;
	endEventName(): string;
	static readonly INPUT_UPDATE_COLLIDER = 'updateCollider';
	private _collisionController;
	collisionController(): CollisionController;
	initializeNode(): void;
	private _controls_by_element_id;
	private _player;
	createControlsInstance(camera: Camera, element: HTMLElement): Promise<MobileJoystickControls>;
	private _initPlayer;
	private _playerOptions;
	player(): CorePlayer | undefined;
	private _updatePlayerParams;
	private _resetPlayer;
	private _updateCollider;
	protected _bind_listeners_to_controls_instance(controls: MobileJoystickControls): void;
	updateRequired(): boolean;
	setupControls(controls: MobileJoystickControls): void;
	disposeControlsForHtmlElementId(html_element_id: string): void;
	static PARAM_CALLBACK_updateCollider(node: MobileJoystickControlsEventNode): void;
	static PARAM_CALLBACK_updatePlayerParams(node: MobileJoystickControlsEventNode): void;
	static PARAM_CALLBACK_resetPlayer(node: MobileJoystickControlsEventNode): void;
}
declare class NodeCookEventParamsConfig extends NodeParamsConfig {
	/** @param mask to select which nodes this will cook or listen to */
	mask: ParamTemplate<ParamType.STRING>;
	/** @param forces cook of nodes mentioned in the mask param */
	force: ParamTemplate<ParamType.BOOLEAN>;
	/** @param defines if the nodes should cook one after the other or in parallel */
	cookMode: ParamTemplate<ParamType.INTEGER>;
	/** @param batch size */
	batchSize: ParamTemplate<ParamType.INTEGER>;
	/** @param if on, we only trigger the first time a specific node has cooked. If false, we register every time a node cooks */
	registerOnlyFirstCooks: ParamTemplate<ParamType.BOOLEAN>;
	/** @param updates the list of nodes from the mask parameter. This can be useful if nodes are added or removed from the scene */
	updateResolve: ParamTemplate<ParamType.BUTTON>;
	/** @param prints the list of nodes the mask resolves to to the console. Useful for debugging */
	printResolve: ParamTemplate<ParamType.BUTTON>;
}
declare class NodeCookEventNode extends TypedEventNode<NodeCookEventParamsConfig> {
	paramsConfig: NodeCookEventParamsConfig;
	static type(): Readonly<'nodeCook'>;
	static readonly INPUT_TRIGGER = 'trigger';
	static readonly OUTPUT_FIRST_NODE = 'first';
	static readonly OUTPUT_EACH_NODE = 'each';
	static readonly OUTPUT_ALL_NODES = 'all';
	private _resolvedNodes;
	initializeNode(): void;
	trigger(): void;
	cook(): void;
	dispose(): void;
	resolvedNodes(): BaseNodeType[];
	private processEventTrigger;
	private _cookNodesWithMode;
	private _cookNodesAllTogether;
	private _cookNodesInBatch;
	private _cookNodes;
	private _cookNode;
	static PARAM_CALLBACK_updateResolvedNodes(node: NodeCookEventNode): void;
	private _updateResolvedNodes;
	private _callbackNameForNode;
	private _dispatchedFirstNodeCooked;
	private _dispatchedAllNodesCooked;
	private _cookStateByNodeId;
	private _reset;
	private _allNodesHaveCooked;
	private _onNodeCookComplete;
	static PARAM_CALLBACK_updateResolve(node: NodeCookEventNode): void;
	static PARAM_CALLBACK_printResolve(node: NodeCookEventNode): void;
	private printResolve;
}
declare class NullEventParamsConfig extends NodeParamsConfig {}
declare class NullEventNode extends TypedEventNode<NullEventParamsConfig> {
	paramsConfig: NullEventParamsConfig;
	static type(): string;
	initializeNode(): void;
	processEvent(event_context: EventContext<Event>): void;
	private processEventTrigger;
}
declare class ParamEventParamsConfig extends NodeParamsConfig {
	/** @param set to listen or stop listening to the param */
	active: ParamTemplate<ParamType.BOOLEAN>;
	/** @param the parameter to update */
	param: ParamTemplate<ParamType.PARAM_PATH>;
	boolean: ParamTemplate<ParamType.BOOLEAN>;
	integer: ParamTemplate<ParamType.INTEGER>;
	float: ParamTemplate<ParamType.FLOAT>;
	vector2: ParamTemplate<ParamType.VECTOR2>;
	vector3: ParamTemplate<ParamType.VECTOR3>;
	vector4: ParamTemplate<ParamType.VECTOR4>;
	ramp: ParamTemplate<ParamType.RAMP>;
	string: ParamTemplate<ParamType.STRING>;
}
declare class ParamEventNode extends TypedEventNode<ParamEventParamsConfig> {
	paramsConfig: ParamEventParamsConfig;
	static type(): Readonly<'param'>;
	static readonly OUTPUT_NAME = 'valueChanged';
	initializeNode(): void;
	cook(): Promise<void>;
	dispose(): void;
	private _reset;
	private _resolvedParam;
	private _previousValueParam;
	private _listenToParam;
	private paramGraphNode;
	private __paramCoreGraphNode__;
	private _createCoreGraphNode;
	private _onParamDirtyBound;
	private _onParamDirty;
}
declare class RaycastCPUVelocityController {
	private _node;
	constructor(_node: RaycastEventNode);
	private _prevPosition;
	private _foundVelocityTargetParam;
	private _hitVelocity;
	private _hitVelocityArray;
	process(hitPosition: Vector3): void;
	reset(): void;
}
declare class CursorHelper {
	setCursorForCPU(context: EventContext<MouseEvent | DragEvent | PointerEvent | TouchEvent>, target: Vector2): void;
	setCursorForGPU(context: EventContext<MouseEvent | DragEvent | PointerEvent | TouchEvent>, target: Vector2): void;
	private setCursor;
	private _updateFromCursor;
}
declare class BaseRaycastController {
	protected _cursorHelper: CursorHelper;
	protected _cursor: Vector2;
}
declare class RaycastCPUController extends BaseRaycastController {
	private _node;
	private _cursorArray;
	private _resolvedTargets;
	readonly velocityController: RaycastCPUVelocityController;
	constructor(_node: RaycastEventNode);
	updateMouse(eventContext: EventContext<MouseEvent | DragEvent | PointerEvent | TouchEvent>): void;
	processEvent(context: EventContext<MouseEvent>): void;
	private _plane;
	private _plane_intersect_target;
	private _intersectPlane;
	private _intersections;
	private _intersectGeometry;
	private _resolveIntersectAttribute;
	private _foundPositionTargetParam;
	private _hitPositionArray;
	private _setPositionParam;
	private _prepareRaycaster;
	updateTarget(): void;
	private _updateTargetFromNode;
	private _updateTargetFromSceneGraph;
	static PARAM_CALLBACK_updateTarget(node: RaycastEventNode): void;
}
declare class RaycastGPUController extends BaseRaycastController {
	private _node;
	private _resolvedMaterial;
	private _restoreContext;
	private _cursorArray;
	private _renderTarget;
	private _read;
	private _paramColor;
	private _paramAlpha;
	constructor(_node: RaycastEventNode);
	updateMouse(eventContext: EventContext<MouseEvent | DragEvent | PointerEvent>): void;
	processEvent(context: EventContext<MouseEvent>): void;
	private _modifySceneAndRenderer;
	private _restoreSceneAndRenderer;
	private _updateMaterial;
	static PARAM_CALLBACK_updateMaterial(node: RaycastEventNode): void;
}
declare class RaycastParamsConfig extends NodeParamsConfig {
	/** @param defines if the ray detection is done on the CPU or GPU (GPU being currently experimental) */
	mode: ParamTemplate<ParamType.INTEGER>;
	/** @param defines if the mouse parameter is update when the cursor screen position changes */
	tmouse: ParamTemplate<ParamType.BOOLEAN>;
	/** @param mouse coordinates (0,0) being the center of the screen, (-1,-1) being the bottom left corner and (1,1) being the top right corner */
	mouse: ParamTemplate<ParamType.VECTOR2>;
	/** @param by default the ray is sent from the current camera, but this allows to set another camera */
	/** @param by default the ray is sent from the current camera, but this allows to set a custom ray */
	/** @param the camera to override to */
	/** @param the ray origin */
	/** @param the ray direction */
	/** @param the material to use on the scene for GPU detection */
	overrideMaterial: ParamTemplate<ParamType.BOOLEAN>;
	/** @param the material to use on the scene for GPU detection */
	material: ParamTemplate<ParamType.NODE_PATH>;
	/** @param the current pixel color being read */
	pixelColor: ParamTemplate<ParamType.COLOR>;
	pixelAlpha: ParamTemplate<ParamType.FLOAT>;
	/** @param the value threshold for which a hit is detected */
	hitThreshold: ParamTemplate<ParamType.FLOAT>;
	/** @param defines the hit it tested against geometry or just a plane */
	intersectWith: ParamTemplate<ParamType.INTEGER>;
	/** @param threshold used to test hit with points */
	pointsThreshold: ParamTemplate<ParamType.FLOAT>;
	/** @param plane direction if the hit is tested against a plane */
	planeDirection: ParamTemplate<ParamType.VECTOR3>;
	/** @param plane offset if the hit is tested against a plane */
	planeOffset: ParamTemplate<ParamType.FLOAT>;
	targetType: ParamTemplate<ParamType.INTEGER>;
	/** @param node whose objects to test hit against, when testing against geometries */
	targetNode: ParamTemplate<ParamType.NODE_PATH>;
	/** @param objects to test hit against, when testing against geometries */
	objectMask: ParamTemplate<ParamType.STRING>;
	/** @param toggle to hit if tested against children */
	traverseChildren: ParamTemplate<ParamType.BOOLEAN>;
	/** @param toggle on to update hit position */
	tposition: ParamTemplate<ParamType.BOOLEAN>;
	/** @param toggle on to set the param to the hit position */
	tpositionTarget: ParamTemplate<ParamType.BOOLEAN>;
	/** @param this will be set to the hit position */
	position: ParamTemplate<ParamType.VECTOR3>;
	/** @param this parameter will be set to the hit position */
	positionTarget: ParamTemplate<ParamType.PARAM_PATH>;
	/** @param toggle on to set the param to the mouse velocity (experimental) */
	tvelocity: ParamTemplate<ParamType.BOOLEAN>;
	/** @param toggle on to set the param to the mouse velocity */
	tvelocityTarget: ParamTemplate<ParamType.BOOLEAN>;
	/** @param this will be set to the mouse velocity */
	velocity: ParamTemplate<ParamType.VECTOR3>;
	/** @param this will be set to the mouse velocity */
	velocityTarget: ParamTemplate<ParamType.PARAM_PATH>;
	/** @param for geometry hit tests, a vertex attribute can be read */
	geoAttribute: ParamTemplate<ParamType.BOOLEAN>;
	/** @param geometry vertex attribute to read */
	geoAttributeName: ParamTemplate<ParamType.STRING>;
	/** @param type of attribute */
	geoAttributeType: ParamTemplate<ParamType.INTEGER>;
	/** @param attribute value for float */
	geoAttributeValue1: ParamTemplate<ParamType.FLOAT>;
	/** @param attribute value for string */
	geoAttributeValues: ParamTemplate<ParamType.STRING>;
}
declare class RaycastEventNode extends TypedEventNode<RaycastParamsConfig> {
	paramsConfig: RaycastParamsConfig;
	static type(): string;
	static readonly INPUT_TRIGGER = 'trigger';
	static readonly INPUT_MOUSE = 'mouse';
	static readonly INPUT_UPDATE_OBJECTS = 'updateObjects';
	static readonly INPUT_TRIGGER_VEL_RESET = 'triggerVelReset';
	static readonly OUTPUT_HIT = 'hit';
	static readonly OUTPUT_MISS = 'miss';
	readonly cpuController: RaycastCPUController;
	readonly gpuController: RaycastGPUController;
	initializeNode(): void;
	triggerHit(context: EventContext<MouseEvent>): void;
	triggerMiss(context: EventContext<MouseEvent>): void;
	private _processMouseEvent;
	private _lastEventProcessedAt;
	private _processTriggerEventThrottled;
	private _processTriggerEvent;
	private _processTriggerUpdateObjects;
	private _processTriggerVelReset;
}
declare class SceneEventParamsConfig extends NodeParamsConfig {
	/** @param toggle on to allow any event to be listened to */
	active: ParamTemplate<ParamType.BOOLEAN>;
	/** @param set which element triggers the event */
	element: ParamTemplate<ParamType.INTEGER>;
	/** @param toggle on to trigger an event when the scene has been created. This can be useful to initialize other nodes */
	created: ParamTemplate<ParamType.BOOLEAN>;
	/** @param toggle on to trigger an event when every object in the scene has been loaded. This can be useful to initialize other nodes */
	ready: ParamTemplate<ParamType.BOOLEAN>;
	/** @param toggle on to trigger an event when the scene starts playing */
	play: ParamTemplate<ParamType.BOOLEAN>;
	/** @param toggle on to trigger an event when the scene pauses */
	pause: ParamTemplate<ParamType.BOOLEAN>;
	/** @param toggle on to trigger an event on every tick */
	tick: ParamTemplate<ParamType.BOOLEAN>;
	/** @param toggle on to trigger an event on every tick */
	treachedTime: ParamTemplate<ParamType.BOOLEAN>;
	/** @param time to trigger an event */
	reachedTime: ParamTemplate<ParamType.FLOAT>;
	/** @param frame to set */
	setFrameValue: ParamTemplate<ParamType.INTEGER>;
	/** @param button to set a specific frame */
	setFrame: ParamTemplate<ParamType.BUTTON>;
}
declare class SceneEventNode extends TypedEventNode<SceneEventParamsConfig> {
	paramsConfig: SceneEventParamsConfig;
	static type(): string;
	private _graphNode;
	dispose(): void;
	initializeNode(): void;
	processEvent(eventContext: EventContext<Event>): Promise<void> | undefined;
	private _onSetFrame;
	private _play;
	private _pause;
	private _timeReached;
	private _onTickCheckTimeReached;
	private _onTickEvent;
	private _updateTimeDependency;
	private _buildOnTickCallback;
	static PARAM_CALLBACK_setFrame(node: SceneEventNode): void;
	static PARAM_CALLBACK_updateTimeDependency(node: SceneEventNode): void;
	static PARAM_CALLBACK_updateSceneEventsController(node: SceneEventNode): void;
	static PARAM_CALLBACK_updateActiveState(node: SceneEventNode): void;
	private _updateSceneEventsController;
}
declare class ScrollTriggerParamsConfig extends NodeParamsConfig {
	/** @param active */
	active: ParamTemplate<ParamType.BOOLEAN>;
	/** @param selector of the element the scroll events are detected for */
	element: ParamTemplate<ParamType.STRING>;
	/** @param use viewport as scroller */
	useViewport: ParamTemplate<ParamType.BOOLEAN>;
	/** @param override the scroller */
	scroller: ParamTemplate<ParamType.STRING>;
	/** @param add markers for debugging */
	markers: ParamTemplate<ParamType.BOOLEAN>;
	/** @param define if progress should be updated */
	tprogress: ParamTemplate<ParamType.BOOLEAN>;
	/** @param progress */
	progress: ParamTemplate<ParamType.FLOAT>;
	/** @param define if the scroll is inside the element */
	tinsideElement: ParamTemplate<ParamType.BOOLEAN>;
	/** @param 1 if the scroll is inside the element */
	insideElement: ParamTemplate<ParamType.BOOLEAN>;
	/** @param sends a trigger when we leaving or entering the element */
	onToggle: ParamTemplate<ParamType.BOOLEAN>;
	/** @param sends a trigger when entering the element */
	onEnter: ParamTemplate<ParamType.BOOLEAN>;
	/** @param sends a trigger when leaving the element */
	onLeave: ParamTemplate<ParamType.BOOLEAN>;
	/** @param sends a trigger when entering again the element */
	onEnterBack: ParamTemplate<ParamType.BOOLEAN>;
	/** @param sends a trigger when leaving again the element */
	onLeaveBack: ParamTemplate<ParamType.BOOLEAN>;
}
declare class ScrollTriggerEventNode extends TypedEventNode<ScrollTriggerParamsConfig> {
	paramsConfig: ScrollTriggerParamsConfig;
	gsap: any;
	ScrollTrigger: any;
	static type(): string;
	dispose(): void;
	initializeNode(): void;
	private _scrollTrigger;
	private _onCreateTrigger;
	private _updateScrollTrigger;
	private _onDisposeTrigger;
	private _disposeScrollTrigger;
	private _querySelector;
	static PARAM_CALLBACK_updateScrollTrigger(node: ScrollTriggerEventNode): void;
}
declare class SetFlagParamsConfig extends NodeParamsConfig {
	/** @param mask to select which nodes this can change the flags of */
	mask: ParamTemplate<ParamType.STRING>;
	/** @param toggle on to update the display flag */
	tdisplay: ParamTemplate<ParamType.BOOLEAN>;
	/** @param sets how the display flag will be updated (set to a value or toggle) */
	displayMode: ParamTemplate<ParamType.INTEGER>;
	/** @param new display flag state */
	display: ParamTemplate<ParamType.BOOLEAN>;
	/** @param toggle on to update the bypass flag */
	tbypass: ParamTemplate<ParamType.BOOLEAN>;
	/** @param sets how the bypass flag will be updated (set to a value or toggle) */
	bypassMode: ParamTemplate<ParamType.INTEGER>;
	/** @param new bypass flag state */
	bypass: ParamTemplate<ParamType.BOOLEAN>;
	/** @param button to trigger the node. Useful to debug */
	execute: ParamTemplate<ParamType.BUTTON>;
}
declare class SetFlagEventNode extends TypedEventNode<SetFlagParamsConfig> {
	paramsConfig: SetFlagParamsConfig;
	static type(): string;
	initializeNode(): void;
	processEvent(eventContext: EventContext<Event>): Promise<void>;
	private _updateNodeFlags;
	private _updateNodeDisplayFlag;
	private _updateNodeBypassFlag;
	static PARAM_CALLBACK_execute(node: SetFlagEventNode): void;
}
declare enum SetParamParamType {
	BOOLEAN = 'boolean',
	BUTTON = 'button',
	NUMBER = 'number',
	VECTOR2 = 'vector2',
	VECTOR3 = 'vector3',
	VECTOR4 = 'vector4',
	STRING = 'string',
}
declare class SetParamParamsConfig extends NodeParamsConfig {
	/** @param the parameter to update */
	param: ParamTemplate<ParamType.PARAM_PATH>;
	/** @param type of the parameter to update */
	type: ParamTemplate<ParamType.INTEGER>;
	/** @param for a boolean parameter, sets to toggle its value */
	toggle: ParamTemplate<ParamType.BOOLEAN>;
	/** @param if toggle is set to off, this will set the value of the parameter */
	boolean: ParamTemplate<ParamType.BOOLEAN>;
	/** @param param value for a float parameter */
	number: ParamTemplate<ParamType.FLOAT>;
	/** @param param value for a vector2 parameter */
	vector2: ParamTemplate<ParamType.VECTOR2>;
	/** @param param value for a vector3 parameter */
	vector3: ParamTemplate<ParamType.VECTOR3>;
	/** @param param value for a vector4 parameter */
	vector4: ParamTemplate<ParamType.VECTOR4>;
	/** @param if on, the value will be incremented by the value, as opposed to be set to the value */
	increment: ParamTemplate<ParamType.BOOLEAN>;
	/** @param param value for a string parameter */
	string: ParamTemplate<ParamType.STRING>;
	/** @param execute button to test the node */
	execute: ParamTemplate<ParamType.BUTTON>;
}
declare class SetParamEventNode extends TypedEventNode<SetParamParamsConfig> {
	paramsConfig: SetParamParamsConfig;
	static type(): string;
	initializeNode(): void;
	setParamType(paramType: SetParamParamType): void;
	processEvent(event_context: EventContext<Event>): Promise<void>;
	private _tmp_vector2;
	private _tmp_vector3;
	private _tmp_vector4;
	private _tmp_array2;
	private _tmp_array3;
	private _tmp_array4;
	private _newParamValue;
	static PARAM_CALLBACK_execute(node: SetParamEventNode): void;
	private _computeParamsIfDirty;
}
declare class PassEventParamsConfig extends NodeParamsConfig {
	/** @param number of possible outputs */
	outputsCount: ParamTemplate<ParamType.INTEGER>;
}
declare class SequenceEventNode extends TypedEventNode<PassEventParamsConfig> {
	paramsConfig: PassEventParamsConfig;
	static type(): string;
	initializeNode(): void;
	private _expected_output_types;
	protected _output_name(index: number): string;
	processEvent(event_context: EventContext<Event>): void;
}
declare class ThrottleEventParamsConfig extends NodeParamsConfig {
	/** @param max time between each event */
	time: ParamTemplate<ParamType.INTEGER>;
	/** @param defines if event is dispatched on the leading edge of the timeout */
	leading: ParamTemplate<ParamType.BOOLEAN>;
	/** @param defines if event is trailing on the leading edge of the timeout */
	trailing: ParamTemplate<ParamType.BOOLEAN>;
}
declare class ThrottleEventNode extends TypedEventNode<ThrottleEventParamsConfig> {
	paramsConfig: ThrottleEventParamsConfig;
	static type(): string;
	static readonly OUTPUT_NAME = 'output';
	initializeNode(): void;
	private _debouncedFunc;
	private _lastEventContextReceived;
	processEvent(eventContext: EventContext<Event>): void;
	private _buildDebouncedFunc;
	private _resetDebouncedFunc;
	static PARAM_CALLBACK_resetDebouncedFunc(node: ThrottleEventNode): void;
}
declare class TimerEventParamsConfig extends NodeParamsConfig {
	/** @param period between each interval */
	period: ParamTemplate<ParamType.INTEGER>;
	/** @param number of times the timer should repeat. Set to -1 to never stop */
	count: ParamTemplate<ParamType.INTEGER>;
}
declare class TimerEventNode extends TypedEventNode<TimerEventParamsConfig> {
	paramsConfig: TimerEventParamsConfig;
	static type(): string;
	initializeNode(): void;
	private _timer_active;
	private _current_count;
	private _start_timer;
	protected _stop_timer(): void;
	private _run_timer;
}
declare class TouchEventParamsConfig extends NodeParamsConfig {
	/** @param toggle on to allow any event to be listened to */
	active: ParamTemplate<ParamType.BOOLEAN>;
	/** @param set which element triggers the event */
	element: ParamTemplate<ParamType.INTEGER>;
	/** @param toggle on to listen to touchstart events */
	touchstart: ParamTemplate<ParamType.BOOLEAN>;
	/** @param toggle on to listen to touchmove events */
	touchmove: ParamTemplate<ParamType.BOOLEAN>;
	/** @param toggle on to listen to touchend events */
	touchend: ParamTemplate<ParamType.BOOLEAN>;
}
declare class TouchEventNode extends TypedInputEventNode<TouchEventParamsConfig> {
	paramsConfig: TouchEventParamsConfig;
	static type(): EventInputType;
	protected acceptedEventTypes(): Set<TouchEventType>;
	initializeNode(): void;
	processEvent(eventContext: EventContext<TouchEvent>): void;
}
declare class ViewerParamsConfig extends NodeParamsConfig {
	/** @param sets the class of the viewer */
	className: ParamTemplate<ParamType.STRING>;
}
declare class ViewerEventNode extends TypedEventNode<ViewerParamsConfig> {
	paramsConfig: ViewerParamsConfig;
	static type(): string;
	initializeNode(): void;
	private _getViewer;
	private _process_trigger_setClass;
	private _process_trigger_unsetClass;
}
declare class WindowEventParamsConfig extends NodeParamsConfig {
	/** @param toggle on to allow any event to be listened to */
	active: ParamTemplate<ParamType.BOOLEAN>;
	/** @param set which element triggers the event */
	element: ParamTemplate<ParamType.INTEGER>;
	/** @param toggle on to listen to resize events */
	resize: ParamTemplate<ParamType.BOOLEAN>;
}
declare class WindowEventNode extends TypedInputEventNode<WindowEventParamsConfig> {
	paramsConfig: WindowEventParamsConfig;
	static type(): EventInputType;
	protected acceptedEventTypes(): Set<WindowEventType>;
	initializeNode(): void;
	processEvent(eventContext: EventContext<Event>): void;
}
declare class ParamLessNetworkEventParamsConfig extends NodeParamsConfig {}
declare class BaseNetworkEventNode<K extends NodeParamsConfig> extends TypedNode<NodeContext.EVENT, K> {
	static context(): NodeContext;
	cook(): void;
}
declare class ParamLessBaseNetworkEventNode extends BaseNetworkEventNode<ParamLessNetworkEventParamsConfig> {}
declare class ActorsNetworkEventNode extends ParamLessBaseNetworkEventNode {
	static type(): NetworkNodeType;
	protected _childrenControllerContext: NodeContext;
	createNode<S extends keyof JsNodeChildrenMap>(node_class: S, options?: NodeCreateOptions): JsNodeChildrenMap[S];
	createNode<K extends valueof<JsNodeChildrenMap>>(node_class: Constructor<K>, options?: NodeCreateOptions): K;
	children(): BaseJsNodeType[];
	nodesByType<K extends keyof JsNodeChildrenMap>(type: K): JsNodeChildrenMap[K][];
	childrenAllowed(): boolean;
	sceneReadonly(): boolean;
	readonly persisted_config: ActorPersistedConfig;
	assemblerController(): JsAssemblerController<JsAssemblerActor> | undefined;
	usedAssembler(): Readonly<AssemblerName.JS_ACTOR>;
	protected _assemblerController: JsAssemblerController<JsAssemblerActor> | undefined;
	private _createAssemblerController;
	readonly compilationController: ActorCompilationController;
	compile(): void;
	cook(): void;
}
declare class DelayAnimParamsConfig extends NodeParamsConfig {
	/** @param delay */
	delay: ParamTemplate<ParamType.FLOAT>;
}
declare class DelayAnimNode extends TypedAnimNode<DelayAnimParamsConfig> {
	readonly paramsConfig: DelayAnimParamsConfig;
	static type(): string;
	initializeNode(): void;
	cook(input_contents: TimelineBuilder[]): void;
}
declare class DurationAnimParamsConfig extends NodeParamsConfig {
	/** @param duration */
	duration: ParamTemplate<ParamType.FLOAT>;
}
declare class DurationAnimNode extends TypedAnimNode<DurationAnimParamsConfig> {
	readonly paramsConfig: DurationAnimParamsConfig;
	static type(): string;
	initializeNode(): void;
	cook(input_contents: TimelineBuilder[]): void;
}
declare enum AnimNodeEasing {
	NONE = 'none',
	POWER1 = 'power1',
	POWER2 = 'power2',
	POWER3 = 'power3',
	POWER4 = 'power4',
	BACK = 'back',
	ELASTIC = 'elastic',
	BOUNCE = 'bounce',
	SLOW = 'slow',
	STEPS = 'steps',
	CIRC = 'circ',
	EXPO = 'expo',
	SINE = 'sine',
}
declare enum InOutMode {
	IN = 'in',
	OUT = 'out',
	IN_OUT = 'inOut',
}
declare enum AnimType {
	COPY = 'copy',
	EASING = 'easing',
	TARGET = 'target',
}
declare class EasingAnimParamsConfig extends NodeParamsConfig {
	/** @param name of easing */
	name: ParamTemplate<ParamType.INTEGER>;
	/** @param defines if the easing is 'in', 'out' or 'in-out' */
	inOut: ParamTemplate<ParamType.INTEGER>;
}
declare class EasingAnimNode extends TypedAnimNode<EasingAnimParamsConfig> {
	readonly paramsConfig: EasingAnimParamsConfig;
	static type(): AnimType;
	initializeNode(): void;
	setEasing(mode: AnimNodeEasing): void;
	setInOut(inOut: InOutMode): void;
	static easingFullName(node: EasingAnimNode): string;
	cook(input_contents: TimelineBuilder[]): void;
}
declare class MergeAnimParamsConfig extends NodeParamsConfig {
	/** @param mode (at the same time or one after the other) */
	mode: ParamTemplate<ParamType.INTEGER>;
	/** @param offset if run one after the other */
	offset: ParamTemplate<ParamType.FLOAT>;
	/** @param override the position */
	overridePositions: ParamTemplate<ParamType.BOOLEAN>;
	/** @param number of inputs that this node can merge animations from */
	inputsCount: ParamTemplate<ParamType.INTEGER>;
}
declare class MergeAnimNode extends TypedAnimNode<MergeAnimParamsConfig> {
	readonly paramsConfig: MergeAnimParamsConfig;
	static type(): string;
	initializeNode(): void;
	cook(inputContents: TimelineBuilder[]): void;
	private _updateTimelineBuilder;
	private _setPlayAllTogether;
	private _setPlayOneAtATime;
	private _callbackUpdateInputsCount;
	static PARAM_CALLBACK_setInputsCount(node: MergeAnimNode): void;
}
declare class NullAnimParamsConfig extends NodeParamsConfig {
	/** @param play the animations */
	play: ParamTemplate<ParamType.BUTTON>;
	/** @param pause the animations */
	pause: ParamTemplate<ParamType.BUTTON>;
	/** @param sets if the animations created can be stopped when a new animation in generated on the same property */
	stoppable: ParamTemplate<ParamType.BOOLEAN>;
	/** @param toggle to see debug infos printed in the console */
	debug: ParamTemplate<ParamType.BOOLEAN>;
}
declare class NullAnimNode extends TypedAnimNode<NullAnimParamsConfig> {
	paramsConfig: NullAnimParamsConfig;
	static type(): string;
	initializeNode(): void;
	cook(inputContents: TimelineBuilder[]): void;
	private _timeline;
	timelineBuilder(): Promise<TimelineBuilder | undefined>;
	play(): Promise<void>;
	pause(): Promise<void>;
	static PARAM_CALLBACK_play(node: NullAnimNode): void;
	static PARAM_CALLBACK_pause(node: NullAnimNode): void;
}
declare class OperationAnimParamsConfig extends NodeParamsConfig {
	/** @param sets the operation (set, add or subtract) */
	operation: ParamTemplate<ParamType.INTEGER>;
}
declare class OperationAnimNode extends TypedAnimNode<OperationAnimParamsConfig> {
	paramsConfig: OperationAnimParamsConfig;
	static type(): string;
	initializeNode(): void;
	cook(input_contents: TimelineBuilder[]): void;
}
declare class PositionAnimParamsConfig extends NodeParamsConfig {
	/** @param sets the mode of the position. It can either be relative or absolute */
	mode: ParamTemplate<ParamType.INTEGER>;
	/** @param if sets to relative, sets if it is relative to the start or end */
	relativeTo: ParamTemplate<ParamType.INTEGER>;
	/** @param offset */
	offset: ParamTemplate<ParamType.FLOAT>;
}
declare class PositionAnimNode extends TypedAnimNode<PositionAnimParamsConfig> {
	paramsConfig: PositionAnimParamsConfig;
	static type(): string;
	initializeNode(): void;
	setMode(mode: AnimationPositionMode): void;
	setRelativeTo(relativeTo: AnimationPositionRelativeTo): void;
	cook(input_contents: TimelineBuilder[]): void;
}
declare class PropertyNameAnimParamsConfig extends NodeParamsConfig {
	/** @param name */
	name: ParamTemplate<ParamType.STRING>;
}
declare class PropertyNameAnimNode extends TypedAnimNode<PropertyNameAnimParamsConfig> {
	paramsConfig: PropertyNameAnimParamsConfig;
	static type(): string;
	initializeNode(): void;
	cook(inputContents: TimelineBuilder[]): void;
}
declare enum AnimPropertyValueNodeMode {
	CUSTOM = 'custom',
	FROM_SCENE_GRAPH = 'from scene graph',
	FROM_NODE = 'from node',
}
declare class PropertyValueAnimParamsConfig extends NodeParamsConfig {
	/** @param mode */
	mode: ParamTemplate<ParamType.INTEGER>;
	/** @param if set to a Polygonjs node, this is the node path */
	nodePath: ParamTemplate<ParamType.NODE_PATH>;
	/** @param if set to a THREE object, this is a mask to find the objects */
	objectMask: ParamTemplate<ParamType.STRING>;
	/** @param print the object matching the objectMask, to help debugging */
	printResolve: ParamTemplate<ParamType.BUTTON>;
	overridePropertyName: ParamTemplate<ParamType.BOOLEAN>;
	propertyName: ParamTemplate<ParamType.STRING>;
	/** @param size of the parameter to animate */
	size: ParamTemplate<ParamType.INTEGER>;
	/** @param value for a float */
	value1: ParamTemplate<ParamType.FLOAT>;
	/** @param value for a vector2 */
	value2: ParamTemplate<ParamType.VECTOR2>;
	/** @param value for a vector3 */
	value3: ParamTemplate<ParamType.VECTOR3>;
	/** @param value for a vector3 as color */
	color: ParamTemplate<ParamType.COLOR>;
	/** @param value for a vector4 */
	value4: ParamTemplate<ParamType.VECTOR4>;
	/** @param when using vector3, use toggle on it should be a color */
	asColor: ParamTemplate<ParamType.BOOLEAN>;
}
declare class PropertyValueAnimNode extends TypedAnimNode<PropertyValueAnimParamsConfig> {
	paramsConfig: PropertyValueAnimParamsConfig;
	static type(): string;
	initializeNode(): void;
	cook(inputContents: TimelineBuilder[]): Promise<void>;
	setMode(targetType: AnimPropertyValueNodeMode): void;
	private _prepareTimelineBuilder;
	private _prepareTimebuilderCustom;
	private _prepareTimebuilderFromSceneGraph;
	private _prepareTimebuilderFromNode;
	static PARAM_CALLBACK_printResolve(node: PropertyValueAnimNode): void;
	private _foundObjectFromSceneGraph;
	private printResolve;
}
declare class RepeatAnimParamsConfig extends NodeParamsConfig {
	/** @param sets if it should repeat indefinitely */
	unlimited: ParamTemplate<ParamType.BOOLEAN>;
	/** @param number of times the animation should repeat */
	count: ParamTemplate<ParamType.INTEGER>;
	/** @param delay */
	delay: ParamTemplate<ParamType.FLOAT>;
	/** @param sets if the animation should go back and forth at each repeat */
	yoyo: ParamTemplate<ParamType.BOOLEAN>;
}
declare class RepeatAnimNode extends TypedAnimNode<RepeatAnimParamsConfig> {
	paramsConfig: RepeatAnimParamsConfig;
	static type(): string;
	initializeNode(): void;
	private _repeat_params;
	cook(input_contents: TimelineBuilder[]): void;
}
declare class PlayAnimParamsConfig extends NodeParamsConfig {
	/** @param play the animations */
	play: ParamTemplate<ParamType.BUTTON>;
	/** @param pause the animations */
	pause: ParamTemplate<ParamType.BUTTON>;
	/** @param reset the animations */
	reset: ParamTemplate<ParamType.BUTTON>;
	/** @param sets if the animations created can be stopped when a new animation in generated on the same property */
	stoppable: ParamTemplate<ParamType.BOOLEAN>;
	/** @param toggle to see debug infos printed in the console */
	debug: ParamTemplate<ParamType.BOOLEAN>;
	/** @param seek */
	seek: ParamTemplate<ParamType.FLOAT>;
}
declare class PlayAnimNode extends TypedAnimNode<PlayAnimParamsConfig> {
	paramsConfig: PlayAnimParamsConfig;
	gsap: typeof gsap;
	static type(): string;
	static displayedInputNames(): string[];
	initializeNode(): void;
	cook(inputContents: TimelineBuilder[]): void;
	private _timeline;
	timelineBuilder(inputIndex: number): Promise<TimelineBuilder | undefined>;
	private _playFromInput;
	play(): Promise<void>;
	reset(): Promise<void>;
	pause(): Promise<void>;
	seek(): Promise<void>;
	static PARAM_CALLBACK_play(node: PlayAnimNode): void;
	static PARAM_CALLBACK_pause(node: PlayAnimNode): void;
	static PARAM_CALLBACK_reset(node: PlayAnimNode): void;
	static PARAM_CALLBACK_seek(node: PlayAnimNode): void;
}
declare class ParamLessSubnetAnimParamsConfig extends NodeParamsConfig {}
declare class BaseSubnetAnimNode<K extends NodeParamsConfig> extends TypedAnimNode<K> {
	initializeNode(): void;
	protected _childrenControllerContext: NodeContext;
	createNode<S extends keyof AnimNodeChildrenMap>(nodeClass: S, options?: NodeCreateOptions): AnimNodeChildrenMap[S];
	createNode<K extends valueof<AnimNodeChildrenMap>>(nodeClass: Constructor<K>, options?: NodeCreateOptions): K;
	children(): BaseAnimNodeType[];
	nodesByType<K extends keyof AnimNodeChildrenMap>(type: K): AnimNodeChildrenMap[K][];
	cook(inputContents: TimelineBuilder[]): Promise<void>;
}
declare class SubnetAnimNode extends BaseSubnetAnimNode<ParamLessSubnetAnimParamsConfig> {
	paramsConfig: ParamLessSubnetAnimParamsConfig;
	static type(): NetworkNodeType;
}
declare class SubnetInputAnimParamsConfig extends NodeParamsConfig {
	/** @param sets which input of the parent subnet node is used */
	input: ParamTemplate<ParamType.INTEGER>;
}
declare class SubnetInputAnimNode extends TypedAnimNode<SubnetInputAnimParamsConfig> {
	paramsConfig: SubnetInputAnimParamsConfig;
	static type(): NetworkChildNodeType;
	private _currentParentInputGraphNode;
	initializeNode(): void;
	cook(): Promise<void>;
	static PARAM_CALLBACK_reset(node: SubnetInputAnimNode): void;
	private _setParentInputDependency;
}
declare class AnimSubnetOutputSopParamsConfig extends NodeParamsConfig {}
declare class SubnetOutputAnimNode extends TypedAnimNode<AnimSubnetOutputSopParamsConfig> {
	paramsConfig: AnimSubnetOutputSopParamsConfig;
	static type(): Readonly<NetworkChildNodeType.OUTPUT>;
	initializeNode(): void;
	dispose(): void;
	cook(inputContents: TimelineBuilder[]): void;
	private _setParentDirtyBound;
	private _setParentDirty;
}
declare class SwitchAnimParamsConfig extends NodeParamsConfig {
	/** @param input to process */
	input: ParamTemplate<ParamType.INTEGER>;
}
declare class SwitchAnimNode extends TypedAnimNode<SwitchAnimParamsConfig> {
	paramsConfig: SwitchAnimParamsConfig;
	static type(): string;
	initializeNode(): void;
	cook(input_contents: TimelineBuilder[]): void;
}
declare enum AnimTargetNodeTargetType {
	SCENE_GRAPH = 'scene graph',
	NODE = 'node',
}
declare class TargetAnimParamsConfig extends NodeParamsConfig {
	/** @param sets if the target is a Polygonjs node, or a THREE object */
	type: ParamTemplate<ParamType.INTEGER>;
	/** @param if set to a Polygonjs node, this is the node path */
	nodePath: ParamTemplate<ParamType.NODE_PATH>;
	/** @param if set to a THREE object, this is a mask to find the objects */
	objectMask: ParamTemplate<ParamType.STRING>;
	/** @param sets if the matrix should be updated as the animation progresses */
	updateMatrix: ParamTemplate<ParamType.BOOLEAN>;
	/** @param prints which objects are targeted by this node, for debugging */
	printResolve: ParamTemplate<ParamType.BUTTON>;
}
declare class TargetAnimNode extends TypedAnimNode<TargetAnimParamsConfig> {
	paramsConfig: TargetAnimParamsConfig;
	static type(): AnimType;
	initializeNode(): void;
	cook(inputCoreContents: TimelineBuilder[]): void;
	setTargetType(targetType: AnimTargetNodeTargetType): void;
	private _create_target;
	private _set_update_callback;
	static PARAM_CALLBACK_print_resolve(node: TargetAnimNode): void;
	private print_resolve;
}
declare class ParamLessNetworkAnimParamsConfig extends NodeParamsConfig {}
declare class BaseNetworkAnimNode<K extends NodeParamsConfig> extends TypedNode<NodeContext.ANIM, K> {
	static context(): NodeContext;
	cook(): void;
}
declare class ParamLessBaseNetworkAnimNode extends BaseNetworkAnimNode<ParamLessNetworkAnimParamsConfig> {}
declare class ActorsNetworkAnimNode extends ParamLessBaseNetworkAnimNode {
	static type(): NetworkNodeType;
	protected _childrenControllerContext: NodeContext;
	createNode<S extends keyof JsNodeChildrenMap>(node_class: S, options?: NodeCreateOptions): JsNodeChildrenMap[S];
	createNode<K extends valueof<JsNodeChildrenMap>>(node_class: Constructor<K>, options?: NodeCreateOptions): K;
	children(): BaseJsNodeType[];
	nodesByType<K extends keyof JsNodeChildrenMap>(type: K): JsNodeChildrenMap[K][];
	childrenAllowed(): boolean;
	sceneReadonly(): boolean;
	readonly persisted_config: ActorPersistedConfig;
	assemblerController(): JsAssemblerController<JsAssemblerActor> | undefined;
	usedAssembler(): Readonly<AssemblerName.JS_ACTOR>;
	protected _assemblerController: JsAssemblerController<JsAssemblerActor> | undefined;
	private _createAssemblerController;
	readonly compilationController: ActorCompilationController;
	compile(): void;
	cook(): void;
}
declare class AnimationsNetworkAnimNode extends ParamLessBaseNetworkAnimNode {
	static type(): NetworkNodeType;
	protected _childrenControllerContext: NodeContext;
	createNode<S extends keyof AnimNodeChildrenMap>(node_class: S, options?: NodeCreateOptions): AnimNodeChildrenMap[S];
	createNode<K extends valueof<AnimNodeChildrenMap>>(node_class: Constructor<K>, options?: NodeCreateOptions): K;
	children(): BaseAnimNodeType[];
	nodesByType<K extends keyof AnimNodeChildrenMap>(type: K): AnimNodeChildrenMap[K][];
}
declare class AMSynthAudioParamsConfig extends NodeParamsConfig {}
declare class AMSynthAudioNode extends TypedAudioNode<AMSynthAudioParamsConfig> {
	paramsConfig: AMSynthAudioParamsConfig;
	static type(): string;
	initializeNode(): void;
	static displayedInputNames(): string[];
	cook(inputContents: AudioBuilder[]): void;
}
declare class AutoFilterAudioParamsConfig extends NodeParamsConfig {
	/** @param baseFrequency */
	baseFrequency: ParamTemplate<ParamType.FLOAT>;
	/** @param octaves */
	octaves: ParamTemplate<ParamType.FLOAT>;
}
declare class AutoFilterAudioNode extends TypedAudioNode<AutoFilterAudioParamsConfig> {
	paramsConfig: AutoFilterAudioParamsConfig;
	static type(): string;
	initializeNode(): void;
	cook(inputContents: AudioBuilder[]): void;
	private __effect__;
	private _effect;
	private _createEffect;
	static PARAM_CALLBACK_updateEffect(node: AutoFilterAudioNode): void;
	private _updateEffect;
}
declare class AutoWahAudioParamsConfig extends NodeParamsConfig {
	/** @param baseFrequency */
	baseFrequency: ParamTemplate<ParamType.FLOAT>;
	/** @param octaves */
	octaves: ParamTemplate<ParamType.FLOAT>;
	/** @param sensitivity */
	sensitivity: ParamTemplate<ParamType.FLOAT>;
	/** @param follower */
	follower: ParamTemplate<ParamType.FLOAT>;
}
declare class AutoWahAudioNode extends TypedAudioNode<AutoWahAudioParamsConfig> {
	paramsConfig: AutoWahAudioParamsConfig;
	static type(): string;
	initializeNode(): void;
	cook(inputContents: AudioBuilder[]): void;
	private __effect__;
	private _effect;
	private _createEffect;
	static PARAM_CALLBACK_updateEffect(node: AutoWahAudioNode): void;
	private _updateEffect;
}
declare class BitCrusherAudioParamsConfig extends NodeParamsConfig {
	/** @param bits */
	bits: ParamTemplate<ParamType.INTEGER>;
}
declare class BitCrusherAudioNode extends TypedAudioNode<BitCrusherAudioParamsConfig> {
	paramsConfig: BitCrusherAudioParamsConfig;
	static type(): string;
	initializeNode(): void;
	cook(inputContents: AudioBuilder[]): void;
}
declare class ChebyshevAudioParamsConfig extends NodeParamsConfig {
	/** @param order */
	order: ParamTemplate<ParamType.INTEGER>;
	/** @param oversample */
	oversample: ParamTemplate<ParamType.INTEGER>;
}
declare class ChebyshevAudioNode extends TypedAudioNode<ChebyshevAudioParamsConfig> {
	paramsConfig: ChebyshevAudioParamsConfig;
	static type(): string;
	initializeNode(): void;
	cook(inputContents: AudioBuilder[]): void;
	private __effect__;
	private _effect;
	private _createEffect;
	static PARAM_CALLBACK_updateEffect(node: ChebyshevAudioNode): void;
	private _updateEffect;
}
declare class ChorusAudioParamsConfig extends NodeParamsConfig {
	/** @param The frequency of the LFO. */
	frequency: ParamTemplate<ParamType.FLOAT>;
	/** The delay of the chorus effect in ms */
	delayTime: ParamTemplate<ParamType.FLOAT>;
	/** The depth of the chorus */
	depth: ParamTemplate<ParamType.FLOAT>;
}
declare class ChorusAudioNode extends TypedAudioNode<ChorusAudioParamsConfig> {
	paramsConfig: ChorusAudioParamsConfig;
	static type(): string;
	initializeNode(): void;
	cook(inputContents: AudioBuilder[]): void;
	private __effect__;
	private _effect;
	private _createEffect;
	static PARAM_CALLBACK_updateEffect(node: ChorusAudioNode): void;
	private _updateEffect;
}
declare class DistortionAudioParamsConfig extends NodeParamsConfig {
	/** @param distortion */
	distortion: ParamTemplate<ParamType.FLOAT>;
	/** @param oversample */
	oversample: ParamTemplate<ParamType.INTEGER>;
}
declare class DistortionAudioNode extends TypedAudioNode<DistortionAudioParamsConfig> {
	paramsConfig: DistortionAudioParamsConfig;
	static type(): string;
	initializeNode(): void;
	cook(inputContents: AudioBuilder[]): void;
	private __effect__;
	private _effect;
	private _createEffect;
	static PARAM_CALLBACK_updateEffect(node: DistortionAudioNode): void;
	private _updateEffect;
}
declare class EnvelopeAudioParamsConfig extends NodeParamsConfig {
	/** @param The amount of time it takes for the envelope to go from 0 to it's maximum value. */
	attack: ParamTemplate<ParamType.FLOAT>;
	/** The period of time after the attack that it takes for the envelope to fall to the sustain value. */
	decay: ParamTemplate<ParamType.FLOAT>;
	/** The percent of the maximum value that the envelope rests at until the release is triggered. */
	sustain: ParamTemplate<ParamType.FLOAT>;
	/** The amount of time after the release is triggered it takes to reach 0. */
	release: ParamTemplate<ParamType.FLOAT>;
}
declare class EnvelopeAudioNode extends TypedAudioNode<EnvelopeAudioParamsConfig> {
	paramsConfig: EnvelopeAudioParamsConfig;
	static type(): string;
	initializeNode(): void;
	cook(inputContents: AudioBuilder[]): void;
}
declare abstract class BaseAnalyserAudioNode<K extends NodeParamsConfig> extends TypedAudioNode<K> {
	abstract getAnalyserValue(): Float32Array | number[] | undefined;
}
declare class FFTAudioParamsConfig extends NodeParamsConfig {
	/** @param array size will be 2**sizeExponent */
	sizeExponent: ParamTemplate<ParamType.INTEGER>;
	/** @param array size */
	arraySize: ParamTemplate<ParamType.INTEGER>;
	/** @param a value from between 0 and 1 where 0 represents no time averaging with the last analysis frame */
	smoothing: ParamTemplate<ParamType.FLOAT>;
	/** @param normalizes the output between 0 and 1. The value will be in decibel otherwise. */
	normalRange: ParamTemplate<ParamType.BOOLEAN>;
	/** @param groups the FFT frequency bands into octave bands */
	asOctaves: ParamTemplate<ParamType.BOOLEAN>;
	octaveDivisions: ParamTemplate<ParamType.INTEGER>;
	/** @param display range param */
	updateRangeParam: ParamTemplate<ParamType.BOOLEAN>;
	/** @param range value */
	range: ParamTemplate<ParamType.VECTOR2>;
	/** @param accumulated range */
	maxRange: ParamTemplate<ParamType.VECTOR2>;
	/** @param resetMaxRange */
	resetMaxRange: ParamTemplate<ParamType.BUTTON>;
}
declare class FFTAudioNode extends BaseAnalyserAudioNode<FFTAudioParamsConfig> {
	paramsConfig: FFTAudioParamsConfig;
	static type(): AudioNodeAnalyserType;
	initializeNode(): void;
	cook(inputContents: AudioBuilder[]): void;
	getAnalyserValue(): Float32Array | undefined;
	private __octaveValues;
	private _octaveDivisions;
	private _octaveValues;
	private __effect__;
	private _effect;
	private _createEffect;
	private _resetEffect;
	static PARAM_CALLBACK_updateEffect(node: FFTAudioNode): void;
	private _updateEffect;
	private _FFTSize;
	static PARAM_CALLBACK_updateUpdateRangeParam(node: FFTAudioNode): void;
	static PARAM_CALLBACK_resetMaxRange(node: FFTAudioNode): void;
	private _updateRangeParam;
	private _updateOnTickHook;
	private _registerOnTickHook;
	private _unRegisterOnTickHook;
	private _tickCallbackName;
}
declare class FMSynthAudioParamsConfig extends NodeParamsConfig {}
declare class FMSynthAudioNode extends TypedAudioNode<FMSynthAudioParamsConfig> {
	paramsConfig: FMSynthAudioParamsConfig;
	static type(): string;
	initializeNode(): void;
	static displayedInputNames(): string[];
	cook(inputContents: AudioBuilder[]): void;
}
declare class FeedbackDelayAudioParamsConfig extends NodeParamsConfig {
	/** @param delayTime */
	delayTime: ParamTemplate<ParamType.FLOAT>;
	/** @param maxDelay */
	maxDelay: ParamTemplate<ParamType.FLOAT>;
	/** @param feedback */
	feedback: ParamTemplate<ParamType.FLOAT>;
}
declare class FeedbackDelayAudioNode extends TypedAudioNode<FeedbackDelayAudioParamsConfig> {
	paramsConfig: FeedbackDelayAudioParamsConfig;
	static type(): string;
	initializeNode(): void;
	cook(inputContents: AudioBuilder[]): void;
}
declare class FetchAudioParamsConfig extends NodeParamsConfig {
	/** @param which node to import */
	audioNode: ParamTemplate<ParamType.NODE_PATH>;
}
declare class FetchAudioNode extends TypedAudioNode<FetchAudioParamsConfig> {
	paramsConfig: FetchAudioParamsConfig;
	static type(): string;
	initializeNode(): void;
	cook(inputContents: AudioBuilder[]): Promise<void>;
}
export declare type OnBeforePlayCallback = (offset: number) => void;
export declare type OnPlaySuccessCallback = () => void;
export declare type OnPlayErrorCallback = (err: unknown) => void;
export declare type OnStopCallback = () => void;
declare enum AudioType {
	FILE = 'file',
}
declare class FileAudioParamsConfig extends NodeParamsConfig {
	/** @param url to fetch the audio file from */
	url: ParamTemplate<ParamType.STRING>;
	/** @param auto start */
	autostart: ParamTemplate<ParamType.BOOLEAN>;
	/** @param duration */
	duration: ParamTemplate<ParamType.FLOAT>;
	/** @param display currentTime param */
	updateCurrentTimeParam: ParamTemplate<ParamType.BOOLEAN>;
	/** @param currentTime */
	currentTime: ParamTemplate<ParamType.FLOAT>;
	/** @param loop */
	loop: ParamTemplate<ParamType.BOOLEAN>;
	/** @param useLoopRange */
	/** @param loop Range */
	/** @param play the audio */
	play: ParamTemplate<ParamType.BUTTON>;
	/** @param stop the audio */
	pause: ParamTemplate<ParamType.BUTTON>;
	/** @param restart the audio */
	restart: ParamTemplate<ParamType.BUTTON>;
	/** @param seek 10 seconds back */
	seekM10: ParamTemplate<ParamType.BUTTON>;
	/** @param seek 5 seconds back */
	seekM5: ParamTemplate<ParamType.BUTTON>;
	/** @param seek 5 seconds forward */
	seekP5: ParamTemplate<ParamType.BUTTON>;
	/** @param seek 10 seconds forward */
	seekP10: ParamTemplate<ParamType.BUTTON>;
}
declare class FileAudioNode extends TypedAudioNode<FileAudioParamsConfig> {
	paramsConfig: FileAudioParamsConfig;
	static type(): AudioType;
	initializeNode(): void;
	dispose(): void;
	private _startedAt;
	private _stoppedAt;
	cook(inputContents: AudioBuilder[]): Promise<void>;
	private _player;
	private _loadUrl;
	play(): Promise<void>;
	pause(): Promise<void>;
	private _reset;
	restart(): Promise<void>;
	seekOffset(offset: number): void;
	static PARAM_CALLBACK_updateUpdateCurrentTimeParam(node: FileAudioNode): void;
	private _updateCurrentTimeParam;
	private _currentTime;
	static PARAM_CALLBACK_updateLoop(node: FileAudioNode): void;
	private _updateLoop;
	private _updateOnTickHook;
	private _registerOnTickHook;
	private _unRegisterOnTickHook;
	private _tickCallbackName;
	static PARAM_CALLBACK_seekOffset(node: FileAudioNode, offset: number): void;
	static PARAM_CALLBACK_play(node: FileAudioNode): void;
	static PARAM_CALLBACK_pause(node: FileAudioNode): void;
	static PARAM_CALLBACK_restart(node: FileAudioNode): void;
	private _playerCallbacks;
	onBeforePlay(callback: OnBeforePlayCallback): void;
	private _runOnBeforePlay;
	onPlaySuccess(callback: OnPlaySuccessCallback): void;
	private _runOnPlaySuccess;
	onPlayError(callback: OnPlayErrorCallback): void;
	private _runOnPlayError;
	onStop(callback: OnStopCallback): void;
	removeOnStop(callback: OnStopCallback): void;
	private _runOnStop;
	private _on;
	private _removeCallback;
}
declare class FrequencyShifterAudioParamsConfig extends NodeParamsConfig {
	/** @param frequency */
	frequency: ParamTemplate<ParamType.FLOAT>;
}
declare class FrequencyShifterAudioNode extends TypedAudioNode<FrequencyShifterAudioParamsConfig> {
	paramsConfig: FrequencyShifterAudioParamsConfig;
	static type(): string;
	initializeNode(): void;
	cook(inputContents: AudioBuilder[]): void;
}
declare class MeterAudioParamsConfig extends NodeParamsConfig {
	/** @param a value from between 0 and 1 where 0 represents no time averaging with the last analysis frame */
	smoothing: ParamTemplate<ParamType.FLOAT>;
	/** @param normalizes the output between 0 and 1. The value will be in decibel otherwise. */
	normalRange: ParamTemplate<ParamType.BOOLEAN>;
	/** @param display meter param */
	updateValueParam: ParamTemplate<ParamType.BOOLEAN>;
	/** @param meter value */
	value: ParamTemplate<ParamType.FLOAT>;
	/** @param display meter param */
	updateRangeParam: ParamTemplate<ParamType.BOOLEAN>;
	/** @param accumulated range */
	maxRange: ParamTemplate<ParamType.VECTOR2>;
	/** @param resetMaxRange */
	resetMaxRange: ParamTemplate<ParamType.BUTTON>;
}
declare class MeterAudioNode extends BaseAnalyserAudioNode<MeterAudioParamsConfig> {
	paramsConfig: MeterAudioParamsConfig;
	static type(): AudioNodeAnalyserType;
	initializeNode(): void;
	cook(inputContents: AudioBuilder[]): void;
	private _arrayValue;
	getAnalyserValue(): number[] | Float32Array | undefined;
	private __effect__;
	private _effect;
	private _createEffect;
	private _resetEffect;
	static PARAM_CALLBACK_updateEffect(node: MeterAudioNode): void;
	private _updateEffect;
	static PARAM_CALLBACK_updateUpdateMeterParam(node: MeterAudioNode): void;
	static PARAM_CALLBACK_resetMaxRange(node: MeterAudioNode): void;
	private _updateMeterParam;
	private _updateOnTickHook;
	private _registerOnTickHook;
	private _unRegisterOnTickHook;
	private _tickCallbackName;
}
declare class MonoSynthAudioParamsConfig extends NodeParamsConfig {}
declare class MonoSynthAudioNode extends TypedAudioNode<MonoSynthAudioParamsConfig> {
	paramsConfig: MonoSynthAudioParamsConfig;
	static type(): string;
	initializeNode(): void;
	static displayedInputNames(): string[];
	cook(inputContents: AudioBuilder[]): void;
}
declare class NoiseAudioParamsConfig extends NodeParamsConfig {
	/** @param Noise type */
	type: ParamTemplate<ParamType.INTEGER>;
	/** playbackRate */
	playbackRate: ParamTemplate<ParamType.FLOAT>;
	/** fadeIn */
	fadeIn: ParamTemplate<ParamType.FLOAT>;
	/** fadeOut */
	fadeOut: ParamTemplate<ParamType.FLOAT>;
	/** play */
	play: ParamTemplate<ParamType.BOOLEAN>;
}
declare class NoiseAudioNode extends TypedAudioNode<NoiseAudioParamsConfig> {
	paramsConfig: NoiseAudioParamsConfig;
	static type(): string;
	initializeNode(): void;
	cook(inputContents: AudioBuilder[]): void;
	private __noise__;
	private _noise;
	private _createEffect;
	static PARAM_CALLBACK_updateNoise(node: NoiseAudioNode): void;
	private _updateNoise;
}
declare class NullAudioParamsConfig extends NodeParamsConfig {}
declare class NullAudioNode extends TypedAudioNode<NullAudioParamsConfig> {
	paramsConfig: NullAudioParamsConfig;
	static type(): string;
	initializeNode(): void;
	cook(inputContents: AudioBuilder[]): void;
}
declare class PhaserAudioParamsConfig extends NodeParamsConfig {
	/** @param frequency */
	frequency: ParamTemplate<ParamType.FLOAT>;
	/** @param baseFrequency */
	baseFrequency: ParamTemplate<ParamType.FLOAT>;
	/** @param octaves */
	octaves: ParamTemplate<ParamType.FLOAT>;
	/** @param sensitivity */
	stages: ParamTemplate<ParamType.FLOAT>;
	/** @param Q */
	Q: ParamTemplate<ParamType.FLOAT>;
}
declare class PhaserAudioNode extends TypedAudioNode<PhaserAudioParamsConfig> {
	paramsConfig: PhaserAudioParamsConfig;
	static type(): string;
	initializeNode(): void;
	cook(inputContents: AudioBuilder[]): void;
	private __effect__;
	private _effect;
	private _createEffect;
	private _resetEffect;
	static PARAM_CALLBACK_updateEffect(node: PhaserAudioNode): void;
	private _updateEffect;
}
declare class PingPongDelayAudioParamsConfig extends NodeParamsConfig {
	/** @param delayTime */
	delayTime: ParamTemplate<ParamType.FLOAT>;
	/** @param maxDelay */
	maxDelay: ParamTemplate<ParamType.FLOAT>;
}
declare class PingPongDelayAudioNode extends TypedAudioNode<PingPongDelayAudioParamsConfig> {
	paramsConfig: PingPongDelayAudioParamsConfig;
	static type(): string;
	initializeNode(): void;
	cook(inputContents: AudioBuilder[]): void;
	private _createEffect;
}
declare class PitchShiftAudioParamsConfig extends NodeParamsConfig {
	/** @param The interval to transpose the incoming signal by */
	pitch: ParamTemplate<ParamType.FLOAT>;
}
declare class PitchShiftAudioNode extends TypedAudioNode<PitchShiftAudioParamsConfig> {
	paramsConfig: PitchShiftAudioParamsConfig;
	static type(): string;
	initializeNode(): void;
	cook(inputContents: AudioBuilder[]): void;
	private __effect__;
	private _effect;
	private _createEffect;
	static PARAM_CALLBACK_updateEffect(node: PitchShiftAudioNode): void;
	private _updateEffect;
}
declare class PlayInstrumentAudioParamsConfig extends NodeParamsConfig {
	/** @param note */
	note: ParamTemplate<ParamType.STRING>;
	/** @param duration */
	duration: ParamTemplate<ParamType.FLOAT>;
	/** @param play the audio */
	/** @param stop the audio */
	showNotes: ParamTemplate<ParamType.BOOLEAN>;
	showKeys: ParamTemplate<ParamType.BOOLEAN>;
	startOctave: ParamTemplate<ParamType.INTEGER>;
	endOctave: ParamTemplate<ParamType.INTEGER>;
	updateNoteFromInstrument: ParamTemplate<ParamType.BOOLEAN>;
}
declare class PlayInstrumentAudioNode extends TypedAudioNode<PlayInstrumentAudioParamsConfig> {
	paramsConfig: PlayInstrumentAudioParamsConfig;
	static type(): string;
	initializeNode(): void;
	cook(inputContents: AudioBuilder[]): void;
	play(): Promise<void>;
	private _getInstrument;
}
declare class PolySynthAudioParamsConfig extends NodeParamsConfig {}
declare class PolySynthAudioNode extends TypedAudioNode<PolySynthAudioParamsConfig> {
	paramsConfig: PolySynthAudioParamsConfig;
	static type(): string;
	initializeNode(): void;
	static displayedInputNames(): string[];
	cook(inputContents: AudioBuilder[]): void;
}
declare class ReverbAudioParamsConfig extends NodeParamsConfig {
	/** @param The duration of the reverb. */
	decay: ParamTemplate<ParamType.FLOAT>;
	/** The amount of time before the reverb is fully ramped in */
	preDelay: ParamTemplate<ParamType.FLOAT>;
}
declare class ReverbAudioNode extends TypedAudioNode<ReverbAudioParamsConfig> {
	paramsConfig: ReverbAudioParamsConfig;
	static type(): string;
	initializeNode(): void;
	cook(inputContents: AudioBuilder[]): void;
	private __effect__;
	private _effect;
	private _createEffect;
	static PARAM_CALLBACK_updateEffect(node: ReverbAudioNode): void;
	private _updateEffect;
}
declare class SamplerAudioParamsConfig extends NodeParamsConfig {
	/** @param map of notes to load */
	urlsMap: ParamTemplate<ParamType.STRING>;
	/** @param base url */
	baseUrl: ParamTemplate<ParamType.STRING>;
	/** @param extension */
	extension: ParamTemplate<ParamType.STRING>;
}
declare class SamplerAudioNode extends TypedAudioNode<SamplerAudioParamsConfig> {
	paramsConfig: SamplerAudioParamsConfig;
	static type(): string;
	initializeNode(): void;
	static displayedInputNames(): string[];
	dispose(): void;
	cook(inputContents: AudioBuilder[]): Promise<void>;
}
declare class StereoWidenerAudioParamsConfig extends NodeParamsConfig {
	/** @param width */
	width: ParamTemplate<ParamType.FLOAT>;
}
declare class StereoWidenerAudioNode extends TypedAudioNode<StereoWidenerAudioParamsConfig> {
	paramsConfig: StereoWidenerAudioParamsConfig;
	static type(): string;
	initializeNode(): void;
	cook(inputContents: AudioBuilder[]): void;
}
declare class SwitchAudioParamsConfig extends NodeParamsConfig {
	/** @param sets which input is used */
	input: ParamTemplate<ParamType.INTEGER>;
}
declare class SwitchAudioNode extends TypedAudioNode<SwitchAudioParamsConfig> {
	paramsConfig: SwitchAudioParamsConfig;
	static type(): string;
	initializeNode(): void;
	cook(inputContents: AudioBuilder[]): Promise<void>;
	private _callbackUpdateInputsEvaluation;
	static PARAM_CALLBACK_setInputsEvaluation(node: SwitchAudioNode): void;
}
declare class SynthAudioParamsConfig extends NodeParamsConfig {
	/** @param The glide time between notes. */
	portamento: ParamTemplate<ParamType.FLOAT>;
}
declare class SynthAudioNode extends TypedAudioNode<SynthAudioParamsConfig> {
	paramsConfig: SynthAudioParamsConfig;
	static type(): string;
	static displayedInputNames(): string[];
	initializeNode(): void;
	cook(inputContents: AudioBuilder[]): void;
}
declare class TremoloAudioParamsConfig extends NodeParamsConfig {
	/** @param frequency */
	frequency: ParamTemplate<ParamType.FLOAT>;
	/** @param depth */
	depth: ParamTemplate<ParamType.FLOAT>;
	/** @param spread (degrees) */
	spread: ParamTemplate<ParamType.FLOAT>;
}
declare class TremoloAudioNode extends TypedAudioNode<TremoloAudioParamsConfig> {
	paramsConfig: TremoloAudioParamsConfig;
	static type(): string;
	initializeNode(): void;
	cook(inputContents: AudioBuilder[]): void;
	private _createEffect;
}
declare class UserMediaAudioParamsConfig extends NodeParamsConfig {
	autostart: ParamTemplate<ParamType.BOOLEAN>;
	/** @param play the audio */
	open: ParamTemplate<ParamType.BUTTON>;
	/** @param stop the audio */
	close: ParamTemplate<ParamType.BUTTON>;
}
declare class UserMediaAudioNode extends TypedAudioNode<UserMediaAudioParamsConfig> {
	paramsConfig: UserMediaAudioParamsConfig;
	static type(): string;
	initializeNode(): void;
	cook(inputContents: AudioBuilder[]): Promise<void>;
	private __userMedia__;
	private _userMedia;
	private _createEffect;
	open(): Promise<UserMedia>;
	close(): void;
	static PARAM_CALLBACK_open(node: UserMediaAudioNode): void;
	static PARAM_CALLBACK_close(node: UserMediaAudioNode): void;
}
declare class VibratoAudioParamsConfig extends NodeParamsConfig {
	/** @param maxDelay */
	maxDelay: ParamTemplate<ParamType.FLOAT>;
	/** @param frequency */
	frequency: ParamTemplate<ParamType.FLOAT>;
	/** @param depth */
	depth: ParamTemplate<ParamType.FLOAT>;
}
declare class VibratoAudioNode extends TypedAudioNode<VibratoAudioParamsConfig> {
	paramsConfig: VibratoAudioParamsConfig;
	static type(): string;
	initializeNode(): void;
	cook(inputContents: AudioBuilder[]): void;
	private _createEffect;
}
declare class VolumeAudioParamsConfig extends NodeParamsConfig {
	/** @param volume */
	volume: ParamTemplate<ParamType.FLOAT>;
}
declare class VolumeAudioNode extends TypedAudioNode<VolumeAudioParamsConfig> {
	paramsConfig: VolumeAudioParamsConfig;
	static type(): string;
	initializeNode(): void;
	cook(inputContents: AudioBuilder[]): void;
	private __effect__;
	private _effect;
	private _createEffect;
	static PARAM_CALLBACK_updateEffect(node: VolumeAudioNode): void;
	private _updateEffect;
}
declare class WaveformAudioParamsConfig extends NodeParamsConfig {
	/** @param array size will be 2**sizeExponent */
	sizeExponent: ParamTemplate<ParamType.INTEGER>;
	/** @param array size */
	arraySize: ParamTemplate<ParamType.INTEGER>;
	/** @param a value from between 0 and 1 where 0 represents no time averaging with the last analysis frame */
	smoothing: ParamTemplate<ParamType.FLOAT>;
	/** @param normalizes the output between 0 and 1. The value will be in decibel otherwise. */
	normalRange: ParamTemplate<ParamType.BOOLEAN>;
	/** @param display range param */
	updateRangeParam: ParamTemplate<ParamType.BOOLEAN>;
	/** @param range value */
	range: ParamTemplate<ParamType.VECTOR2>;
	/** @param accumulated range */
	maxRange: ParamTemplate<ParamType.VECTOR2>;
	/** @param resetMaxRange */
	resetMaxRange: ParamTemplate<ParamType.BUTTON>;
}
declare class WaveformAudioNode extends BaseAnalyserAudioNode<WaveformAudioParamsConfig> {
	paramsConfig: WaveformAudioParamsConfig;
	static type(): AudioNodeAnalyserType;
	initializeNode(): void;
	cook(inputContents: AudioBuilder[]): void;
	private _previousValue;
	getAnalyserValue(): Float32Array | undefined;
	private _getWaveFormValue;
	private _blendValue;
	private __effect__;
	private _effect;
	private _createEffect;
	private _resetEffect;
	private _effectSize;
	static PARAM_CALLBACK_updateUpdateRangeParam(node: WaveformAudioNode): void;
	static PARAM_CALLBACK_resetMaxRange(node: WaveformAudioNode): void;
	private _updateRangeParam;
	private _updateOnTickHook;
	private _registerOnTickHook;
	private _unRegisterOnTickHook;
	private _tickCallbackName;
}
declare class ParamLessNetworkAudioParamsConfig extends NodeParamsConfig {}
declare class BaseNetworkAudioNode<K extends NodeParamsConfig> extends TypedNode<NodeContext.AUDIO, K> {
	static context(): NodeContext;
	cook(): void;
}
declare class ParamLessBaseNetworkAudioNode extends BaseNetworkAudioNode<ParamLessNetworkAudioParamsConfig> {}
declare class ActorsNetworkAudioNode extends ParamLessBaseNetworkAudioNode {
	static type(): NetworkNodeType;
	protected _childrenControllerContext: NodeContext;
	createNode<S extends keyof JsNodeChildrenMap>(node_class: S, options?: NodeCreateOptions): JsNodeChildrenMap[S];
	createNode<K extends valueof<JsNodeChildrenMap>>(node_class: Constructor<K>, options?: NodeCreateOptions): K;
	children(): BaseJsNodeType[];
	nodesByType<K extends keyof JsNodeChildrenMap>(type: K): JsNodeChildrenMap[K][];
	childrenAllowed(): boolean;
	sceneReadonly(): boolean;
	readonly persisted_config: ActorPersistedConfig;
	assemblerController(): JsAssemblerController<JsAssemblerActor> | undefined;
	usedAssembler(): Readonly<AssemblerName.JS_ACTOR>;
	protected _assemblerController: JsAssemblerController<JsAssemblerActor> | undefined;
	private _createAssemblerController;
	readonly compilationController: ActorCompilationController;
	compile(): void;
	cook(): void;
}
declare class AnimationsNetworkAudioNode extends ParamLessBaseNetworkAudioNode {
	static type(): NetworkNodeType;
	protected _childrenControllerContext: NodeContext;
	createNode<S extends keyof AnimNodeChildrenMap>(node_class: S, options?: NodeCreateOptions): AnimNodeChildrenMap[S];
	createNode<K extends valueof<AnimNodeChildrenMap>>(node_class: Constructor<K>, options?: NodeCreateOptions): K;
	children(): BaseAnimNodeType[];
	nodesByType<K extends keyof AnimNodeChildrenMap>(type: K): AnimNodeChildrenMap[K][];
}
declare class AudioNetworkAudioNode extends ParamLessBaseNetworkAudioNode {
	static type(): NetworkNodeType;
	protected _childrenControllerContext: NodeContext;
	createNode<S extends keyof AudioNodeChildrenMap>(
		node_class: S,
		options?: NodeCreateOptions
	): AudioNodeChildrenMap[S];
	createNode<K extends valueof<AudioNodeChildrenMap>>(node_class: Constructor<K>, options?: NodeCreateOptions): K;
	children(): BaseAudioNodeType[];
	nodesByType<K extends keyof AudioNodeChildrenMap>(type: K): AudioNodeChildrenMap[K][];
}
declare class CopNetworkAudioNode extends ParamLessBaseNetworkAudioNode {
	static type(): NetworkNodeType;
	protected _childrenControllerContext: NodeContext;
	createNode<S extends keyof AudioNodeChildrenMap>(
		node_class: S,
		options?: NodeCreateOptions
	): AudioNodeChildrenMap[S];
	createNode<K extends valueof<AudioNodeChildrenMap>>(node_class: Constructor<K>, options?: NodeCreateOptions): K;
	children(): BaseAudioNodeType[];
	nodesByType<K extends keyof AudioNodeChildrenMap>(type: K): AudioNodeChildrenMap[K][];
}
declare class EventsNetworkAudioNode extends ParamLessBaseNetworkAudioNode {
	static type(): NetworkNodeType;
	protected _childrenControllerContext: NodeContext;
	createNode<S extends keyof EventNodeChildrenMap>(
		node_class: S,
		options?: NodeCreateOptions
	): EventNodeChildrenMap[S];
	createNode<K extends valueof<EventNodeChildrenMap>>(node_class: Constructor<K>, options?: NodeCreateOptions): K;
	children(): BaseEventNodeType[];
	nodesByType<K extends keyof EventNodeChildrenMap>(type: K): EventNodeChildrenMap[K][];
}
export declare type MaterialTexturesRecord = Map<string, Texture | null>;
export declare type SetParamsTextureNodesRecord = Map<string, BaseCopNodeType>;
declare abstract class BaseController {
	protected node: BaseNodeType;
	constructor(node: BaseNodeType);
	initializeNode(): void;
	abstract updateMaterial(material: Material): void | Promise<void>;
	setParamsFromMaterial(material: Material, record: SetParamsTextureNodesRecord): void;
	getTextures(material: Material, record: MaterialTexturesRecord): void;
}
declare abstract class TypedMatNode<M extends Material, K extends NodeParamsConfig> extends TypedNode<
	NodeContext.MAT,
	K
> {
	static context(): NodeContext;
	initializeBaseNode(): void;
	protected _cookWhenDirtyBound: () => Promise<void>;
	protected _cookMainWithoutInputsWhenDirty(): Promise<void>;
	abstract material(): Promise<M | undefined>;
	setMaterial(material: M): void;
}
declare abstract class PrimitiveMatNode<M extends Material, K extends NodeParamsConfig> extends TypedMatNode<M, K> {
	protected _material: M | undefined;
	abstract createMaterial(): M;
	__materialSync__(): M;
	material(): Promise<M>;
	initializeBaseNode(): void;
	private set_material_name;
	setMaterial(material: M): void;
	getTextures(material: M, record: MaterialTexturesRecord): void;
	setParamsFromMaterial(material: M, record: SetParamsTextureNodesRecord): void;
	protected controllersList: Array<BaseController>;
	protected controllersPromises(material: M): Array<void | Promise<void>>;
	initializeNode(): void;
}
declare class UpdateMatNode<M extends Material, K extends NodeParamsConfig> extends TypedMatNode<M, K> {
	readonly flags: FlagsControllerB;
	protected _cookWhenDirtyBound: () => Promise<void>;
	protected _cookMainWithoutInputsWhenDirty(): Promise<void>;
	material(): Promise<M | undefined>;
	initializeBaseNode(): void;
}
export declare type BaseMatNodeType = TypedMatNode<Material, any>;
declare const AdvancedCommonParamsConfig_base: {
	new (...args: any[]): {
		/** @param defines if the material is double sided or not */
		doubleSided: ParamTemplate<ParamType.BOOLEAN>;
		/** @param if the material is not double sided, it can be front sided, or back sided */
		front: ParamTemplate<ParamType.BOOLEAN>;
		/** @param override the default shadowSide behavior */
		overrideShadowSide: ParamTemplate<ParamType.BOOLEAN>;
		/** @param defines which side(s) are used when rendering shadows */
		shadowDoubleSided: ParamTemplate<ParamType.BOOLEAN>;
		/** @param if the material is not double sided, it can be front sided, or back sided, when computing shadows */
		shadowFront: ParamTemplate<ParamType.BOOLEAN>;
		/** @param defines if the objects using this material will be rendered in the color buffer. Setting it to false can have those objects occlude the ones behind */
		colorWrite: ParamTemplate<ParamType.BOOLEAN>;
		/** @param defines if the objects using this material will be rendered in the depth buffer. This can often help transparent objects */
		depthWrite: ParamTemplate<ParamType.BOOLEAN>;
		/** @param toggle depth test */
		depthTest: ParamTemplate<ParamType.BOOLEAN>;
		/** @param premultipliedAlpha */
		premultipliedAlpha: ParamTemplate<ParamType.BOOLEAN>;
		/** @param blending */
		blending: ParamTemplate<ParamType.INTEGER>;
		/** @param dithering, which can be useful when using postprocessing and banding appears on some objects */
		dithering: ParamTemplate<ParamType.BOOLEAN>;
		/** @param activate polygon offset */
		polygonOffset: ParamTemplate<ParamType.BOOLEAN>;
		polygonOffsetFactor: ParamTemplate<ParamType.INTEGER>;
		polygonOffsetUnits: ParamTemplate<ParamType.INTEGER>;
	};
} & typeof NodeParamsConfig;
declare class AdvancedCommonParamsConfig extends AdvancedCommonParamsConfig_base {}
export interface AdvancedCommonControllers {
	advancedCommon: AdvancedCommonController;
}
declare abstract class AdvancedCommonMapMatNode extends TypedMatNode<Material, AdvancedCommonParamsConfig> {
	controllers: AdvancedCommonControllers;
	material(): Promise<Material | undefined>;
}
declare class AdvancedCommonController extends BaseController {
	protected node: AdvancedCommonMapMatNode;
	constructor(node: AdvancedCommonMapMatNode);
	static update(node: AdvancedCommonMapMatNode): Promise<void>;
	updateMaterial(material: Material): void;
	setParamsFromMaterial(material: Material, record: SetParamsTextureNodesRecord): void;
}
export interface UniformsTransparencyControllers {
	uniformTransparency: UniformsTransparencyController;
}
export declare type TransparencyMaterial = Material;
declare const TransparencyParamsConfig_base: {
	new (...args: any[]): {
		/** @param sets the material to transparent */
		transparent: ParamTemplate<ParamType.BOOLEAN>;
		/** @param sets the material opacity */
		opacity: ParamTemplate<ParamType.FLOAT>;
		/** @param sets the min alpha below which the material is invisible */
		alphaTest: ParamTemplate<ParamType.FLOAT>;
	};
} & typeof NodeParamsConfig;
declare class TransparencyParamsConfig extends TransparencyParamsConfig_base {}
declare class TransparencyMatNode extends TypedMatNode<TransparencyMaterial, TransparencyParamsConfig> {
	material(): Promise<Material | undefined>;
	controllers: UniformsTransparencyControllers;
}
declare class UniformsTransparencyController extends BaseController {
	protected node: TransparencyMatNode;
	constructor(node: TransparencyMatNode);
	static update(node: TransparencyMatNode): Promise<void>;
	updateMaterial(material: TransparencyMaterial): void;
	private _updateTransparency;
	private _updateCommon;
}
export interface WireframeShaderMaterialControllers {
	wireframeShader: WireframeShaderMaterialController;
}
declare const WireframeParamsConfig_base: {
	new (...args: any[]): {
		/** @param toggle on to set material to wireframe */
		wireframe: ParamTemplate<ParamType.BOOLEAN>;
		/** @param wireframe line width */
		wireframeLinewidth: ParamTemplate<ParamType.FLOAT>;
	};
} & typeof NodeParamsConfig;
declare class WireframeParamsConfig extends WireframeParamsConfig_base {}
declare class WireframedMatNode extends TypedMatNode<Material, WireframeParamsConfig> {
	material(): Promise<Material | undefined>;
	controllers: WireframeShaderMaterialControllers;
}
declare class WireframeShaderMaterialController extends BaseController {
	protected node: WireframedMatNode;
	constructor(node: WireframedMatNode);
	static update(node: WireframedMatNode): Promise<void>;
	updateMaterial(material: Material): void;
}
export interface FogControllers {
	fog: FogController;
}
export declare type FoggableMaterial =
	| ShaderMaterial
	| MeshToonMaterial
	| MeshStandardMaterial
	| MeshPhysicalMaterial
	| MeshPhongMaterial
	| MeshMatcapMaterial
	| MeshLambertMaterial
	| MeshBasicMaterial;
declare const FogParamsConfig_base: {
	new (...args: any[]): {
		/** @param toggle on if you have a fog in the scene and the material should be affected by it */
		useFog: ParamTemplate<ParamType.BOOLEAN>;
	};
} & typeof NodeParamsConfig;
declare class FogParamsConfig extends FogParamsConfig_base {}
declare abstract class FogMatNode extends TypedMatNode<FoggableMaterial, FogParamsConfig> {
	controllers: FogControllers;
	material(): Promise<FoggableMaterial | undefined>;
}
declare class FogController extends BaseController {
	protected node: FogMatNode;
	constructor(node: FogMatNode);
	static update(node: FogMatNode): Promise<void>;
	updateMaterial(material: FoggableMaterial): void;
}
export interface CodeControllers
	extends AdvancedCommonControllers,
		FogControllers,
		UniformsTransparencyControllers,
		WireframeShaderMaterialControllers {}
declare const CodeMatParamsConfig_base: {
	new (...args: any[]): {
		useFog: ParamTemplate<ParamType.BOOLEAN>;
	};
} & {
	new (...args: any[]): {
		wireframe: ParamTemplate<ParamType.BOOLEAN>;
		wireframeLinewidth: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		doubleSided: ParamTemplate<ParamType.BOOLEAN>;
		front: ParamTemplate<ParamType.BOOLEAN>;
		overrideShadowSide: ParamTemplate<ParamType.BOOLEAN>;
		shadowDoubleSided: ParamTemplate<ParamType.BOOLEAN>;
		shadowFront: ParamTemplate<ParamType.BOOLEAN>;
		colorWrite: ParamTemplate<ParamType.BOOLEAN>;
		depthWrite: ParamTemplate<ParamType.BOOLEAN>;
		depthTest: ParamTemplate<ParamType.BOOLEAN>;
		premultipliedAlpha: ParamTemplate<ParamType.BOOLEAN>;
		blending: ParamTemplate<ParamType.INTEGER>;
		dithering: ParamTemplate<ParamType.BOOLEAN>;
		polygonOffset: ParamTemplate<ParamType.BOOLEAN>;
		polygonOffsetFactor: ParamTemplate<ParamType.INTEGER>;
		polygonOffsetUnits: ParamTemplate<ParamType.INTEGER>;
	};
} & {
	new (...args: any[]): {
		transparent: ParamTemplate<ParamType.BOOLEAN>;
		opacity: ParamTemplate<ParamType.FLOAT>;
		alphaTest: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		advanced: ParamTemplate<ParamType.FOLDER>;
	};
} & {
	new (...args: any[]): {
		vertexShader: ParamTemplate<ParamType.FOLDER>;
		vertex: ParamTemplate<ParamType.STRING>;
		fragmentShader: ParamTemplate<ParamType.FOLDER>;
		fragment: ParamTemplate<ParamType.STRING>;
		extensions: ParamTemplate<ParamType.FOLDER>;
		derivatives: ParamTemplate<ParamType.BOOLEAN>;
	};
} & typeof NodeParamsConfig;
declare class CodeMatParamsConfig extends CodeMatParamsConfig_base {}
declare class CodeMatNode extends PrimitiveMatNode<ShaderMaterial, CodeMatParamsConfig> {
	paramsConfig: CodeMatParamsConfig;
	static type(): string;
	createMaterial(): ShaderMaterial;
	readonly controllers: CodeControllers;
	protected controllersList: any[];
	cook(): Promise<void>;
}
export declare type ColoredMaterial = MeshBasicMaterial | ShadowMaterial | MeshStandardMaterial;
declare const ColorParamsConfig_base: {
	new (...args: any[]): {
		/** @param material color */
		color: ParamTemplate<ParamType.COLOR>;
		/** @param defines if the color attribute on the geometry is used */
		useVertexColors: ParamTemplate<ParamType.BOOLEAN>;
		/** @param sets the material to transparent */
		transparent: ParamTemplate<ParamType.BOOLEAN>;
		/** @param sets the material opacity */
		opacity: ParamTemplate<ParamType.FLOAT>;
		/** @param sets the min alpha below which the material is invisible */
		alphaTest: ParamTemplate<ParamType.FLOAT>;
	};
} & typeof NodeParamsConfig;
declare class ColorParamsConfig extends ColorParamsConfig_base {}
export interface ColorsControllers {
	colors: ColorsController;
}
declare class ColoredMatNode extends TypedMatNode<ColoredMaterial, ColorParamsConfig> {
	controllers: ColorsControllers;
	material(): Promise<ColoredMaterial | undefined>;
}
declare class ColorsController extends BaseController {
	protected node: ColoredMatNode;
	constructor(node: ColoredMatNode);
	static update(node: ColoredMatNode): Promise<void>;
	updateMaterial(material: ColoredMaterial): void;
	setParamsFromMaterial(material: ColoredMaterial, record: SetParamsTextureNodesRecord): void;
}
export interface ColorControllers {
	colors: ColorsController;
}
declare const ColorMatParamsConfig_base: {
	new (...args: any[]): {
		color: ParamTemplate<ParamType.COLOR>;
		useVertexColors: ParamTemplate<ParamType.BOOLEAN>;
		transparent: ParamTemplate<ParamType.BOOLEAN>;
		opacity: ParamTemplate<ParamType.FLOAT>;
		alphaTest: ParamTemplate<ParamType.FLOAT>;
	};
} & typeof NodeParamsConfig;
declare class ColorMatParamsConfig extends ColorMatParamsConfig_base {}
declare class ColorMatNode extends UpdateMatNode<ColoredMaterial, ColorMatParamsConfig> {
	paramsConfig: ColorMatParamsConfig;
	static type(): string;
	readonly controllers: ColorControllers;
	cook(inputMaterials: Material[]): Promise<void>;
}
export declare type FilterFlags<Base, Condition> = {
	[Key in keyof Base]: Base[Key] extends Condition ? Key : never;
};
export declare type AllowedNames<Base, Condition> = FilterFlags<Base, Condition>[keyof Base];
export declare type SubType<Base, Condition> = Pick<Base, AllowedNames<Base, Condition>>;
export declare type BaseTextureControllerCurrentMaterial = Material;
declare abstract class BaseTextureMapController extends BaseController {
	protected node: BaseMatNodeType;
	constructor(node: BaseMatNodeType);
	protected add_hooks(use_map_param: BooleanParam, path_param: NodePathParam): void;
	static update(node: BaseNodeType): Promise<void>;
	private updateBound;
	update(): Promise<void>;
	_update<M extends BaseTextureControllerCurrentMaterial>(
		material: M,
		mat_attrib_name: string,
		use_map_param: BooleanParam,
		path_param: NodePathParam
	): Promise<void>;
	_update_texture_on_material<M extends Material>(
		material: M,
		mat_attrib_name: keyof SubType<M, Texture | null>,
		use_map_param: BooleanParam,
		path_param: NodePathParam
	): Promise<void>;
	private _apply_texture_on_material;
	private _remove_texture_from_material;
	private _update_required_attribute;
}
export declare type TextureEnvMapControllerCurrentMaterial = MeshStandardMaterial | MeshPhysicalMaterial;
declare const TextureEnvMapParamsConfig_base: {
	new (...args: any[]): {
		/** @param toggle if you want to use an environment map */
		useEnvMap: ParamTemplate<ParamType.BOOLEAN>;
		/** @param specify the environment map COP node */
		envMap: ParamTemplate<ParamType.NODE_PATH>;
		/** @param environment intensity */
		envMapIntensity: ParamTemplate<ParamType.FLOAT>;
	};
} & typeof NodeParamsConfig;
declare class TextureEnvMapParamsConfig extends TextureEnvMapParamsConfig_base {}
export interface TextureEnvMapControllers {
	envMap: TextureEnvMapController;
}
declare abstract class TextureEnvMapMatNode extends TypedMatNode<
	TextureEnvMapControllerCurrentMaterial,
	TextureEnvMapParamsConfig
> {
	controllers: TextureEnvMapControllers;
	material(): Promise<TextureEnvMapControllerCurrentMaterial | undefined>;
}
declare class TextureEnvMapController extends BaseTextureMapController {
	protected node: TextureEnvMapMatNode;
	constructor(node: TextureEnvMapMatNode);
	initializeNode(): void;
	static update(node: TextureEnvMapMatNode): Promise<void>;
	update(): Promise<void>;
	updateMaterial(material: TextureEnvMapControllerCurrentMaterial): Promise<void>;
	getTextures(material: TextureEnvMapControllerCurrentMaterial, record: MaterialTexturesRecord): void;
	setParamsFromMaterial(material: TextureEnvMapControllerCurrentMaterial, record: SetParamsTextureNodesRecord): void;
}
export interface EnvMapControllers {
	envMap: TextureEnvMapController;
}
declare const EnvMapMatParamsConfig_base: {
	new (...args: any[]): {
		useEnvMap: ParamTemplate<ParamType.BOOLEAN>;
		envMap: ParamTemplate<ParamType.NODE_PATH>;
		envMapIntensity: ParamTemplate<ParamType.FLOAT>;
	};
} & typeof NodeParamsConfig;
declare class EnvMapMatParamsConfig extends EnvMapMatParamsConfig_base {}
declare class EnvMapMatNode extends UpdateMatNode<MeshStandardMaterial, EnvMapMatParamsConfig> {
	paramsConfig: EnvMapMatParamsConfig;
	static type(): string;
	readonly controllers: EnvMapControllers;
	cook(inputMaterials: Material[]): Promise<void>;
}
declare enum MatType {
	LINE_BASIC = 'lineBasic',
	LINE_BASIC_BUILDER = 'lineBasicBuilder',
	MESH_BASIC = 'meshBasic',
	MESH_BASIC_BUILDER = 'meshBasicBuilder',
	MESH_LAMBERT = 'meshLambert',
	MESH_LAMBERT_BUILDER = 'meshLambertBuilder',
	MESH_MATCAP = 'meshMatcap',
	MESH_NORMAL = 'meshNormal',
	MESH_PHONG = 'meshPhong',
	MESH_PHONG_BUILDER = 'meshPhongBuilder',
	MESH_PHYSICAL = 'meshPhysical',
	MESH_PHYSICAL_BUILDER = 'meshPhysicalBuilder',
	MESH_STANDARD = 'meshStandard',
	MESH_STANDARD_BUILDER = 'meshStandardBuilder',
	MESH_TOON = 'meshToon',
	POINTS = 'points',
	POINTS_BUILDER = 'pointsBuilder',
	RAY_MARCHING_BUILDER = 'rayMarchingBuilder',
	SHADOW = 'shadow',
	SKY = 'sky',
	VOLUME = 'volume',
	VOLUME_BUILDER = 'volumeBuilder',
}
export interface LineBasicBuilderControllers extends AdvancedCommonControllers {}
declare const LineBasicMatParamsConfig_base: {
	new (...args: any[]): {
		doubleSided: ParamTemplate<ParamType.BOOLEAN>;
		front: ParamTemplate<ParamType.BOOLEAN>;
		overrideShadowSide: ParamTemplate<ParamType.BOOLEAN>;
		shadowDoubleSided: ParamTemplate<ParamType.BOOLEAN>;
		shadowFront: ParamTemplate<ParamType.BOOLEAN>;
		colorWrite: ParamTemplate<ParamType.BOOLEAN>;
		depthWrite: ParamTemplate<ParamType.BOOLEAN>;
		depthTest: ParamTemplate<ParamType.BOOLEAN>;
		premultipliedAlpha: ParamTemplate<ParamType.BOOLEAN>;
		blending: ParamTemplate<ParamType.INTEGER>;
		dithering: ParamTemplate<ParamType.BOOLEAN>;
		polygonOffset: ParamTemplate<ParamType.BOOLEAN>;
		polygonOffsetFactor: ParamTemplate<ParamType.INTEGER>;
		polygonOffsetUnits: ParamTemplate<ParamType.INTEGER>;
	};
} & typeof NodeParamsConfig;
declare class LineBasicMatParamsConfig extends LineBasicMatParamsConfig_base {
	/** @param line color */
	color: ParamTemplate<ParamType.COLOR>;
	/** @param line width */
	lineWidth: ParamTemplate<ParamType.FLOAT>;
}
declare class LineBasicMatNode extends PrimitiveMatNode<LineBasicMaterial, LineBasicMatParamsConfig> {
	paramsConfig: LineBasicMatParamsConfig;
	static type(): MatType.LINE_BASIC;
	createMaterial(): LineBasicMaterial;
	readonly controllers: LineBasicBuilderControllers;
	protected controllersList: any[];
	cook(): Promise<void>;
}
declare class ShaderAssemblerLine extends ShaderAssemblerMaterial {
	templateShader(): {
		vertexShader: string;
		fragmentShader: string;
		uniforms: {
			[uniform: string]: IUniform<any>;
		};
	};
	createMaterial(): LineBasicMaterial;
	customAssemblerClassByCustomName(): CustomAssemblerMap;
	create_shader_configs(): ShaderConfig[];
	static output_input_connection_points(): (
		| GlConnectionPoint<GlConnectionPointType.VEC3>
		| GlConnectionPoint<GlConnectionPointType.VEC2>
		| GlConnectionPoint<GlConnectionPointType.FLOAT>
	)[];
	add_output_inputs(output_child: OutputGlNode): void;
	static create_globals_node_output_connections(): (
		| GlConnectionPoint<GlConnectionPointType.VEC3>
		| GlConnectionPoint<GlConnectionPointType.VEC2>
		| GlConnectionPoint<GlConnectionPointType.VEC4>
		| GlConnectionPoint<GlConnectionPointType.FLOAT>
	)[];
	create_globals_node_output_connections(): (
		| GlConnectionPoint<GlConnectionPointType.VEC3>
		| GlConnectionPoint<GlConnectionPointType.VEC2>
		| GlConnectionPoint<GlConnectionPointType.VEC4>
		| GlConnectionPoint<GlConnectionPointType.FLOAT>
	)[];
	create_variable_configs(): VariableConfig[];
	protected linesToRemove(shader_name: ShaderName): string[] | undefined;
}
export declare type RemoveShaders<Type> = {
	[Property in keyof Type as Exclude<Property, 'fragmentShader' | 'vertexShader'>]: Type[Property];
};
export interface OnBeforeCompileDataJSONWithoutShaders extends RemoveShaders<OnBeforeCompileDataJSON> {}
export interface PersistedConfigBaseMaterialData {
	material: object;
	onBeforeCompileDataJSONWithoutShaders: OnBeforeCompileDataJSONWithoutShaders;
	customMaterials?: PolyDictionary<PersistedConfigBaseMaterialData>;
}
export interface PersistedConfigBaseMaterialDataWithShaders
	extends PersistedConfigBaseMaterialData,
		PersistedConfigWithShaders {}
declare class MaterialPersistedConfig extends BasePersistedConfig {
	protected node: BaseBuilderMatNodeType;
	private _material;
	constructor(node: BaseBuilderMatNodeType);
	toData(): Promise<PersistedConfigBaseMaterialDataWithShaders | undefined>;
	load(data: PersistedConfigBaseMaterialDataWithShaders): void;
	material(): MaterialWithCustomMaterials | undefined;
}
declare class FloatToIntGlParamsConfig extends NodeParamsConfig {
	float: ParamTemplate<ParamType.FLOAT>;
}
declare class FloatToIntGlNode extends TypedGlNode<FloatToIntGlParamsConfig> {
	paramsConfig: FloatToIntGlParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(shaders_collection_controller: ShadersCollectionController): void;
}
declare class IntToFloatGlParamsConfig extends NodeParamsConfig {
	int: ParamTemplate<ParamType.INTEGER>;
}
declare class IntToFloatGlNode extends TypedGlNode<IntToFloatGlParamsConfig> {
	paramsConfig: IntToFloatGlParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(shaders_collection_controller: ShadersCollectionController): void;
}
declare class IntToBoolGlParamsConfig extends NodeParamsConfig {
	int: ParamTemplate<ParamType.INTEGER>;
}
declare class IntToBoolGlNode extends TypedGlNode<IntToBoolGlParamsConfig> {
	paramsConfig: IntToBoolGlParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(shaders_collection_controller: ShadersCollectionController): void;
}
declare class BoolToIntGlParamsConfig extends NodeParamsConfig {
	bool: ParamTemplate<ParamType.BOOLEAN>;
}
declare class BoolToIntGlNode extends TypedGlNode<BoolToIntGlParamsConfig> {
	paramsConfig: BoolToIntGlParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(shaders_collection_controller: ShadersCollectionController): void;
}
declare class FloatToVec2GlParamsConfig extends NodeParamsConfig {
	x: ParamTemplate<ParamType.FLOAT>;
	y: ParamTemplate<ParamType.FLOAT>;
}
declare class FloatToVec2GlNode extends TypedGlNode<FloatToVec2GlParamsConfig> {
	paramsConfig: FloatToVec2GlParamsConfig;
	static type(): string;
	static readonly OUTPUT_NAME = 'vec2';
	initializeNode(): void;
	setLines(shaders_collection_controller: ShadersCollectionController): void;
}
declare class FloatToVec3GlParamsConfig extends NodeParamsConfig {
	x: ParamTemplate<ParamType.FLOAT>;
	y: ParamTemplate<ParamType.FLOAT>;
	z: ParamTemplate<ParamType.FLOAT>;
}
declare class FloatToVec3GlNode extends TypedGlNode<FloatToVec3GlParamsConfig> {
	paramsConfig: FloatToVec3GlParamsConfig;
	static type(): string;
	static readonly OUTPUT_NAME = 'vec3';
	initializeNode(): void;
	setLines(shaders_collection_controller: ShadersCollectionController): void;
}
declare class FloatToVec4GlParamsConfig extends NodeParamsConfig {
	x: ParamTemplate<ParamType.FLOAT>;
	y: ParamTemplate<ParamType.FLOAT>;
	z: ParamTemplate<ParamType.FLOAT>;
	w: ParamTemplate<ParamType.FLOAT>;
}
declare class FloatToVec4GlNode extends TypedGlNode<FloatToVec4GlParamsConfig> {
	paramsConfig: FloatToVec4GlParamsConfig;
	static type(): string;
	static readonly OUTPUT_NAME = 'vec4';
	initializeNode(): void;
	setLines(shaders_collection_controller: ShadersCollectionController): void;
}
declare class VecToParamsGlConfig extends NodeParamsConfig {}
declare class BaseVecToGlNode extends TypedGlNode<VecToParamsGlConfig> {
	paramsConfig: VecToParamsGlConfig;
}
declare const Vec2ToFloatGlNode_base: typeof BaseVecToGlNode;
declare class Vec2ToFloatGlNode extends Vec2ToFloatGlNode_base {}
declare const Vec3ToFloatGlNode_base: typeof BaseVecToGlNode;
declare class Vec3ToFloatGlNode extends Vec3ToFloatGlNode_base {}
declare const Vec4ToFloatGlNode_base: typeof BaseVecToGlNode;
declare class Vec4ToFloatGlNode extends Vec4ToFloatGlNode_base {}
declare class Vec4ToVec3GlNode extends BaseVecToGlNode {
	static type(): string;
	static readonly INPUT_NAME_VEC4 = 'vec4';
	static readonly OUTPUT_NAME_VEC3 = 'vec3';
	static readonly OUTPUT_NAME_W = 'w';
	initializeNode(): void;
	createParams(): void;
	setLines(shaders_collection_controller: ShadersCollectionController): void;
}
declare class Vec3ToVec2GlNode extends BaseVecToGlNode {
	static type(): string;
	static readonly INPUT_NAME_VEC3 = 'vec3';
	static readonly OUTPUT_NAME_VEC2 = 'vec2';
	static readonly OUTPUT_NAME_Z = 'z';
	initializeNode(): void;
	createParams(): void;
	setLines(shaders_collection_controller: ShadersCollectionController): void;
}
declare class Vec2ToVec3GlNode extends BaseVecToGlNode {
	static type(): string;
	static readonly INPUT_NAME_VEC2 = 'vec2';
	static readonly INPUT_NAME_Z = 'z';
	static readonly OUTPUT_NAME_VEC3 = 'vec3';
	initializeNode(): void;
	createParams(): void;
	setLines(shaders_collection_controller: ShadersCollectionController): void;
}
declare class Vec3ToVec4GlNode extends BaseVecToGlNode {
	static type(): string;
	static readonly INPUT_NAME_VEC3 = 'vec3';
	static readonly INPUT_NAME_W = 'w';
	static readonly OUTPUT_NAME_VEC4 = 'vec4';
	initializeNode(): void;
	createParams(): void;
	setLines(shaders_collection_controller: ShadersCollectionController): void;
}
declare class BaseGlMathFunctionParamsConfig extends NodeParamsConfig {}
declare abstract class BaseGlMathFunctionGlNode extends TypedGlNode<BaseGlMathFunctionParamsConfig> {
	paramsConfig: BaseGlMathFunctionParamsConfig;
	protected gl_method_name(): string;
	protected gl_function_definitions(): TypedGLDefinition<GLDefinitionType>[];
	initializeNode(): void;
	protected _expected_input_types(): GlConnectionPointType[];
	protected _expected_output_types(): GlConnectionPointType[];
	protected _gl_input_name(index: number): string;
	setLines(shaders_collection_controller: ShadersCollectionController): void;
}
declare abstract class BaseNodeGlMathFunctionArg1GlNode extends BaseGlMathFunctionGlNode {
	protected _gl_input_name(index: number): string;
	protected _expected_input_types(): GlConnectionPointType[];
}
declare abstract class BaseNodeGlMathFunctionArg2GlNode extends BaseGlMathFunctionGlNode {
	protected _expected_input_types(): GlConnectionPointType[];
}
declare abstract class BaseNodeGlMathFunctionArg3GlNode extends BaseGlMathFunctionGlNode {
	protected _expected_input_types(): GlConnectionPointType[];
}
declare abstract class BaseNodeGlMathFunctionArg4GlNode extends BaseGlMathFunctionGlNode {
	protected _expected_input_types(): GlConnectionPointType[];
}
declare abstract class BaseNodeGlMathFunctionArg5GlNode extends BaseGlMathFunctionGlNode {
	protected _expected_input_types(): GlConnectionPointType[];
}
declare const AbsGlNode_base: typeof BaseNodeGlMathFunctionArg1GlNode;
declare class AbsGlNode extends AbsGlNode_base {}
declare const AcosGlNode_base: typeof BaseNodeGlMathFunctionArg1GlNode;
declare class AcosGlNode extends AcosGlNode_base {}
declare const AsinGlNode_base: typeof BaseNodeGlMathFunctionArg1GlNode;
declare class AsinGlNode extends AsinGlNode_base {}
declare const AtanGlNode_base: typeof BaseNodeGlMathFunctionArg1GlNode;
declare class AtanGlNode extends AtanGlNode_base {}
declare const CeilGlNode_base: typeof BaseNodeGlMathFunctionArg1GlNode;
declare class CeilGlNode extends CeilGlNode_base {}
declare const CosGlNode_base: typeof BaseNodeGlMathFunctionArg1GlNode;
declare class CosGlNode extends CosGlNode_base {}
declare const DegreesGlNode_base: typeof BaseNodeGlMathFunctionArg1GlNode;
declare class DegreesGlNode extends DegreesGlNode_base {}
declare const ExpGlNode_base: typeof BaseNodeGlMathFunctionArg1GlNode;
declare class ExpGlNode extends ExpGlNode_base {}
declare const Exp2GlNode_base: typeof BaseNodeGlMathFunctionArg1GlNode;
declare class Exp2GlNode extends Exp2GlNode_base {}
declare const FloorGlNode_base: typeof BaseNodeGlMathFunctionArg1GlNode;
declare class FloorGlNode extends FloorGlNode_base {}
declare const FractGlNode_base: typeof BaseNodeGlMathFunctionArg1GlNode;
declare class FractGlNode extends FractGlNode_base {}
declare const InverseSqrtGlNode_base: typeof BaseNodeGlMathFunctionArg1GlNode;
declare class InverseSqrtGlNode extends InverseSqrtGlNode_base {}
declare const LogGlNode_base: typeof BaseNodeGlMathFunctionArg1GlNode;
declare class LogGlNode extends LogGlNode_base {}
declare const Log2GlNode_base: typeof BaseNodeGlMathFunctionArg1GlNode;
declare class Log2GlNode extends Log2GlNode_base {}
declare const NormalizeGlNode_base: typeof BaseNodeGlMathFunctionArg1GlNode;
declare class NormalizeGlNode extends NormalizeGlNode_base {}
declare const RadiansGlNode_base: typeof BaseNodeGlMathFunctionArg1GlNode;
declare class RadiansGlNode extends RadiansGlNode_base {}
declare const SignGlNode_base: typeof BaseNodeGlMathFunctionArg1GlNode;
declare class SignGlNode extends SignGlNode_base {}
declare const SinGlNode_base: typeof BaseNodeGlMathFunctionArg1GlNode;
declare class SinGlNode extends SinGlNode_base {}
declare const SqrtGlNode_base: typeof BaseNodeGlMathFunctionArg1GlNode;
declare class SqrtGlNode extends SqrtGlNode_base {}
declare const TanGlNode_base: typeof BaseNodeGlMathFunctionArg1GlNode;
declare class TanGlNode extends TanGlNode_base {}
declare const DistanceGlNode_base: typeof BaseNodeGlMathFunctionArg2GlNode;
declare class DistanceGlNode extends DistanceGlNode_base {}
declare const DotGlNode_base: typeof BaseNodeGlMathFunctionArg2GlNode;
declare class DotGlNode extends DotGlNode_base {}
declare const MaxGlNode_base: typeof BaseNodeGlMathFunctionArg2GlNode;
declare class MaxGlNode extends MaxGlNode_base {}
declare const MinGlNode_base: typeof BaseNodeGlMathFunctionArg2GlNode;
declare class MinGlNode extends MinGlNode_base {}
declare const ModGlNode_base: typeof BaseNodeGlMathFunctionArg2GlNode;
declare class ModGlNode extends ModGlNode_base {
	paramDefaultValue(name: string): number;
	_expected_input_types(): GlConnectionPointType[];
}
declare const PowGlNode_base: typeof BaseNodeGlMathFunctionArg2GlNode;
declare class PowGlNode extends PowGlNode_base {}
declare const ReflectGlNode_base: typeof BaseNodeGlMathFunctionArg2GlNode;
declare class ReflectGlNode extends ReflectGlNode_base {}
declare const StepGlNode_base: typeof BaseNodeGlMathFunctionArg2GlNode;
declare class StepGlNode extends StepGlNode_base {}
declare const ClampGlNode_base: typeof BaseNodeGlMathFunctionArg3GlNode;
declare class ClampGlNode extends ClampGlNode_base {
	protected _expected_output_types(): GlConnectionPointType[];
}
declare const FaceforwardGlNode_base: typeof BaseNodeGlMathFunctionArg3GlNode;
declare class FaceforwardGlNode extends FaceforwardGlNode_base {}
declare const SmoothstepGlNode_base: typeof BaseNodeGlMathFunctionArg3GlNode;
declare class SmoothstepGlNode extends SmoothstepGlNode_base {
	protected _expected_output_types(): GlConnectionPointType[];
}
declare const AddGlNode_base: typeof BaseNodeGlMathFunctionArg2GlNode;
declare class AddGlNode extends AddGlNode_base {}
declare const DivideGlNode_base: typeof BaseNodeGlMathFunctionArg2GlNode;
declare class DivideGlNode extends DivideGlNode_base {
	paramDefaultValue(name: string): number;
}
declare const SubtractGlNode_base: typeof BaseNodeGlMathFunctionArg2GlNode;
declare class SubtractGlNode extends SubtractGlNode_base {}
declare const MultGlNode_base: typeof BaseNodeGlMathFunctionArg2GlNode;
declare class MultGlNode extends MultGlNode_base {
	static type(): string;
	paramDefaultValue(name: string): number;
	initializeNode(): void;
	protected _expected_output_type(): GlConnectionPointType[];
	protected _expected_input_types(): GlConnectionPointType[];
}
declare abstract class BaseNodeGlMathFunctionArgBoolean2GlNode extends BaseNodeGlMathFunctionArg2GlNode {
	initializeNode(): void;
	protected _expected_input_types(): GlConnectionPointType[];
	protected _expected_output_types(): GlConnectionPointType[];
	boolean_operation(): string;
	setLines(shaders_collection_controller: ShadersCollectionController): void;
}
declare const AndGlNode_base: typeof BaseNodeGlMathFunctionArgBoolean2GlNode;
declare class AndGlNode extends AndGlNode_base {}
declare const OrGlNode_base: typeof BaseNodeGlMathFunctionArgBoolean2GlNode;
declare class OrGlNode extends OrGlNode_base {}
declare enum AccelerationGlInput {
	POSITION = 'position',
	VELOCITY = 'velocity',
	MASS = 'mass',
	FORCE = 'force',
}
declare enum AccelerationGlOutput {
	POSITION = 'position',
	VELOCITY = 'velocity',
}
declare class AccelerationGlParamsConfig extends NodeParamsConfig {}
declare class AccelerationGlNode extends TypedGlNode<AccelerationGlParamsConfig> {
	paramsConfig: AccelerationGlParamsConfig;
	static type(): string;
	initializeNode(): void;
	protected _expected_input_types(): GlConnectionPointType[];
	private _expected_output_types;
	protected _gl_input_name(index: number): AccelerationGlInput;
	protected _gl_output_name(index: number): AccelerationGlOutput;
	paramDefaultValue(name: string): number | Number3;
	setLines(shaders_collection_controller: ShadersCollectionController): void;
}
declare class AlignGlNode extends BaseNodeGlMathFunctionArg2GlNode {
	static type(): string;
	initializeNode(): void;
	paramDefaultValue(name: string): Number3;
	gl_method_name(): string;
	gl_function_definitions(): FunctionGLDefinition[];
}
declare class CartesianToPolarGlParamsConfig extends NodeParamsConfig {
	xyz: ParamTemplate<ParamType.VECTOR3>;
}
declare class CartesianToPolarGlNode extends TypedGlNode<CartesianToPolarGlParamsConfig> {
	paramsConfig: CartesianToPolarGlParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class CheckersGlParamsConfig extends NodeParamsConfig {
	uv: ParamTemplate<ParamType.VECTOR2>;
	freq: ParamTemplate<ParamType.VECTOR2>;
	freqMult: ParamTemplate<ParamType.FLOAT>;
	filtered: ParamTemplate<ParamType.BOOLEAN>;
}
declare class CheckersGlNode extends TypedGlNode<CheckersGlParamsConfig> {
	paramsConfig: CheckersGlParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(shadersCollectionController: ShadersCollectionController): void;
}
declare enum ColorCorrectType {
	LINEAR = 'Linear',
	SRGB = 'sRGB',
}
declare class ColorCorrectParamsConfig extends NodeParamsConfig {
	color: ParamTemplate<ParamType.VECTOR4>;
	from: ParamTemplate<ParamType.INTEGER>;
	to: ParamTemplate<ParamType.INTEGER>;
}
declare class ColorCorrectGlNode extends TypedGlNode<ColorCorrectParamsConfig> {
	paramsConfig: ColorCorrectParamsConfig;
	static type(): string;
	static INPUT_NAME: string;
	static OUTPUT_NAME: string;
	initializeNode(): void;
	colorSpaces(): {
		from: ColorCorrectType;
		to: ColorCorrectType;
	};
	setLines(shaders_collection_controller: ShadersCollectionController): void;
}
declare enum GlCompareTestName {
	EQUAL = 'Equal',
	LESS_THAN = 'Less Than',
	GREATER_THAN = 'Greater Than',
	LESS_THAN_OR_EQUAL = 'Less Than Or Equal',
	GREATER_THAN_OR_EQUAL = 'Greater Than Or Equal',
	NOT_EQUAL = 'Not Equal',
}
declare enum GlCompareTestOperation {
	EQUAL = '==',
	LESS_THAN = '<',
	GREATER_THAN = '>',
	LESS_THAN_OR_EQUAL = '<=',
	GREATER_THAN_OR_EQUAL = '>=',
	NOT_EQUAL = '!=',
}
declare class CompareGlParamsConfig extends NodeParamsConfig {
	test: ParamTemplate<ParamType.INTEGER>;
}
declare class CompareGlNode extends TypedGlNode<CompareGlParamsConfig> {
	paramsConfig: CompareGlParamsConfig;
	static type(): string;
	initializeNode(): void;
	setTestName(test: GlCompareTestName): void;
	testName(): GlCompareTestName;
	operator(): GlCompareTestOperation;
	protected _gl_input_name(index: number): string;
	protected _expected_input_type(): GlConnectionPointType[];
	setLines(shaders_collection_controller: ShadersCollectionController): void;
}
declare class ComplementGlNode extends BaseNodeGlMathFunctionArg1GlNode {
	static type(): string;
	gl_method_name(): string;
	gl_function_definitions(): FunctionGLDefinition[];
}
declare class ConstantGlParamsConfig extends NodeParamsConfig {
	type: ParamTemplate<ParamType.INTEGER>;
	bool: ParamTemplate<ParamType.BOOLEAN>;
	int: ParamTemplate<ParamType.INTEGER>;
	float: ParamTemplate<ParamType.FLOAT>;
	vec2: ParamTemplate<ParamType.VECTOR2>;
	vec3: ParamTemplate<ParamType.VECTOR3>;
	color: ParamTemplate<ParamType.COLOR>;
	vec4: ParamTemplate<ParamType.VECTOR4>;
	/** @param when using vec3, use toggle on it should be a color */
	asColor: ParamTemplate<ParamType.BOOLEAN>;
}
declare class ConstantGlNode extends TypedGlNode<ConstantGlParamsConfig> {
	paramsConfig: ConstantGlParamsConfig;
	static type(): string;
	static readonly OUTPUT_NAME = 'val';
	initializeNode(): void;
	setLines(shaders_collection_controller: ShadersCollectionController): void;
	private _currentConnectionType;
	currentParam(): BaseParamType;
	private _currentVarName;
	currentValue(): string | undefined;
	setGlType(type: GlConnectionPointType): void;
}
declare class CrossGlParamsConfig extends NodeParamsConfig {
	x: ParamTemplate<ParamType.VECTOR3>;
	y: ParamTemplate<ParamType.VECTOR3>;
}
declare class CrossGlNode extends TypedGlNode<CrossGlParamsConfig> {
	paramsConfig: CrossGlParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(shaders_collection_controller: ShadersCollectionController): void;
}
declare const CycleGlNode_base: typeof BaseNodeGlMathFunctionArg3GlNode;
declare class CycleGlNode extends CycleGlNode_base {}
declare class DiskGlParamsConfig extends NodeParamsConfig {
	position: ParamTemplate<ParamType.VECTOR2>;
	center: ParamTemplate<ParamType.VECTOR2>;
	radius: ParamTemplate<ParamType.FLOAT>;
	feather: ParamTemplate<ParamType.FLOAT>;
}
declare class DiskGlNode extends TypedGlNode<DiskGlParamsConfig> {
	paramsConfig: DiskGlParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(shaders_collection_controller: ShadersCollectionController): void;
}
declare class DitherGlParamsConfig extends NodeParamsConfig {
	alpha: ParamTemplate<ParamType.FLOAT>;
	alphaTest: ParamTemplate<ParamType.FLOAT>;
}
declare class DitherGlNode extends TypedGlNode<DitherGlParamsConfig> {
	paramsConfig: DitherGlParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class EasingGlParamsConfig extends NodeParamsConfig {
	type: ParamTemplate<ParamType.INTEGER>;
}
declare class EasingGlNode extends TypedGlNode<EasingGlParamsConfig> {
	paramsConfig: EasingGlParamsConfig;
	static type(): string;
	initializeNode(): void;
	private _expected_input_types;
	private _expected_output_types;
	_gl_input_name(index: number): string;
	_gl_output_name(index: number): string;
	setLines(shaders_collection_controller: ShadersCollectionController): void;
	private _buildBodyLines;
}
declare class FitGlNode extends BaseNodeGlMathFunctionArg5GlNode {
	static type(): string;
	protected _gl_input_name(index: number): string;
	paramDefaultValue(name: string): number;
	protected gl_method_name(): string;
	gl_function_definitions(): FunctionGLDefinition[];
}
declare class FitTo01GlNode extends BaseNodeGlMathFunctionArg3GlNode {
	static type(): string;
	_gl_input_name(index: number): string;
	paramDefaultValue(name: string): number;
	gl_method_name(): string;
	gl_function_definitions(): FunctionGLDefinition[];
}
declare class FitFrom01GlNode extends BaseNodeGlMathFunctionArg3GlNode {
	static type(): string;
	_gl_input_name(index: number): string;
	paramDefaultValue(name: string): number;
	gl_method_name(): string;
	gl_function_definitions(): FunctionGLDefinition[];
}
declare class FitFrom01ToVarianceGlNode extends BaseNodeGlMathFunctionArg3GlNode {
	static type(): string;
	_gl_input_name(index: number): string;
	paramDefaultValue(name: string): number;
	gl_method_name(): string;
	gl_function_definitions(): FunctionGLDefinition[];
}
declare class FogGlParamsConfig extends NodeParamsConfig {
	mvPosition: ParamTemplate<ParamType.VECTOR4>;
	baseColor: ParamTemplate<ParamType.COLOR>;
	fogColor: ParamTemplate<ParamType.COLOR>;
	near: ParamTemplate<ParamType.FLOAT>;
	far: ParamTemplate<ParamType.FLOAT>;
}
declare class FogGlNode extends TypedGlNode<FogGlParamsConfig> {
	paramsConfig: FogGlParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(shaders_collection_controller: ShadersCollectionController): void;
}
declare class SubnetOutputGlParamsConfig extends NodeParamsConfig {}
declare class SubnetOutputGlNode extends TypedGlNode<SubnetOutputGlParamsConfig> {
	paramsConfig: SubnetOutputGlParamsConfig;
	static type(): Readonly<NetworkChildNodeType.OUTPUT>;
	initializeNode(): void;
	parent(): SubnetGlNode | null;
	protected _expected_input_name(index: number): string;
	protected _expected_input_types(): GlConnectionPointType[];
	setLines(shadersCollectionController: ShadersCollectionController): never[];
}
declare class SubnetInputGlParamsConfig extends NodeParamsConfig {}
declare class SubnetInputGlNode extends TypedGlNode<SubnetInputGlParamsConfig> {
	paramsConfig: SubnetInputGlParamsConfig;
	static type(): NetworkChildNodeType;
	initializeNode(): void;
	parent(): SubnetGlNode | null;
	private _expected_output_names;
	protected _expected_output_types(): GlConnectionPointType[];
	setLines(shaders_collection_controller: ShadersCollectionController): void;
}
declare const TypedSubnetGlParamsConfig_base: {
	new (...args: any[]): {
		inputs: ParamTemplate<ParamType.FOLDER>;
		inputsCount: ParamTemplate<ParamType.INTEGER>;
		inputType0: ParamTemplate<ParamType.INTEGER>;
		inputName0: ParamTemplate<ParamType.STRING>;
		inputType1: ParamTemplate<ParamType.INTEGER>;
		inputName1: ParamTemplate<ParamType.STRING>;
		inputType2: ParamTemplate<ParamType.INTEGER>;
		inputName2: ParamTemplate<ParamType.STRING>;
		inputType3: ParamTemplate<ParamType.INTEGER>;
		inputName3: ParamTemplate<ParamType.STRING>;
		inputType4: ParamTemplate<ParamType.INTEGER>;
		inputName4: ParamTemplate<ParamType.STRING>;
		inputType5: ParamTemplate<ParamType.INTEGER>;
		inputName5: ParamTemplate<ParamType.STRING>;
		inputType6: ParamTemplate<ParamType.INTEGER>;
		inputName6: ParamTemplate<ParamType.STRING>;
		inputType7: ParamTemplate<ParamType.INTEGER>;
		inputName7: ParamTemplate<ParamType.STRING>;
		inputType8: ParamTemplate<ParamType.INTEGER>;
		inputName8: ParamTemplate<ParamType.STRING>;
		inputType9: ParamTemplate<ParamType.INTEGER>;
		inputName9: ParamTemplate<ParamType.STRING>;
		spare: ParamTemplate<ParamType.FOLDER>;
	};
} & typeof NodeParamsConfig;
declare class TypedSubnetGlParamsConfig extends TypedSubnetGlParamsConfig_base {}
declare class AbstractTypedSubnetGlNode<K extends NodeParamsConfig> extends TypedGlNode<K> {
	protected _childrenControllerContext: NodeContext;
	initializeNode(): void;
	protected _expectedInputTypes(): GlConnectionPointType[];
	protected _expectedInputName(index: number): string;
	protected _expectedOutputTypes(): GlConnectionPointType[];
	protected _expectedOutputName(index: number): string;
	childExpectedInputConnectionPointTypes(): GlConnectionPointType[];
	childExpectedOutputConnectionPointTypes(): GlConnectionPointType[];
	childExpectedInputConnectionPointName(index: number): string;
	childExpectedOutputConnectionPointName(index: number): string;
	createNode<S extends keyof GlNodeChildrenMap>(node_class: S, options?: NodeCreateOptions): GlNodeChildrenMap[S];
	createNode<K extends valueof<GlNodeChildrenMap>>(node_class: Constructor<K>, options?: NodeCreateOptions): K;
	children(): BaseGlNodeType[];
	nodesByType<K extends keyof GlNodeChildrenMap>(type: K): GlNodeChildrenMap[K][];
	protected _setLinesPreBlock(shadersCollectionController: ShadersCollectionController): void;
	protected setLinesBlockStart(shadersCollectionController: ShadersCollectionController): void;
	setSubnetInputLines(shadersCollectionController: ShadersCollectionController, childNode: SubnetInputGlNode): void;
	setSubnetOutputLines(shadersCollectionController: ShadersCollectionController, childNode: SubnetOutputGlNode): void;
	setLines(shadersCollectionController: ShadersCollectionController): void;
	protected _runCodeBuilder(shadersCollectionController: ShadersCollectionController): CodeBuilder | undefined;
	private _addCodeBuilderDefinition;
	protected _sanitizeBodyLines(lines: string[]): string[];
}
declare class TypedSubnetGlNode<K extends TypedSubnetGlParamsConfig> extends AbstractTypedSubnetGlNode<K> {
	initializeNode(): void;
	protected _inputTypeParams(): IntegerParam[];
	protected _inputNameParams(): StringParam[];
	setInputType(index: number, type: GlConnectionPointType): void;
	setInputName(index: number, inputName: string): void;
	protected _expectedInputsCount(): number;
	protected _expectedInputTypes(): GlConnectionPointType[];
	protected _expectedInputName(index: number): string;
	protected _expectedOutputTypes(): GlConnectionPointType[];
	protected _expectedOutputName(index: number): string;
}
declare const SubnetGlParamsConfig_base: {
	new (...args: any[]): {
		inputs: ParamTemplate<ParamType.FOLDER>;
		inputsCount: ParamTemplate<ParamType.INTEGER>;
		inputType0: ParamTemplate<ParamType.INTEGER>;
		inputName0: ParamTemplate<ParamType.STRING>;
		inputType1: ParamTemplate<ParamType.INTEGER>;
		inputName1: ParamTemplate<ParamType.STRING>;
		inputType2: ParamTemplate<ParamType.INTEGER>;
		inputName2: ParamTemplate<ParamType.STRING>;
		inputType3: ParamTemplate<ParamType.INTEGER>;
		inputName3: ParamTemplate<ParamType.STRING>;
		inputType4: ParamTemplate<ParamType.INTEGER>;
		inputName4: ParamTemplate<ParamType.STRING>;
		inputType5: ParamTemplate<ParamType.INTEGER>;
		inputName5: ParamTemplate<ParamType.STRING>;
		inputType6: ParamTemplate<ParamType.INTEGER>;
		inputName6: ParamTemplate<ParamType.STRING>;
		inputType7: ParamTemplate<ParamType.INTEGER>;
		inputName7: ParamTemplate<ParamType.STRING>;
		inputType8: ParamTemplate<ParamType.INTEGER>;
		inputName8: ParamTemplate<ParamType.STRING>;
		inputType9: ParamTemplate<ParamType.INTEGER>;
		inputName9: ParamTemplate<ParamType.STRING>;
		spare: ParamTemplate<ParamType.FOLDER>;
	};
} & typeof NodeParamsConfig;
declare class SubnetGlParamsConfig extends SubnetGlParamsConfig_base {}
declare class SubnetGlNode extends TypedSubnetGlNode<SubnetGlParamsConfig> {
	paramsConfig: SubnetGlParamsConfig;
	static type(): NetworkNodeType;
}
declare const ForLoopGlParamsConfig_base: {
	new (...args: any[]): {
		inputs: ParamTemplate<ParamType.FOLDER>;
		inputsCount: ParamTemplate<ParamType.INTEGER>;
		inputType0: ParamTemplate<ParamType.INTEGER>;
		inputName0: ParamTemplate<ParamType.STRING>;
		inputType1: ParamTemplate<ParamType.INTEGER>;
		inputName1: ParamTemplate<ParamType.STRING>;
		inputType2: ParamTemplate<ParamType.INTEGER>;
		inputName2: ParamTemplate<ParamType.STRING>;
		inputType3: ParamTemplate<ParamType.INTEGER>;
		inputName3: ParamTemplate<ParamType.STRING>;
		inputType4: ParamTemplate<ParamType.INTEGER>;
		inputName4: ParamTemplate<ParamType.STRING>;
		inputType5: ParamTemplate<ParamType.INTEGER>;
		inputName5: ParamTemplate<ParamType.STRING>;
		inputType6: ParamTemplate<ParamType.INTEGER>;
		inputName6: ParamTemplate<ParamType.STRING>;
		inputType7: ParamTemplate<ParamType.INTEGER>;
		inputName7: ParamTemplate<ParamType.STRING>;
		inputType8: ParamTemplate<ParamType.INTEGER>;
		inputName8: ParamTemplate<ParamType.STRING>;
		inputType9: ParamTemplate<ParamType.INTEGER>;
		inputName9: ParamTemplate<ParamType.STRING>;
		spare: ParamTemplate<ParamType.FOLDER>;
	};
} & typeof NodeParamsConfig;
declare class ForLoopGlParamsConfig extends ForLoopGlParamsConfig_base {
	start: ParamTemplate<ParamType.FLOAT>;
	max: ParamTemplate<ParamType.FLOAT>;
	step: ParamTemplate<ParamType.FLOAT>;
	asFloat: ParamTemplate<ParamType.BOOLEAN>;
}
declare class ForLoopGlNode extends TypedSubnetGlNode<ForLoopGlParamsConfig> {
	paramsConfig: ForLoopGlParamsConfig;
	static type(): string;
	paramDefaultValue(name: string): number;
	childExpectedInputConnectionPointTypes(): GlConnectionPointType[];
	childExpectedInputConnectionPointName(index: number): string;
	protected setLinesBlockStart(shaders_collection_controller: ShadersCollectionController): void;
	setSubnetInputLines(shadersCollectionController: ShadersCollectionController, childNode: SubnetInputGlNode): void;
	private _typesData;
}
declare class FresnelGlParamsConfig extends NodeParamsConfig {
	worldPosition: ParamTemplate<ParamType.VECTOR4>;
	worldNormal: ParamTemplate<ParamType.VECTOR3>;
	cameraPosition: ParamTemplate<ParamType.VECTOR3>;
}
declare class FresnelGlNode extends TypedGlNode<FresnelGlParamsConfig> {
	paramsConfig: FresnelGlParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(shadersCollectionController: ShadersCollectionController): void;
	private _varFromParam;
	private _getGlobalVar;
}
declare class GridGlParamsConfig extends NodeParamsConfig {
	uv: ParamTemplate<ParamType.VECTOR2>;
	lineWidth: ParamTemplate<ParamType.FLOAT>;
	freq: ParamTemplate<ParamType.VECTOR2>;
	freqMult: ParamTemplate<ParamType.FLOAT>;
	filtered: ParamTemplate<ParamType.BOOLEAN>;
}
declare class GridGlNode extends TypedGlNode<GridGlParamsConfig> {
	paramsConfig: GridGlParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class LabToRgbGlParamsConfig extends NodeParamsConfig {
	hsluv: ParamTemplate<ParamType.VECTOR3>;
}
declare class HsluvToRgbGlNode extends TypedGlNode<LabToRgbGlParamsConfig> {
	paramsConfig: LabToRgbGlParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(shaders_collection_controller: ShadersCollectionController): void;
}
declare class HsvToRgbGlParamsConfig extends NodeParamsConfig {
	hsv: ParamTemplate<ParamType.VECTOR3>;
}
declare class HsvToRgbGlNode extends TypedGlNode<HsvToRgbGlParamsConfig> {
	paramsConfig: HsvToRgbGlParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(shaders_collection_controller: ShadersCollectionController): void;
}
declare const IfThenGlParamsConfig_base: {
	new (...args: any[]): {
		inputs: ParamTemplate<ParamType.FOLDER>;
		inputsCount: ParamTemplate<ParamType.INTEGER>;
		inputType0: ParamTemplate<ParamType.INTEGER>;
		inputName0: ParamTemplate<ParamType.STRING>;
		inputType1: ParamTemplate<ParamType.INTEGER>;
		inputName1: ParamTemplate<ParamType.STRING>;
		inputType2: ParamTemplate<ParamType.INTEGER>;
		inputName2: ParamTemplate<ParamType.STRING>;
		inputType3: ParamTemplate<ParamType.INTEGER>;
		inputName3: ParamTemplate<ParamType.STRING>;
		inputType4: ParamTemplate<ParamType.INTEGER>;
		inputName4: ParamTemplate<ParamType.STRING>;
		inputType5: ParamTemplate<ParamType.INTEGER>;
		inputName5: ParamTemplate<ParamType.STRING>;
		inputType6: ParamTemplate<ParamType.INTEGER>;
		inputName6: ParamTemplate<ParamType.STRING>;
		inputType7: ParamTemplate<ParamType.INTEGER>;
		inputName7: ParamTemplate<ParamType.STRING>;
		inputType8: ParamTemplate<ParamType.INTEGER>;
		inputName8: ParamTemplate<ParamType.STRING>;
		inputType9: ParamTemplate<ParamType.INTEGER>;
		inputName9: ParamTemplate<ParamType.STRING>;
		spare: ParamTemplate<ParamType.FOLDER>;
	};
} & typeof NodeParamsConfig;
declare class IfThenGlParamsConfig extends IfThenGlParamsConfig_base {}
declare class IfThenGlNode extends TypedSubnetGlNode<IfThenGlParamsConfig> {
	paramsConfig: IfThenGlParamsConfig;
	static type(): Readonly<'ifThen'>;
	protected _expectedInputsCount(): number;
	protected _expectedInputTypes(): GlConnectionPointType[];
	protected _expectedInputName(index: number): string;
	childExpectedInputConnectionPointTypes(): GlConnectionPointType[];
	childExpectedInputConnectionPointName(index: number): string;
	protected _setLinesPreBlock(shadersCollectionController: ShadersCollectionController): void;
	setSubnetInputLines(shadersCollectionController: ShadersCollectionController, childNode: SubnetInputGlNode): void;
	protected setLinesBlockStart(shaders_collection_controller: ShadersCollectionController): void;
}
declare class InRangeGlParamsConfig extends NodeParamsConfig {}
declare class InRangeGlNode extends TypedGlNode<InRangeGlParamsConfig> {
	paramsConfig: InRangeGlParamsConfig;
	static type(): string;
	static OUTPUT: string;
	static INPUT: string;
	static INPUT_MIN: string;
	static INPUT_MAX: string;
	initializeNode(): void;
	private _expected_input_types;
	setLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class IsInfOrNanGlParamsConfig extends NodeParamsConfig {
	testIsInf: ParamTemplate<ParamType.BOOLEAN>;
	testIsNan: ParamTemplate<ParamType.BOOLEAN>;
}
declare class IsInfOrNanGlNode extends TypedGlNode<IsInfOrNanGlParamsConfig> {
	paramsConfig: IsInfOrNanGlParamsConfig;
	static type(): string;
	static OUTPUT: string;
	static INPUT: string;
	initializeNode(): void;
	private _expected_input_types;
	setLines(shadersCollectionController: ShadersCollectionController): void;
	private _functionCalls;
}
declare class ImpostorUvGlParamsConfig extends NodeParamsConfig {
	center: ParamTemplate<ParamType.VECTOR3>;
	cameraPos: ParamTemplate<ParamType.VECTOR3>;
	uv: ParamTemplate<ParamType.VECTOR2>;
	tilesCount: ParamTemplate<ParamType.INTEGER>;
	offset: ParamTemplate<ParamType.FLOAT>;
}
declare class ImpostorUvGlNode extends TypedGlNode<ImpostorUvGlParamsConfig> {
	paramsConfig: ImpostorUvGlParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(shaders_collection_controller: ShadersCollectionController): void;
}
declare class InstanceTransformGlParamsConfig extends NodeParamsConfig {
	position: ParamTemplate<ParamType.VECTOR3>;
	normal: ParamTemplate<ParamType.VECTOR3>;
	instancePosition: ParamTemplate<ParamType.VECTOR3>;
	instanceQuaternion: ParamTemplate<ParamType.VECTOR4>;
	instanceScale: ParamTemplate<ParamType.VECTOR3>;
}
declare class InstanceTransformGlNode extends TypedGlNode<InstanceTransformGlParamsConfig> {
	paramsConfig: InstanceTransformGlParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(shaders_collection_controller: ShadersCollectionController): void;
	gl_output_name_position(): string;
	gl_output_name_normal(): string;
	private _defaultPosition;
	private _defaultNormal;
	private _defaultInstancePosition;
	private _defaultInputInstanceQuaternion;
	private _defaultInputInstanceScale;
}
declare class LengthGlNode extends BaseNodeGlMathFunctionArg1GlNode {
	static type(): string;
	initializeNode(): void;
	protected _gl_input_name(index: number): string;
	gl_method_name(): string;
	protected _expected_output_types(): GlConnectionPointType[];
}
declare class LuminanceGlParamsConfig extends NodeParamsConfig {
	color: ParamTemplate<ParamType.VECTOR3>;
}
declare class LuminanceGlNode extends TypedGlNode<LuminanceGlParamsConfig> {
	paramsConfig: LuminanceGlParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class MaxLengthGlNode extends BaseNodeGlMathFunctionArg2GlNode {
	static type(): string;
	protected _expected_input_types(): GlConnectionPointType[];
	protected _gl_input_name(index: number): string;
	paramDefaultValue(name: string): number;
	protected gl_method_name(): string;
	gl_function_definitions(): FunctionGLDefinition[];
}
declare class MixGlNode extends BaseGlMathFunctionGlNode {
	static type(): string;
	protected gl_method_name(): string;
	paramDefaultValue(name: string): number;
	initializeNode(): void;
	protected _gl_output_name(): string;
	protected _expected_input_types(): GlConnectionPointType[];
	protected _expected_output_types(): GlConnectionPointType[];
}
declare class ModelViewMatrixMultGlParamsConfig extends NodeParamsConfig {
	vector: ParamTemplate<ParamType.VECTOR3>;
}
declare class ModelViewMatrixMultGlNode extends TypedGlNode<ModelViewMatrixMultGlParamsConfig> {
	paramsConfig: ModelViewMatrixMultGlParamsConfig;
	static type(): Readonly<'modelViewMatrixMult'>;
	initializeNode(): void;
	setLines(shaders_collection_controller: ShadersCollectionController): void;
}
declare enum MultAddGlNodeInputName {
	VALUE = 'value',
	PRE_ADD = 'preAdd',
	MULT = 'mult',
	POST_ADD = 'postAdd',
}
declare class MultAddGlNode extends BaseNodeGlMathFunctionArg4GlNode {
	static type(): string;
	protected _gl_input_name(index: number): MultAddGlNodeInputName;
	paramDefaultValue(name: string): number;
	setLines(shaders_collection_controller: ShadersCollectionController): void;
}
declare enum MultScalarGlNodeInputName {
	VALUE = 'value',
	MULT = 'mult',
}
declare class MultScalarGlNode extends BaseNodeGlMathFunctionArg2GlNode {
	static type(): string;
	protected _expected_input_types(): GlConnectionPointType[];
	protected _gl_input_name(index: number): MultScalarGlNodeInputName;
	paramDefaultValue(name: string): number;
	setLines(shaders_collection_controller: ShadersCollectionController): void;
}
declare class NegateGlNode extends BaseNodeGlMathFunctionArg1GlNode {
	static type(): string;
	initializeNode(): void;
	protected _gl_input_name(index: number): string;
	setLines(shaders_collection_controller: ShadersCollectionController): void;
}
declare class NeighbourAttractGlParamsConfig extends NodeParamsConfig {
	positionAttribName: ParamTemplate<ParamType.STRING>;
	position: ParamTemplate<ParamType.VECTOR3>;
	amount: ParamTemplate<ParamType.FLOAT>;
	startDist: ParamTemplate<ParamType.FLOAT>;
	midDist: ParamTemplate<ParamType.FLOAT>;
	endDist: ParamTemplate<ParamType.FLOAT>;
}
declare class NeighbourAttractGlNode extends TypedGlNode<NeighbourAttractGlParamsConfig> {
	paramsConfig: NeighbourAttractGlParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(shadersCollectionController: ShadersCollectionController): void;
	private _templateFunctionDefinition;
}
declare class NeighbourAttractRepulseParamsConfig extends NodeParamsConfig {
	positionAttribName: ParamTemplate<ParamType.STRING>;
	position: ParamTemplate<ParamType.VECTOR3>;
	repulse: ParamTemplate<ParamType.BOOLEAN>;
	repulseAmount: ParamTemplate<ParamType.FLOAT>;
	repulseMinDist: ParamTemplate<ParamType.FLOAT>;
	repulseMaxDist: ParamTemplate<ParamType.FLOAT>;
	attract: ParamTemplate<ParamType.BOOLEAN>;
	attractAmount: ParamTemplate<ParamType.FLOAT>;
	attractStartDist: ParamTemplate<ParamType.FLOAT>;
	attractMidDist: ParamTemplate<ParamType.FLOAT>;
	attractEndDist: ParamTemplate<ParamType.FLOAT>;
}
declare class NeighbourAttractRepulseGlNode extends TypedGlNode<NeighbourAttractRepulseParamsConfig> {
	paramsConfig: NeighbourAttractRepulseParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(shadersCollectionController: ShadersCollectionController): void;
	private _templateFlocking;
}
declare class NeighbourDensityGlParamsConfig extends NodeParamsConfig {
	positionAttribName: ParamTemplate<ParamType.STRING>;
	position: ParamTemplate<ParamType.VECTOR3>;
	amount: ParamTemplate<ParamType.FLOAT>;
	minDist: ParamTemplate<ParamType.FLOAT>;
	maxDist: ParamTemplate<ParamType.FLOAT>;
}
declare class NeighbourDensityGlNode extends TypedGlNode<NeighbourDensityGlParamsConfig> {
	paramsConfig: NeighbourDensityGlParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(shadersCollectionController: ShadersCollectionController): void;
	private _templateFunctionDefinition;
}
declare class NeighbourRepulseGlParamsConfig extends NodeParamsConfig {
	positionAttribName: ParamTemplate<ParamType.STRING>;
	position: ParamTemplate<ParamType.VECTOR3>;
	amount: ParamTemplate<ParamType.FLOAT>;
	minDist: ParamTemplate<ParamType.FLOAT>;
	maxDist: ParamTemplate<ParamType.FLOAT>;
}
declare class NeighbourRepulseGlNode extends TypedGlNode<NeighbourRepulseGlParamsConfig> {
	paramsConfig: NeighbourRepulseGlParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(shadersCollectionController: ShadersCollectionController): void;
	private _templateFunctionDefinition;
}
declare enum NoiseName {
	CLASSIC_PERLIN_2D = 'Classic Perlin 2D',
	CLASSIC_PERLIN_3D = 'Classic Perlin 3D',
	CLASSIC_PERLIN_4D = 'Classic Perlin 4D',
	NOISE_2D = 'noise2D',
	NOISE_3D = 'noise3D',
	NOISE_4D = 'noise4D',
}
declare enum NoiseOutputType {
	NoChange = 0,
	Float = 1,
	Vec2 = 2,
	Vec3 = 3,
	Vec4 = 4,
}
declare enum NoiseGlNodeInputName {
	AMP = 'amp',
	POSITION = 'position',
	FREQ = 'freq',
	OFFSET = 'offset',
}
declare class NoiseGlParamsConfig extends NodeParamsConfig {
	type: ParamTemplate<ParamType.INTEGER>;
	outputType: ParamTemplate<ParamType.INTEGER>;
	octaves: ParamTemplate<ParamType.INTEGER>;
	ampAttenuation: ParamTemplate<ParamType.FLOAT>;
	freqIncrease: ParamTemplate<ParamType.FLOAT>;
}
declare class NoiseGlNode extends TypedGlNode<NoiseGlParamsConfig> {
	paramsConfig: NoiseGlParamsConfig;
	static type(): GlType;
	initializeNode(): void;
	setNoiseName(noiseName: NoiseName): void;
	setOutputType(outputType: NoiseOutputType): void;
	protected _gl_input_name(index: number): NoiseGlNodeInputName;
	paramDefaultValue(name: string): number;
	private _expected_input_types;
	private _expected_output_types;
	setLines(shaders_collection_controller: ShadersCollectionController): void;
	private fbmMethodName;
	private fbmFunction;
	private singleNoiseLine;
}
declare class NullGlNode extends BaseNodeGlMathFunctionArg1GlNode {
	static type(): string;
	setLines(shaders_collection_controller: ShadersCollectionController): void;
}
declare class ParamGlParamsConfig extends NodeParamsConfig {
	name: ParamTemplate<ParamType.STRING>;
	type: ParamTemplate<ParamType.INTEGER>;
	asColor: ParamTemplate<ParamType.BOOLEAN>;
}
declare class ParamGlNode extends TypedGlNode<ParamGlParamsConfig> {
	paramsConfig: ParamGlParamsConfig;
	static type(): Readonly<GlType.PARAM>;
	initializeNode(): void;
	setLines(shadersCollectionController: ShadersCollectionController): void;
	paramsGenerating(): boolean;
	setParamConfigs(): void;
	uniformName(): string;
	setGlType(type: GlConnectionPointType): void;
}
declare class OklabToRgbGlParamsConfig extends NodeParamsConfig {
	oklab: ParamTemplate<ParamType.VECTOR3>;
}
declare class OklabToRgbGlNode extends TypedGlNode<OklabToRgbGlParamsConfig> {
	paramsConfig: OklabToRgbGlParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(shaders_collection_controller: ShadersCollectionController): void;
}
declare class PolarToCartesianGlParamsConfig extends NodeParamsConfig {
	polar: ParamTemplate<ParamType.VECTOR3>;
}
declare class PolarToCartesianGlNode extends TypedGlNode<PolarToCartesianGlParamsConfig> {
	paramsConfig: PolarToCartesianGlParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class QuatMultGlNode extends BaseNodeGlMathFunctionArg1GlNode {
	static type(): string;
	initializeNode(): void;
	gl_method_name(): string;
	gl_function_definitions(): FunctionGLDefinition[];
}
declare class QuatFromAxisAngleGlNode extends BaseNodeGlMathFunctionArg2GlNode {
	static type(): string;
	initializeNode(): void;
	paramDefaultValue(name: string): number | Number3;
	gl_method_name(): string;
	gl_function_definitions(): FunctionGLDefinition[];
}
declare class QuatSlerpGlNode extends BaseNodeGlMathFunctionArg1GlNode {
	static type(): string;
	initializeNode(): void;
	gl_method_name(): string;
	gl_function_definitions(): FunctionGLDefinition[];
}
declare class QuatToAngleGlNode extends BaseNodeGlMathFunctionArg1GlNode {
	static type(): string;
	initializeNode(): void;
	gl_method_name(): string;
	gl_function_definitions(): FunctionGLDefinition[];
}
declare class QuatToAxisGlNode extends BaseNodeGlMathFunctionArg1GlNode {
	static type(): string;
	initializeNode(): void;
	gl_method_name(): string;
	gl_function_definitions(): FunctionGLDefinition[];
}
declare class RampGlParamsConfig extends NodeParamsConfig {
	name: ParamTemplate<ParamType.STRING>;
	input: ParamTemplate<ParamType.FLOAT>;
}
declare class RampGlNode extends TypedGlNode<RampGlParamsConfig> {
	paramsConfig: RampGlParamsConfig;
	static type(): Readonly<'ramp'>;
	initializeNode(): void;
	setLines(shadersCollectionController: ShadersCollectionController): void;
	paramsGenerating(): boolean;
	setParamConfigs(): void;
	uniformName(): string;
}
declare class RandomGlParamsConfig extends NodeParamsConfig {
	seed: ParamTemplate<ParamType.VECTOR2>;
}
declare class RandomGlNode extends TypedGlNode<RandomGlParamsConfig> {
	paramsConfig: RandomGlParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(shaders_collection_controller: ShadersCollectionController): void;
}
declare class RefractGlNode extends BaseGlMathFunctionGlNode {
	static type(): string;
	initializeNode(): void;
	gl_method_name(): string;
	protected _expected_input_types(): GlConnectionPointType[];
	protected _expected_output_types(): GlConnectionPointType[];
}
declare class RgbToHsvGlParamsConfig extends NodeParamsConfig {
	rgb: ParamTemplate<ParamType.VECTOR3>;
}
declare class RgbToHsvGlNode extends TypedGlNode<RgbToHsvGlParamsConfig> {
	paramsConfig: RgbToHsvGlParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(shaders_collection_controller: ShadersCollectionController): void;
}
declare enum GlRotateMode {
	AXIS = 0,
	QUAT = 1,
}
declare class RotateParamsConfig extends NodeParamsConfig {
	signature: ParamTemplate<ParamType.INTEGER>;
}
declare class RotateGlNode extends TypedGlNode<RotateParamsConfig> {
	paramsConfig: RotateParamsConfig;
	static type(): string;
	initializeNode(): void;
	set_signature(mode: GlRotateMode): void;
	protected _gl_input_name(index: number): string;
	paramDefaultValue(name: string): Number3;
	gl_method_name(): string;
	protected _expected_input_types(): GlConnectionPointType[];
	protected _expected_output_types(): GlConnectionPointType[];
	gl_function_definitions(): FunctionGLDefinition[];
	setLines(shaders_collection_controller: ShadersCollectionController): void;
}
declare class RoundGlNode extends BaseNodeGlMathFunctionArg1GlNode {
	static type(): string;
	setLines(shadersCollectionController: ShadersCollectionController): void;
	private _singleLine;
}
declare class BaseSDF2DGlParamsConfig extends NodeParamsConfig {
	position: ParamTemplate<ParamType.VECTOR2>;
}
declare class BaseSDF2DGlNode<K extends BaseSDF2DGlParamsConfig> extends TypedGlNode<K> {
	protected position(): string;
	private _defaultPosition;
	protected _addSDF2DMethods(shadersCollectionController: ShadersCollectionController): void;
}
declare class SDF2DBoxGlParamsConfig extends NodeParamsConfig {
	position: ParamTemplate<ParamType.VECTOR2>;
	center: ParamTemplate<ParamType.VECTOR2>;
	size: ParamTemplate<ParamType.VECTOR2>;
}
declare class SDF2DBoxGlNode extends BaseSDF2DGlNode<SDF2DBoxGlParamsConfig> {
	paramsConfig: SDF2DBoxGlParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class SDF2DCircleGlParamsConfig extends NodeParamsConfig {
	position: ParamTemplate<ParamType.VECTOR2>;
	center: ParamTemplate<ParamType.VECTOR2>;
	radius: ParamTemplate<ParamType.FLOAT>;
}
declare class SDF2DCircleGlNode extends BaseSDF2DGlNode<SDF2DCircleGlParamsConfig> {
	paramsConfig: SDF2DCircleGlParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class SDF2DCrossGlParamsConfig extends NodeParamsConfig {
	position: ParamTemplate<ParamType.VECTOR2>;
	center: ParamTemplate<ParamType.VECTOR2>;
	length: ParamTemplate<ParamType.FLOAT>;
	width: ParamTemplate<ParamType.FLOAT>;
	radius: ParamTemplate<ParamType.FLOAT>;
}
declare class SDF2DCrossGlNode extends BaseSDF2DGlNode<SDF2DCrossGlParamsConfig> {
	paramsConfig: SDF2DCrossGlParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class SDF2DHeartGlParamsConfig extends NodeParamsConfig {
	position: ParamTemplate<ParamType.VECTOR2>;
	center: ParamTemplate<ParamType.VECTOR2>;
}
declare class SDF2DHeartGlNode extends BaseSDF2DGlNode<SDF2DHeartGlParamsConfig> {
	paramsConfig: SDF2DHeartGlParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class SDF2DRoundedXGlParamsConfig extends NodeParamsConfig {
	position: ParamTemplate<ParamType.VECTOR2>;
	center: ParamTemplate<ParamType.VECTOR2>;
	length: ParamTemplate<ParamType.FLOAT>;
	radius: ParamTemplate<ParamType.FLOAT>;
}
declare class SDF2DRoundedXGlNode extends BaseSDF2DGlNode<SDF2DRoundedXGlParamsConfig> {
	paramsConfig: SDF2DRoundedXGlParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class SDF2DStairsGlParamsConfig extends NodeParamsConfig {
	position: ParamTemplate<ParamType.VECTOR2>;
	center: ParamTemplate<ParamType.VECTOR2>;
	width: ParamTemplate<ParamType.FLOAT>;
	height: ParamTemplate<ParamType.FLOAT>;
	steps: ParamTemplate<ParamType.FLOAT>;
}
declare class SDF2DStairsGlNode extends BaseSDF2DGlNode<SDF2DStairsGlParamsConfig> {
	paramsConfig: SDF2DStairsGlParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class BaseSDFGlParamsConfig extends NodeParamsConfig {
	position: ParamTemplate<ParamType.VECTOR3>;
}
declare class BaseSDFGlNode<K extends BaseSDFGlParamsConfig> extends TypedGlNode<K> {
	protected position(): string;
	private _defaultPosition;
	protected _addSDFMethods(shadersCollectionController: ShadersCollectionController): void;
	static addSDFMethods(shadersCollectionController: ShadersCollectionController, node: BaseGlNodeType): void;
}
declare class SDFBoxGlParamsConfig extends NodeParamsConfig {
	position: ParamTemplate<ParamType.VECTOR3>;
	center: ParamTemplate<ParamType.VECTOR3>;
	size: ParamTemplate<ParamType.FLOAT>;
	sizes: ParamTemplate<ParamType.VECTOR3>;
}
declare class SDFBoxGlNode extends BaseSDFGlNode<SDFBoxGlParamsConfig> {
	paramsConfig: SDFBoxGlParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class SDFBoxFrameGlParamsConfig extends NodeParamsConfig {
	position: ParamTemplate<ParamType.VECTOR3>;
	center: ParamTemplate<ParamType.VECTOR3>;
	size: ParamTemplate<ParamType.FLOAT>;
	sizes: ParamTemplate<ParamType.VECTOR3>;
	width: ParamTemplate<ParamType.FLOAT>;
}
declare class SDFBoxFrameGlNode extends BaseSDFGlNode<SDFBoxFrameGlParamsConfig> {
	paramsConfig: SDFBoxFrameGlParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class SDFBoxRoundGlParamsConfig extends NodeParamsConfig {
	position: ParamTemplate<ParamType.VECTOR3>;
	center: ParamTemplate<ParamType.VECTOR3>;
	size: ParamTemplate<ParamType.FLOAT>;
	sizes: ParamTemplate<ParamType.VECTOR3>;
	radius: ParamTemplate<ParamType.FLOAT>;
}
declare class SDFBoxRoundGlNode extends BaseSDFGlNode<SDFBoxRoundGlParamsConfig> {
	paramsConfig: SDFBoxRoundGlParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class SDFCapsuleGlParamsConfig extends NodeParamsConfig {
	position: ParamTemplate<ParamType.VECTOR3>;
	center: ParamTemplate<ParamType.VECTOR3>;
	start: ParamTemplate<ParamType.VECTOR3>;
	end: ParamTemplate<ParamType.VECTOR3>;
	radius: ParamTemplate<ParamType.FLOAT>;
}
declare class SDFCapsuleGlNode extends BaseSDFGlNode<SDFCapsuleGlParamsConfig> {
	paramsConfig: SDFCapsuleGlParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class SDFCapsuleVerticalGlParamsConfig extends NodeParamsConfig {
	position: ParamTemplate<ParamType.VECTOR3>;
	center: ParamTemplate<ParamType.VECTOR3>;
	height: ParamTemplate<ParamType.FLOAT>;
	radius: ParamTemplate<ParamType.FLOAT>;
}
declare class SDFCapsuleVerticalGlNode extends BaseSDFGlNode<SDFCapsuleVerticalGlParamsConfig> {
	paramsConfig: SDFCapsuleVerticalGlParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class SDFConeGlParamsConfig extends NodeParamsConfig {
	position: ParamTemplate<ParamType.VECTOR3>;
	center: ParamTemplate<ParamType.VECTOR3>;
	height: ParamTemplate<ParamType.FLOAT>;
	angle: ParamTemplate<ParamType.FLOAT>;
}
declare class SDFConeGlNode extends BaseSDFGlNode<SDFConeGlParamsConfig> {
	paramsConfig: SDFConeGlParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class SDFConeRoundGlParamsConfig extends NodeParamsConfig {
	position: ParamTemplate<ParamType.VECTOR3>;
	center: ParamTemplate<ParamType.VECTOR3>;
	height: ParamTemplate<ParamType.FLOAT>;
	radius1: ParamTemplate<ParamType.FLOAT>;
	radius2: ParamTemplate<ParamType.FLOAT>;
}
declare class SDFConeRoundGlNode extends BaseSDFGlNode<SDFConeRoundGlParamsConfig> {
	paramsConfig: SDFConeRoundGlParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class SDFContextGlParamsConfig extends NodeParamsConfig {}
declare class SDFContextGlNode extends TypedGlNode<SDFContextGlParamsConfig> {
	paramsConfig: SDFContextGlParamsConfig;
	static type(): GlType;
	initializeNode(): void;
	private _expectedInputTypes;
	private _expectedOutputTypes;
	private _glInputNames;
	private _glOutputNames;
	setLines(shaders_collection_controller: ShadersCollectionController): void;
}
declare class SDFElongateGlParamsConfig extends NodeParamsConfig {
	position: ParamTemplate<ParamType.VECTOR3>;
	center: ParamTemplate<ParamType.VECTOR3>;
	mult: ParamTemplate<ParamType.VECTOR3>;
	fast: ParamTemplate<ParamType.BOOLEAN>;
}
declare class SDFElongateGlNode extends BaseSDFGlNode<SDFElongateGlParamsConfig> {
	paramsConfig: SDFElongateGlParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(shadersCollectionController: ShadersCollectionController): void;
}
declare enum SDFExtrudeAxis {
	X = 'X',
	Y = 'Y',
	Z = 'Z',
}
declare class SDFExtrudeGlParamsConfig extends NodeParamsConfig {
	position: ParamTemplate<ParamType.VECTOR3>;
	center: ParamTemplate<ParamType.VECTOR3>;
	height: ParamTemplate<ParamType.FLOAT>;
	d: ParamTemplate<ParamType.FLOAT>;
	axis: ParamTemplate<ParamType.INTEGER>;
}
declare class SDFExtrudeGlNode extends BaseSDFGlNode<SDFExtrudeGlParamsConfig> {
	paramsConfig: SDFExtrudeGlParamsConfig;
	static type(): string;
	initializeNode(): void;
	setAxis(axis: SDFExtrudeAxis): void;
	setLines(shadersCollectionController: ShadersCollectionController): void;
	private _functionName;
}
declare class SDFFractalMandelbrotGlParamsConfig extends NodeParamsConfig {
	position: ParamTemplate<ParamType.VECTOR3>;
	center: ParamTemplate<ParamType.VECTOR3>;
	power: ParamTemplate<ParamType.FLOAT>;
	QPreMult: ParamTemplate<ParamType.VECTOR3>;
	QPostMult: ParamTemplate<ParamType.VECTOR3>;
	thetaMult: ParamTemplate<ParamType.FLOAT>;
	iterations: ParamTemplate<ParamType.INTEGER>;
	externalBoundingRadius: ParamTemplate<ParamType.FLOAT>;
}
declare class SDFFractalMandelbrotGlNode extends BaseSDFGlNode<SDFFractalMandelbrotGlParamsConfig> {
	paramsConfig: SDFFractalMandelbrotGlParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(shadersCollectionController: ShadersCollectionController): void;
}
declare const SDFGradientGlParamsConfig_base: {
	new (...args: any[]): {
		inputs: ParamTemplate<ParamType.FOLDER>;
		inputsCount: ParamTemplate<ParamType.INTEGER>;
		inputType0: ParamTemplate<ParamType.INTEGER>;
		inputName0: ParamTemplate<ParamType.STRING>;
		inputType1: ParamTemplate<ParamType.INTEGER>;
		inputName1: ParamTemplate<ParamType.STRING>;
		inputType2: ParamTemplate<ParamType.INTEGER>;
		inputName2: ParamTemplate<ParamType.STRING>;
		inputType3: ParamTemplate<ParamType.INTEGER>;
		inputName3: ParamTemplate<ParamType.STRING>;
		inputType4: ParamTemplate<ParamType.INTEGER>;
		inputName4: ParamTemplate<ParamType.STRING>;
		inputType5: ParamTemplate<ParamType.INTEGER>;
		inputName5: ParamTemplate<ParamType.STRING>;
		inputType6: ParamTemplate<ParamType.INTEGER>;
		inputName6: ParamTemplate<ParamType.STRING>;
		inputType7: ParamTemplate<ParamType.INTEGER>;
		inputName7: ParamTemplate<ParamType.STRING>;
		inputType8: ParamTemplate<ParamType.INTEGER>;
		inputName8: ParamTemplate<ParamType.STRING>;
		inputType9: ParamTemplate<ParamType.INTEGER>;
		inputName9: ParamTemplate<ParamType.STRING>;
		spare: ParamTemplate<ParamType.FOLDER>;
	};
} & typeof NodeParamsConfig;
declare class SDFGradientGlParamsConfig extends SDFGradientGlParamsConfig_base {
	epsilon: ParamTemplate<ParamType.FLOAT>;
}
declare class SDFGradientGlNode extends TypedSubnetGlNode<SDFGradientGlParamsConfig> {
	paramsConfig: SDFGradientGlParamsConfig;
	static type(): Readonly<'SDFGradient'>;
	protected _expectedInputsCount(): number;
	protected _expectedInputTypes(): GlConnectionPointType[];
	protected _expectedOutputTypes(): GlConnectionPointType[];
	protected _expectedInputName(index: number): string;
	protected _expectedOutputName(index: number): string;
	childExpectedOutputConnectionPointTypes(): GlConnectionPointType[];
	childExpectedOutputConnectionPointName(index: number): string;
	setSubnetInputLines(shadersCollectionController: ShadersCollectionController, childNode: SubnetInputGlNode): void;
	setSubnetOutputLines(shadersCollectionController: ShadersCollectionController, childNode: SubnetOutputGlNode): void;
	setLines(shadersCollectionController: ShadersCollectionController): void;
	private _declareFunctions;
	private _callFunctions;
}
declare class SDFHexagonalPrismGlParamsConfig extends NodeParamsConfig {
	position: ParamTemplate<ParamType.VECTOR3>;
	center: ParamTemplate<ParamType.VECTOR3>;
	radius: ParamTemplate<ParamType.FLOAT>;
	height: ParamTemplate<ParamType.FLOAT>;
}
declare class SDFHexagonalPrismGlNode extends BaseSDFGlNode<SDFHexagonalPrismGlParamsConfig> {
	paramsConfig: SDFHexagonalPrismGlParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class SDFHorseShoeGlParamsConfig extends NodeParamsConfig {
	position: ParamTemplate<ParamType.VECTOR3>;
	center: ParamTemplate<ParamType.VECTOR3>;
	angle: ParamTemplate<ParamType.FLOAT>;
	radius: ParamTemplate<ParamType.FLOAT>;
	length: ParamTemplate<ParamType.FLOAT>;
	thickness: ParamTemplate<ParamType.FLOAT>;
	width: ParamTemplate<ParamType.FLOAT>;
}
declare class SDFHorseShoeGlNode extends BaseSDFGlNode<SDFHorseShoeGlParamsConfig> {
	paramsConfig: SDFHorseShoeGlParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class SDFIntersectGlParamsConfig extends NodeParamsConfig {
	smooth: ParamTemplate<ParamType.BOOLEAN>;
}
declare class SDFIntersectGlNode extends TypedGlNode<SDFIntersectGlParamsConfig> {
	paramsConfig: SDFIntersectGlParamsConfig;
	static type(): string;
	initializeNode(): void;
	private _glInputName;
	private _glOutputName;
	private _expectedInputTypes;
	private _expectedOutputTypes;
	setLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class SDFLinkGlParamsConfig extends NodeParamsConfig {
	position: ParamTemplate<ParamType.VECTOR3>;
	center: ParamTemplate<ParamType.VECTOR3>;
	halfLength: ParamTemplate<ParamType.FLOAT>;
	radius1: ParamTemplate<ParamType.FLOAT>;
	radius2: ParamTemplate<ParamType.FLOAT>;
}
declare class SDFLinkGlNode extends BaseSDFGlNode<SDFLinkGlParamsConfig> {
	paramsConfig: SDFLinkGlParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class SDFMaterialGlParamsConfig extends NodeParamsConfig {
	globals: ParamTemplate<ParamType.FOLDER>;
	color: ParamTemplate<ParamType.COLOR>;
	useEnvMap: ParamTemplate<ParamType.BOOLEAN>;
	useReflection: ParamTemplate<ParamType.BOOLEAN>;
	useRefraction: ParamTemplate<ParamType.BOOLEAN>;
	lighting: ParamTemplate<ParamType.FOLDER>;
	useLights: ParamTemplate<ParamType.BOOLEAN>;
	diffuse: ParamTemplate<ParamType.COLOR>;
	emissive: ParamTemplate<ParamType.COLOR>;
	envMap: ParamTemplate<ParamType.FOLDER>;
	envMapTint: ParamTemplate<ParamType.COLOR>;
	envMapIntensity: ParamTemplate<ParamType.FLOAT>;
	envMapRoughness: ParamTemplate<ParamType.FLOAT>;
	envMapFresnel: ParamTemplate<ParamType.FLOAT>;
	envMapFresnelPower: ParamTemplate<ParamType.FLOAT>;
	reflection: ParamTemplate<ParamType.FOLDER>;
	reflectionTint: ParamTemplate<ParamType.COLOR>;
	reflectionDepth: ParamTemplate<ParamType.INTEGER>;
	reflectivity: ParamTemplate<ParamType.FLOAT>;
	reflectionBiasMult: ParamTemplate<ParamType.FLOAT>;
	refraction: ParamTemplate<ParamType.FOLDER>;
	refractionTint: ParamTemplate<ParamType.COLOR>;
	ior: ParamTemplate<ParamType.FLOAT>;
	splitRGB: ParamTemplate<ParamType.BOOLEAN>;
	iorOffset: ParamTemplate<ParamType.VECTOR3>;
	transmission: ParamTemplate<ParamType.FLOAT>;
	absorption: ParamTemplate<ParamType.FLOAT>;
	refractionDepth: ParamTemplate<ParamType.INTEGER>;
	refractionMaxDist: ParamTemplate<ParamType.FLOAT>;
	refractionBiasMult: ParamTemplate<ParamType.FLOAT>;
	sampleEnvMapOnLastRefractionRay: ParamTemplate<ParamType.BOOLEAN>;
	refractionStartOutsideMedium: ParamTemplate<ParamType.BOOLEAN>;
}
declare class SDFMaterialGlNode extends TypedGlNode<SDFMaterialGlParamsConfig> {
	paramsConfig: SDFMaterialGlParamsConfig;
	static type(): GlType;
	initializeNode(): void;
	materialIdName(): string;
	private _materialId;
	setLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class SDFMaxGlParamsConfig extends NodeParamsConfig {}
declare class SDFMaxGlNode extends TypedGlNode<SDFMaxGlParamsConfig> {
	paramsConfig: SDFMaxGlParamsConfig;
	static type(): string;
	initializeNode(): void;
	private _glInputName;
	private _glOutputName;
	private _expectedInputTypes;
	private _expectedOutputTypes;
	setLines(shadersCollectionController: ShadersCollectionController): void;
	private _setLinesFloat;
	private _setLinesSDFContext;
}
declare class SDFMinGlParamsConfig extends NodeParamsConfig {}
declare class SDFMinGlNode extends TypedGlNode<SDFMinGlParamsConfig> {
	paramsConfig: SDFMinGlParamsConfig;
	static type(): string;
	initializeNode(): void;
	private _glInputName;
	private _glOutputName;
	private _expectedInputTypes;
	private _expectedOutputTypes;
	setLines(shadersCollectionController: ShadersCollectionController): void;
	private _setLinesFloat;
	private _setLinesSDFContext;
}
declare class SDFMirrorGlParamsConfig extends NodeParamsConfig {
	position: ParamTemplate<ParamType.VECTOR3>;
	center: ParamTemplate<ParamType.VECTOR3>;
	smooth: ParamTemplate<ParamType.BOOLEAN>;
	smoothFactor: ParamTemplate<ParamType.FLOAT>;
	mirrorX: ParamTemplate<ParamType.BOOLEAN>;
	mirrorY: ParamTemplate<ParamType.BOOLEAN>;
	mirrorZ: ParamTemplate<ParamType.BOOLEAN>;
}
declare class SDFMirrorGlNode extends BaseSDFGlNode<SDFMirrorGlParamsConfig> {
	paramsConfig: SDFMirrorGlParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(shadersCollectionController: ShadersCollectionController): void;
	private _functionSuffix;
}
declare class SDFOctahedronGlParamsConfig extends NodeParamsConfig {
	position: ParamTemplate<ParamType.VECTOR3>;
	center: ParamTemplate<ParamType.VECTOR3>;
	size: ParamTemplate<ParamType.FLOAT>;
}
declare class SDFOctahedronGlNode extends BaseSDFGlNode<SDFOctahedronGlParamsConfig> {
	paramsConfig: SDFOctahedronGlParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class SDFOctogonalPrismGlParamsConfig extends NodeParamsConfig {
	position: ParamTemplate<ParamType.VECTOR3>;
	center: ParamTemplate<ParamType.VECTOR3>;
	radius: ParamTemplate<ParamType.FLOAT>;
	height: ParamTemplate<ParamType.FLOAT>;
}
declare class SDFOctogonalPrismGlNode extends BaseSDFGlNode<SDFOctogonalPrismGlParamsConfig> {
	paramsConfig: SDFOctogonalPrismGlParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class SDFOnionGlParamsConfig extends NodeParamsConfig {}
declare class SDFOnionGlNode extends TypedGlNode<SDFOnionGlParamsConfig> {
	paramsConfig: SDFOnionGlParamsConfig;
	static type(): string;
	initializeNode(): void;
	paramDefaultValue(name: string): number;
	private _glInputName;
	private _glOutputName;
	private _expectedInputTypes;
	private _expectedOutputTypes;
	setLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class SDFPlaneGlParamsConfig extends NodeParamsConfig {
	position: ParamTemplate<ParamType.VECTOR3>;
	center: ParamTemplate<ParamType.VECTOR3>;
	normal: ParamTemplate<ParamType.VECTOR3>;
	offset: ParamTemplate<ParamType.FLOAT>;
}
declare class SDFPlaneGlNode extends BaseSDFGlNode<SDFPlaneGlParamsConfig> {
	paramsConfig: SDFPlaneGlParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class SDFPyramidGlParamsConfig extends NodeParamsConfig {
	position: ParamTemplate<ParamType.VECTOR3>;
	center: ParamTemplate<ParamType.VECTOR3>;
	height: ParamTemplate<ParamType.FLOAT>;
}
declare class SDFPyramidGlNode extends BaseSDFGlNode<SDFPyramidGlParamsConfig> {
	paramsConfig: SDFPyramidGlParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class SDFQuadGlParamsConfig extends NodeParamsConfig {
	position: ParamTemplate<ParamType.VECTOR3>;
	center: ParamTemplate<ParamType.VECTOR3>;
	a: ParamTemplate<ParamType.VECTOR3>;
	b: ParamTemplate<ParamType.VECTOR3>;
	c: ParamTemplate<ParamType.VECTOR3>;
	d: ParamTemplate<ParamType.VECTOR3>;
	thickness: ParamTemplate<ParamType.FLOAT>;
}
declare class SDFQuadGlNode extends BaseSDFGlNode<SDFQuadGlParamsConfig> {
	paramsConfig: SDFQuadGlParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class SDFRepeatGlParamsConfig extends NodeParamsConfig {
	position: ParamTemplate<ParamType.VECTOR3>;
	center: ParamTemplate<ParamType.VECTOR3>;
	period: ParamTemplate<ParamType.VECTOR3>;
	repeatX: ParamTemplate<ParamType.BOOLEAN>;
	repeatY: ParamTemplate<ParamType.BOOLEAN>;
	repeatZ: ParamTemplate<ParamType.BOOLEAN>;
	clamped: ParamTemplate<ParamType.BOOLEAN>;
	clampedX: ParamTemplate<ParamType.BOOLEAN>;
	boundX: ParamTemplate<ParamType.VECTOR2>;
	clampedY: ParamTemplate<ParamType.BOOLEAN>;
	boundY: ParamTemplate<ParamType.VECTOR2>;
	clampedZ: ParamTemplate<ParamType.BOOLEAN>;
	boundZ: ParamTemplate<ParamType.VECTOR2>;
}
declare class SDFRepeatGlNode extends BaseSDFGlNode<SDFRepeatGlParamsConfig> {
	paramsConfig: SDFRepeatGlParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(shadersCollectionController: ShadersCollectionController): void;
	private _clampedAxisesCount;
	repeatAll(): boolean;
	clamped(): boolean;
	clampedX(): boolean;
	clampedY(): boolean;
	clampedZ(): boolean;
	clampedAll(): boolean;
	private _functionSuffixUnclamped;
}
declare class SDFRepeatPolarGlParamsConfig extends NodeParamsConfig {
	position: ParamTemplate<ParamType.VECTOR3>;
	center: ParamTemplate<ParamType.VECTOR3>;
	periodLon: ParamTemplate<ParamType.FLOAT>;
}
declare class SDFRepeatPolarGlNode extends BaseSDFGlNode<SDFRepeatPolarGlParamsConfig> {
	paramsConfig: SDFRepeatPolarGlParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(shadersCollectionController: ShadersCollectionController): void;
}
declare enum SDFRevolutionAxis {
	X = 'X',
	Y = 'Y',
	Z = 'Z',
}
declare class SDFRevolutionGlParamsConfig extends NodeParamsConfig {
	position: ParamTemplate<ParamType.VECTOR3>;
	center: ParamTemplate<ParamType.VECTOR3>;
	radius: ParamTemplate<ParamType.FLOAT>;
	axis: ParamTemplate<ParamType.INTEGER>;
}
declare class SDFRevolutionGlNode extends BaseSDFGlNode<SDFRevolutionGlParamsConfig> {
	paramsConfig: SDFRevolutionGlParamsConfig;
	static type(): string;
	initializeNode(): void;
	setAxis(axis: SDFRevolutionAxis): void;
	setLines(shadersCollectionController: ShadersCollectionController): void;
	private _functionName;
}
declare class SDFRhombusGlParamsConfig extends NodeParamsConfig {
	position: ParamTemplate<ParamType.VECTOR3>;
	center: ParamTemplate<ParamType.VECTOR3>;
	length1: ParamTemplate<ParamType.FLOAT>;
	length2: ParamTemplate<ParamType.FLOAT>;
	height: ParamTemplate<ParamType.FLOAT>;
	radius: ParamTemplate<ParamType.FLOAT>;
}
declare class SDFRhombusGlNode extends BaseSDFGlNode<SDFRhombusGlParamsConfig> {
	paramsConfig: SDFRhombusGlParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class SDFRhombusTriacontahedronGlParamsConfig extends NodeParamsConfig {
	position: ParamTemplate<ParamType.VECTOR3>;
	center: ParamTemplate<ParamType.VECTOR3>;
	m1: ParamTemplate<ParamType.FLOAT>;
	m2: ParamTemplate<ParamType.FLOAT>;
	f: ParamTemplate<ParamType.FLOAT>;
}
declare class SDFRhombusTriacontahedronGlNode extends BaseSDFGlNode<SDFRhombusTriacontahedronGlParamsConfig> {
	paramsConfig: SDFRhombusTriacontahedronGlParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class SDFSolidAngleGlParamsConfig extends NodeParamsConfig {
	position: ParamTemplate<ParamType.VECTOR3>;
	center: ParamTemplate<ParamType.VECTOR3>;
	angle: ParamTemplate<ParamType.FLOAT>;
	radius: ParamTemplate<ParamType.FLOAT>;
}
declare class SDFSolidAngleGlNode extends BaseSDFGlNode<SDFSolidAngleGlParamsConfig> {
	paramsConfig: SDFSolidAngleGlParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class SDFSphereGlParamsConfig extends NodeParamsConfig {
	position: ParamTemplate<ParamType.VECTOR3>;
	center: ParamTemplate<ParamType.VECTOR3>;
	radius: ParamTemplate<ParamType.FLOAT>;
}
declare class SDFSphereGlNode extends BaseSDFGlNode<SDFSphereGlParamsConfig> {
	paramsConfig: SDFSphereGlParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class SDFSphereCutGlParamsConfig extends NodeParamsConfig {
	position: ParamTemplate<ParamType.VECTOR3>;
	center: ParamTemplate<ParamType.VECTOR3>;
	radius: ParamTemplate<ParamType.FLOAT>;
	height: ParamTemplate<ParamType.FLOAT>;
}
declare class SDFSphereCutGlNode extends BaseSDFGlNode<SDFSphereCutGlParamsConfig> {
	paramsConfig: SDFSphereCutGlParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class SDFSphereHollowGlParamsConfig extends NodeParamsConfig {
	position: ParamTemplate<ParamType.VECTOR3>;
	center: ParamTemplate<ParamType.VECTOR3>;
	radius: ParamTemplate<ParamType.FLOAT>;
	height: ParamTemplate<ParamType.FLOAT>;
	thickness: ParamTemplate<ParamType.FLOAT>;
}
declare class SDFSphereHollowGlNode extends BaseSDFGlNode<SDFSphereHollowGlParamsConfig> {
	paramsConfig: SDFSphereHollowGlParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class SDFSubtractGlParamsConfig extends NodeParamsConfig {
	smooth: ParamTemplate<ParamType.BOOLEAN>;
}
declare class SDFSubtractGlNode extends TypedGlNode<SDFSubtractGlParamsConfig> {
	paramsConfig: SDFSubtractGlParamsConfig;
	static type(): string;
	initializeNode(): void;
	private _glInputName;
	private _glOutputName;
	private _expectedInputTypes;
	private _expectedOutputTypes;
	setLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class SDFTorusGlParamsConfig extends NodeParamsConfig {
	position: ParamTemplate<ParamType.VECTOR3>;
	center: ParamTemplate<ParamType.VECTOR3>;
	radius1: ParamTemplate<ParamType.FLOAT>;
	radius2: ParamTemplate<ParamType.FLOAT>;
	capped: ParamTemplate<ParamType.BOOLEAN>;
	angle: ParamTemplate<ParamType.FLOAT>;
}
declare class SDFTorusGlNode extends BaseSDFGlNode<SDFTorusGlParamsConfig> {
	paramsConfig: SDFTorusGlParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class SDFTransformGlParamsConfig extends NodeParamsConfig {
	position: ParamTemplate<ParamType.VECTOR3>;
	t: ParamTemplate<ParamType.VECTOR3>;
	r: ParamTemplate<ParamType.VECTOR3>;
}
declare class SDFTransformGlNode extends BaseSDFGlNode<SDFTransformGlParamsConfig> {
	paramsConfig: SDFTransformGlParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class SDFTriangleGlParamsConfig extends NodeParamsConfig {
	position: ParamTemplate<ParamType.VECTOR3>;
	center: ParamTemplate<ParamType.VECTOR3>;
	a: ParamTemplate<ParamType.VECTOR3>;
	b: ParamTemplate<ParamType.VECTOR3>;
	c: ParamTemplate<ParamType.VECTOR3>;
	thickness: ParamTemplate<ParamType.FLOAT>;
}
declare class SDFTriangleGlNode extends BaseSDFGlNode<SDFTriangleGlParamsConfig> {
	paramsConfig: SDFTriangleGlParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class SDFTriangularPrismGlParamsConfig extends NodeParamsConfig {
	position: ParamTemplate<ParamType.VECTOR3>;
	center: ParamTemplate<ParamType.VECTOR3>;
	radius: ParamTemplate<ParamType.FLOAT>;
	height: ParamTemplate<ParamType.FLOAT>;
}
declare class SDFTriangularPrismGlNode extends BaseSDFGlNode<SDFTriangularPrismGlParamsConfig> {
	paramsConfig: SDFTriangularPrismGlParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class SDFTubeGlParamsConfig extends NodeParamsConfig {
	position: ParamTemplate<ParamType.VECTOR3>;
	center: ParamTemplate<ParamType.VECTOR3>;
	capped: ParamTemplate<ParamType.BOOLEAN>;
	radius: ParamTemplate<ParamType.FLOAT>;
	height: ParamTemplate<ParamType.FLOAT>;
}
declare class SDFTubeGlNode extends BaseSDFGlNode<SDFTubeGlParamsConfig> {
	paramsConfig: SDFTubeGlParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class SDFTwistGlParamsConfig extends NodeParamsConfig {
	position: ParamTemplate<ParamType.VECTOR3>;
	center: ParamTemplate<ParamType.VECTOR3>;
	twist: ParamTemplate<ParamType.FLOAT>;
	axis: ParamTemplate<ParamType.INTEGER>;
}
declare class SDFTwistGlNode extends BaseSDFGlNode<SDFTwistGlParamsConfig> {
	paramsConfig: SDFTwistGlParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(shadersCollectionController: ShadersCollectionController): void;
	private _functionSuffix;
}
declare class SDFUnionGlParamsConfig extends NodeParamsConfig {
	smooth: ParamTemplate<ParamType.BOOLEAN>;
}
declare class SDFUnionGlNode extends TypedGlNode<SDFUnionGlParamsConfig> {
	paramsConfig: SDFUnionGlParamsConfig;
	static type(): string;
	initializeNode(): void;
	private _glInputName;
	private _glOutputName;
	private _expectedInputTypes;
	private _expectedOutputTypes;
	setLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class VATDataGlParamsConfig extends NodeParamsConfig {
	color: ParamTemplate<ParamType.COLOR>;
	thickness: ParamTemplate<ParamType.FLOAT>;
	power: ParamTemplate<ParamType.FLOAT>;
	scale: ParamTemplate<ParamType.FLOAT>;
	distortion: ParamTemplate<ParamType.FLOAT>;
	ambient: ParamTemplate<ParamType.FLOAT>;
	attenuation: ParamTemplate<ParamType.FLOAT>;
}
declare class SSSModelGlNode extends TypedGlNode<VATDataGlParamsConfig> {
	paramsConfig: VATDataGlParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(shaders_collection_controller: ShadersCollectionController): void;
	private _paramLineFloat;
}
declare class SphereGlParamsConfig extends NodeParamsConfig {
	position: ParamTemplate<ParamType.VECTOR3>;
	center: ParamTemplate<ParamType.VECTOR3>;
	radius: ParamTemplate<ParamType.FLOAT>;
	feather: ParamTemplate<ParamType.FLOAT>;
}
declare class SphereGlNode extends TypedGlNode<SphereGlParamsConfig> {
	paramsConfig: SphereGlParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(shaders_collection_controller: ShadersCollectionController): void;
}
declare class SwitchParamsConfig extends NodeParamsConfig {}
declare class SwitchGlNode extends TypedGlNode<SwitchParamsConfig> {
	paramsConfig: SwitchParamsConfig;
	static type(): string;
	static INPUT_INDEX: string;
	initializeNode(): void;
	protected _gl_input_name(index: number): string;
	protected _expected_input_types(): GlConnectionPointType[];
	protected _expected_output_types(): GlConnectionPointType[];
	setLines(shaders_collection_controller: ShadersCollectionController): void;
}
declare class TextureGlParamsConfig extends NodeParamsConfig {
	paramName: ParamTemplate<ParamType.STRING>;
	uv: ParamTemplate<ParamType.VECTOR2>;
	tblur: ParamTemplate<ParamType.BOOLEAN>;
	resolution: ParamTemplate<ParamType.VECTOR2>;
	blurPixelsCountX: ParamTemplate<ParamType.INTEGER>;
	blurPixelsCountY: ParamTemplate<ParamType.INTEGER>;
}
declare class TextureGlNode extends TypedGlNode<TextureGlParamsConfig> {
	paramsConfig: TextureGlParamsConfig;
	static type(): Readonly<'texture'>;
	static readonly OUTPUT_NAME = 'rgba';
	initializeNode(): void;
	setLines(shaders_collection_controller: ShadersCollectionController): void;
	paramsGenerating(): boolean;
	setParamConfigs(): void;
	uniformName(): string;
}
declare class Texture2DArrayGlParamsConfig extends NodeParamsConfig {
	paramName: ParamTemplate<ParamType.STRING>;
	uv: ParamTemplate<ParamType.VECTOR2>;
	layer: ParamTemplate<ParamType.INTEGER>;
}
declare class Texture2DArrayGlNode extends TypedGlNode<Texture2DArrayGlParamsConfig> {
	paramsConfig: Texture2DArrayGlParamsConfig;
	static type(): Readonly<'texture2DArray'>;
	static readonly OUTPUT_NAME = 'rgba';
	initializeNode(): void;
	setLines(shaders_collection_controller: ShadersCollectionController): void;
	paramsGenerating(): boolean;
	setParamConfigs(): void;
	uniformName(): string;
}
declare class TextureSDFGlParamsConfig extends NodeParamsConfig {
	paramName: ParamTemplate<ParamType.STRING>;
	position: ParamTemplate<ParamType.VECTOR3>;
	center: ParamTemplate<ParamType.VECTOR3>;
	boundMin: ParamTemplate<ParamType.VECTOR3>;
	boundMax: ParamTemplate<ParamType.VECTOR3>;
	boundScale: ParamTemplate<ParamType.VECTOR3>;
	bias: ParamTemplate<ParamType.FLOAT>;
	tblur: ParamTemplate<ParamType.BOOLEAN>;
	blurDist: ParamTemplate<ParamType.FLOAT>;
}
declare class TextureSDFGlNode extends BaseSDFGlNode<TextureSDFGlParamsConfig> {
	paramsConfig: TextureSDFGlParamsConfig;
	static type(): Readonly<'textureSDF'>;
	static readonly OUTPUT_NAME = 'd';
	initializeNode(): void;
	setLines(shadersCollectionController: ShadersCollectionController): void;
	paramsGenerating(): boolean;
	setParamConfigs(): void;
	uniformName(): string;
}
declare class TileUvGlParamsConfig extends NodeParamsConfig {
	uv: ParamTemplate<ParamType.VECTOR2>;
	tile: ParamTemplate<ParamType.FLOAT>;
	tilesCount: ParamTemplate<ParamType.VECTOR2>;
}
declare class TileUvGlNode extends TypedGlNode<TileUvGlParamsConfig> {
	paramsConfig: TileUvGlParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(shaders_collection_controller: ShadersCollectionController): void;
}
declare class ToWorldSpaceGlParamsConfig extends NodeParamsConfig {
	vec: ParamTemplate<ParamType.VECTOR3>;
	interpretation: ParamTemplate<ParamType.INTEGER>;
}
declare class ToWorldSpaceGlNode extends TypedGlNode<ToWorldSpaceGlParamsConfig> {
	paramsConfig: ToWorldSpaceGlParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(shaders_collection_controller: ShadersCollectionController): void;
}
declare enum TwoWaySwitchGlNodeInputName {
	CONDITION = 'condition',
	IF_TRUE = 'ifTrue',
	IF_FALSE = 'ifFalse',
}
declare class TwoWaySwitchGlNode extends ParamlessTypedGlNode {
	static type(): string;
	initializeNode(): void;
	protected _gl_input_name(index: number): TwoWaySwitchGlNodeInputName;
	protected _gl_output_name(): string;
	protected _expected_input_types(): GlConnectionPointType[];
	protected _expected_output_types(): GlConnectionPointType[];
	setLines(shaders_collection_controller: ShadersCollectionController): void;
}
declare class UvToOklabGlParamsConfig extends NodeParamsConfig {
	uvw: ParamTemplate<ParamType.VECTOR3>;
}
declare class UvToOklabGlNode extends TypedGlNode<UvToOklabGlParamsConfig> {
	paramsConfig: UvToOklabGlParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(shaders_collection_controller: ShadersCollectionController): void;
}
declare class VaryingWriteGlParamsConfig extends NodeParamsConfig {
	name: ParamTemplate<ParamType.STRING>;
	type: ParamTemplate<ParamType.INTEGER>;
}
declare class VaryingWriteGlNode extends TypedGlNode<VaryingWriteGlParamsConfig> {
	paramsConfig: VaryingWriteGlParamsConfig;
	static type(): Readonly<GlType.VARYING_WRITE>;
	static readonly INPUT_NAME = 'vertex';
	initializeNode(): void;
	inputName(): string;
	setLines(shaders_collection_controller: ShadersCollectionController): void;
	attributeName(): string;
	glType(): GlConnectionPointType | undefined;
	setGlType(type: GlConnectionPointType): void;
}
declare class VaryingReadGlParamsConfig extends NodeParamsConfig {
	name: ParamTemplate<ParamType.STRING>;
	type: ParamTemplate<ParamType.INTEGER>;
}
declare class VaryingReadGlNode extends TypedGlNode<VaryingReadGlParamsConfig> {
	paramsConfig: VaryingReadGlParamsConfig;
	static type(): Readonly<'varyingRead'>;
	static readonly OUTPUT_NAME = 'fragment';
	initializeNode(): void;
	outputName(): string;
	setLines(shaders_collection_controller: ShadersCollectionController): void;
	attributeName(): string;
	glType(): GlConnectionPointType;
	setGlType(type: GlConnectionPointType): void;
}
declare const VectorAlignGlNode_base: typeof BaseNodeGlMathFunctionArg3GlNode;
declare class VectorAlignGlNode extends VectorAlignGlNode_base {
	protected _expected_input_types(): GlConnectionPointType[];
	protected _expected_output_types(): GlConnectionPointType[];
	paramDefaultValue(name: string): Number3;
}
declare const VectorAngleGlNode_base: typeof BaseNodeGlMathFunctionArg2GlNode;
declare class VectorAngleGlNode extends VectorAngleGlNode_base {
	_expected_input_types(): GlConnectionPointType[];
	_expected_output_types(): GlConnectionPointType[];
	paramDefaultValue(name: string): Number3;
}
export interface GlNodeChildrenMap {
	abs: AbsGlNode;
	acceleration: AccelerationGlNode;
	acos: AcosGlNode;
	add: AddGlNode;
	align: AlignGlNode;
	and: AndGlNode;
	asin: AsinGlNode;
	atan: AtanGlNode;
	attribute: AttributeGlNode;
	boolToInt: BoolToIntGlNode;
	cartesianToPolar: CartesianToPolarGlNode;
	ceil: CeilGlNode;
	clamp: ClampGlNode;
	checkers: CheckersGlNode;
	colorCorrect: ColorCorrectGlNode;
	compare: CompareGlNode;
	complement: ComplementGlNode;
	constant: ConstantGlNode;
	cos: CosGlNode;
	cross: CrossGlNode;
	cycle: CycleGlNode;
	degrees: DegreesGlNode;
	disk: DiskGlNode;
	distance: DistanceGlNode;
	dither: DitherGlNode;
	divide: DivideGlNode;
	dot: DotGlNode;
	easing: EasingGlNode;
	exp: ExpGlNode;
	exp2: Exp2GlNode;
	faceForward: FaceforwardGlNode;
	fit: FitGlNode;
	fitTo01: FitTo01GlNode;
	fitFrom01: FitFrom01GlNode;
	fitFrom01ToVariance: FitFrom01ToVarianceGlNode;
	floatToInt: FloatToIntGlNode;
	floatToVec2: FloatToVec2GlNode;
	floatToVec3: FloatToVec3GlNode;
	floatToVec4: FloatToVec4GlNode;
	floor: FloorGlNode;
	fract: FractGlNode;
	fresnel: FresnelGlNode;
	fog: FogGlNode;
	forLoop: ForLoopGlNode;
	globals: GlobalsGlNode;
	grid: GridGlNode;
	hsluvToRgb: HsluvToRgbGlNode;
	hsvToRgb: HsvToRgbGlNode;
	ifThen: IfThenGlNode;
	impostorUv: ImpostorUvGlNode;
	inRange: InRangeGlNode;
	intToBool: IntToBoolGlNode;
	intToFloat: IntToFloatGlNode;
	inverseSqrt: InverseSqrtGlNode;
	instanceTransform: InstanceTransformGlNode;
	isInfOrNan: IsInfOrNanGlNode;
	length: LengthGlNode;
	log: LogGlNode;
	log2: Log2GlNode;
	luminance: LuminanceGlNode;
	max: MaxGlNode;
	maxLength: MaxLengthGlNode;
	min: MinGlNode;
	mix: MixGlNode;
	mod: ModGlNode;
	modelViewMatrixMult: ModelViewMatrixMultGlNode;
	mult: MultGlNode;
	multAdd: MultAddGlNode;
	multScalar: MultScalarGlNode;
	negate: NegateGlNode;
	neighbourAttract: NeighbourAttractGlNode;
	neighbourAttractRepulse: NeighbourAttractRepulseGlNode;
	neighbourDensity: NeighbourDensityGlNode;
	neighbourRepulse: NeighbourRepulseGlNode;
	noise: NoiseGlNode;
	normalize: NormalizeGlNode;
	null: NullGlNode;
	oklabToRgb: OklabToRgbGlNode;
	or: OrGlNode;
	output: OutputGlNode;
	param: ParamGlNode;
	polarToCartesian: PolarToCartesianGlNode;
	pow: PowGlNode;
	quatMult: QuatMultGlNode;
	quatFromAxisAngle: QuatFromAxisAngleGlNode;
	quatSlerp: QuatSlerpGlNode;
	quatToAngle: QuatToAngleGlNode;
	quatToAxis: QuatToAxisGlNode;
	radians: RadiansGlNode;
	ramp: RampGlNode;
	random: RandomGlNode;
	reflect: ReflectGlNode;
	refract: RefractGlNode;
	rgbToHsv: RgbToHsvGlNode;
	rotate: RotateGlNode;
	round: RoundGlNode;
	sign: SignGlNode;
	sin: SinGlNode;
	smoothstep: SmoothstepGlNode;
	sphere: SphereGlNode;
	sqrt: SqrtGlNode;
	SDF2DBox: SDF2DBoxGlNode;
	SDF2DCircle: SDF2DCircleGlNode;
	SDF2DCross: SDF2DCrossGlNode;
	SDF2DHeart: SDF2DHeartGlNode;
	SDF2DRoundedX: SDF2DRoundedXGlNode;
	SDF2DStairs: SDF2DStairsGlNode;
	SDFBox: SDFBoxGlNode;
	SDFBoxFrame: SDFBoxFrameGlNode;
	SDFBoxRound: SDFBoxRoundGlNode;
	SDFCapsule: SDFCapsuleGlNode;
	SDFCapsuleVertical: SDFCapsuleVerticalGlNode;
	SDFCone: SDFConeGlNode;
	SDFConeRound: SDFConeRoundGlNode;
	SDFContext: SDFContextGlNode;
	SDFElongate: SDFElongateGlNode;
	SDFExtrude: SDFExtrudeGlNode;
	SDFFractalMandelbrot: SDFFractalMandelbrotGlNode;
	SDFGradient: SDFGradientGlNode;
	SDFHexagonalPrism: SDFHexagonalPrismGlNode;
	SDFHorseShoe: SDFHorseShoeGlNode;
	SDFIntersect: SDFIntersectGlNode;
	SDFLink: SDFLinkGlNode;
	SDFMaterial: SDFMaterialGlNode;
	SDFMax: SDFMaxGlNode;
	SDFMin: SDFMinGlNode;
	SDFMirror: SDFMirrorGlNode;
	SDFOctahedron: SDFOctahedronGlNode;
	SDFOctogonalPrism: SDFOctogonalPrismGlNode;
	SDFOnion: SDFOnionGlNode;
	SDFPlane: SDFPlaneGlNode;
	SDFPyramid: SDFPyramidGlNode;
	SDFQuad: SDFQuadGlNode;
	SDFRepeat: SDFRepeatGlNode;
	SDFRepeatPolar: SDFRepeatPolarGlNode;
	SDFRevolution: SDFRevolutionGlNode;
	SDFRhombus: SDFRhombusGlNode;
	SDFRhombusTriacontahedron: SDFRhombusTriacontahedronGlNode;
	SDFSolidAngle: SDFSolidAngleGlNode;
	SDFSphere: SDFSphereGlNode;
	SDFSphereCut: SDFSphereCutGlNode;
	SDFSphereHollow: SDFSphereHollowGlNode;
	SDFSubtract: SDFSubtractGlNode;
	SDFTorus: SDFTorusGlNode;
	SDFTube: SDFTubeGlNode;
	SDFTransform: SDFTransformGlNode;
	SDFTriangle: SDFTriangleGlNode;
	SDFTriangularPrism: SDFTriangularPrismGlNode;
	SDFTwist: SDFTwistGlNode;
	SDFUnion: SDFUnionGlNode;
	SSSModel: SSSModelGlNode;
	step: StepGlNode;
	subnet: SubnetGlNode;
	subnetInput: SubnetInputGlNode;
	subnetOutput: SubnetOutputGlNode;
	subtract: SubtractGlNode;
	switch: SwitchGlNode;
	tan: TanGlNode;
	texture: TextureGlNode;
	texture2DArray: Texture2DArrayGlNode;
	textureSDF: TextureSDFGlNode;
	tileUv: TileUvGlNode;
	toWorldSpace: ToWorldSpaceGlNode;
	twoWaySwitch: TwoWaySwitchGlNode;
	uvToOklab: UvToOklabGlNode;
	varyingWrite: VaryingWriteGlNode;
	varyingRead: VaryingReadGlNode;
	vec2ToFloat: Vec2ToFloatGlNode;
	vec2ToVec3: Vec2ToVec3GlNode;
	vec3ToFloat: Vec3ToFloatGlNode;
	vec3ToVec2: Vec3ToVec2GlNode;
	vec3ToVec4: Vec3ToVec4GlNode;
	vec4ToFloat: Vec4ToFloatGlNode;
	vec4ToVec3: Vec4ToVec3GlNode;
	vectorAlign: VectorAlignGlNode;
	vectorAngle: VectorAngleGlNode;
}
declare const MatBuilderParamsConfig_base: {
	new (...args: any[]): {
		/** @param if toggled on, the shader will be built from the gl nodes of another material. This can be useful to have multiple materials use the same gl network, but still set the uniforms differently */
		setBuilderNode: ParamTemplate<ParamType.BOOLEAN>;
		/** @param builder node */
		builderNode: ParamTemplate<ParamType.NODE_PATH>;
	};
} & typeof NodeParamsConfig;
declare class MatBuilderParamsConfig extends MatBuilderParamsConfig_base {}
declare abstract class TypedBuilderMatNode<
	M extends MaterialWithCustomMaterials,
	A extends ShaderAssemblerMaterial,
	K extends MatBuilderParamsConfig
> extends PrimitiveMatNode<M, K> {
	protected _assemblerController: GlAssemblerController<A> | undefined;
	protected _childrenControllerContext: NodeContext;
	readonly persisted_config: MaterialPersistedConfig;
	createMaterial(): M;
	assemblerController(): GlAssemblerController<A> | undefined;
	protected abstract _createAssemblerController(): GlAssemblerController<A> | undefined;
	customMaterialRequested(customName: CustomMaterialName): boolean;
	createNode<S extends keyof GlNodeChildrenMap>(node_class: S, options?: NodeCreateOptions): GlNodeChildrenMap[S];
	createNode<K extends valueof<GlNodeChildrenMap>>(node_class: Constructor<K>, options?: NodeCreateOptions): K;
	children(): BaseGlNodeType[];
	nodesByType<K extends keyof GlNodeChildrenMap>(type: K): GlNodeChildrenMap[K][];
	childrenAllowed(): boolean;
	sceneReadonly(): boolean;
	compileIfRequired(material: M): void;
	protected _compile(material: M): void;
	private _setAssemblerGlParentNode;
	static PARAM_CALLBACK_setCompileRequired(node: BaseBuilderMatNodeType): void;
	private PARAM_CALLBACK_setCompileRequired;
}
export declare type BaseBuilderMatNodeType = TypedBuilderMatNode<
	MaterialWithCustomMaterials,
	ShaderAssemblerMaterial,
	MatBuilderParamsConfig
>;
export interface LineBasicBuilderControllers extends AdvancedCommonControllers, UniformsTransparencyControllers {}
export interface LineBasicBuilderMaterial extends LineBasicMaterial {
	vertexShader: string;
	fragmentShader: string;
	customMaterials: {
		[key in CustomMaterialName]?: Material;
	};
}
declare const LineBasicBuilderMatParamsConfig_base: {
	new (...args: any[]): {
		doubleSided: ParamTemplate<ParamType.BOOLEAN>;
		front: ParamTemplate<ParamType.BOOLEAN>;
		overrideShadowSide: ParamTemplate<ParamType.BOOLEAN>;
		shadowDoubleSided: ParamTemplate<ParamType.BOOLEAN>;
		shadowFront: ParamTemplate<ParamType.BOOLEAN>;
		colorWrite: ParamTemplate<ParamType.BOOLEAN>;
		depthWrite: ParamTemplate<ParamType.BOOLEAN>;
		depthTest: ParamTemplate<ParamType.BOOLEAN>;
		premultipliedAlpha: ParamTemplate<ParamType.BOOLEAN>;
		blending: ParamTemplate<ParamType.INTEGER>;
		dithering: ParamTemplate<ParamType.BOOLEAN>;
		polygonOffset: ParamTemplate<ParamType.BOOLEAN>;
		polygonOffsetFactor: ParamTemplate<ParamType.INTEGER>;
		polygonOffsetUnits: ParamTemplate<ParamType.INTEGER>;
	};
} & {
	new (...args: any[]): {
		setBuilderNode: ParamTemplate<ParamType.BOOLEAN>;
		builderNode: ParamTemplate<ParamType.NODE_PATH>;
	};
} & {
	new (...args: any[]): {
		advanced: ParamTemplate<ParamType.FOLDER>;
	};
} & {
	new (...args: any[]): {
		transparent: ParamTemplate<ParamType.BOOLEAN>;
		opacity: ParamTemplate<ParamType.FLOAT>;
		alphaTest: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		default: ParamTemplate<ParamType.FOLDER>;
	};
} & typeof NodeParamsConfig;
declare class LineBasicBuilderMatParamsConfig extends LineBasicBuilderMatParamsConfig_base {
	linewidth: ParamTemplate<ParamType.FLOAT>;
}
declare class LineBasicBuilderMatNode extends TypedBuilderMatNode<
	LineBasicBuilderMaterial,
	ShaderAssemblerLine,
	LineBasicBuilderMatParamsConfig
> {
	paramsConfig: LineBasicBuilderMatParamsConfig;
	static type(): MatType;
	usedAssembler(): Readonly<AssemblerName.GL_LINE>;
	protected _createAssemblerController(): GlAssemblerController<ShaderAssemblerLine> | undefined;
	readonly controllers: LineBasicBuilderControllers;
	protected controllersList: any[];
	cook(): Promise<void>;
}
export declare type TextureMapCurrentMaterial =
	| MeshBasicMaterial
	| MeshLambertMaterial
	| MeshMatcapMaterial
	| MeshPhongMaterial
	| MeshStandardMaterial
	| MeshPhysicalMaterial
	| MeshToonMaterial
	| PointsMaterial;
declare const TextureMapParamsConfig_base: {
	new (...args: any[]): {
		/** @param toggle on to use a map affecting color */
		useMap: ParamTemplate<ParamType.BOOLEAN>;
		/** @param texture map affecting color */
		map: ParamTemplate<ParamType.NODE_PATH>;
	};
} & typeof NodeParamsConfig;
declare class TextureMapParamsConfig extends TextureMapParamsConfig_base {}
export interface TextureMapControllers {
	map: TextureMapController;
}
declare abstract class TextureMapMatNode extends TypedMatNode<TextureMapCurrentMaterial, TextureMapParamsConfig> {
	controllers: TextureMapControllers;
	material(): Promise<TextureMapCurrentMaterial | undefined>;
}
declare class TextureMapController extends BaseTextureMapController {
	protected node: TextureMapMatNode;
	constructor(node: TextureMapMatNode);
	initializeNode(): void;
	static update(node: TextureMapMatNode): Promise<void>;
	update(): Promise<void>;
	updateMaterial(material: TextureMapCurrentMaterial): Promise<void>;
	getTextures(material: TextureMapCurrentMaterial, record: MaterialTexturesRecord): void;
	setParamsFromMaterial(material: TextureMapCurrentMaterial, record: SetParamsTextureNodesRecord): void;
}
export declare type TextureAlphaMapControllerCurrentMaterial =
	| MeshBasicMaterial
	| MeshLambertMaterial
	| MeshPhongMaterial
	| MeshStandardMaterial
	| MeshPhysicalMaterial
	| MeshMatcapMaterial
	| MeshToonMaterial
	| PointsMaterial;
declare const TextureAlphaMapParamsConfig_base: {
	new (...args: any[]): {
		/** @param toggle if you want to use an alpha map */
		useAlphaMap: ParamTemplate<ParamType.BOOLEAN>;
		/** @param specify the alpha map COP node */
		alphaMap: ParamTemplate<ParamType.NODE_PATH>;
	};
} & typeof NodeParamsConfig;
declare class TextureAlphaMapParamsConfig extends TextureAlphaMapParamsConfig_base {}
export interface TextureAlphaMapControllers {
	alphaMap: TextureAlphaMapController;
}
declare abstract class TextureAlphaMapMatNode extends TypedMatNode<
	TextureAlphaMapControllerCurrentMaterial,
	TextureAlphaMapParamsConfig
> {
	controllers: TextureAlphaMapControllers;
	material(): Promise<TextureAlphaMapControllerCurrentMaterial | undefined>;
}
declare class TextureAlphaMapController extends BaseTextureMapController {
	protected node: TextureAlphaMapMatNode;
	constructor(node: TextureAlphaMapMatNode);
	initializeNode(): void;
	static update(node: TextureAlphaMapMatNode): Promise<void>;
	update(): Promise<void>;
	updateMaterial(material: TextureAlphaMapControllerCurrentMaterial): Promise<void>;
	getTextures(material: TextureAlphaMapControllerCurrentMaterial, record: MaterialTexturesRecord): void;
	setParamsFromMaterial(
		material: TextureAlphaMapControllerCurrentMaterial,
		record: SetParamsTextureNodesRecord
	): void;
}
export declare type TextureAOMapControllerCurrentMaterial =
	| MeshBasicMaterial
	| MeshLambertMaterial
	| MeshStandardMaterial
	| MeshPhysicalMaterial
	| MeshToonMaterial;
declare const TextureAOMapParamsConfig_base: {
	new (...args: any[]): {
		/** @param toggle if you want to use an ambient occlusion map */
		useAOMap: ParamTemplate<ParamType.BOOLEAN>;
		/** @param specify the AO map COP node */
		aoMap: ParamTemplate<ParamType.NODE_PATH>;
		/** @param ambient occlusion intensity */
		aoMapIntensity: ParamTemplate<ParamType.FLOAT>;
	};
} & typeof NodeParamsConfig;
declare class TextureAOMapParamsConfig extends TextureAOMapParamsConfig_base {}
export interface TextureAOMapControllers {
	aoMap: TextureAOMapController;
}
declare abstract class TextureAOMapMatNode extends TypedMatNode<
	TextureAOMapControllerCurrentMaterial,
	TextureAOMapParamsConfig
> {
	controllers: TextureAOMapControllers;
	material(): Promise<TextureAOMapControllerCurrentMaterial | undefined>;
}
declare class TextureAOMapController extends BaseTextureMapController {
	protected node: TextureAOMapMatNode;
	constructor(node: TextureAOMapMatNode);
	initializeNode(): void;
	static update(node: TextureAOMapMatNode): Promise<void>;
	update(): Promise<void>;
	updateMaterial(material: TextureAOMapControllerCurrentMaterial): Promise<void>;
	getTextures(material: TextureAOMapControllerCurrentMaterial, record: MaterialTexturesRecord): void;
	setParamsFromMaterial(material: TextureAOMapControllerCurrentMaterial, record: SetParamsTextureNodesRecord): void;
}
export declare type TextureEnvMapSimpleCurrentMaterial = MeshBasicMaterial | MeshLambertMaterial | MeshPhongMaterial;
declare const TextureEnvMapSimpleParamsConfig_base: {
	new (...args: any[]): {
		/** @param toggle if you want to use an environment map */
		useEnvMap: ParamTemplate<ParamType.BOOLEAN>;
		/** @param specify the environment map COP node. Note that this only works with CubeCamera */
		envMap: ParamTemplate<ParamType.NODE_PATH>;
		/** @param defines how the env map is combined with the color */
		combine: ParamTemplate<ParamType.INTEGER>;
		/** @param environment intensity */
		reflectivity: ParamTemplate<ParamType.FLOAT>;
		/** @param refraction ratio */
		refractionRatio: ParamTemplate<ParamType.FLOAT>;
	};
} & typeof NodeParamsConfig;
declare class TextureEnvMapSimpleParamsConfig extends TextureEnvMapSimpleParamsConfig_base {}
export interface TextureEnvMapSimpleControllers {
	envMap: TextureEnvMapSimpleController;
}
declare abstract class TextureEnvMapSimpleMatNode extends TypedMatNode<
	TextureEnvMapSimpleCurrentMaterial,
	TextureEnvMapSimpleParamsConfig
> {
	controllers: TextureEnvMapSimpleControllers;
	material(): Promise<TextureEnvMapSimpleCurrentMaterial | undefined>;
}
declare class TextureEnvMapSimpleController extends BaseTextureMapController {
	protected node: TextureEnvMapSimpleMatNode;
	constructor(node: TextureEnvMapSimpleMatNode);
	initializeNode(): void;
	static update(node: TextureEnvMapSimpleMatNode): Promise<void>;
	update(): Promise<void>;
	updateMaterial(material: TextureEnvMapSimpleCurrentMaterial): Promise<void>;
	getTextures(material: TextureEnvMapSimpleCurrentMaterial, record: MaterialTexturesRecord): void;
	setParamsFromMaterial(material: TextureEnvMapSimpleCurrentMaterial, record: SetParamsTextureNodesRecord): void;
}
export declare type TextureLightMapCurrentMaterial =
	| MeshBasicMaterial
	| MeshLambertMaterial
	| MeshStandardMaterial
	| MeshPhysicalMaterial
	| MeshToonMaterial;
declare const TextureLightMapParamsConfig_base: {
	new (...args: any[]): {
		/** @param toggle if you want to use a light map */
		useLightMap: ParamTemplate<ParamType.BOOLEAN>;
		/** @param specify the light map COP node */
		lightMap: ParamTemplate<ParamType.NODE_PATH>;
		/** @param light. When set to 0, reflections from environment maps will be very sharp, or blurred when 1. Any value between 0 and 1 can help modulate this. */
		lightMapIntensity: ParamTemplate<ParamType.FLOAT>;
	};
} & typeof NodeParamsConfig;
declare class TextureLightMapParamsConfig extends TextureLightMapParamsConfig_base {}
export interface TextureLightMapControllers {
	lightMap: TextureLightMapController;
}
declare abstract class TextureLightMapMatNode extends TypedMatNode<
	TextureLightMapCurrentMaterial,
	TextureLightMapParamsConfig
> {
	controllers: TextureLightMapControllers;
	material(): Promise<TextureLightMapCurrentMaterial | undefined>;
}
declare class TextureLightMapController extends BaseTextureMapController {
	protected node: TextureLightMapMatNode;
	constructor(node: TextureLightMapMatNode);
	initializeNode(): void;
	static update(node: TextureLightMapMatNode): Promise<void>;
	update(): Promise<void>;
	updateMaterial(material: TextureLightMapCurrentMaterial): Promise<void>;
	getTextures(material: TextureLightMapCurrentMaterial, record: MaterialTexturesRecord): void;
	setParamsFromMaterial(material: TextureLightMapCurrentMaterial, record: SetParamsTextureNodesRecord): void;
}
export interface WireframeControllers {
	wireframe: WireframeController;
}
export declare type WireframedMaterial =
	| MeshToonMaterial
	| MeshBasicMaterial
	| MeshStandardMaterial
	| MeshPhysicalMaterial;
declare const WireframeParamsConfig_base: {
	new (...args: any[]): {
		/** @param toggle on to set material to wireframe */
		wireframe: ParamTemplate<ParamType.BOOLEAN>;
		/** @param wireframe line width */
		wireframeLinewidth: ParamTemplate<ParamType.FLOAT>;
		/** @param define appearance of line ends */
		wireframeLinecap: ParamTemplate<ParamType.INTEGER>;
		/** @param Define appearance of line joints */
		wireframeLinejoin: ParamTemplate<ParamType.INTEGER>;
	};
} & typeof NodeParamsConfig;
declare class WireframeParamsConfig extends WireframeParamsConfig_base {}
declare class WireframedMatNode extends TypedMatNode<WireframedMaterial, WireframeParamsConfig> {
	material(): Promise<WireframedMaterial | undefined>;
	controllers: WireframeControllers;
}
declare class WireframeController extends BaseController {
	protected node: WireframedMatNode;
	constructor(node: WireframedMatNode);
	static update(node: WireframedMatNode): Promise<void>;
	updateMaterial(material: WireframedMaterial): void;
	getTextures(material: WireframedMaterial, record: MaterialTexturesRecord): void;
	setParamsFromMaterial(material: WireframedMaterial, record: SetParamsTextureNodesRecord): void;
}
export interface MeshBasicMaterialWithLightMap extends MeshBasicMaterial {
	lightMap: Texture | null;
	lightMapIntensity: number;
}
export interface MeshBasicControllers
	extends AdvancedCommonControllers,
		ColorsControllers,
		FogControllers,
		TextureAlphaMapControllers,
		TextureAOMapControllers,
		TextureEnvMapSimpleControllers,
		TextureLightMapControllers,
		TextureMapControllers,
		WireframeControllers {}
declare const MeshBasicMatParamsConfig_base: {
	new (...args: any[]): {
		useFog: ParamTemplate<ParamType.BOOLEAN>;
	};
} & {
	new (...args: any[]): {
		wireframe: ParamTemplate<ParamType.BOOLEAN>;
		wireframeLinewidth: ParamTemplate<ParamType.FLOAT>;
		wireframeLinecap: ParamTemplate<ParamType.INTEGER>;
		wireframeLinejoin: ParamTemplate<ParamType.INTEGER>;
	};
} & {
	new (...args: any[]): {
		doubleSided: ParamTemplate<ParamType.BOOLEAN>;
		front: ParamTemplate<ParamType.BOOLEAN>;
		overrideShadowSide: ParamTemplate<ParamType.BOOLEAN>;
		shadowDoubleSided: ParamTemplate<ParamType.BOOLEAN>;
		shadowFront: ParamTemplate<ParamType.BOOLEAN>;
		colorWrite: ParamTemplate<ParamType.BOOLEAN>;
		depthWrite: ParamTemplate<ParamType.BOOLEAN>;
		depthTest: ParamTemplate<ParamType.BOOLEAN>;
		premultipliedAlpha: ParamTemplate<ParamType.BOOLEAN>;
		blending: ParamTemplate<ParamType.INTEGER>;
		dithering: ParamTemplate<ParamType.BOOLEAN>;
		polygonOffset: ParamTemplate<ParamType.BOOLEAN>;
		polygonOffsetFactor: ParamTemplate<ParamType.INTEGER>;
		polygonOffsetUnits: ParamTemplate<ParamType.INTEGER>;
	};
} & {
	new (...args: any[]): {
		advanced: ParamTemplate<ParamType.FOLDER>;
	};
} & {
	new (...args: any[]): {
		useLightMap: ParamTemplate<ParamType.BOOLEAN>;
		lightMap: ParamTemplate<ParamType.NODE_PATH>;
		lightMapIntensity: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		useEnvMap: ParamTemplate<ParamType.BOOLEAN>;
		envMap: ParamTemplate<ParamType.NODE_PATH>;
		combine: ParamTemplate<ParamType.INTEGER>;
		reflectivity: ParamTemplate<ParamType.FLOAT>;
		refractionRatio: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		useAOMap: ParamTemplate<ParamType.BOOLEAN>;
		aoMap: ParamTemplate<ParamType.NODE_PATH>;
		aoMapIntensity: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		useAlphaMap: ParamTemplate<ParamType.BOOLEAN>;
		alphaMap: ParamTemplate<ParamType.NODE_PATH>;
	};
} & {
	new (...args: any[]): {
		useMap: ParamTemplate<ParamType.BOOLEAN>;
		map: ParamTemplate<ParamType.NODE_PATH>;
	};
} & {
	new (...args: any[]): {
		textures: ParamTemplate<ParamType.FOLDER>;
	};
} & {
	new (...args: any[]): {
		color: ParamTemplate<ParamType.COLOR>;
		useVertexColors: ParamTemplate<ParamType.BOOLEAN>;
		transparent: ParamTemplate<ParamType.BOOLEAN>;
		opacity: ParamTemplate<ParamType.FLOAT>;
		alphaTest: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		default: ParamTemplate<ParamType.FOLDER>;
	};
} & typeof NodeParamsConfig;
declare class MeshBasicMatParamsConfig extends MeshBasicMatParamsConfig_base {}
declare class MeshBasicMatNode extends PrimitiveMatNode<MeshBasicMaterialWithLightMap, MeshBasicMatParamsConfig> {
	paramsConfig: MeshBasicMatParamsConfig;
	static type(): MatType.MESH_BASIC;
	createMaterial(): MeshBasicMaterialWithLightMap;
	readonly controllers: MeshBasicControllers;
	protected controllersList: any[];
	cook(): Promise<void>;
}
declare abstract class ShaderAssemblerMesh extends ShaderAssemblerMaterial {
	customAssemblerClassByCustomName(): CustomAssemblerMap | undefined;
}
declare class ShaderAssemblerBasic extends ShaderAssemblerMesh {
	templateShader(): {
		vertexShader: string;
		fragmentShader: string;
		uniforms: {
			[uniform: string]: IUniform<any>;
		};
	};
	createMaterial(): MeshBasicMaterial;
}
export interface UniformFogControllers {
	uniformFog: UniformFogController;
}
declare const FogParamsConfig_base: {
	new (...args: any[]): {
		/** @param toggle on if you have a fog in the scene and the material should be affected by it */
		useFog: ParamTemplate<ParamType.BOOLEAN>;
	};
} & typeof NodeParamsConfig;
declare class FogParamsConfig extends FogParamsConfig_base {}
export declare type FoggableMaterial =
	| ShaderMaterial
	| PointsMaterial
	| MeshStandardMaterial
	| MeshPhysicalMaterial
	| MeshPhongMaterial
	| MeshLambertMaterial
	| MeshBasicMaterial;
declare abstract class FogMatNode extends TypedMatNode<FoggableMaterial, FogParamsConfig> {
	controllers: UniformFogControllers;
}
declare class UniformFogController extends BaseController {
	protected node: FogMatNode;
	constructor(node: FogMatNode);
	static update(node: FogMatNode): Promise<void>;
	updateMaterial(material: FoggableMaterial): void;
	getTextures(material: FoggableMaterial, record: MaterialTexturesRecord): void;
	setParamsFromMaterial(material: FoggableMaterial, record: SetParamsTextureNodesRecord): void;
}
export interface MeshBasicBuilderControllers
	extends AdvancedCommonControllers,
		UniformFogControllers,
		TextureAlphaMapControllers,
		TextureAOMapControllers,
		TextureEnvMapSimpleControllers,
		TextureMapControllers,
		UniformsTransparencyControllers,
		WireframeShaderMaterialControllers {}
export interface MeshBasicBuilderMaterial extends MeshBasicMaterial {
	vertexShader: string;
	fragmentShader: string;
	uniforms: IUniforms;
	customMaterials: {
		[key in CustomMaterialName]?: Material;
	};
}
declare const MeshBasicBuilderMatParamsConfig_base: {
	new (...args: any[]): {
		overrideCustomMaterials: ParamTemplate<ParamType.BOOLEAN>;
		createCustomMatDistance: ParamTemplate<ParamType.BOOLEAN>;
		createCustomMatDepth: ParamTemplate<ParamType.BOOLEAN>;
		createCustomMatDepthDOF: ParamTemplate<ParamType.BOOLEAN>;
	};
} & {
	new (...args: any[]): {
		useFog: ParamTemplate<ParamType.BOOLEAN>;
	};
} & {
	new (...args: any[]): {
		wireframe: ParamTemplate<ParamType.BOOLEAN>;
		wireframeLinewidth: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		doubleSided: ParamTemplate<ParamType.BOOLEAN>;
		front: ParamTemplate<ParamType.BOOLEAN>;
		overrideShadowSide: ParamTemplate<ParamType.BOOLEAN>;
		shadowDoubleSided: ParamTemplate<ParamType.BOOLEAN>;
		shadowFront: ParamTemplate<ParamType.BOOLEAN>;
		colorWrite: ParamTemplate<ParamType.BOOLEAN>;
		depthWrite: ParamTemplate<ParamType.BOOLEAN>;
		depthTest: ParamTemplate<ParamType.BOOLEAN>;
		premultipliedAlpha: ParamTemplate<ParamType.BOOLEAN>;
		blending: ParamTemplate<ParamType.INTEGER>;
		dithering: ParamTemplate<ParamType.BOOLEAN>;
		polygonOffset: ParamTemplate<ParamType.BOOLEAN>;
		polygonOffsetFactor: ParamTemplate<ParamType.INTEGER>;
		polygonOffsetUnits: ParamTemplate<ParamType.INTEGER>;
	};
} & {
	new (...args: any[]): {
		setBuilderNode: ParamTemplate<ParamType.BOOLEAN>;
		builderNode: ParamTemplate<ParamType.NODE_PATH>;
	};
} & {
	new (...args: any[]): {
		advanced: ParamTemplate<ParamType.FOLDER>;
	};
} & {
	new (...args: any[]): {
		useEnvMap: ParamTemplate<ParamType.BOOLEAN>;
		envMap: ParamTemplate<ParamType.NODE_PATH>;
		combine: ParamTemplate<ParamType.INTEGER>;
		reflectivity: ParamTemplate<ParamType.FLOAT>;
		refractionRatio: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		useAOMap: ParamTemplate<ParamType.BOOLEAN>;
		aoMap: ParamTemplate<ParamType.NODE_PATH>;
		aoMapIntensity: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		useAlphaMap: ParamTemplate<ParamType.BOOLEAN>;
		alphaMap: ParamTemplate<ParamType.NODE_PATH>;
	};
} & {
	new (...args: any[]): {
		useMap: ParamTemplate<ParamType.BOOLEAN>;
		map: ParamTemplate<ParamType.NODE_PATH>;
	};
} & {
	new (...args: any[]): {
		textures: ParamTemplate<ParamType.FOLDER>;
	};
} & {
	new (...args: any[]): {
		transparent: ParamTemplate<ParamType.BOOLEAN>;
		opacity: ParamTemplate<ParamType.FLOAT>;
		alphaTest: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		default: ParamTemplate<ParamType.FOLDER>;
	};
} & typeof NodeParamsConfig;
declare class MeshBasicBuilderMatParamsConfig extends MeshBasicBuilderMatParamsConfig_base {}
declare class MeshBasicBuilderMatNode extends TypedBuilderMatNode<
	MeshBasicBuilderMaterial,
	ShaderAssemblerBasic,
	MeshBasicBuilderMatParamsConfig
> {
	paramsConfig: MeshBasicBuilderMatParamsConfig;
	static type(): MatType;
	usedAssembler(): Readonly<AssemblerName.GL_MESH_BASIC>;
	protected _createAssemblerController(): GlAssemblerController<ShaderAssemblerBasic> | undefined;
	customMaterialRequested(customName: CustomMaterialName): boolean;
	readonly controllers: MeshBasicBuilderControllers;
	protected controllersList: any[];
	cook(): Promise<void>;
}
export interface MeshDepthControllers extends AdvancedCommonControllers {}
declare const MeshDepthMatParamsConfig_base: {
	new (...args: any[]): {
		doubleSided: ParamTemplate<ParamType.BOOLEAN>;
		front: ParamTemplate<ParamType.BOOLEAN>;
		overrideShadowSide: ParamTemplate<ParamType.BOOLEAN>;
		shadowDoubleSided: ParamTemplate<ParamType.BOOLEAN>;
		shadowFront: ParamTemplate<ParamType.BOOLEAN>;
		colorWrite: ParamTemplate<ParamType.BOOLEAN>;
		depthWrite: ParamTemplate<ParamType.BOOLEAN>;
		depthTest: ParamTemplate<ParamType.BOOLEAN>;
		premultipliedAlpha: ParamTemplate<ParamType.BOOLEAN>;
		blending: ParamTemplate<ParamType.INTEGER>;
		dithering: ParamTemplate<ParamType.BOOLEAN>;
		polygonOffset: ParamTemplate<ParamType.BOOLEAN>;
		polygonOffsetFactor: ParamTemplate<ParamType.INTEGER>;
		polygonOffsetUnits: ParamTemplate<ParamType.INTEGER>;
	};
} & typeof NodeParamsConfig;
declare class MeshDepthMatParamsConfig extends MeshDepthMatParamsConfig_base {}
declare class MeshDepthMatNode extends PrimitiveMatNode<MeshDepthMaterial, MeshDepthMatParamsConfig> {
	paramsConfig: MeshDepthMatParamsConfig;
	static type(): string;
	createMaterial(): MeshDepthMaterial;
	readonly controllers: MeshDepthControllers;
	protected controllersList: any[];
	cook(): Promise<void>;
}
declare class ShaderAssemblerCustomMeshDepth extends ShaderAssemblerMaterial {
	protected _gl_parent_node: AssemblerControllerNode;
	constructor(_gl_parent_node: AssemblerControllerNode);
	templateShader(): {
		vertexShader: string;
		fragmentShader: string;
		uniforms: {
			[uniform: string]: IUniform<any>;
		};
	};
	protected insertBodyAfter(shaderName: ShaderName): string | undefined;
	protected depthPacking(): DepthPackingStrategies;
	createMaterial(): MeshDepthMaterial;
}
declare class ShaderAssemblerCustomMeshDepthForRender extends ShaderAssemblerCustomMeshDepth {
	protected depthPacking(): DepthPackingStrategies;
}
export interface MeshDepthBuilderControllers extends AdvancedCommonControllers, UniformsTransparencyControllers {}
export interface MeshDepthBuilderMaterial extends MeshDepthMaterial {
	vertexShader: string;
	fragmentShader: string;
	uniforms: IUniforms;
	customMaterials: {
		[key in CustomMaterialName]?: Material;
	};
}
declare const MeshDepthBuilderMatParamsConfig_base: {
	new (...args: any[]): {
		doubleSided: ParamTemplate<ParamType.BOOLEAN>;
		front: ParamTemplate<ParamType.BOOLEAN>;
		overrideShadowSide: ParamTemplate<ParamType.BOOLEAN>;
		shadowDoubleSided: ParamTemplate<ParamType.BOOLEAN>;
		shadowFront: ParamTemplate<ParamType.BOOLEAN>;
		colorWrite: ParamTemplate<ParamType.BOOLEAN>;
		depthWrite: ParamTemplate<ParamType.BOOLEAN>;
		depthTest: ParamTemplate<ParamType.BOOLEAN>;
		premultipliedAlpha: ParamTemplate<ParamType.BOOLEAN>;
		blending: ParamTemplate<ParamType.INTEGER>;
		dithering: ParamTemplate<ParamType.BOOLEAN>;
		polygonOffset: ParamTemplate<ParamType.BOOLEAN>;
		polygonOffsetFactor: ParamTemplate<ParamType.INTEGER>;
		polygonOffsetUnits: ParamTemplate<ParamType.INTEGER>;
	};
} & {
	new (...args: any[]): {
		setBuilderNode: ParamTemplate<ParamType.BOOLEAN>;
		builderNode: ParamTemplate<ParamType.NODE_PATH>;
	};
} & {
	new (...args: any[]): {
		transparent: ParamTemplate<ParamType.BOOLEAN>;
		opacity: ParamTemplate<ParamType.FLOAT>;
		alphaTest: ParamTemplate<ParamType.FLOAT>;
	};
} & typeof NodeParamsConfig;
declare class MeshDepthBuilderMatParamsConfig extends MeshDepthBuilderMatParamsConfig_base {}
declare class MeshDepthBuilderMatNode extends TypedBuilderMatNode<
	MeshDepthBuilderMaterial,
	ShaderAssemblerCustomMeshDepth,
	MeshDepthBuilderMatParamsConfig
> {
	paramsConfig: MeshDepthBuilderMatParamsConfig;
	static type(): string;
	usedAssembler(): Readonly<AssemblerName.GL_MESH_DEPTH>;
	protected _createAssemblerController(): GlAssemblerController<ShaderAssemblerCustomMeshDepthForRender> | undefined;
	customMaterialRequested(customName: CustomMaterialName): boolean;
	readonly controllers: MeshDepthBuilderControllers;
	protected controllersList: any[];
	cook(): Promise<void>;
}
export interface MeshDistanceControllers extends AdvancedCommonControllers {}
declare const MeshDistanceMatParamsConfig_base: {
	new (...args: any[]): {
		doubleSided: ParamTemplate<ParamType.BOOLEAN>;
		front: ParamTemplate<ParamType.BOOLEAN>;
		overrideShadowSide: ParamTemplate<ParamType.BOOLEAN>;
		shadowDoubleSided: ParamTemplate<ParamType.BOOLEAN>;
		shadowFront: ParamTemplate<ParamType.BOOLEAN>;
		colorWrite: ParamTemplate<ParamType.BOOLEAN>;
		depthWrite: ParamTemplate<ParamType.BOOLEAN>;
		depthTest: ParamTemplate<ParamType.BOOLEAN>;
		premultipliedAlpha: ParamTemplate<ParamType.BOOLEAN>;
		blending: ParamTemplate<ParamType.INTEGER>;
		dithering: ParamTemplate<ParamType.BOOLEAN>;
		polygonOffset: ParamTemplate<ParamType.BOOLEAN>;
		polygonOffsetFactor: ParamTemplate<ParamType.INTEGER>;
		polygonOffsetUnits: ParamTemplate<ParamType.INTEGER>;
	};
} & typeof NodeParamsConfig;
declare class MeshDistanceMatParamsConfig extends MeshDistanceMatParamsConfig_base {}
declare class MeshDistanceMatNode extends PrimitiveMatNode<MeshDistanceMaterial, MeshDistanceMatParamsConfig> {
	paramsConfig: MeshDistanceMatParamsConfig;
	static type(): string;
	createMaterial(): MeshDistanceMaterial;
	readonly controllers: MeshDistanceControllers;
	protected controllersList: any[];
	cook(): Promise<void>;
}
declare class ShaderAssemblerCustomMeshDistance extends ShaderAssemblerMaterial {
	protected _gl_parent_node: AssemblerControllerNode;
	constructor(_gl_parent_node: AssemblerControllerNode);
	templateShader(): {
		vertexShader: string;
		fragmentShader: string;
		uniforms: {
			[uniform: string]: IUniform<any>;
		};
	};
	protected insertBodyAfter(shaderName: ShaderName): string | undefined;
	createMaterial(): MeshDistanceMaterial;
}
declare class ShaderAssemblerCustomMeshDistanceForRender extends ShaderAssemblerCustomMeshDistance {}
export interface MeshDistanceBuilderControllers extends AdvancedCommonControllers, UniformsTransparencyControllers {}
export interface MeshDistanceBuilderMaterial extends MeshDistanceMaterial {
	vertexShader: string;
	fragmentShader: string;
	uniforms: IUniforms;
	customMaterials: {
		[key in CustomMaterialName]?: Material;
	};
}
declare const MeshDistanceBuilderMatParamsConfig_base: {
	new (...args: any[]): {
		doubleSided: ParamTemplate<ParamType.BOOLEAN>;
		front: ParamTemplate<ParamType.BOOLEAN>;
		overrideShadowSide: ParamTemplate<ParamType.BOOLEAN>;
		shadowDoubleSided: ParamTemplate<ParamType.BOOLEAN>;
		shadowFront: ParamTemplate<ParamType.BOOLEAN>;
		colorWrite: ParamTemplate<ParamType.BOOLEAN>;
		depthWrite: ParamTemplate<ParamType.BOOLEAN>;
		depthTest: ParamTemplate<ParamType.BOOLEAN>;
		premultipliedAlpha: ParamTemplate<ParamType.BOOLEAN>;
		blending: ParamTemplate<ParamType.INTEGER>;
		dithering: ParamTemplate<ParamType.BOOLEAN>;
		polygonOffset: ParamTemplate<ParamType.BOOLEAN>;
		polygonOffsetFactor: ParamTemplate<ParamType.INTEGER>;
		polygonOffsetUnits: ParamTemplate<ParamType.INTEGER>;
	};
} & {
	new (...args: any[]): {
		setBuilderNode: ParamTemplate<ParamType.BOOLEAN>;
		builderNode: ParamTemplate<ParamType.NODE_PATH>;
	};
} & {
	new (...args: any[]): {
		transparent: ParamTemplate<ParamType.BOOLEAN>;
		opacity: ParamTemplate<ParamType.FLOAT>;
		alphaTest: ParamTemplate<ParamType.FLOAT>;
	};
} & typeof NodeParamsConfig;
declare class MeshDistanceBuilderMatParamsConfig extends MeshDistanceBuilderMatParamsConfig_base {}
declare class MeshDistanceBuilderMatNode extends TypedBuilderMatNode<
	MeshDistanceBuilderMaterial,
	ShaderAssemblerCustomMeshDistance,
	MeshDistanceBuilderMatParamsConfig
> {
	paramsConfig: MeshDistanceBuilderMatParamsConfig;
	static type(): string;
	usedAssembler(): Readonly<AssemblerName.GL_MESH_DISTANCE>;
	protected _createAssemblerController():
		| GlAssemblerController<ShaderAssemblerCustomMeshDistanceForRender>
		| undefined;
	customMaterialRequested(customName: CustomMaterialName): boolean;
	readonly controllers: MeshDistanceBuilderControllers;
	protected controllersList: any[];
	cook(): Promise<void>;
}
export declare type TextureEmissiveMapControllerCurrentMaterial =
	| MeshPhongMaterial
	| MeshLambertMaterial
	| MeshStandardMaterial
	| MeshPhysicalMaterial
	| MeshToonMaterial;
declare const TextureEmissiveMapParamsConfig_base: {
	new (...args: any[]): {
		/** @param emissive color */
		emissive: ParamTemplate<ParamType.COLOR>;
		/** @param toggle if you want to use a emissive map */
		useEmissiveMap: ParamTemplate<ParamType.BOOLEAN>;
		/** @param specify the emissive map COP node */
		emissiveMap: ParamTemplate<ParamType.NODE_PATH>;
		/** @param emissive intensity */
		emissiveIntensity: ParamTemplate<ParamType.FLOAT>;
	};
} & typeof NodeParamsConfig;
declare class TextureEmissiveMapParamsConfig extends TextureEmissiveMapParamsConfig_base {}
export interface TextureEmissiveMapControllers {
	emissiveMap: TextureEmissiveMapController;
}
declare abstract class TextureEmissiveMapMatNode extends TypedMatNode<
	TextureEmissiveMapControllerCurrentMaterial,
	TextureEmissiveMapParamsConfig
> {
	controllers: TextureEmissiveMapControllers;
	material(): Promise<TextureEmissiveMapControllerCurrentMaterial | undefined>;
}
declare class TextureEmissiveMapController extends BaseTextureMapController {
	protected node: TextureEmissiveMapMatNode;
	constructor(node: TextureEmissiveMapMatNode);
	initializeNode(): void;
	static update(node: TextureEmissiveMapMatNode): Promise<void>;
	update(): Promise<void>;
	updateMaterial(material: TextureEmissiveMapControllerCurrentMaterial): Promise<void>;
	getTextures(material: TextureEmissiveMapControllerCurrentMaterial, record: MaterialTexturesRecord): void;
	setParamsFromMaterial(
		material: TextureEmissiveMapControllerCurrentMaterial,
		record: SetParamsTextureNodesRecord
	): void;
}
declare const FlatShadingParamsConfig_base: {
	new (...args: any[]): {
		/** @param defines if the material is flat shaded */
		flatShading: ParamTemplate<ParamType.BOOLEAN>;
	};
} & typeof NodeParamsConfig;
declare class FlatShadingParamsConfig extends FlatShadingParamsConfig_base {}
export interface FlatShadingControllers {
	flatShading: FlatShadingController;
}
export declare type FlatShadingControllerCurrentMaterial =
	| MeshLambertMaterial
	| MeshMatcapMaterial
	| MeshNormalMaterial
	| MeshPhongMaterial
	| MeshStandardMaterial;
declare abstract class FlatShadingMapMatNode extends TypedMatNode<
	FlatShadingControllerCurrentMaterial,
	FlatShadingParamsConfig
> {
	controllers: FlatShadingControllers;
	material(): Promise<FlatShadingControllerCurrentMaterial | undefined>;
}
declare class FlatShadingController extends BaseController {
	protected node: FlatShadingMapMatNode;
	constructor(node: FlatShadingMapMatNode);
	static update(node: FlatShadingMapMatNode): Promise<void>;
	updateMaterial(material: FlatShadingControllerCurrentMaterial): void;
	setParamsFromMaterial(material: FlatShadingControllerCurrentMaterial, record: SetParamsTextureNodesRecord): void;
}
export interface MeshLambertControllers
	extends AdvancedCommonControllers,
		ColorsControllers,
		FogControllers,
		FlatShadingControllers,
		TextureAlphaMapControllers,
		TextureAOMapControllers,
		TextureEmissiveMapControllers,
		TextureEnvMapSimpleControllers,
		TextureLightMapControllers,
		TextureMapControllers,
		WireframeControllers {}
declare const MeshLambertMatParamsConfig_base: {
	new (...args: any[]): {
		useFog: ParamTemplate<ParamType.BOOLEAN>;
	};
} & {
	new (...args: any[]): {
		wireframe: ParamTemplate<ParamType.BOOLEAN>;
		wireframeLinewidth: ParamTemplate<ParamType.FLOAT>;
		wireframeLinecap: ParamTemplate<ParamType.INTEGER>;
		wireframeLinejoin: ParamTemplate<ParamType.INTEGER>;
	};
} & {
	new (...args: any[]): {
		doubleSided: ParamTemplate<ParamType.BOOLEAN>;
		front: ParamTemplate<ParamType.BOOLEAN>;
		overrideShadowSide: ParamTemplate<ParamType.BOOLEAN>;
		shadowDoubleSided: ParamTemplate<ParamType.BOOLEAN>;
		shadowFront: ParamTemplate<ParamType.BOOLEAN>;
		colorWrite: ParamTemplate<ParamType.BOOLEAN>;
		depthWrite: ParamTemplate<ParamType.BOOLEAN>;
		depthTest: ParamTemplate<ParamType.BOOLEAN>;
		premultipliedAlpha: ParamTemplate<ParamType.BOOLEAN>;
		blending: ParamTemplate<ParamType.INTEGER>;
		dithering: ParamTemplate<ParamType.BOOLEAN>;
		polygonOffset: ParamTemplate<ParamType.BOOLEAN>;
		polygonOffsetFactor: ParamTemplate<ParamType.INTEGER>;
		polygonOffsetUnits: ParamTemplate<ParamType.INTEGER>;
	};
} & {
	new (...args: any[]): {
		flatShading: ParamTemplate<ParamType.BOOLEAN>;
	};
} & {
	new (...args: any[]): {
		advanced: ParamTemplate<ParamType.FOLDER>;
	};
} & {
	new (...args: any[]): {
		useLightMap: ParamTemplate<ParamType.BOOLEAN>;
		lightMap: ParamTemplate<ParamType.NODE_PATH>;
		lightMapIntensity: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		useEnvMap: ParamTemplate<ParamType.BOOLEAN>;
		envMap: ParamTemplate<ParamType.NODE_PATH>;
		combine: ParamTemplate<ParamType.INTEGER>;
		reflectivity: ParamTemplate<ParamType.FLOAT>;
		refractionRatio: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		emissive: ParamTemplate<ParamType.COLOR>;
		useEmissiveMap: ParamTemplate<ParamType.BOOLEAN>;
		emissiveMap: ParamTemplate<ParamType.NODE_PATH>;
		emissiveIntensity: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		useAOMap: ParamTemplate<ParamType.BOOLEAN>;
		aoMap: ParamTemplate<ParamType.NODE_PATH>;
		aoMapIntensity: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		useAlphaMap: ParamTemplate<ParamType.BOOLEAN>;
		alphaMap: ParamTemplate<ParamType.NODE_PATH>;
	};
} & {
	new (...args: any[]): {
		useMap: ParamTemplate<ParamType.BOOLEAN>;
		map: ParamTemplate<ParamType.NODE_PATH>;
	};
} & {
	new (...args: any[]): {
		textures: ParamTemplate<ParamType.FOLDER>;
	};
} & {
	new (...args: any[]): {
		color: ParamTemplate<ParamType.COLOR>;
		useVertexColors: ParamTemplate<ParamType.BOOLEAN>;
		transparent: ParamTemplate<ParamType.BOOLEAN>;
		opacity: ParamTemplate<ParamType.FLOAT>;
		alphaTest: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		default: ParamTemplate<ParamType.FOLDER>;
	};
} & typeof NodeParamsConfig;
declare class MeshLambertMatParamsConfig extends MeshLambertMatParamsConfig_base {}
declare class MeshLambertMatNode extends PrimitiveMatNode<MeshLambertMaterial, MeshLambertMatParamsConfig> {
	paramsConfig: MeshLambertMatParamsConfig;
	static type(): MatType.MESH_LAMBERT;
	createMaterial(): MeshLambertMaterial;
	readonly controllers: MeshLambertControllers;
	protected controllersList: any[];
	cook(): Promise<void>;
}
declare class ShaderAssemblerLambert extends ShaderAssemblerMesh {
	templateShader(): {
		vertexShader: string;
		fragmentShader: string;
		uniforms: {
			[uniform: string]: IUniform<any>;
		};
	};
	createMaterial(): MeshLambertMaterial;
}
declare const PCSSParamsConfig_base: {
	new (...args: any[]): {
		/** @param if on, the material will blur shadows cast on this object. Note that you should adjust the near parameter of the light shadow to get the result visible */
		shadowPCSS: ParamTemplate<ParamType.BOOLEAN>;
		/** @param shadowPCSSFilterSize PCSS Shadow filter size */
		shadowPCSSFilterSize: ParamTemplate<ParamType.FLOAT>;
	};
} & typeof NodeParamsConfig;
declare class PCSSParamsConfig extends PCSSParamsConfig_base {}
export interface PCSSControllers {
	PCSS: PCSSController;
}
declare abstract class PCSSMapMatNode extends TypedMatNode<Material, PCSSParamsConfig> {
	controllers: PCSSControllers;
	material(): Promise<Material | undefined>;
}
declare class PCSSController extends BaseController {
	protected node: PCSSMapMatNode;
	constructor(node: PCSSMapMatNode);
	static filterFragmentShader(node: PCSSMapMatNode, fragmentShader: string): string;
	static update(node: PCSSMapMatNode): Promise<void>;
	update(): Promise<void>;
	updateMaterial(material: Material): void;
	static PARAM_CALLBACK_setRecompileRequired(node: PCSSMapMatNode): void;
}
export interface MeshLambertBuilderMaterial extends MeshLambertMaterial {
	vertexShader: string;
	fragmentShader: string;
	uniforms: IUniforms;
	customMaterials: {
		[key in CustomMaterialName]?: Material;
	};
}
export interface MeshLambertBuilderControllers
	extends AdvancedCommonControllers,
		PCSSControllers,
		TextureAlphaMapControllers,
		TextureAOMapControllers,
		TextureEmissiveMapControllers,
		TextureEnvMapSimpleControllers,
		TextureLightMapControllers,
		TextureMapControllers,
		UniformFogControllers,
		UniformsTransparencyControllers,
		WireframeShaderMaterialControllers {}
declare const MeshLambertBuilderMatParamsConfig_base: {
	new (...args: any[]): {
		shadowPCSS: ParamTemplate<ParamType.BOOLEAN>;
		shadowPCSSFilterSize: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		useFog: ParamTemplate<ParamType.BOOLEAN>;
	};
} & {
	new (...args: any[]): {
		wireframe: ParamTemplate<ParamType.BOOLEAN>;
		wireframeLinewidth: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		doubleSided: ParamTemplate<ParamType.BOOLEAN>;
		front: ParamTemplate<ParamType.BOOLEAN>;
		overrideShadowSide: ParamTemplate<ParamType.BOOLEAN>;
		shadowDoubleSided: ParamTemplate<ParamType.BOOLEAN>;
		shadowFront: ParamTemplate<ParamType.BOOLEAN>;
		colorWrite: ParamTemplate<ParamType.BOOLEAN>;
		depthWrite: ParamTemplate<ParamType.BOOLEAN>;
		depthTest: ParamTemplate<ParamType.BOOLEAN>;
		premultipliedAlpha: ParamTemplate<ParamType.BOOLEAN>;
		blending: ParamTemplate<ParamType.INTEGER>;
		dithering: ParamTemplate<ParamType.BOOLEAN>;
		polygonOffset: ParamTemplate<ParamType.BOOLEAN>;
		polygonOffsetFactor: ParamTemplate<ParamType.INTEGER>;
		polygonOffsetUnits: ParamTemplate<ParamType.INTEGER>;
	};
} & {
	new (...args: any[]): {
		setBuilderNode: ParamTemplate<ParamType.BOOLEAN>;
		builderNode: ParamTemplate<ParamType.NODE_PATH>;
	};
} & {
	new (...args: any[]): {
		advanced: ParamTemplate<ParamType.FOLDER>;
	};
} & {
	new (...args: any[]): {
		useLightMap: ParamTemplate<ParamType.BOOLEAN>;
		lightMap: ParamTemplate<ParamType.NODE_PATH>;
		lightMapIntensity: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		useEnvMap: ParamTemplate<ParamType.BOOLEAN>;
		envMap: ParamTemplate<ParamType.NODE_PATH>;
		combine: ParamTemplate<ParamType.INTEGER>;
		reflectivity: ParamTemplate<ParamType.FLOAT>;
		refractionRatio: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		emissive: ParamTemplate<ParamType.COLOR>;
		useEmissiveMap: ParamTemplate<ParamType.BOOLEAN>;
		emissiveMap: ParamTemplate<ParamType.NODE_PATH>;
		emissiveIntensity: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		useAOMap: ParamTemplate<ParamType.BOOLEAN>;
		aoMap: ParamTemplate<ParamType.NODE_PATH>;
		aoMapIntensity: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		useAlphaMap: ParamTemplate<ParamType.BOOLEAN>;
		alphaMap: ParamTemplate<ParamType.NODE_PATH>;
	};
} & {
	new (...args: any[]): {
		useMap: ParamTemplate<ParamType.BOOLEAN>;
		map: ParamTemplate<ParamType.NODE_PATH>;
	};
} & {
	new (...args: any[]): {
		textures: ParamTemplate<ParamType.FOLDER>;
	};
} & {
	new (...args: any[]): {
		transparent: ParamTemplate<ParamType.BOOLEAN>;
		opacity: ParamTemplate<ParamType.FLOAT>;
		alphaTest: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		default: ParamTemplate<ParamType.FOLDER>;
	};
} & typeof NodeParamsConfig;
declare class MeshLambertBuilderMatParamsConfig extends MeshLambertBuilderMatParamsConfig_base {}
declare class MeshLambertBuilderMatNode extends TypedBuilderMatNode<
	MeshLambertBuilderMaterial,
	ShaderAssemblerLambert,
	MeshLambertBuilderMatParamsConfig
> {
	paramsConfig: MeshLambertBuilderMatParamsConfig;
	static type(): MatType;
	usedAssembler(): Readonly<AssemblerName.GL_MESH_LAMBERT>;
	protected _createAssemblerController(): GlAssemblerController<ShaderAssemblerLambert> | undefined;
	readonly controllers: MeshLambertBuilderControllers;
	protected controllersList: any[];
	cook(): Promise<void>;
}
export declare type TextureBumpMapControllerCurrentMaterial =
	| MeshMatcapMaterial
	| MeshNormalMaterial
	| MeshPhysicalMaterial
	| MeshStandardMaterial
	| MeshToonMaterial;
declare const TextureBumpMapParamsConfig_base: {
	new (...args: any[]): {
		/** @param toggle if you want to use a bump map */
		useBumpMap: ParamTemplate<ParamType.BOOLEAN>;
		/** @param specify the bump map COP node */
		bumpMap: ParamTemplate<ParamType.NODE_PATH>;
		/** @param bump scale */
		bumpScale: ParamTemplate<ParamType.FLOAT>;
		/** @param bump bias */
		bumpBias: ParamTemplate<ParamType.FLOAT>;
	};
} & typeof NodeParamsConfig;
declare class TextureBumpMapParamsConfig extends TextureBumpMapParamsConfig_base {}
export interface TextureBumpMapControllers {
	bumpMap: TextureBumpMapController;
}
declare abstract class TextureBumpMapMatNode extends TypedMatNode<
	TextureBumpMapControllerCurrentMaterial,
	TextureBumpMapParamsConfig
> {
	controllers: TextureBumpMapControllers;
	material(): Promise<TextureBumpMapControllerCurrentMaterial | undefined>;
}
declare class TextureBumpMapController extends BaseTextureMapController {
	protected node: TextureBumpMapMatNode;
	constructor(node: TextureBumpMapMatNode);
	initializeNode(): void;
	static update(node: TextureBumpMapMatNode): Promise<void>;
	update(): Promise<void>;
	updateMaterial(material: TextureBumpMapControllerCurrentMaterial): Promise<void>;
	getTextures(material: TextureBumpMapControllerCurrentMaterial, record: MaterialTexturesRecord): void;
	setParamsFromMaterial(material: TextureBumpMapControllerCurrentMaterial, record: SetParamsTextureNodesRecord): void;
}
export declare type TextureNormalMapControllerCurrentMaterial =
	| MeshPhongMaterial
	| MeshNormalMaterial
	| MeshMatcapMaterial
	| MeshPhysicalMaterial
	| MeshToonMaterial
	| MeshStandardMaterial;
declare const TextureNormalMapParamsConfig_base: {
	new (...args: any[]): {
		/** @param toggle if you want to use a normal map */
		useNormalMap: ParamTemplate<ParamType.BOOLEAN>;
		/** @param specify the normal map COP node */
		normalMap: ParamTemplate<ParamType.NODE_PATH>;
		/** @param type of normal map being used */
		normalMapType: ParamTemplate<ParamType.INTEGER>;
		/** @param How much the normal map affects the material. Typical ranges are 0-1 */
		normalScale: ParamTemplate<ParamType.VECTOR2>;
		/** @param Normal Map Scale Multiplier, which multiples normalScale */
		normalScaleMult: ParamTemplate<ParamType.FLOAT>;
	};
} & typeof NodeParamsConfig;
declare class TextureNormalMapParamsConfig extends TextureNormalMapParamsConfig_base {}
export interface TextureNormalMapControllers {
	normalMap: TextureNormalMapController;
}
declare abstract class TextureNormalMapMatNode extends TypedMatNode<
	TextureNormalMapControllerCurrentMaterial,
	TextureNormalMapParamsConfig
> {
	controllers: TextureNormalMapControllers;
	material(): Promise<TextureNormalMapControllerCurrentMaterial | undefined>;
}
declare class TextureNormalMapController extends BaseTextureMapController {
	protected node: TextureNormalMapMatNode;
	constructor(node: TextureNormalMapMatNode);
	initializeNode(): void;
	static update(node: TextureNormalMapMatNode): Promise<void>;
	update(): Promise<void>;
	updateMaterial(material: TextureNormalMapControllerCurrentMaterial): Promise<void>;
	getTextures(material: TextureNormalMapControllerCurrentMaterial, record: MaterialTexturesRecord): void;
	setParamsFromMaterial(
		material: TextureNormalMapControllerCurrentMaterial,
		record: SetParamsTextureNodesRecord
	): void;
}
export declare type TextureDisplacementMapControllerCurrentMaterial =
	| MeshMatcapMaterial
	| MeshNormalMaterial
	| MeshStandardMaterial
	| MeshPhysicalMaterial
	| MeshToonMaterial;
declare const TextureDisplacementMapParamsConfig_base: {
	new (...args: any[]): {
		/** @param toggle if you want to use a displacement map */
		useDisplacementMap: ParamTemplate<ParamType.BOOLEAN>;
		/** @param specify the displacement map COP node */
		displacementMap: ParamTemplate<ParamType.NODE_PATH>;
		/** @param displacement scale */
		displacementScale: ParamTemplate<ParamType.FLOAT>;
		/** @param displacement bias */
		displacementBias: ParamTemplate<ParamType.FLOAT>;
	};
} & typeof NodeParamsConfig;
declare class TextureDisplacementMapParamsConfig extends TextureDisplacementMapParamsConfig_base {}
export interface TextureDisplacementMapControllers {
	displacementMap: TextureDisplacementMapController;
}
declare abstract class TextureDisplacementMapMatNode extends TypedMatNode<
	TextureDisplacementMapControllerCurrentMaterial,
	TextureDisplacementMapParamsConfig
> {
	controllers: TextureDisplacementMapControllers;
	material(): Promise<TextureDisplacementMapControllerCurrentMaterial | undefined>;
}
declare class TextureDisplacementMapController extends BaseTextureMapController {
	protected node: TextureDisplacementMapMatNode;
	constructor(node: TextureDisplacementMapMatNode);
	initializeNode(): void;
	static update(node: TextureDisplacementMapMatNode): Promise<void>;
	update(): Promise<void>;
	updateMaterial(material: TextureDisplacementMapControllerCurrentMaterial): Promise<void>;
	getTextures(material: TextureDisplacementMapControllerCurrentMaterial, record: MaterialTexturesRecord): void;
	setParamsFromMaterial(
		material: TextureDisplacementMapControllerCurrentMaterial,
		record: SetParamsTextureNodesRecord
	): void;
}
export declare type TextureMatcapMaterial = MeshMatcapMaterial;
export declare type TextureMatCapControllerCurrentMaterial = TextureMatcapMaterial;
declare const TextureMatcapMapParamsConfig_base: {
	new (...args: any[]): {
		/** @param toggle if you want to use a matcap map */
		useMatcapMap: ParamTemplate<ParamType.BOOLEAN>;
		/** @param specify the matcap map COP node */
		matcapMap: ParamTemplate<ParamType.NODE_PATH>;
	};
} & typeof NodeParamsConfig;
declare class TextureMatcapMapParamsConfig extends TextureMatcapMapParamsConfig_base {}
export interface TextureMatcapMapControllers {
	matcap: TextureMatcapMapController;
}
declare abstract class TextureMatcapMapMatNode extends TypedMatNode<
	TextureMatCapControllerCurrentMaterial,
	TextureMatcapMapParamsConfig
> {
	controllers: TextureMatcapMapControllers;
	material(): Promise<MeshMatcapMaterial | undefined>;
}
declare class TextureMatcapMapController extends BaseTextureMapController {
	protected node: TextureMatcapMapMatNode;
	constructor(node: TextureMatcapMapMatNode);
	initializeNode(): void;
	static update(node: TextureMatcapMapMatNode): Promise<void>;
	update(): Promise<void>;
	updateMaterial(material: TextureMatCapControllerCurrentMaterial): Promise<void>;
	getTextures(material: TextureMatCapControllerCurrentMaterial, record: MaterialTexturesRecord): void;
	setParamsFromMaterial(material: TextureMatCapControllerCurrentMaterial, record: SetParamsTextureNodesRecord): void;
}
export interface MeshMatCapControllers
	extends AdvancedCommonControllers,
		ColorsControllers,
		FogControllers,
		FlatShadingControllers,
		TextureAlphaMapControllers,
		TextureBumpMapControllers,
		TextureDisplacementMapControllers,
		TextureMapControllers,
		TextureMatcapMapControllers,
		TextureNormalMapControllers {}
declare const MeshMatCapMatParamsConfig_base: {
	new (...args: any[]): {
		useFog: ParamTemplate<ParamType.BOOLEAN>;
	};
} & {
	new (...args: any[]): {
		doubleSided: ParamTemplate<ParamType.BOOLEAN>;
		front: ParamTemplate<ParamType.BOOLEAN>;
		overrideShadowSide: ParamTemplate<ParamType.BOOLEAN>;
		shadowDoubleSided: ParamTemplate<ParamType.BOOLEAN>;
		shadowFront: ParamTemplate<ParamType.BOOLEAN>;
		colorWrite: ParamTemplate<ParamType.BOOLEAN>;
		depthWrite: ParamTemplate<ParamType.BOOLEAN>;
		depthTest: ParamTemplate<ParamType.BOOLEAN>;
		premultipliedAlpha: ParamTemplate<ParamType.BOOLEAN>;
		blending: ParamTemplate<ParamType.INTEGER>;
		dithering: ParamTemplate<ParamType.BOOLEAN>;
		polygonOffset: ParamTemplate<ParamType.BOOLEAN>;
		polygonOffsetFactor: ParamTemplate<ParamType.INTEGER>;
		polygonOffsetUnits: ParamTemplate<ParamType.INTEGER>;
	};
} & {
	new (...args: any[]): {
		flatShading: ParamTemplate<ParamType.BOOLEAN>;
	};
} & {
	new (...args: any[]): {
		advanced: ParamTemplate<ParamType.FOLDER>;
	};
} & {
	new (...args: any[]): {
		useNormalMap: ParamTemplate<ParamType.BOOLEAN>;
		normalMap: ParamTemplate<ParamType.NODE_PATH>;
		normalMapType: ParamTemplate<ParamType.INTEGER>;
		normalScale: ParamTemplate<ParamType.VECTOR2>;
		normalScaleMult: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		useDisplacementMap: ParamTemplate<ParamType.BOOLEAN>;
		displacementMap: ParamTemplate<ParamType.NODE_PATH>;
		displacementScale: ParamTemplate<ParamType.FLOAT>;
		displacementBias: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		useBumpMap: ParamTemplate<ParamType.BOOLEAN>;
		bumpMap: ParamTemplate<ParamType.NODE_PATH>;
		bumpScale: ParamTemplate<ParamType.FLOAT>;
		bumpBias: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		useAlphaMap: ParamTemplate<ParamType.BOOLEAN>;
		alphaMap: ParamTemplate<ParamType.NODE_PATH>;
	};
} & {
	new (...args: any[]): {
		useMap: ParamTemplate<ParamType.BOOLEAN>;
		map: ParamTemplate<ParamType.NODE_PATH>;
	};
} & {
	new (...args: any[]): {
		useMatcapMap: ParamTemplate<ParamType.BOOLEAN>;
		matcapMap: ParamTemplate<ParamType.NODE_PATH>;
	};
} & {
	new (...args: any[]): {
		textures: ParamTemplate<ParamType.FOLDER>;
	};
} & {
	new (...args: any[]): {
		color: ParamTemplate<ParamType.COLOR>;
		useVertexColors: ParamTemplate<ParamType.BOOLEAN>;
		transparent: ParamTemplate<ParamType.BOOLEAN>;
		opacity: ParamTemplate<ParamType.FLOAT>;
		alphaTest: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		default: ParamTemplate<ParamType.FOLDER>;
	};
} & typeof NodeParamsConfig;
declare class MeshMatCapMatParamsConfig extends MeshMatCapMatParamsConfig_base {}
declare class MeshMatcapMatNode extends PrimitiveMatNode<MeshMatcapMaterial, MeshMatCapMatParamsConfig> {
	paramsConfig: MeshMatCapMatParamsConfig;
	static type(): MatType.MESH_MATCAP;
	createMaterial(): MeshMatcapMaterial;
	readonly controllers: MeshMatCapControllers;
	protected controllersList: any[];
	cook(): Promise<void>;
}
export interface MeshNormalControllers
	extends AdvancedCommonControllers,
		TextureBumpMapControllers,
		TextureDisplacementMapControllers,
		FlatShadingControllers,
		TextureNormalMapControllers {}
declare const MeshNormalMatParamsConfig_base: {
	new (...args: any[]): {
		doubleSided: ParamTemplate<ParamType.BOOLEAN>;
		front: ParamTemplate<ParamType.BOOLEAN>;
		overrideShadowSide: ParamTemplate<ParamType.BOOLEAN>;
		shadowDoubleSided: ParamTemplate<ParamType.BOOLEAN>;
		shadowFront: ParamTemplate<ParamType.BOOLEAN>;
		colorWrite: ParamTemplate<ParamType.BOOLEAN>;
		depthWrite: ParamTemplate<ParamType.BOOLEAN>;
		depthTest: ParamTemplate<ParamType.BOOLEAN>;
		premultipliedAlpha: ParamTemplate<ParamType.BOOLEAN>;
		blending: ParamTemplate<ParamType.INTEGER>;
		dithering: ParamTemplate<ParamType.BOOLEAN>;
		polygonOffset: ParamTemplate<ParamType.BOOLEAN>;
		polygonOffsetFactor: ParamTemplate<ParamType.INTEGER>;
		polygonOffsetUnits: ParamTemplate<ParamType.INTEGER>;
	};
} & {
	new (...args: any[]): {
		flatShading: ParamTemplate<ParamType.BOOLEAN>;
	};
} & {
	new (...args: any[]): {
		useNormalMap: ParamTemplate<ParamType.BOOLEAN>;
		normalMap: ParamTemplate<ParamType.NODE_PATH>;
		normalMapType: ParamTemplate<ParamType.INTEGER>;
		normalScale: ParamTemplate<ParamType.VECTOR2>;
		normalScaleMult: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		useDisplacementMap: ParamTemplate<ParamType.BOOLEAN>;
		displacementMap: ParamTemplate<ParamType.NODE_PATH>;
		displacementScale: ParamTemplate<ParamType.FLOAT>;
		displacementBias: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		useBumpMap: ParamTemplate<ParamType.BOOLEAN>;
		bumpMap: ParamTemplate<ParamType.NODE_PATH>;
		bumpScale: ParamTemplate<ParamType.FLOAT>;
		bumpBias: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		textures: ParamTemplate<ParamType.FOLDER>;
	};
} & {
	new (...args: any[]): {
		default: ParamTemplate<ParamType.FOLDER>;
	};
} & typeof NodeParamsConfig;
declare class MeshNormalMatParamsConfig extends MeshNormalMatParamsConfig_base {}
declare class MeshNormalMatNode extends PrimitiveMatNode<MeshNormalMaterial, MeshNormalMatParamsConfig> {
	paramsConfig: MeshNormalMatParamsConfig;
	static type(): MatType.MESH_NORMAL;
	createMaterial(): MeshNormalMaterial;
	readonly controllers: MeshNormalControllers;
	protected controllersList: any[];
	cook(): Promise<void>;
}
export declare type TextureSpecularMapControllerCurrentMaterial = MeshPhongMaterial;
declare const TextureSpecularMapParamsConfig_base: {
	new (...args: any[]): {
		/** @param toggle if you want to use a specular map */
		useSpecularMap: ParamTemplate<ParamType.BOOLEAN>;
		/** @param specify the specular map COP node */
		specularMap: ParamTemplate<ParamType.NODE_PATH>;
	};
} & typeof NodeParamsConfig;
declare class TextureSpecularMapParamsConfig extends TextureSpecularMapParamsConfig_base {}
export interface TextureSpecularMapControllers {
	specularMap: TextureSpecularMapController;
}
declare abstract class TextureSpecularMapMatNode extends TypedMatNode<
	TextureSpecularMapControllerCurrentMaterial,
	TextureSpecularMapParamsConfig
> {
	controllers: TextureSpecularMapControllers;
}
declare class TextureSpecularMapController extends BaseTextureMapController {
	protected node: TextureSpecularMapMatNode;
	constructor(node: TextureSpecularMapMatNode);
	initializeNode(): void;
	static update(node: TextureSpecularMapMatNode): Promise<void>;
	update(): Promise<void>;
	updateMaterial(material: TextureSpecularMapControllerCurrentMaterial): Promise<void>;
	getTextures(material: TextureSpecularMapControllerCurrentMaterial, record: MaterialTexturesRecord): void;
	setParamsFromMaterial(
		material: TextureSpecularMapControllerCurrentMaterial,
		record: SetParamsTextureNodesRecord
	): void;
}
export interface MeshPhongControllers
	extends AdvancedCommonControllers,
		ColorsControllers,
		FogControllers,
		FlatShadingControllers,
		TextureAlphaMapControllers,
		TextureAOMapControllers,
		TextureBumpMapControllers,
		TextureDisplacementMapControllers,
		TextureEmissiveMapControllers,
		TextureEnvMapSimpleControllers,
		TextureLightMapControllers,
		TextureMapControllers,
		TextureNormalMapControllers,
		TextureSpecularMapControllers,
		WireframeControllers {}
declare const MeshPhongMatParamsConfig_base: {
	new (...args: any[]): {
		useFog: ParamTemplate<ParamType.BOOLEAN>;
	};
} & {
	new (...args: any[]): {
		wireframe: ParamTemplate<ParamType.BOOLEAN>;
		wireframeLinewidth: ParamTemplate<ParamType.FLOAT>;
		wireframeLinecap: ParamTemplate<ParamType.INTEGER>;
		wireframeLinejoin: ParamTemplate<ParamType.INTEGER>;
	};
} & {
	new (...args: any[]): {
		doubleSided: ParamTemplate<ParamType.BOOLEAN>;
		front: ParamTemplate<ParamType.BOOLEAN>;
		overrideShadowSide: ParamTemplate<ParamType.BOOLEAN>;
		shadowDoubleSided: ParamTemplate<ParamType.BOOLEAN>;
		shadowFront: ParamTemplate<ParamType.BOOLEAN>;
		colorWrite: ParamTemplate<ParamType.BOOLEAN>;
		depthWrite: ParamTemplate<ParamType.BOOLEAN>;
		depthTest: ParamTemplate<ParamType.BOOLEAN>;
		premultipliedAlpha: ParamTemplate<ParamType.BOOLEAN>;
		blending: ParamTemplate<ParamType.INTEGER>;
		dithering: ParamTemplate<ParamType.BOOLEAN>;
		polygonOffset: ParamTemplate<ParamType.BOOLEAN>;
		polygonOffsetFactor: ParamTemplate<ParamType.INTEGER>;
		polygonOffsetUnits: ParamTemplate<ParamType.INTEGER>;
	};
} & {
	new (...args: any[]): {
		flatShading: ParamTemplate<ParamType.BOOLEAN>;
	};
} & {
	new (...args: any[]): {
		advanced: ParamTemplate<ParamType.FOLDER>;
	};
} & {
	new (...args: any[]): {
		useSpecularMap: ParamTemplate<ParamType.BOOLEAN>;
		specularMap: ParamTemplate<ParamType.NODE_PATH>;
	};
} & {
	new (...args: any[]): {
		useNormalMap: ParamTemplate<ParamType.BOOLEAN>;
		normalMap: ParamTemplate<ParamType.NODE_PATH>;
		normalMapType: ParamTemplate<ParamType.INTEGER>;
		normalScale: ParamTemplate<ParamType.VECTOR2>;
		normalScaleMult: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		useLightMap: ParamTemplate<ParamType.BOOLEAN>;
		lightMap: ParamTemplate<ParamType.NODE_PATH>;
		lightMapIntensity: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		useEnvMap: ParamTemplate<ParamType.BOOLEAN>;
		envMap: ParamTemplate<ParamType.NODE_PATH>;
		combine: ParamTemplate<ParamType.INTEGER>;
		reflectivity: ParamTemplate<ParamType.FLOAT>;
		refractionRatio: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		emissive: ParamTemplate<ParamType.COLOR>;
		useEmissiveMap: ParamTemplate<ParamType.BOOLEAN>;
		emissiveMap: ParamTemplate<ParamType.NODE_PATH>;
		emissiveIntensity: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		useDisplacementMap: ParamTemplate<ParamType.BOOLEAN>;
		displacementMap: ParamTemplate<ParamType.NODE_PATH>;
		displacementScale: ParamTemplate<ParamType.FLOAT>;
		displacementBias: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		useBumpMap: ParamTemplate<ParamType.BOOLEAN>;
		bumpMap: ParamTemplate<ParamType.NODE_PATH>;
		bumpScale: ParamTemplate<ParamType.FLOAT>;
		bumpBias: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		useAOMap: ParamTemplate<ParamType.BOOLEAN>;
		aoMap: ParamTemplate<ParamType.NODE_PATH>;
		aoMapIntensity: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		useAlphaMap: ParamTemplate<ParamType.BOOLEAN>;
		alphaMap: ParamTemplate<ParamType.NODE_PATH>;
	};
} & {
	new (...args: any[]): {
		useMap: ParamTemplate<ParamType.BOOLEAN>;
		map: ParamTemplate<ParamType.NODE_PATH>;
	};
} & {
	new (...args: any[]): {
		textures: ParamTemplate<ParamType.FOLDER>;
	};
} & {
	new (...args: any[]): {
		color: ParamTemplate<ParamType.COLOR>;
		useVertexColors: ParamTemplate<ParamType.BOOLEAN>;
		transparent: ParamTemplate<ParamType.BOOLEAN>;
		opacity: ParamTemplate<ParamType.FLOAT>;
		alphaTest: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		default: ParamTemplate<ParamType.FOLDER>;
	};
} & typeof NodeParamsConfig;
declare class MeshPhongMatParamsConfig extends MeshPhongMatParamsConfig_base {}
declare class MeshPhongMatNode extends PrimitiveMatNode<MeshPhongMaterial, MeshPhongMatParamsConfig> {
	paramsConfig: MeshPhongMatParamsConfig;
	static type(): MatType.MESH_PHONG;
	createMaterial(): MeshPhongMaterial;
	readonly controllers: MeshPhongControllers;
	protected controllersList: any[];
	cook(): Promise<void>;
}
declare class ShaderAssemblerPhong extends ShaderAssemblerMesh {
	templateShader(): {
		vertexShader: string;
		fragmentShader: string;
		uniforms: {
			[uniform: string]: IUniform<any>;
		};
	};
	createMaterial(): MeshPhongMaterial;
}
export interface MeshPhongBuilderMaterial extends MeshPhongMaterial {
	vertexShader: string;
	fragmentShader: string;
	uniforms: IUniforms;
	customMaterials: {
		[key in CustomMaterialName]?: Material;
	};
}
export interface MeshPhongBuilderControllers
	extends AdvancedCommonControllers,
		PCSSControllers,
		TextureAlphaMapControllers,
		TextureAOMapControllers,
		TextureBumpMapControllers,
		TextureDisplacementMapControllers,
		TextureEmissiveMapControllers,
		TextureEnvMapSimpleControllers,
		TextureLightMapControllers,
		TextureMapControllers,
		TextureNormalMapControllers,
		TextureSpecularMapControllers,
		UniformFogControllers,
		UniformsTransparencyControllers,
		WireframeShaderMaterialControllers {}
declare const MeshPhongBuilderMatParamsConfig_base: {
	new (...args: any[]): {
		shadowPCSS: ParamTemplate<ParamType.BOOLEAN>;
		shadowPCSSFilterSize: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		useFog: ParamTemplate<ParamType.BOOLEAN>;
	};
} & {
	new (...args: any[]): {
		wireframe: ParamTemplate<ParamType.BOOLEAN>;
		wireframeLinewidth: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		doubleSided: ParamTemplate<ParamType.BOOLEAN>;
		front: ParamTemplate<ParamType.BOOLEAN>;
		overrideShadowSide: ParamTemplate<ParamType.BOOLEAN>;
		shadowDoubleSided: ParamTemplate<ParamType.BOOLEAN>;
		shadowFront: ParamTemplate<ParamType.BOOLEAN>;
		colorWrite: ParamTemplate<ParamType.BOOLEAN>;
		depthWrite: ParamTemplate<ParamType.BOOLEAN>;
		depthTest: ParamTemplate<ParamType.BOOLEAN>;
		premultipliedAlpha: ParamTemplate<ParamType.BOOLEAN>;
		blending: ParamTemplate<ParamType.INTEGER>;
		dithering: ParamTemplate<ParamType.BOOLEAN>;
		polygonOffset: ParamTemplate<ParamType.BOOLEAN>;
		polygonOffsetFactor: ParamTemplate<ParamType.INTEGER>;
		polygonOffsetUnits: ParamTemplate<ParamType.INTEGER>;
	};
} & {
	new (...args: any[]): {
		setBuilderNode: ParamTemplate<ParamType.BOOLEAN>;
		builderNode: ParamTemplate<ParamType.NODE_PATH>;
	};
} & {
	new (...args: any[]): {
		advanced: ParamTemplate<ParamType.FOLDER>;
	};
} & {
	new (...args: any[]): {
		useSpecularMap: ParamTemplate<ParamType.BOOLEAN>;
		specularMap: ParamTemplate<ParamType.NODE_PATH>;
	};
} & {
	new (...args: any[]): {
		useNormalMap: ParamTemplate<ParamType.BOOLEAN>;
		normalMap: ParamTemplate<ParamType.NODE_PATH>;
		normalMapType: ParamTemplate<ParamType.INTEGER>;
		normalScale: ParamTemplate<ParamType.VECTOR2>;
		normalScaleMult: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		useLightMap: ParamTemplate<ParamType.BOOLEAN>;
		lightMap: ParamTemplate<ParamType.NODE_PATH>;
		lightMapIntensity: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		useEnvMap: ParamTemplate<ParamType.BOOLEAN>;
		envMap: ParamTemplate<ParamType.NODE_PATH>;
		combine: ParamTemplate<ParamType.INTEGER>;
		reflectivity: ParamTemplate<ParamType.FLOAT>;
		refractionRatio: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		emissive: ParamTemplate<ParamType.COLOR>;
		useEmissiveMap: ParamTemplate<ParamType.BOOLEAN>;
		emissiveMap: ParamTemplate<ParamType.NODE_PATH>;
		emissiveIntensity: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		useDisplacementMap: ParamTemplate<ParamType.BOOLEAN>;
		displacementMap: ParamTemplate<ParamType.NODE_PATH>;
		displacementScale: ParamTemplate<ParamType.FLOAT>;
		displacementBias: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		useBumpMap: ParamTemplate<ParamType.BOOLEAN>;
		bumpMap: ParamTemplate<ParamType.NODE_PATH>;
		bumpScale: ParamTemplate<ParamType.FLOAT>;
		bumpBias: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		useAOMap: ParamTemplate<ParamType.BOOLEAN>;
		aoMap: ParamTemplate<ParamType.NODE_PATH>;
		aoMapIntensity: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		useAlphaMap: ParamTemplate<ParamType.BOOLEAN>;
		alphaMap: ParamTemplate<ParamType.NODE_PATH>;
	};
} & {
	new (...args: any[]): {
		useMap: ParamTemplate<ParamType.BOOLEAN>;
		map: ParamTemplate<ParamType.NODE_PATH>;
	};
} & {
	new (...args: any[]): {
		textures: ParamTemplate<ParamType.FOLDER>;
	};
} & {
	new (...args: any[]): {
		transparent: ParamTemplate<ParamType.BOOLEAN>;
		opacity: ParamTemplate<ParamType.FLOAT>;
		alphaTest: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		default: ParamTemplate<ParamType.FOLDER>;
	};
} & typeof NodeParamsConfig;
declare class MeshPhongBuilderMatParamsConfig extends MeshPhongBuilderMatParamsConfig_base {}
declare class MeshPhongBuilderMatNode extends TypedBuilderMatNode<
	MeshPhongBuilderMaterial,
	ShaderAssemblerPhong,
	MeshPhongBuilderMatParamsConfig
> {
	paramsConfig: MeshPhongBuilderMatParamsConfig;
	static type(): MatType;
	usedAssembler(): Readonly<AssemblerName.GL_MESH_PHONG>;
	protected _createAssemblerController(): GlAssemblerController<ShaderAssemblerPhong> | undefined;
	readonly controllers: MeshPhongBuilderControllers;
	protected controllersList: any[];
	cook(): Promise<void>;
}
export declare type TextureMetalnessRoughnessCurrentMaterial = MeshStandardMaterial | MeshPhysicalMaterial;
declare const TextureMetalnessMapParamsConfig_base: {
	new (...args: any[]): {
		/** @param toggle if you want to use a metalness map */
		useMetalnessMap: ParamTemplate<ParamType.BOOLEAN>;
		/** @param specify the metalness map COP node */
		metalnessMap: ParamTemplate<ParamType.NODE_PATH>;
		/** @param metalness. It's recommended to either set this value to 0 or to 1, as objects are either metallic or not. Any value in between tends to look like an alien plastic */
		metalness: ParamTemplate<ParamType.FLOAT>;
		/** @param toggle if you want to use a roughness map */
		useRoughnessMap: ParamTemplate<ParamType.BOOLEAN>;
		/** @param specify the roughness map COP node */
		roughnessMap: ParamTemplate<ParamType.NODE_PATH>;
		/** @param roughness. When set to 0, reflections from environment maps will be very sharp, or blurred when 1. Any value between 0 and 1 can help modulate this. */
		roughness: ParamTemplate<ParamType.FLOAT>;
	};
} & typeof NodeParamsConfig;
declare class TextureMetalnessMapParamsConfig extends TextureMetalnessMapParamsConfig_base {}
export interface TextureMetalnessRoughnessMapControllers {
	metalnessRoughnessMap: TextureMetalnessRoughnessMapController;
}
declare abstract class TextureMetalnessMapMatNode extends TypedMatNode<
	TextureMetalnessRoughnessCurrentMaterial,
	TextureMetalnessMapParamsConfig
> {
	controllers: TextureMetalnessRoughnessMapControllers;
	material(): Promise<TextureMetalnessRoughnessCurrentMaterial | undefined>;
}
declare class TextureMetalnessRoughnessMapController extends BaseTextureMapController {
	protected node: TextureMetalnessMapMatNode;
	constructor(node: TextureMetalnessMapMatNode);
	initializeNode(): void;
	static update(node: TextureMetalnessMapMatNode): Promise<void>;
	update(): Promise<void>;
	updateMaterial(material: TextureMetalnessRoughnessCurrentMaterial): Promise<void>;
	getTextures(material: TextureMetalnessRoughnessCurrentMaterial, record: MaterialTexturesRecord): void;
	setParamsFromMaterial(
		material: TextureMetalnessRoughnessCurrentMaterial,
		record: SetParamsTextureNodesRecord
	): void;
}
export declare type MeshPhysicalControllerCurrentMaterial = MeshPhysicalMaterial;
declare const TextureClearCoatMapParamsConfig_base: {
	new (...args: any[]): {
		/** @param Represents the thickness of the clear coat layer, from 0.0 to 1.0 */
		clearcoat: ParamTemplate<ParamType.FLOAT>;
		/** @param toggle if you want to use a roughness map */
		useClearCoatMap: ParamTemplate<ParamType.BOOLEAN>;
		/** @param specify the roughness map COP node */
		clearcoatMap: ParamTemplate<ParamType.NODE_PATH>;
		/** @param toggle if you want to use a clear coat normal map */
		useClearCoatNormalMap: ParamTemplate<ParamType.BOOLEAN>;
		/** @param specify the roughness map COP node */
		clearcoatNormalMap: ParamTemplate<ParamType.NODE_PATH>;
		/** @param How much the normal map affects the material. Typical ranges are 0-1 */
		clearcoatNormalScale: ParamTemplate<ParamType.VECTOR2>;
		/** @param clearcoatRoughness */
		clearcoatRoughness: ParamTemplate<ParamType.FLOAT>;
		/** @param toggle if you want to use a clear cloat map */
		useClearCoatRoughnessMap: ParamTemplate<ParamType.BOOLEAN>;
		/** @param specify the roughness map COP node */
		clearcoatRoughnessMap: ParamTemplate<ParamType.NODE_PATH>;
		/** @param toggle if you want to use sheen */
		useSheen: ParamTemplate<ParamType.BOOLEAN>;
		/** @param The intensity of the sheen layer, from 0.0 to 1.0. Default is 0.0. */
		sheen: ParamTemplate<ParamType.FLOAT>;
		/** @param If a color is assigned to this property, the material will use a special sheen BRDF intended for rendering cloth materials such as velvet. The sheen color provides the ability to create two-tone specular materials. null by default */
		sheenRoughness: ParamTemplate<ParamType.FLOAT>;
		/** @param If a color is assigned to this property, the material will use a special sheen BRDF intended for rendering cloth materials such as velvet. The sheen color provides the ability to create two-tone specular materials. null by default */
		sheenColor: ParamTemplate<ParamType.COLOR>;
		/** @param toggle if you want to use iridescence */
		useIridescence: ParamTemplate<ParamType.BOOLEAN>;
		/** @param Iridescence amount */
		iridescence: ParamTemplate<ParamType.FLOAT>;
		/** @param iridescence index of refraction */
		iridescenceIOR: ParamTemplate<ParamType.FLOAT>;
		/** @param Iridescence Thickness Range */
		iridescenceThicknessRange: ParamTemplate<ParamType.VECTOR2>;
		/** @param toggle if you want to use an iridescence map */
		useIridescenceMap: ParamTemplate<ParamType.BOOLEAN>;
		/** @param specify the iridescence map COP node */
		iridescenceMap: ParamTemplate<ParamType.NODE_PATH>;
		/** @param toggle if you want to use an iridescence map */
		useIridescenceThicknessMap: ParamTemplate<ParamType.BOOLEAN>;
		/** @param specify the iridescence map COP node */
		iridescenceThicknessMap: ParamTemplate<ParamType.NODE_PATH>;
		/** @param Degree of transmission (or optical transparency), from 0.0 to 1.0. Default is 0.0.
Thin, transparent or semitransparent, plastic or glass materials remain largely reflective even if they are fully transmissive. The transmission property can be used to model these materials.
When transmission is non-zero, opacity should be set to 1.  */
		transmission: ParamTemplate<ParamType.FLOAT>;
		/** @param toggle if you want to use a transmission map */
		useTransmissionMap: ParamTemplate<ParamType.BOOLEAN>;
		/** @param specify the roughness map COP node */
		transmissionMap: ParamTemplate<ParamType.NODE_PATH>;
		/** @param Index-of-refraction for non-metallic materials */
		ior: ParamTemplate<ParamType.FLOAT>;
		/** @param thickness  */
		thickness: ParamTemplate<ParamType.FLOAT>;
		/** @param toggle if you want to use a thickness map */
		useThicknessMap: ParamTemplate<ParamType.BOOLEAN>;
		/** @param specify the roughness map COP node */
		thicknessMap: ParamTemplate<ParamType.NODE_PATH>;
		/** @param attenuation distance */
		attenuationDistance: ParamTemplate<ParamType.FLOAT>;
		/** @param attenuation color */
		attenuationColor: ParamTemplate<ParamType.COLOR>;
	};
} & typeof NodeParamsConfig;
declare class TextureClearCoatMapParamsConfig extends TextureClearCoatMapParamsConfig_base {}
export interface MeshPhysicalControllers {
	physical: MeshPhysicalController;
}
declare abstract class TextureClearCoatMapMatNode extends TypedMatNode<
	MeshPhysicalControllerCurrentMaterial,
	TextureClearCoatMapParamsConfig
> {
	controllers: MeshPhysicalControllers;
	material(): Promise<MeshPhysicalMaterial | undefined>;
}
declare class MeshPhysicalController extends BaseTextureMapController {
	protected node: TextureClearCoatMapMatNode;
	constructor(node: TextureClearCoatMapMatNode);
	initializeNode(): void;
	private _sheenColorClone;
	private _iridescenceRange;
	static update(node: TextureClearCoatMapMatNode): Promise<void>;
	updateMaterial(material: MeshPhysicalControllerCurrentMaterial): Promise<void>;
	getTextures(material: MeshPhysicalControllerCurrentMaterial, record: MaterialTexturesRecord): void;
	setParamsFromMaterial(material: MeshPhysicalControllerCurrentMaterial, record: SetParamsTextureNodesRecord): void;
}
export interface MeshPhysicalMatControllers
	extends AdvancedCommonControllers,
		ColorsControllers,
		TextureAlphaMapControllers,
		TextureAOMapControllers,
		TextureBumpMapControllers,
		TextureDisplacementMapControllers,
		TextureEmissiveMapControllers,
		TextureEnvMapControllers,
		TextureLightMapControllers,
		TextureMapControllers,
		TextureMetalnessRoughnessMapControllers,
		TextureNormalMapControllers,
		MeshPhysicalControllers,
		FogControllers,
		WireframeControllers {}
declare const MeshPhysicalMatParamsConfig_base: {
	new (...args: any[]): {
		useFog: ParamTemplate<ParamType.BOOLEAN>;
	};
} & {
	new (...args: any[]): {
		wireframe: ParamTemplate<ParamType.BOOLEAN>;
		wireframeLinewidth: ParamTemplate<ParamType.FLOAT>;
		wireframeLinecap: ParamTemplate<ParamType.INTEGER>;
		wireframeLinejoin: ParamTemplate<ParamType.INTEGER>;
	};
} & {
	new (...args: any[]): {
		doubleSided: ParamTemplate<ParamType.BOOLEAN>;
		front: ParamTemplate<ParamType.BOOLEAN>;
		overrideShadowSide: ParamTemplate<ParamType.BOOLEAN>;
		shadowDoubleSided: ParamTemplate<ParamType.BOOLEAN>;
		shadowFront: ParamTemplate<ParamType.BOOLEAN>;
		colorWrite: ParamTemplate<ParamType.BOOLEAN>;
		depthWrite: ParamTemplate<ParamType.BOOLEAN>;
		depthTest: ParamTemplate<ParamType.BOOLEAN>;
		premultipliedAlpha: ParamTemplate<ParamType.BOOLEAN>;
		blending: ParamTemplate<ParamType.INTEGER>;
		dithering: ParamTemplate<ParamType.BOOLEAN>;
		polygonOffset: ParamTemplate<ParamType.BOOLEAN>;
		polygonOffsetFactor: ParamTemplate<ParamType.INTEGER>;
		polygonOffsetUnits: ParamTemplate<ParamType.INTEGER>;
	};
} & {
	new (...args: any[]): {
		advanced: ParamTemplate<ParamType.FOLDER>;
	};
} & {
	new (...args: any[]): {
		clearcoat: ParamTemplate<ParamType.FLOAT>;
		useClearCoatMap: ParamTemplate<ParamType.BOOLEAN>;
		clearcoatMap: ParamTemplate<ParamType.NODE_PATH>;
		useClearCoatNormalMap: ParamTemplate<ParamType.BOOLEAN>;
		clearcoatNormalMap: ParamTemplate<ParamType.NODE_PATH>;
		clearcoatNormalScale: ParamTemplate<ParamType.VECTOR2>;
		clearcoatRoughness: ParamTemplate<ParamType.FLOAT>;
		useClearCoatRoughnessMap: ParamTemplate<ParamType.BOOLEAN>;
		clearcoatRoughnessMap: ParamTemplate<ParamType.NODE_PATH>;
		useSheen: ParamTemplate<ParamType.BOOLEAN>;
		sheen: ParamTemplate<ParamType.FLOAT>;
		sheenRoughness: ParamTemplate<ParamType.FLOAT>;
		sheenColor: ParamTemplate<ParamType.COLOR>;
		useIridescence: ParamTemplate<ParamType.BOOLEAN>;
		iridescence: ParamTemplate<ParamType.FLOAT>;
		iridescenceIOR: ParamTemplate<ParamType.FLOAT>;
		iridescenceThicknessRange: ParamTemplate<ParamType.VECTOR2>;
		useIridescenceMap: ParamTemplate<ParamType.BOOLEAN>;
		iridescenceMap: ParamTemplate<ParamType.NODE_PATH>;
		useIridescenceThicknessMap: ParamTemplate<ParamType.BOOLEAN>;
		iridescenceThicknessMap: ParamTemplate<ParamType.NODE_PATH>;
		transmission: ParamTemplate<ParamType.FLOAT>;
		useTransmissionMap: ParamTemplate<ParamType.BOOLEAN>;
		transmissionMap: ParamTemplate<ParamType.NODE_PATH>;
		ior: ParamTemplate<ParamType.FLOAT>;
		thickness: ParamTemplate<ParamType.FLOAT>;
		useThicknessMap: ParamTemplate<ParamType.BOOLEAN>;
		thicknessMap: ParamTemplate<ParamType.NODE_PATH>;
		attenuationDistance: ParamTemplate<ParamType.FLOAT>;
		attenuationColor: ParamTemplate<ParamType.COLOR>;
	};
} & {
	new (...args: any[]): {
		useMetalnessMap: ParamTemplate<ParamType.BOOLEAN>;
		metalnessMap: ParamTemplate<ParamType.NODE_PATH>;
		metalness: ParamTemplate<ParamType.FLOAT>;
		useRoughnessMap: ParamTemplate<ParamType.BOOLEAN>;
		roughnessMap: ParamTemplate<ParamType.NODE_PATH>;
		roughness: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		useNormalMap: ParamTemplate<ParamType.BOOLEAN>;
		normalMap: ParamTemplate<ParamType.NODE_PATH>;
		normalMapType: ParamTemplate<ParamType.INTEGER>;
		normalScale: ParamTemplate<ParamType.VECTOR2>;
		normalScaleMult: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		useLightMap: ParamTemplate<ParamType.BOOLEAN>;
		lightMap: ParamTemplate<ParamType.NODE_PATH>;
		lightMapIntensity: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		useEnvMap: ParamTemplate<ParamType.BOOLEAN>;
		envMap: ParamTemplate<ParamType.NODE_PATH>;
		envMapIntensity: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		emissive: ParamTemplate<ParamType.COLOR>;
		useEmissiveMap: ParamTemplate<ParamType.BOOLEAN>;
		emissiveMap: ParamTemplate<ParamType.NODE_PATH>;
		emissiveIntensity: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		useDisplacementMap: ParamTemplate<ParamType.BOOLEAN>;
		displacementMap: ParamTemplate<ParamType.NODE_PATH>;
		displacementScale: ParamTemplate<ParamType.FLOAT>;
		displacementBias: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		useBumpMap: ParamTemplate<ParamType.BOOLEAN>;
		bumpMap: ParamTemplate<ParamType.NODE_PATH>;
		bumpScale: ParamTemplate<ParamType.FLOAT>;
		bumpBias: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		useAOMap: ParamTemplate<ParamType.BOOLEAN>;
		aoMap: ParamTemplate<ParamType.NODE_PATH>;
		aoMapIntensity: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		useAlphaMap: ParamTemplate<ParamType.BOOLEAN>;
		alphaMap: ParamTemplate<ParamType.NODE_PATH>;
	};
} & {
	new (...args: any[]): {
		useMap: ParamTemplate<ParamType.BOOLEAN>;
		map: ParamTemplate<ParamType.NODE_PATH>;
	};
} & {
	new (...args: any[]): {
		textures: ParamTemplate<ParamType.FOLDER>;
	};
} & {
	new (...args: any[]): {
		color: ParamTemplate<ParamType.COLOR>;
		useVertexColors: ParamTemplate<ParamType.BOOLEAN>;
		transparent: ParamTemplate<ParamType.BOOLEAN>;
		opacity: ParamTemplate<ParamType.FLOAT>;
		alphaTest: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		default: ParamTemplate<ParamType.FOLDER>;
	};
} & typeof NodeParamsConfig;
declare class MeshPhysicalMatParamsConfig extends MeshPhysicalMatParamsConfig_base {}
declare class MeshPhysicalMatNode extends PrimitiveMatNode<MeshPhysicalMaterial, MeshPhysicalMatParamsConfig> {
	paramsConfig: MeshPhysicalMatParamsConfig;
	static type(): MatType.MESH_PHYSICAL;
	createMaterial(): MeshPhysicalMaterial;
	readonly controllers: MeshPhysicalMatControllers;
	protected controllersList: any[];
	cook(): Promise<void>;
}
declare class ShaderAssemblerStandard extends ShaderAssemblerMesh {
	protected _gl_parent_node: AssemblerControllerNode;
	static USE_SSS: Readonly<boolean>;
	isPhysical(): boolean;
	constructor(_gl_parent_node: AssemblerControllerNode);
	templateShader(): {
		vertexShader: string;
		fragmentShader: string;
		uniforms: {
			[uniform: string]: IUniform<any>;
		};
	};
	static filterFragmentShader(fragmentShader: string): string;
	createMaterial(): any;
	add_output_inputs(output_child: OutputGlNode): void;
	create_shader_configs(): ShaderConfig[];
	create_variable_configs(): VariableConfig[];
}
declare class ShaderAssemblerPhysical extends ShaderAssemblerStandard {
	protected _gl_parent_node: AssemblerControllerNode;
	constructor(_gl_parent_node: AssemblerControllerNode);
	isPhysical(): boolean;
	static filterFragmentShader(fragmentShader: string): string;
	createMaterial(): any;
}
export interface MeshPhysicalBuilderMaterial extends MeshPhysicalMaterial {
	vertexShader: string;
	fragmentShader: string;
	uniforms: IUniforms;
	customMaterials: {
		[key in CustomMaterialName]?: Material;
	};
}
export interface MeshPhysicalBuilderControllers
	extends AdvancedCommonControllers,
		PCSSControllers,
		TextureAlphaMapControllers,
		TextureAOMapControllers,
		TextureBumpMapControllers,
		TextureDisplacementMapControllers,
		TextureEmissiveMapControllers,
		TextureEnvMapControllers,
		TextureLightMapControllers,
		TextureMapControllers,
		TextureMetalnessRoughnessMapControllers,
		TextureNormalMapControllers,
		MeshPhysicalControllers,
		UniformFogControllers,
		UniformsTransparencyControllers,
		WireframeShaderMaterialControllers {}
declare const MeshPhysicalBuilderMatParamsConfig_base: {
	new (...args: any[]): {
		overrideCustomMaterials: ParamTemplate<ParamType.BOOLEAN>;
		createCustomMatDistance: ParamTemplate<ParamType.BOOLEAN>;
		createCustomMatDepth: ParamTemplate<ParamType.BOOLEAN>;
		createCustomMatDepthDOF: ParamTemplate<ParamType.BOOLEAN>;
	};
} & {
	new (...args: any[]): {
		shadowPCSS: ParamTemplate<ParamType.BOOLEAN>;
		shadowPCSSFilterSize: ParamTemplate<ParamType.FLOAT>;
		useFog: ParamTemplate<ParamType.BOOLEAN>;
		wireframe: ParamTemplate<ParamType.BOOLEAN>;
		wireframeLinewidth: ParamTemplate<ParamType.FLOAT>;
		doubleSided: ParamTemplate<ParamType.BOOLEAN>;
		front: ParamTemplate<ParamType.BOOLEAN>;
		overrideShadowSide: ParamTemplate<ParamType.BOOLEAN>;
		shadowDoubleSided: ParamTemplate<ParamType.BOOLEAN>;
		shadowFront: ParamTemplate<ParamType.BOOLEAN>;
		colorWrite: ParamTemplate<ParamType.BOOLEAN>;
		depthWrite: ParamTemplate<ParamType.BOOLEAN>;
		depthTest: ParamTemplate<ParamType.BOOLEAN>;
		premultipliedAlpha: ParamTemplate<ParamType.BOOLEAN>;
		blending: ParamTemplate<ParamType.INTEGER>;
		dithering: ParamTemplate<ParamType.BOOLEAN>;
		polygonOffset: ParamTemplate<ParamType.BOOLEAN>;
		polygonOffsetFactor: ParamTemplate<ParamType.INTEGER>;
		polygonOffsetUnits: ParamTemplate<ParamType.INTEGER>;
		setBuilderNode: ParamTemplate<ParamType.BOOLEAN>;
		builderNode: ParamTemplate<ParamType.NODE_PATH>;
	};
} & {
	new (...args: any[]): {
		advanced: ParamTemplate<ParamType.FOLDER>;
	};
} & {
	new (...args: any[]): {
		clearcoat: ParamTemplate<ParamType.FLOAT>;
		useClearCoatMap: ParamTemplate<ParamType.BOOLEAN>;
		clearcoatMap: ParamTemplate<ParamType.NODE_PATH>;
		useClearCoatNormalMap: ParamTemplate<ParamType.BOOLEAN>;
		clearcoatNormalMap: ParamTemplate<ParamType.NODE_PATH>;
		clearcoatNormalScale: ParamTemplate<ParamType.VECTOR2>;
		clearcoatRoughness: ParamTemplate<ParamType.FLOAT>;
		useClearCoatRoughnessMap: ParamTemplate<ParamType.BOOLEAN>;
		clearcoatRoughnessMap: ParamTemplate<ParamType.NODE_PATH>;
		useSheen: ParamTemplate<ParamType.BOOLEAN>;
		sheen: ParamTemplate<ParamType.FLOAT>;
		sheenRoughness: ParamTemplate<ParamType.FLOAT>;
		sheenColor: ParamTemplate<ParamType.COLOR>;
		useIridescence: ParamTemplate<ParamType.BOOLEAN>;
		iridescence: ParamTemplate<ParamType.FLOAT>;
		iridescenceIOR: ParamTemplate<ParamType.FLOAT>;
		iridescenceThicknessRange: ParamTemplate<ParamType.VECTOR2>;
		useIridescenceMap: ParamTemplate<ParamType.BOOLEAN>;
		iridescenceMap: ParamTemplate<ParamType.NODE_PATH>;
		useIridescenceThicknessMap: ParamTemplate<ParamType.BOOLEAN>;
		iridescenceThicknessMap: ParamTemplate<ParamType.NODE_PATH>;
		transmission: ParamTemplate<ParamType.FLOAT>;
		useTransmissionMap: ParamTemplate<ParamType.BOOLEAN>;
		transmissionMap: ParamTemplate<ParamType.NODE_PATH>;
		ior: ParamTemplate<ParamType.FLOAT>;
		thickness: ParamTemplate<ParamType.FLOAT>;
		useThicknessMap: ParamTemplate<ParamType.BOOLEAN>;
		thicknessMap: ParamTemplate<ParamType.NODE_PATH>;
		attenuationDistance: ParamTemplate<ParamType.FLOAT>;
		attenuationColor: ParamTemplate<ParamType.COLOR>;
	};
} & {
	new (...args: any[]): {
		useMetalnessMap: ParamTemplate<ParamType.BOOLEAN>;
		metalnessMap: ParamTemplate<ParamType.NODE_PATH>;
		metalness: ParamTemplate<ParamType.FLOAT>;
		useRoughnessMap: ParamTemplate<ParamType.BOOLEAN>;
		roughnessMap: ParamTemplate<ParamType.NODE_PATH>;
		roughness: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		useNormalMap: ParamTemplate<ParamType.BOOLEAN>;
		normalMap: ParamTemplate<ParamType.NODE_PATH>;
		normalMapType: ParamTemplate<ParamType.INTEGER>;
		normalScale: ParamTemplate<ParamType.VECTOR2>;
		normalScaleMult: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		useLightMap: ParamTemplate<ParamType.BOOLEAN>;
		lightMap: ParamTemplate<ParamType.NODE_PATH>;
		lightMapIntensity: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		useEnvMap: ParamTemplate<ParamType.BOOLEAN>;
		envMap: ParamTemplate<ParamType.NODE_PATH>;
		envMapIntensity: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		emissive: ParamTemplate<ParamType.COLOR>;
		useEmissiveMap: ParamTemplate<ParamType.BOOLEAN>;
		emissiveMap: ParamTemplate<ParamType.NODE_PATH>;
		emissiveIntensity: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		useDisplacementMap: ParamTemplate<ParamType.BOOLEAN>;
		displacementMap: ParamTemplate<ParamType.NODE_PATH>;
		displacementScale: ParamTemplate<ParamType.FLOAT>;
		displacementBias: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		useBumpMap: ParamTemplate<ParamType.BOOLEAN>;
		bumpMap: ParamTemplate<ParamType.NODE_PATH>;
		bumpScale: ParamTemplate<ParamType.FLOAT>;
		bumpBias: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		useAOMap: ParamTemplate<ParamType.BOOLEAN>;
		aoMap: ParamTemplate<ParamType.NODE_PATH>;
		aoMapIntensity: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		useAlphaMap: ParamTemplate<ParamType.BOOLEAN>;
		alphaMap: ParamTemplate<ParamType.NODE_PATH>;
	};
} & {
	new (...args: any[]): {
		useMap: ParamTemplate<ParamType.BOOLEAN>;
		map: ParamTemplate<ParamType.NODE_PATH>;
	};
} & {
	new (...args: any[]): {
		textures: ParamTemplate<ParamType.FOLDER>;
	};
} & {
	new (...args: any[]): {
		transparent: ParamTemplate<ParamType.BOOLEAN>;
		opacity: ParamTemplate<ParamType.FLOAT>;
		alphaTest: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		default: ParamTemplate<ParamType.FOLDER>;
	};
} & typeof NodeParamsConfig;
declare class MeshPhysicalBuilderMatParamsConfig extends MeshPhysicalBuilderMatParamsConfig_base {}
declare class MeshPhysicalBuilderMatNode extends TypedBuilderMatNode<
	MeshPhysicalBuilderMaterial,
	ShaderAssemblerPhysical,
	MeshPhysicalBuilderMatParamsConfig
> {
	paramsConfig: MeshPhysicalBuilderMatParamsConfig;
	static type(): MatType;
	usedAssembler(): Readonly<AssemblerName.GL_MESH_PHYSICAL>;
	protected _createAssemblerController(): GlAssemblerController<ShaderAssemblerPhysical> | undefined;
	customMaterialRequested(customName: CustomMaterialName): boolean;
	readonly controllers: MeshPhysicalBuilderControllers;
	protected controllersList: any[];
	createMaterial(): MeshPhysicalBuilderMaterial;
	cook(): Promise<void>;
}
export interface MeshStandardControllers
	extends AdvancedCommonControllers,
		ColorsControllers,
		FlatShadingControllers,
		FogControllers,
		TextureAlphaMapControllers,
		TextureAOMapControllers,
		TextureBumpMapControllers,
		TextureDisplacementMapControllers,
		TextureEmissiveMapControllers,
		TextureEnvMapControllers,
		TextureLightMapControllers,
		TextureMapControllers,
		TextureMetalnessRoughnessMapControllers,
		TextureNormalMapControllers,
		WireframeControllers {}
declare const MeshStandardMatParamsConfig_base: {
	new (...args: any[]): {
		useFog: ParamTemplate<ParamType.BOOLEAN>;
	};
} & {
	new (...args: any[]): {
		wireframe: ParamTemplate<ParamType.BOOLEAN>;
		wireframeLinewidth: ParamTemplate<ParamType.FLOAT>;
		wireframeLinecap: ParamTemplate<ParamType.INTEGER>;
		wireframeLinejoin: ParamTemplate<ParamType.INTEGER>;
	};
} & {
	new (...args: any[]): {
		doubleSided: ParamTemplate<ParamType.BOOLEAN>;
		front: ParamTemplate<ParamType.BOOLEAN>;
		overrideShadowSide: ParamTemplate<ParamType.BOOLEAN>;
		shadowDoubleSided: ParamTemplate<ParamType.BOOLEAN>;
		shadowFront: ParamTemplate<ParamType.BOOLEAN>;
		colorWrite: ParamTemplate<ParamType.BOOLEAN>;
		depthWrite: ParamTemplate<ParamType.BOOLEAN>;
		depthTest: ParamTemplate<ParamType.BOOLEAN>;
		premultipliedAlpha: ParamTemplate<ParamType.BOOLEAN>;
		blending: ParamTemplate<ParamType.INTEGER>;
		dithering: ParamTemplate<ParamType.BOOLEAN>;
		polygonOffset: ParamTemplate<ParamType.BOOLEAN>;
		polygonOffsetFactor: ParamTemplate<ParamType.INTEGER>;
		polygonOffsetUnits: ParamTemplate<ParamType.INTEGER>;
	};
} & {
	new (...args: any[]): {
		flatShading: ParamTemplate<ParamType.BOOLEAN>;
	};
} & {
	new (...args: any[]): {
		advanced: ParamTemplate<ParamType.FOLDER>;
	};
} & {
	new (...args: any[]): {
		useMetalnessMap: ParamTemplate<ParamType.BOOLEAN>;
		metalnessMap: ParamTemplate<ParamType.NODE_PATH>;
		metalness: ParamTemplate<ParamType.FLOAT>;
		useRoughnessMap: ParamTemplate<ParamType.BOOLEAN>;
		roughnessMap: ParamTemplate<ParamType.NODE_PATH>;
		roughness: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		useNormalMap: ParamTemplate<ParamType.BOOLEAN>;
		normalMap: ParamTemplate<ParamType.NODE_PATH>;
		normalMapType: ParamTemplate<ParamType.INTEGER>;
		normalScale: ParamTemplate<ParamType.VECTOR2>;
		normalScaleMult: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		useLightMap: ParamTemplate<ParamType.BOOLEAN>;
		lightMap: ParamTemplate<ParamType.NODE_PATH>;
		lightMapIntensity: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		useEnvMap: ParamTemplate<ParamType.BOOLEAN>;
		envMap: ParamTemplate<ParamType.NODE_PATH>;
		envMapIntensity: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		emissive: ParamTemplate<ParamType.COLOR>;
		useEmissiveMap: ParamTemplate<ParamType.BOOLEAN>;
		emissiveMap: ParamTemplate<ParamType.NODE_PATH>;
		emissiveIntensity: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		useDisplacementMap: ParamTemplate<ParamType.BOOLEAN>;
		displacementMap: ParamTemplate<ParamType.NODE_PATH>;
		displacementScale: ParamTemplate<ParamType.FLOAT>;
		displacementBias: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		useBumpMap: ParamTemplate<ParamType.BOOLEAN>;
		bumpMap: ParamTemplate<ParamType.NODE_PATH>;
		bumpScale: ParamTemplate<ParamType.FLOAT>;
		bumpBias: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		useAOMap: ParamTemplate<ParamType.BOOLEAN>;
		aoMap: ParamTemplate<ParamType.NODE_PATH>;
		aoMapIntensity: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		useAlphaMap: ParamTemplate<ParamType.BOOLEAN>;
		alphaMap: ParamTemplate<ParamType.NODE_PATH>;
	};
} & {
	new (...args: any[]): {
		useMap: ParamTemplate<ParamType.BOOLEAN>;
		map: ParamTemplate<ParamType.NODE_PATH>;
	};
} & {
	new (...args: any[]): {
		textures: ParamTemplate<ParamType.FOLDER>;
	};
} & {
	new (...args: any[]): {
		color: ParamTemplate<ParamType.COLOR>;
		useVertexColors: ParamTemplate<ParamType.BOOLEAN>;
		transparent: ParamTemplate<ParamType.BOOLEAN>;
		opacity: ParamTemplate<ParamType.FLOAT>;
		alphaTest: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		default: ParamTemplate<ParamType.FOLDER>;
	};
} & typeof NodeParamsConfig;
declare class MeshStandardMatParamsConfig extends MeshStandardMatParamsConfig_base {}
declare class MeshStandardMatNode extends PrimitiveMatNode<MeshStandardMaterial, MeshStandardMatParamsConfig> {
	paramsConfig: MeshStandardMatParamsConfig;
	static type(): MatType.MESH_STANDARD;
	createMaterial(): MeshStandardMaterial;
	readonly controllers: MeshStandardControllers;
	protected controllersList: any[];
	cook(): Promise<void>;
}
export interface MeshStandardBuilderControllers
	extends AdvancedCommonControllers,
		PCSSControllers,
		TextureAlphaMapControllers,
		TextureAOMapControllers,
		TextureBumpMapControllers,
		TextureDisplacementMapControllers,
		TextureEmissiveMapControllers,
		TextureEnvMapControllers,
		TextureLightMapControllers,
		TextureMapControllers,
		TextureMetalnessRoughnessMapControllers,
		TextureNormalMapControllers,
		UniformFogControllers,
		UniformsTransparencyControllers,
		WireframeShaderMaterialControllers {}
export interface MeshStandardBuilderMaterial extends MeshStandardMaterial {
	vertexShader: string;
	fragmentShader: string;
	uniforms: IUniforms;
	customMaterials: {
		[key in CustomMaterialName]?: Material;
	};
}
declare const MeshStandardBuilderMatParamsConfig_base: {
	new (...args: any[]): {
		overrideCustomMaterials: ParamTemplate<ParamType.BOOLEAN>;
		createCustomMatDistance: ParamTemplate<ParamType.BOOLEAN>;
		createCustomMatDepth: ParamTemplate<ParamType.BOOLEAN>;
		createCustomMatDepthDOF: ParamTemplate<ParamType.BOOLEAN>;
	};
} & {
	new (...args: any[]): {
		shadowPCSS: ParamTemplate<ParamType.BOOLEAN>;
		shadowPCSSFilterSize: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		useFog: ParamTemplate<ParamType.BOOLEAN>;
	};
} & {
	new (...args: any[]): {
		wireframe: ParamTemplate<ParamType.BOOLEAN>;
		wireframeLinewidth: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		doubleSided: ParamTemplate<ParamType.BOOLEAN>;
		front: ParamTemplate<ParamType.BOOLEAN>;
		overrideShadowSide: ParamTemplate<ParamType.BOOLEAN>;
		shadowDoubleSided: ParamTemplate<ParamType.BOOLEAN>;
		shadowFront: ParamTemplate<ParamType.BOOLEAN>;
		colorWrite: ParamTemplate<ParamType.BOOLEAN>;
		depthWrite: ParamTemplate<ParamType.BOOLEAN>;
		depthTest: ParamTemplate<ParamType.BOOLEAN>;
		premultipliedAlpha: ParamTemplate<ParamType.BOOLEAN>;
		blending: ParamTemplate<ParamType.INTEGER>;
		dithering: ParamTemplate<ParamType.BOOLEAN>;
		polygonOffset: ParamTemplate<ParamType.BOOLEAN>;
		polygonOffsetFactor: ParamTemplate<ParamType.INTEGER>;
		polygonOffsetUnits: ParamTemplate<ParamType.INTEGER>;
	};
} & {
	new (...args: any[]): {
		setBuilderNode: ParamTemplate<ParamType.BOOLEAN>;
		builderNode: ParamTemplate<ParamType.NODE_PATH>;
	};
} & {
	new (...args: any[]): {
		advanced: ParamTemplate<ParamType.FOLDER>;
	};
} & {
	new (...args: any[]): {
		useMetalnessMap: ParamTemplate<ParamType.BOOLEAN>;
		metalnessMap: ParamTemplate<ParamType.NODE_PATH>;
		metalness: ParamTemplate<ParamType.FLOAT>;
		useRoughnessMap: ParamTemplate<ParamType.BOOLEAN>;
		roughnessMap: ParamTemplate<ParamType.NODE_PATH>;
		roughness: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		useNormalMap: ParamTemplate<ParamType.BOOLEAN>;
		normalMap: ParamTemplate<ParamType.NODE_PATH>;
		normalMapType: ParamTemplate<ParamType.INTEGER>;
		normalScale: ParamTemplate<ParamType.VECTOR2>;
		normalScaleMult: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		useLightMap: ParamTemplate<ParamType.BOOLEAN>;
		lightMap: ParamTemplate<ParamType.NODE_PATH>;
		lightMapIntensity: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		useEnvMap: ParamTemplate<ParamType.BOOLEAN>;
		envMap: ParamTemplate<ParamType.NODE_PATH>;
		envMapIntensity: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		emissive: ParamTemplate<ParamType.COLOR>;
		useEmissiveMap: ParamTemplate<ParamType.BOOLEAN>;
		emissiveMap: ParamTemplate<ParamType.NODE_PATH>;
		emissiveIntensity: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		useDisplacementMap: ParamTemplate<ParamType.BOOLEAN>;
		displacementMap: ParamTemplate<ParamType.NODE_PATH>;
		displacementScale: ParamTemplate<ParamType.FLOAT>;
		displacementBias: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		useBumpMap: ParamTemplate<ParamType.BOOLEAN>;
		bumpMap: ParamTemplate<ParamType.NODE_PATH>;
		bumpScale: ParamTemplate<ParamType.FLOAT>;
		bumpBias: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		useAOMap: ParamTemplate<ParamType.BOOLEAN>;
		aoMap: ParamTemplate<ParamType.NODE_PATH>;
		aoMapIntensity: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		useAlphaMap: ParamTemplate<ParamType.BOOLEAN>;
		alphaMap: ParamTemplate<ParamType.NODE_PATH>;
	};
} & {
	new (...args: any[]): {
		useMap: ParamTemplate<ParamType.BOOLEAN>;
		map: ParamTemplate<ParamType.NODE_PATH>;
	};
} & {
	new (...args: any[]): {
		textures: ParamTemplate<ParamType.FOLDER>;
	};
} & {
	new (...args: any[]): {
		transparent: ParamTemplate<ParamType.BOOLEAN>;
		opacity: ParamTemplate<ParamType.FLOAT>;
		alphaTest: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		default: ParamTemplate<ParamType.FOLDER>;
	};
} & typeof NodeParamsConfig;
declare class MeshStandardBuilderMatParamsConfig extends MeshStandardBuilderMatParamsConfig_base {}
declare class MeshStandardBuilderMatNode extends TypedBuilderMatNode<
	MeshStandardBuilderMaterial,
	ShaderAssemblerStandard,
	MeshStandardBuilderMatParamsConfig
> {
	paramsConfig: MeshStandardBuilderMatParamsConfig;
	static type(): MatType;
	usedAssembler(): Readonly<AssemblerName.GL_MESH_STANDARD>;
	protected _createAssemblerController(): GlAssemblerController<ShaderAssemblerStandard> | undefined;
	customMaterialRequested(customName: CustomMaterialName): boolean;
	readonly controllers: MeshStandardBuilderControllers;
	protected controllersList: any[];
	cook(): Promise<void>;
}
export declare type TextureGradientMaterial = MeshToonMaterial;
export declare type TextureGradientMapCurrentMaterial = TextureGradientMaterial;
declare const TextureGradientMapParamsConfig_base: {
	new (...args: any[]): {
		/** @param toggle if you want to use a gradient map */
		useGradientMap: ParamTemplate<ParamType.BOOLEAN>;
		/** Gradient map for toon shading. It's required to set Texture.minFilter and Texture.magFilter to THREE.NearestFilter when using this type of texture */
		gradientMap: ParamTemplate<ParamType.NODE_PATH>;
	};
} & typeof NodeParamsConfig;
declare class TextureGradientMapParamsConfig extends TextureGradientMapParamsConfig_base {}
export interface TextureGradientMapControllers {
	gradientMap: TextureGradientMapController;
}
declare abstract class TextureGradientMapMatNode extends TypedMatNode<
	TextureGradientMapCurrentMaterial,
	TextureGradientMapParamsConfig
> {
	controllers: TextureGradientMapControllers;
	material(): Promise<MeshToonMaterial | undefined>;
}
declare class TextureGradientMapController extends BaseTextureMapController {
	protected node: TextureGradientMapMatNode;
	constructor(node: TextureGradientMapMatNode);
	initializeNode(): void;
	static update(node: TextureGradientMapMatNode): Promise<void>;
	update(): Promise<void>;
	updateMaterial(material: TextureGradientMapCurrentMaterial): Promise<void>;
	getTextures(material: TextureGradientMapCurrentMaterial, record: MaterialTexturesRecord): void;
	setParamsFromMaterial(material: TextureGradientMapCurrentMaterial, record: SetParamsTextureNodesRecord): void;
}
export interface MeshToonControllers
	extends AdvancedCommonControllers,
		ColorsControllers,
		FogControllers,
		TextureAlphaMapControllers,
		TextureAOMapControllers,
		TextureBumpMapControllers,
		TextureDisplacementMapControllers,
		TextureEmissiveMapControllers,
		TextureGradientMapControllers,
		TextureLightMapControllers,
		TextureMapControllers,
		TextureNormalMapControllers,
		WireframeControllers {}
declare const MeshToonMatParamsConfig_base: {
	new (...args: any[]): {
		useFog: ParamTemplate<ParamType.BOOLEAN>;
	};
} & {
	new (...args: any[]): {
		wireframe: ParamTemplate<ParamType.BOOLEAN>;
		wireframeLinewidth: ParamTemplate<ParamType.FLOAT>;
		wireframeLinecap: ParamTemplate<ParamType.INTEGER>;
		wireframeLinejoin: ParamTemplate<ParamType.INTEGER>;
	};
} & {
	new (...args: any[]): {
		doubleSided: ParamTemplate<ParamType.BOOLEAN>;
		front: ParamTemplate<ParamType.BOOLEAN>;
		overrideShadowSide: ParamTemplate<ParamType.BOOLEAN>;
		shadowDoubleSided: ParamTemplate<ParamType.BOOLEAN>;
		shadowFront: ParamTemplate<ParamType.BOOLEAN>;
		colorWrite: ParamTemplate<ParamType.BOOLEAN>;
		depthWrite: ParamTemplate<ParamType.BOOLEAN>;
		depthTest: ParamTemplate<ParamType.BOOLEAN>;
		premultipliedAlpha: ParamTemplate<ParamType.BOOLEAN>;
		blending: ParamTemplate<ParamType.INTEGER>;
		dithering: ParamTemplate<ParamType.BOOLEAN>;
		polygonOffset: ParamTemplate<ParamType.BOOLEAN>;
		polygonOffsetFactor: ParamTemplate<ParamType.INTEGER>;
		polygonOffsetUnits: ParamTemplate<ParamType.INTEGER>;
	};
} & {
	new (...args: any[]): {
		advanced: ParamTemplate<ParamType.FOLDER>;
	};
} & {
	new (...args: any[]): {
		useNormalMap: ParamTemplate<ParamType.BOOLEAN>;
		normalMap: ParamTemplate<ParamType.NODE_PATH>;
		normalMapType: ParamTemplate<ParamType.INTEGER>;
		normalScale: ParamTemplate<ParamType.VECTOR2>;
		normalScaleMult: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		useLightMap: ParamTemplate<ParamType.BOOLEAN>;
		lightMap: ParamTemplate<ParamType.NODE_PATH>;
		lightMapIntensity: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		useGradientMap: ParamTemplate<ParamType.BOOLEAN>;
		gradientMap: ParamTemplate<ParamType.NODE_PATH>;
	};
} & {
	new (...args: any[]): {
		emissive: ParamTemplate<ParamType.COLOR>;
		useEmissiveMap: ParamTemplate<ParamType.BOOLEAN>;
		emissiveMap: ParamTemplate<ParamType.NODE_PATH>;
		emissiveIntensity: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		useDisplacementMap: ParamTemplate<ParamType.BOOLEAN>;
		displacementMap: ParamTemplate<ParamType.NODE_PATH>;
		displacementScale: ParamTemplate<ParamType.FLOAT>;
		displacementBias: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		useBumpMap: ParamTemplate<ParamType.BOOLEAN>;
		bumpMap: ParamTemplate<ParamType.NODE_PATH>;
		bumpScale: ParamTemplate<ParamType.FLOAT>;
		bumpBias: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		useAOMap: ParamTemplate<ParamType.BOOLEAN>;
		aoMap: ParamTemplate<ParamType.NODE_PATH>;
		aoMapIntensity: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		useAlphaMap: ParamTemplate<ParamType.BOOLEAN>;
		alphaMap: ParamTemplate<ParamType.NODE_PATH>;
	};
} & {
	new (...args: any[]): {
		useMap: ParamTemplate<ParamType.BOOLEAN>;
		map: ParamTemplate<ParamType.NODE_PATH>;
	};
} & {
	new (...args: any[]): {
		textures: ParamTemplate<ParamType.FOLDER>;
	};
} & {
	new (...args: any[]): {
		color: ParamTemplate<ParamType.COLOR>;
		useVertexColors: ParamTemplate<ParamType.BOOLEAN>;
		transparent: ParamTemplate<ParamType.BOOLEAN>;
		opacity: ParamTemplate<ParamType.FLOAT>;
		alphaTest: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		default: ParamTemplate<ParamType.FOLDER>;
	};
} & typeof NodeParamsConfig;
declare class MeshToonMatParamsConfig extends MeshToonMatParamsConfig_base {}
declare class MeshToonMatNode extends PrimitiveMatNode<MeshToonMaterial, MeshToonMatParamsConfig> {
	paramsConfig: MeshToonMatParamsConfig;
	static type(): MatType.MESH_TOON;
	createMaterial(): MeshToonMaterial;
	readonly controllers: MeshToonControllers;
	private controllerNames;
	initializeNode(): void;
	cook(): Promise<void>;
}
export interface PointsSizeControllers {
	pointsSize: PointsSizeController;
}
declare const PointsParamsConfig_base: {
	new (...args: any[]): {
		size: ParamTemplate<ParamType.FLOAT>;
		sizeAttenuation: ParamTemplate<ParamType.BOOLEAN>;
	};
} & typeof NodeParamsConfig;
declare class PointsParamsConfig extends PointsParamsConfig_base {}
declare class PointsMatNode extends TypedMatNode<PointsMaterial, PointsParamsConfig> {
	material(): Promise<PointsMaterial | undefined>;
	controllers: PointsSizeControllers;
}
declare class PointsSizeController extends BaseController {
	protected node: PointsMatNode;
	constructor(node: PointsMatNode);
	static update(node: PointsMatNode): Promise<void>;
	updateMaterial(material: PointsMaterial): void;
}
export interface PointsControllers
	extends AdvancedCommonControllers,
		ColorsControllers,
		PointsSizeControllers,
		TextureAlphaMapControllers,
		TextureMapControllers,
		UniformFogControllers {}
declare const PointsMatParamsConfig_base: {
	new (...args: any[]): {
		useFog: ParamTemplate<ParamType.BOOLEAN>;
	};
} & {
	new (...args: any[]): {
		doubleSided: ParamTemplate<ParamType.BOOLEAN>;
		front: ParamTemplate<ParamType.BOOLEAN>;
		overrideShadowSide: ParamTemplate<ParamType.BOOLEAN>;
		shadowDoubleSided: ParamTemplate<ParamType.BOOLEAN>;
		shadowFront: ParamTemplate<ParamType.BOOLEAN>;
		colorWrite: ParamTemplate<ParamType.BOOLEAN>;
		depthWrite: ParamTemplate<ParamType.BOOLEAN>;
		depthTest: ParamTemplate<ParamType.BOOLEAN>;
		premultipliedAlpha: ParamTemplate<ParamType.BOOLEAN>;
		blending: ParamTemplate<ParamType.INTEGER>;
		dithering: ParamTemplate<ParamType.BOOLEAN>;
		polygonOffset: ParamTemplate<ParamType.BOOLEAN>;
		polygonOffsetFactor: ParamTemplate<ParamType.INTEGER>;
		polygonOffsetUnits: ParamTemplate<ParamType.INTEGER>;
	};
} & {
	new (...args: any[]): {
		advanced: ParamTemplate<ParamType.FOLDER>;
	};
} & {
	new (...args: any[]): {
		useAlphaMap: ParamTemplate<ParamType.BOOLEAN>;
		alphaMap: ParamTemplate<ParamType.NODE_PATH>;
	};
} & {
	new (...args: any[]): {
		useMap: ParamTemplate<ParamType.BOOLEAN>;
		map: ParamTemplate<ParamType.NODE_PATH>;
	};
} & {
	new (...args: any[]): {
		textures: ParamTemplate<ParamType.FOLDER>;
	};
} & {
	new (...args: any[]): {
		color: ParamTemplate<ParamType.COLOR>;
		useVertexColors: ParamTemplate<ParamType.BOOLEAN>;
		transparent: ParamTemplate<ParamType.BOOLEAN>;
		opacity: ParamTemplate<ParamType.FLOAT>;
		alphaTest: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		size: ParamTemplate<ParamType.FLOAT>;
		sizeAttenuation: ParamTemplate<ParamType.BOOLEAN>;
	};
} & {
	new (...args: any[]): {
		default: ParamTemplate<ParamType.FOLDER>;
	};
} & typeof NodeParamsConfig;
declare class PointsMatParamsConfig extends PointsMatParamsConfig_base {}
declare class PointsMatNode extends PrimitiveMatNode<PointsMaterial, PointsMatParamsConfig> {
	paramsConfig: PointsMatParamsConfig;
	static type(): MatType.POINTS;
	createMaterial(): PointsMaterial;
	readonly controllers: PointsControllers;
	protected controllersList: any[];
	cook(): Promise<void>;
}
declare class ShaderAssemblerPoints extends ShaderAssemblerMaterial {
	customAssemblerClassByCustomName(): CustomAssemblerMap;
	templateShader(): {
		vertexShader: string;
		fragmentShader: string;
		uniforms: {
			[uniform: string]: IUniform<any>;
		};
	};
	createMaterial(): PointsMaterial;
	add_output_inputs(output_child: OutputGlNode): void;
	create_globals_node_output_connections(): (
		| GlConnectionPoint<GlConnectionPointType.VEC3>
		| GlConnectionPoint<GlConnectionPointType.VEC2>
		| GlConnectionPoint<GlConnectionPointType.VEC4>
		| GlConnectionPoint<GlConnectionPointType.FLOAT>
	)[];
	create_shader_configs(): ShaderConfig[];
	create_variable_configs(): VariableConfig[];
	protected linesToRemove(shader_name: ShaderName): string[] | undefined;
}
export interface PointsBuilderControllers
	extends AdvancedCommonControllers,
		PointsSizeControllers,
		UniformFogControllers,
		UniformsTransparencyControllers {}
export interface PointsBuilderMaterial extends PointsMaterial {
	vertexShader: string;
	fragmentShader: string;
	customMaterials: {
		[key in CustomMaterialName]?: Material;
	};
}
declare const PointsBuilderMatParamsConfig_base: {
	new (...args: any[]): {
		useFog: ParamTemplate<ParamType.BOOLEAN>;
	};
} & {
	new (...args: any[]): {
		doubleSided: ParamTemplate<ParamType.BOOLEAN>;
		front: ParamTemplate<ParamType.BOOLEAN>;
		overrideShadowSide: ParamTemplate<ParamType.BOOLEAN>;
		shadowDoubleSided: ParamTemplate<ParamType.BOOLEAN>;
		shadowFront: ParamTemplate<ParamType.BOOLEAN>;
		colorWrite: ParamTemplate<ParamType.BOOLEAN>;
		depthWrite: ParamTemplate<ParamType.BOOLEAN>;
		depthTest: ParamTemplate<ParamType.BOOLEAN>;
		premultipliedAlpha: ParamTemplate<ParamType.BOOLEAN>;
		blending: ParamTemplate<ParamType.INTEGER>;
		dithering: ParamTemplate<ParamType.BOOLEAN>;
		polygonOffset: ParamTemplate<ParamType.BOOLEAN>;
		polygonOffsetFactor: ParamTemplate<ParamType.INTEGER>;
		polygonOffsetUnits: ParamTemplate<ParamType.INTEGER>;
	};
} & {
	new (...args: any[]): {
		setBuilderNode: ParamTemplate<ParamType.BOOLEAN>;
		builderNode: ParamTemplate<ParamType.NODE_PATH>;
	};
} & {
	new (...args: any[]): {
		advanced: ParamTemplate<ParamType.FOLDER>;
	};
} & {
	new (...args: any[]): {
		transparent: ParamTemplate<ParamType.BOOLEAN>;
		opacity: ParamTemplate<ParamType.FLOAT>;
		alphaTest: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		size: ParamTemplate<ParamType.FLOAT>;
		sizeAttenuation: ParamTemplate<ParamType.BOOLEAN>;
	};
} & {
	new (...args: any[]): {
		default: ParamTemplate<ParamType.FOLDER>;
	};
} & typeof NodeParamsConfig;
declare class PointsBuilderMatParamsConfig extends PointsBuilderMatParamsConfig_base {}
declare class PointsBuilderMatNode extends TypedBuilderMatNode<
	PointsBuilderMaterial,
	ShaderAssemblerPoints,
	PointsBuilderMatParamsConfig
> {
	paramsConfig: PointsBuilderMatParamsConfig;
	static type(): MatType;
	usedAssembler(): Readonly<AssemblerName.GL_POINTS>;
	protected _createAssemblerController(): GlAssemblerController<ShaderAssemblerPoints> | undefined;
	readonly controllers: PointsBuilderControllers;
	protected controllersList: any[];
	cook(): Promise<void>;
}
declare abstract class BaseShaderAssemblerRayMarchingAbstract extends ShaderAssemblerMaterial {
	customAssemblerClassByCustomName(): CustomAssemblerMap;
	set_node_lines_globals(
		globals_node: GlobalsGlNode,
		shaders_collection_controller: ShadersCollectionController
	): void;
}
declare class BaseShaderAssemblerRayMarchingRendered extends BaseShaderAssemblerRayMarchingAbstract {
	protected _gl_parent_node: AssemblerControllerNode;
	constructor(_gl_parent_node: AssemblerControllerNode);
	templateShader(): {
		vertexShader: string;
		fragmentShader: string;
		uniforms: any;
	};
	createMaterial(): ShaderMaterial;
	protected _raymarchingLightsWorldCoordsDependent(): boolean;
	add_output_inputs(output_child: OutputGlNode): void;
	static create_globals_node_output_connections(): (
		| GlConnectionPoint<GlConnectionPointType.VEC3>
		| GlConnectionPoint<GlConnectionPointType.FLOAT>
	)[];
	create_globals_node_output_connections(): (
		| GlConnectionPoint<GlConnectionPointType.VEC3>
		| GlConnectionPoint<GlConnectionPointType.FLOAT>
	)[];
	protected insertBodyAfter(shaderName: ShaderName): string | undefined;
	protected insertDefineAfter(shaderName: ShaderName): string | undefined;
	protected linesToRemove(shaderName: ShaderName): string[] | undefined;
	create_shader_configs(): ShaderConfig[];
	static create_variable_configs(): VariableConfig[];
	create_variable_configs(): VariableConfig[];
	private _applyMaterialAssembler;
	private _applyMaterialMaterial;
	setGlParentNode(gl_parent_node: AssemblerControllerNode): void;
	compileMaterial(material: Material): void;
	applyMaterialAssemblerFilterFragmentShader(fragmentShader: string): string;
}
declare class ShaderAssemblerRayMarching extends BaseShaderAssemblerRayMarchingRendered {
	templateShader(): {
		vertexShader: string;
		fragmentShader: string;
		uniforms: any;
	};
	customAssemblerClassByCustomName(): CustomAssemblerMap;
	createMaterial(): ShaderMaterial;
}
declare const RayMarchingBuilderMatParamsConfig_base: {
	new (...args: any[]): {
		debug: ParamTemplate<ParamType.BOOLEAN>;
		debugMode: ParamTemplate<ParamType.INTEGER>;
		debugMinSteps: ParamTemplate<ParamType.INTEGER>;
		debugMaxSteps: ParamTemplate<ParamType.INTEGER>;
		debugMinDepth: ParamTemplate<ParamType.FLOAT>;
		debugMaxDepth: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		overrideCustomMaterials: ParamTemplate<ParamType.BOOLEAN>;
		createCustomMatDistance: ParamTemplate<ParamType.BOOLEAN>;
		shadowDistanceMin: ParamTemplate<ParamType.FLOAT>;
		shadowDistanceMax: ParamTemplate<ParamType.FLOAT>;
		createCustomMatDepth: ParamTemplate<ParamType.BOOLEAN>;
		shadowDepthMin: ParamTemplate<ParamType.FLOAT>;
		shadowDepthMax: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		/** @param defines if the material is double sided or not */
		doubleSided: ParamTemplate<ParamType.BOOLEAN>;
		/** @param if the material is not double sided, it can be front sided, or back sided */
		front: ParamTemplate<ParamType.BOOLEAN>;
	};
} & {
	new (...args: any[]): {
		setBuilderNode: ParamTemplate<ParamType.BOOLEAN>;
		builderNode: ParamTemplate<ParamType.NODE_PATH>;
	};
} & {
	new (...args: any[]): {
		advanced: ParamTemplate<ParamType.FOLDER>;
	};
} & {
	new (...args: any[]): {
		useEnvMap: ParamTemplate<ParamType.BOOLEAN>;
		envMap: ParamTemplate<ParamType.NODE_PATH>;
		envMapIntensity: ParamTemplate<ParamType.FLOAT>;
		envMapRoughness: ParamTemplate<ParamType.FLOAT>;
		tEnvMapRotate: ParamTemplate<ParamType.BOOLEAN>;
		envMapRotation: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		textures: ParamTemplate<ParamType.FOLDER>;
	};
} & {
	new (...args: any[]): {
		maxSteps: ParamTemplate<ParamType.INTEGER>;
		maxDist: ParamTemplate<ParamType.FLOAT>;
		surfDist: ParamTemplate<ParamType.FLOAT>;
		normalsBias: ParamTemplate<ParamType.FLOAT>;
		shadowBias: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		default: ParamTemplate<ParamType.FOLDER>;
	};
} & typeof NodeParamsConfig;
declare class RayMarchingBuilderMatParamsConfig extends RayMarchingBuilderMatParamsConfig_base {}
declare class RayMarchingBuilderMatNode extends TypedBuilderMatNode<
	ShaderMaterialWithCustomMaterials,
	ShaderAssemblerRayMarching,
	RayMarchingBuilderMatParamsConfig
> {
	paramsConfig: RayMarchingBuilderMatParamsConfig;
	static type(): MatType;
	usedAssembler(): Readonly<AssemblerName.GL_RAYMARCHING>;
	protected _createAssemblerController(): GlAssemblerController<ShaderAssemblerRayMarching> | undefined;
	customMaterialRequested(customName: CustomMaterialName): boolean;
	private _rayMarchingController;
	initializeNode(): void;
	cook(): Promise<void>;
}
export interface ShadowControllers extends AdvancedCommonControllers, ColorsControllers {}
declare const ShadowMatParamsConfig_base: {
	new (...args: any[]): {
		doubleSided: ParamTemplate<ParamType.BOOLEAN>;
		front: ParamTemplate<ParamType.BOOLEAN>;
		overrideShadowSide: ParamTemplate<ParamType.BOOLEAN>;
		shadowDoubleSided: ParamTemplate<ParamType.BOOLEAN>;
		shadowFront: ParamTemplate<ParamType.BOOLEAN>;
		colorWrite: ParamTemplate<ParamType.BOOLEAN>;
		depthWrite: ParamTemplate<ParamType.BOOLEAN>;
		depthTest: ParamTemplate<ParamType.BOOLEAN>;
		premultipliedAlpha: ParamTemplate<ParamType.BOOLEAN>;
		blending: ParamTemplate<ParamType.INTEGER>;
		dithering: ParamTemplate<ParamType.BOOLEAN>;
		polygonOffset: ParamTemplate<ParamType.BOOLEAN>;
		polygonOffsetFactor: ParamTemplate<ParamType.INTEGER>;
		polygonOffsetUnits: ParamTemplate<ParamType.INTEGER>;
	};
} & {
	new (...args: any[]): {
		color: ParamTemplate<ParamType.COLOR>;
		useVertexColors: ParamTemplate<ParamType.BOOLEAN>;
		transparent: ParamTemplate<ParamType.BOOLEAN>;
		opacity: ParamTemplate<ParamType.FLOAT>;
		alphaTest: ParamTemplate<ParamType.FLOAT>;
	};
} & typeof NodeParamsConfig;
declare class ShadowMatParamsConfig extends ShadowMatParamsConfig_base {}
declare class ShadowMatNode extends PrimitiveMatNode<ShadowMaterial, ShadowMatParamsConfig> {
	paramsConfig: ShadowMatParamsConfig;
	static type(): MatType;
	createMaterial(): ShadowMaterial;
	readonly controllers: ShadowControllers;
	protected controllersList: any[];
	cook(): Promise<void>;
}
export interface ShaderMaterialWithSkyUniforms extends ShaderMaterial {
	uniforms: {
		turbidity: {
			value: number;
		};
		rayleigh: {
			value: number;
		};
		mieCoefficient: {
			value: number;
		};
		mieDirectionalG: {
			value: number;
		};
		sunPosition: {
			value: Vector3;
		};
		up: {
			value: Vector3;
		};
	};
}
declare class SkyMatParamsConfig extends NodeParamsConfig {
	/** @param turbidity */
	turbidity: ParamTemplate<ParamType.FLOAT>;
	/** @param rayleigh */
	rayleigh: ParamTemplate<ParamType.FLOAT>;
	/** @param mieCoefficient */
	mieCoefficient: ParamTemplate<ParamType.FLOAT>;
	/** @param mieDirectional */
	mieDirectional: ParamTemplate<ParamType.FLOAT>;
	/** @param inclination */
	inclination: ParamTemplate<ParamType.FLOAT>;
	/** @param azimuth */
	azimuth: ParamTemplate<ParamType.FLOAT>;
	/** @param up */
	up: ParamTemplate<ParamType.VECTOR3>;
}
declare class SkyMatNode extends PrimitiveMatNode<ShaderMaterialWithSkyUniforms, SkyMatParamsConfig> {
	paramsConfig: SkyMatParamsConfig;
	static type(): MatType;
	createMaterial(): ShaderMaterialWithSkyUniforms;
	cook(): Promise<void>;
}
declare const VolumeMatParamsConfig_base: {
	new (...args: any[]): {
		color: ParamTemplate<ParamType.COLOR>;
		stepSize: ParamTemplate<ParamType.FLOAT>;
		density: ParamTemplate<ParamType.FLOAT>;
		shadowDensity: ParamTemplate<ParamType.FLOAT>;
		lightDir: ParamTemplate<ParamType.VECTOR3>;
	};
} & typeof NodeParamsConfig;
declare class VolumeMatParamsConfig extends VolumeMatParamsConfig_base {}
declare class VolumeMatNode extends PrimitiveMatNode<ShaderMaterial, VolumeMatParamsConfig> {
	paramsConfig: VolumeMatParamsConfig;
	static type(): MatType;
	private _volumeController;
	createMaterial(): ShaderMaterial;
	initializeNode(): void;
	cook(): Promise<void>;
}
declare abstract class BaseShaderAssemblerVolume extends ShaderAssemblerMaterial {
	customAssemblerClassByCustomName(): CustomAssemblerMap;
}
declare class ShaderAssemblerVolume extends BaseShaderAssemblerVolume {
	templateShader(): {
		vertexShader: string;
		fragmentShader: string;
		uniforms: any;
	};
	createMaterial(): ShaderMaterial;
	add_output_inputs(output_child: OutputGlNode): void;
	static create_globals_node_output_connections(): (
		| GlConnectionPoint<GlConnectionPointType.VEC3>
		| GlConnectionPoint<GlConnectionPointType.FLOAT>
	)[];
	create_globals_node_output_connections(): (
		| GlConnectionPoint<GlConnectionPointType.VEC3>
		| GlConnectionPoint<GlConnectionPointType.FLOAT>
	)[];
	protected insertBodyAfter(shader_name: ShaderName): string | undefined;
	protected linesToRemove(shader_name: ShaderName): string[] | undefined;
	create_shader_configs(): ShaderConfig[];
	static create_variable_configs(): VariableConfig[];
	create_variable_configs(): VariableConfig[];
	set_node_lines_globals(
		globals_node: GlobalsGlNode,
		shaders_collection_controller: ShadersCollectionController
	): void;
}
declare const VolumeBuilderMatParamsConfig_base: {
	new (...args: any[]): {
		setBuilderNode: ParamTemplate<ParamType.BOOLEAN>;
		builderNode: ParamTemplate<ParamType.NODE_PATH>;
	};
} & {
	new (...args: any[]): {
		color: ParamTemplate<ParamType.COLOR>;
		stepSize: ParamTemplate<ParamType.FLOAT>;
		density: ParamTemplate<ParamType.FLOAT>;
		shadowDensity: ParamTemplate<ParamType.FLOAT>;
		lightDir: ParamTemplate<ParamType.VECTOR3>;
	};
} & typeof NodeParamsConfig;
declare class VolumeBuilderMatParamsConfig extends VolumeBuilderMatParamsConfig_base {}
declare class VolumeBuilderMatNode extends TypedBuilderMatNode<
	ShaderMaterialWithCustomMaterials,
	ShaderAssemblerVolume,
	VolumeBuilderMatParamsConfig
> {
	paramsConfig: VolumeBuilderMatParamsConfig;
	static type(): MatType;
	usedAssembler(): Readonly<AssemblerName.GL_VOLUME>;
	protected _createAssemblerController(): GlAssemblerController<ShaderAssemblerVolume> | undefined;
	private _volumeController;
	initializeNode(): void;
	cook(): Promise<void>;
}
declare class ParamLessNetworkMatParamsConfig extends NodeParamsConfig {}
declare class BaseNetworkMatNode<K extends NodeParamsConfig> extends TypedNode<NodeContext.MAT, K> {
	static context(): NodeContext;
	cook(): void;
}
declare class ParamLessBaseNetworkMatNode extends BaseNetworkMatNode<ParamLessNetworkMatParamsConfig> {}
declare class ActorsNetworkMatNode extends ParamLessBaseNetworkMatNode {
	static type(): NetworkNodeType;
	protected _childrenControllerContext: NodeContext;
	createNode<S extends keyof JsNodeChildrenMap>(node_class: S, options?: NodeCreateOptions): JsNodeChildrenMap[S];
	createNode<K extends valueof<JsNodeChildrenMap>>(node_class: Constructor<K>, options?: NodeCreateOptions): K;
	children(): BaseJsNodeType[];
	nodesByType<K extends keyof JsNodeChildrenMap>(type: K): JsNodeChildrenMap[K][];
	childrenAllowed(): boolean;
	sceneReadonly(): boolean;
	readonly persisted_config: ActorPersistedConfig;
	assemblerController(): JsAssemblerController<JsAssemblerActor> | undefined;
	usedAssembler(): Readonly<AssemblerName.JS_ACTOR>;
	protected _assemblerController: JsAssemblerController<JsAssemblerActor> | undefined;
	private _createAssemblerController;
	readonly compilationController: ActorCompilationController;
	compile(): void;
	cook(): void;
}
declare class AnimationsNetworkMatNode extends ParamLessBaseNetworkMatNode {
	static type(): NetworkNodeType;
	protected _childrenControllerContext: NodeContext;
	createNode<S extends keyof AnimNodeChildrenMap>(node_class: S, options?: NodeCreateOptions): AnimNodeChildrenMap[S];
	createNode<K extends valueof<AnimNodeChildrenMap>>(node_class: Constructor<K>, options?: NodeCreateOptions): K;
	children(): BaseAnimNodeType[];
	nodesByType<K extends keyof AnimNodeChildrenMap>(type: K): AnimNodeChildrenMap[K][];
}
declare class AudioNetworkMatNode extends ParamLessBaseNetworkMatNode {
	static type(): NetworkNodeType;
	protected _childrenControllerContext: NodeContext;
	createNode<S extends keyof AudioNodeChildrenMap>(
		node_class: S,
		options?: NodeCreateOptions
	): AudioNodeChildrenMap[S];
	createNode<K extends valueof<AudioNodeChildrenMap>>(node_class: Constructor<K>, options?: NodeCreateOptions): K;
	children(): BaseAudioNodeType[];
	nodesByType<K extends keyof AudioNodeChildrenMap>(type: K): AudioNodeChildrenMap[K][];
}
declare class AudioAnalyserCopParamsConfig extends NodeParamsConfig {
	/** @param if off, the texture will not be updated */
	activeR: ParamTemplate<ParamType.BOOLEAN>;
	/** @param audio node to read data from, into the RED channel */
	audioNodeR: ParamTemplate<ParamType.NODE_PATH>;
	/** @param decibel range */
	rangeR: ParamTemplate<ParamType.VECTOR2>;
	/** @param speed mult */
	speedMultR: ParamTemplate<ParamType.FLOAT>;
	/** @param if off, the texture will not be updated */
	activeG: ParamTemplate<ParamType.BOOLEAN>;
	/** @param audio node to read data from, into the GREEN channel */
	audioNodeG: ParamTemplate<ParamType.NODE_PATH>;
	/** @param decibel range */
	rangeG: ParamTemplate<ParamType.VECTOR2>;
	/** @param speed mult */
	speedMultG: ParamTemplate<ParamType.FLOAT>;
	/** @param if off, the texture will not be updated */
	activeB: ParamTemplate<ParamType.BOOLEAN>;
	/** @param audio node to read data from, into the BLUE channel */
	audioNodeB: ParamTemplate<ParamType.NODE_PATH>;
	/** @param decibel range */
	rangeB: ParamTemplate<ParamType.VECTOR2>;
	/** @param speed mult */
	speedMultB: ParamTemplate<ParamType.FLOAT>;
	/** @param if off, the texture will not be updated */
	activeA: ParamTemplate<ParamType.BOOLEAN>;
	/** @param audio node to read data from, into the ALPHA channel */
	audioNodeA: ParamTemplate<ParamType.NODE_PATH>;
	/** @param decibel range */
	rangeA: ParamTemplate<ParamType.VECTOR2>;
	/** @param speed mult */
	speedMultA: ParamTemplate<ParamType.FLOAT>;
}
declare class AudioAnalyserCopNode extends TypedCopNode<AudioAnalyserCopParamsConfig> {
	paramsConfig: AudioAnalyserCopParamsConfig;
	static type(): string;
	cook(): Promise<void>;
	dispose(): void;
	private _audioNodesByChannel;
	private _valuesByChannel;
	private _getAudioNodes;
	private _getAudioNode;
	private _updateTexture;
	private _valuesForChannel;
	private _updateTextureChannel;
	private _dataTexture;
	private _createDataTexture;
	private _paramSetByChannel;
	private _initParamsByChannel;
	private _registerOnTickHook;
	private _unRegisterOnTickHook;
	private _tickCallbackName;
}
declare enum CopType {
	BUILDER = 'builder',
	BUILDER_2D_ARRAY = 'builder2DArray',
	CUBE_MAP = 'cubeMap',
	CUBE_CAMERA = 'cubeCamera',
	CUBE_MAP_FROM_SCENE = 'cubeMapFromScene',
	ENV_MAP = 'envMap',
	GIF = 'gif',
	LUT = 'lut',
	SDF_BLUR = 'SDFBlur',
	SDF_FROM_OBJECT = 'SDFFromObject',
	SDF_FROM_URL = 'SDFFromUrl',
	SNAPSHOT = 'snapshot',
	VIDEO = 'video',
	WEB_CAM = 'webCam',
}
declare const CopTextureParamsConfig_base: {
	new (...args: any[]): {
		/** @param toggle on to allow updating the texture encoding */
		tencoding: ParamTemplate<ParamType.BOOLEAN>;
		/** @param sets the texture encoding */
		encoding: ParamTemplate<ParamType.INTEGER>;
		/** @param toggle on to allow updating the texture mapping */
		tmapping: ParamTemplate<ParamType.BOOLEAN>;
		/** @param sets the texture mapping */
		mapping: ParamTemplate<ParamType.INTEGER>;
		/** @param toggle on to allow updating the texture wrap */
		twrap: ParamTemplate<ParamType.BOOLEAN>;
		/** @param sets the texture wrapS */
		wrapS: ParamTemplate<ParamType.INTEGER>;
		/** @param sets the texture wrapT */
		wrapT: ParamTemplate<ParamType.INTEGER>;
		/** @param toggle on to allow updating the texture min filter */
		tminFilter: ParamTemplate<ParamType.BOOLEAN>;
		/** @param sets the texture min filter */
		minFilter: ParamTemplate<ParamType.INTEGER>;
		/** @param toggle on to allow updating the texture mag filter */
		tmagFilter: ParamTemplate<ParamType.BOOLEAN>;
		/** @param sets the texture mag filter */
		magFilter: ParamTemplate<ParamType.INTEGER>;
		/** @param toggle on to allow updating the texture anisotropy */
		tanisotropy: ParamTemplate<ParamType.BOOLEAN>;
		/** @param sets the anisotropy from the max value allowed by the renderer */
		useRendererMaxAnisotropy: ParamTemplate<ParamType.BOOLEAN>;
		/** @param sets the anisotropy manually */
		anisotropy: ParamTemplate<ParamType.INTEGER>;
		/** @param Toggle on to update the flipY */
		tflipY: ParamTemplate<ParamType.BOOLEAN>;
		/** @param sets the flipY */
		flipY: ParamTemplate<ParamType.BOOLEAN>;
		/** @param toggle on to update the texture transform */
		ttransform: ParamTemplate<ParamType.BOOLEAN>;
		/** @param updates the texture offset */
		offset: ParamTemplate<ParamType.VECTOR2>;
		/** @param updates the texture repeat */
		repeat: ParamTemplate<ParamType.VECTOR2>;
		/** @param updates the texture rotation */
		rotation: ParamTemplate<ParamType.FLOAT>;
		/** @param updates the texture center */
		center: ParamTemplate<ParamType.VECTOR2>;
		/** @param toggle on to display advanced parameters */
		tadvanced: ParamTemplate<ParamType.BOOLEAN>;
		/** @param toggle on to allow overriding the texture format */
		tformat: ParamTemplate<ParamType.BOOLEAN>;
		/** @param sets the texture format */
		format: ParamTemplate<ParamType.INTEGER>;
		/** @param toggle on to allow overriding the texture type */
		ttype: ParamTemplate<ParamType.BOOLEAN>;
		/** @param sets the texture ty[e] */
		type: ParamTemplate<ParamType.INTEGER>;
	};
} & typeof NodeParamsConfig;
declare class CopTextureParamsConfig extends CopTextureParamsConfig_base {}
declare class TextureCopNode extends TypedCopNode<CopTextureParamsConfig> {
	paramsConfig: CopTextureParamsConfig;
	readonly textureParamsController: TextureParamsController;
}
declare class TextureParamsController {
	protected node: TextureCopNode;
	constructor(node: TextureCopNode);
	update(texture: Texture): Promise<void>;
	private _updateEncoding;
	private _updateAdvanced;
	private _updateMapping;
	private _updateWrap;
	private _updateFilter;
	private _updateFlip;
	private _rendererController;
	private _updateAnisotropy;
	private _maxRendererAnisotropy;
	private _updateTransform;
	private _updateTransformOffset;
	private _updateTransformRepeat;
	private _updateTransformRotation;
	private _updateTransformCenter;
	static PARAM_CALLBACK_update_encoding(node: TextureCopNode): void;
	static PARAM_CALLBACK_update_mapping(node: TextureCopNode): void;
	static PARAM_CALLBACK_update_wrap(node: TextureCopNode): void;
	static PARAM_CALLBACK_update_filter(node: TextureCopNode): void;
	static PARAM_CALLBACK_update_anisotropy(node: TextureCopNode): void;
	static PARAM_CALLBACK_update_flipY(node: TextureCopNode): void;
	static PARAM_CALLBACK_update_transform(node: TextureCopNode): void;
	static PARAM_CALLBACK_update_offset(node: TextureCopNode): void;
	static PARAM_CALLBACK_update_repeat(node: TextureCopNode): void;
	static PARAM_CALLBACK_update_rotation(node: TextureCopNode): void;
	static PARAM_CALLBACK_update_center(node: TextureCopNode): void;
	static PARAM_CALLBACK_update_advanced(node: TextureCopNode): void;
	static copyTextureAttributes(texture: Texture, inputTexture: Texture): void;
	paramLabelsParams(): (BooleanParam | IntegerParam)[];
	paramLabels(): string[];
}
declare class ShaderAssemblerTexture2DArray extends BaseGlShaderAssembler {
	private _uniforms;
	templateShader(): {
		fragmentShader: string;
		vertexShader: undefined;
		uniforms: {
			uLayer: {
				value: number;
			};
		};
	};
	fragment_shader(): string | undefined;
	uniforms(): IUniforms | undefined;
	updateFragmentShader(): void;
	add_output_inputs(output_child: OutputGlNode): void;
	add_globals_outputs(globals_node: GlobalsGlNode): void;
	create_shader_configs(): ShaderConfig[];
	create_variable_configs(): VariableConfig[];
	protected insertDefineAfter(shader_name: ShaderName): string;
	protected insertBodyAfter(shader_name: ShaderName): string;
	protected linesToRemove(shader_name: ShaderName): string[];
	private _handle_gl_FragCoord;
	private _handle_resolution;
	private _handleUVW;
	private _handleLayer;
	set_node_lines_output(output_node: OutputGlNode, shaders_collection_controller: ShadersCollectionController): void;
	set_node_lines_globals(
		globals_node: GlobalsGlNode,
		shaders_collection_controller: ShadersCollectionController
	): void;
}
declare const Builder2DArrayCopParamsConfig_base: {
	new (...args: any[]): {
		tencoding: ParamTemplate<ParamType.BOOLEAN>;
		encoding: ParamTemplate<ParamType.INTEGER>;
		tmapping: ParamTemplate<ParamType.BOOLEAN>;
		mapping: ParamTemplate<ParamType.INTEGER>;
		twrap: ParamTemplate<ParamType.BOOLEAN>;
		wrapS: ParamTemplate<ParamType.INTEGER>;
		wrapT: ParamTemplate<ParamType.INTEGER>;
		tminFilter: ParamTemplate<ParamType.BOOLEAN>;
		minFilter: ParamTemplate<ParamType.INTEGER>;
		tmagFilter: ParamTemplate<ParamType.BOOLEAN>;
		magFilter: ParamTemplate<ParamType.INTEGER>;
		tanisotropy: ParamTemplate<ParamType.BOOLEAN>;
		useRendererMaxAnisotropy: ParamTemplate<ParamType.BOOLEAN>;
		anisotropy: ParamTemplate<ParamType.INTEGER>;
		tflipY: ParamTemplate<ParamType.BOOLEAN>;
		flipY: ParamTemplate<ParamType.BOOLEAN>;
		ttransform: ParamTemplate<ParamType.BOOLEAN>;
		offset: ParamTemplate<ParamType.VECTOR2>;
		repeat: ParamTemplate<ParamType.VECTOR2>;
		rotation: ParamTemplate<ParamType.FLOAT>;
		center: ParamTemplate<ParamType.VECTOR2>;
		tadvanced: ParamTemplate<ParamType.BOOLEAN>;
		tformat: ParamTemplate<ParamType.BOOLEAN>;
		format: ParamTemplate<ParamType.INTEGER>;
		ttype: ParamTemplate<ParamType.BOOLEAN>;
		type: ParamTemplate<ParamType.INTEGER>;
	};
} & {
	new (...args: any[]): {
		/** @param textures resolution */
		resolution: ParamTemplate<ParamType.VECTOR2>;
		/** @param layers */
		layers: ParamTemplate<ParamType.INTEGER>;
		/** @param use the main camera renderer. This can save memory, but can also lead to colors being affected by the renderer.outputEncoding */
		useCameraRenderer: ParamTemplate<ParamType.BOOLEAN>;
		/** @param use a data texture instead of a render target, which can be useful when using that texture as and envMap */
		/** @param force Render */
		render: ParamTemplate<ParamType.BUTTON>;
	};
} & typeof NodeParamsConfig;
declare class Builder2DArrayCopParamsConfig extends Builder2DArrayCopParamsConfig_base {}
declare class Builder2DArrayCopNode extends TypedCopNode<Builder2DArrayCopParamsConfig> {
	paramsConfig: Builder2DArrayCopParamsConfig;
	static type(): CopType;
	readonly persisted_config: TexturePersistedConfig;
	protected _assemblerController: GlAssemblerController<ShaderAssemblerTexture2DArray> | undefined;
	usedAssembler(): Readonly<AssemblerName.GL_TEXTURE_2D_ARRAY>;
	protected _createAssemblerController(): GlAssemblerController<ShaderAssemblerTexture2DArray> | undefined;
	assemblerController(): GlAssemblerController<ShaderAssemblerTexture2DArray> | undefined;
	private _textureMesh;
	private _fragmentShader;
	private _uniforms;
	readonly textureMaterial: ShaderMaterial;
	private _textureScene;
	private _textureCamera;
	private _renderTarget;
	private _dataTextureController;
	private _rendererController;
	readonly textureParamsController: TextureParamsController;
	protected _childrenControllerContext: NodeContext;
	initializeNode(): void;
	createNode<S extends keyof GlNodeChildrenMap>(node_class: S, options?: NodeCreateOptions): GlNodeChildrenMap[S];
	createNode<K extends valueof<GlNodeChildrenMap>>(node_class: Constructor<K>, options?: NodeCreateOptions): K;
	children(): BaseGlNodeType[];
	nodesByType<K extends keyof GlNodeChildrenMap>(type: K): GlNodeChildrenMap[K][];
	childrenAllowed(): boolean;
	sceneReadonly(): boolean;
	private _cook_main_without_inputs_when_dirty_bound;
	private _cook_main_without_inputs_when_dirty;
	cook(): Promise<void>;
	shaders_by_name(): {
		fragment: string | undefined;
	};
	compileIfRequired(): void;
	private compile;
	callbackName(): string;
	dispose(): void;
	removeCallbacks(): void;
	readonly boundRenderOnTarget: () => Promise<void>;
	renderOnTargetWithoutUpdatingTextureFromParams(): Promise<void>;
	private _renderOnTarget;
	private _postRender;
	private _prevTarget;
	private _prevOutputEncoding;
	private _prevToneMapping;
	private _saveRendererState;
	private _prepareRenderer;
	private _setRenderLayer;
	private _restoreRendererState;
	private _renderer;
	private _createRendererIfRequired;
	private _resetRenderer;
	renderer(): WebGLRenderer | undefined;
	renderTarget(): Promise<WebGLArrayRenderTarget>;
	private createRenderTargetIfRequired;
	private _renderTargetResolutionValid;
	private _createRenderTarget;
	static PARAM_CALLBACK_render(node: Builder2DArrayCopNode): void;
	static PARAM_CALLBACK_resetRenderer(node: Builder2DArrayCopNode): void;
}
export interface PersistedConfigBaseTextureData extends PersistedConfigWithShaders {
	uniforms: IUniforms;
	param_uniform_pairs: [string, string][];
	uniforms_time_dependent?: boolean;
	uniforms_resolution_dependent?: boolean;
}
declare class TexturePersistedConfig extends BasePersistedConfig {
	protected node: BuilderCopNode | Builder2DArrayCopNode;
	constructor(node: BuilderCopNode | Builder2DArrayCopNode);
	toData(): Promise<PersistedConfigBaseTextureData | undefined>;
	load(data: PersistedConfigBaseTextureData): void;
}
declare class ShaderAssemblerTexture extends BaseGlShaderAssembler {
	private _uniforms;
	templateShader(): {
		fragmentShader: string;
		vertexShader: undefined;
		uniforms: undefined;
	};
	fragment_shader(): string | undefined;
	uniforms(): IUniforms | undefined;
	updateFragmentShader(): void;
	add_output_inputs(output_child: OutputGlNode): void;
	add_globals_outputs(globals_node: GlobalsGlNode): void;
	create_shader_configs(): ShaderConfig[];
	create_variable_configs(): VariableConfig[];
	protected insertDefineAfter(shader_name: ShaderName): string;
	protected insertBodyAfter(shader_name: ShaderName): string;
	protected linesToRemove(shader_name: ShaderName): string[];
	private _handle_gl_FragCoord;
	private _handle_resolution;
	private _handleUV;
	set_node_lines_output(output_node: OutputGlNode, shaders_collection_controller: ShadersCollectionController): void;
	set_node_lines_globals(
		globals_node: GlobalsGlNode,
		shaders_collection_controller: ShadersCollectionController
	): void;
}
declare const BuilderCopParamsConfig_base: {
	new (...args: any[]): {
		tencoding: ParamTemplate<ParamType.BOOLEAN>;
		encoding: ParamTemplate<ParamType.INTEGER>;
		tmapping: ParamTemplate<ParamType.BOOLEAN>;
		mapping: ParamTemplate<ParamType.INTEGER>;
		twrap: ParamTemplate<ParamType.BOOLEAN>;
		wrapS: ParamTemplate<ParamType.INTEGER>;
		wrapT: ParamTemplate<ParamType.INTEGER>;
		tminFilter: ParamTemplate<ParamType.BOOLEAN>;
		minFilter: ParamTemplate<ParamType.INTEGER>;
		tmagFilter: ParamTemplate<ParamType.BOOLEAN>;
		magFilter: ParamTemplate<ParamType.INTEGER>;
		tanisotropy: ParamTemplate<ParamType.BOOLEAN>;
		useRendererMaxAnisotropy: ParamTemplate<ParamType.BOOLEAN>;
		anisotropy: ParamTemplate<ParamType.INTEGER>;
		tflipY: ParamTemplate<ParamType.BOOLEAN>;
		flipY: ParamTemplate<ParamType.BOOLEAN>;
		ttransform: ParamTemplate<ParamType.BOOLEAN>;
		offset: ParamTemplate<ParamType.VECTOR2>;
		repeat: ParamTemplate<ParamType.VECTOR2>;
		rotation: ParamTemplate<ParamType.FLOAT>;
		center: ParamTemplate<ParamType.VECTOR2>;
		tadvanced: ParamTemplate<ParamType.BOOLEAN>;
		tformat: ParamTemplate<ParamType.BOOLEAN>;
		format: ParamTemplate<ParamType.INTEGER>;
		ttype: ParamTemplate<ParamType.BOOLEAN>;
		type: ParamTemplate<ParamType.INTEGER>;
	};
} & {
	new (...args: any[]): {
		/** @param texture resolution */
		resolution: ParamTemplate<ParamType.VECTOR2>;
		/** @param use the main camera renderer. This can save memory, but can also lead to colors being affected by the renderer.outputEncoding */
		useCameraRenderer: ParamTemplate<ParamType.BOOLEAN>;
		/** @param use a data texture instead of a render target, which can be useful when using that texture as and envMap */
		useDataTexture: ParamTemplate<ParamType.BOOLEAN>;
		/** @param force Render */
		render: ParamTemplate<ParamType.BUTTON>;
	};
} & typeof NodeParamsConfig;
declare class BuilderCopParamsConfig extends BuilderCopParamsConfig_base {}
declare class BuilderCopNode extends TypedCopNode<BuilderCopParamsConfig> {
	paramsConfig: BuilderCopParamsConfig;
	static type(): CopType;
	readonly persisted_config: TexturePersistedConfig;
	protected _assemblerController: GlAssemblerController<ShaderAssemblerTexture> | undefined;
	usedAssembler(): Readonly<AssemblerName.GL_TEXTURE>;
	protected _createAssemblerController(): GlAssemblerController<ShaderAssemblerTexture> | undefined;
	assemblerController(): GlAssemblerController<ShaderAssemblerTexture> | undefined;
	private _textureMesh;
	private _fragmentShader;
	private _uniforms;
	readonly textureMaterial: ShaderMaterial;
	private _textureScene;
	private _textureCamera;
	private _renderTarget;
	private _dataTextureController;
	private _rendererController;
	readonly textureParamsController: TextureParamsController;
	protected _childrenControllerContext: NodeContext;
	initializeNode(): void;
	createNode<S extends keyof GlNodeChildrenMap>(node_class: S, options?: NodeCreateOptions): GlNodeChildrenMap[S];
	createNode<K extends valueof<GlNodeChildrenMap>>(node_class: Constructor<K>, options?: NodeCreateOptions): K;
	children(): BaseGlNodeType[];
	nodesByType<K extends keyof GlNodeChildrenMap>(type: K): GlNodeChildrenMap[K][];
	childrenAllowed(): boolean;
	sceneReadonly(): boolean;
	private _cook_main_without_inputs_when_dirty_bound;
	private _cook_main_without_inputs_when_dirty;
	cook(): Promise<void>;
	shaders_by_name(): {
		fragment: string | undefined;
	};
	compileIfRequired(): void;
	private compile;
	callbackName(): string;
	dispose(): void;
	removeCallbacks(): void;
	readonly boundRenderOnTarget: () => Promise<void>;
	renderOnTargetWithoutUpdatingTextureFromParams(): Promise<void>;
	private _renderOnTarget;
	private _postRender;
	private _prevTarget;
	private _prevOutputEncoding;
	private _prevToneMapping;
	private _saveRendererState;
	private _prepareRenderer;
	private _restoreRendererState;
	private _renderer;
	private _createRendererIfRequired;
	private _resetRenderer;
	renderer(): WebGLRenderer | undefined;
	renderTarget(): Promise<WebGLRenderTarget>;
	private createRenderTargetIfRequired;
	private _renderTargetResolutionValid;
	private _createRenderTarget;
	static PARAM_CALLBACK_render(node: BuilderCopNode): void;
	static PARAM_CALLBACK_resetRenderer(node: BuilderCopNode): void;
}
declare const CanvasCopParamConfig_base: {
	new (...args: any[]): {
		tencoding: ParamTemplate<ParamType.BOOLEAN>;
		encoding: ParamTemplate<ParamType.INTEGER>;
		tmapping: ParamTemplate<ParamType.BOOLEAN>;
		mapping: ParamTemplate<ParamType.INTEGER>;
		twrap: ParamTemplate<ParamType.BOOLEAN>;
		wrapS: ParamTemplate<ParamType.INTEGER>;
		wrapT: ParamTemplate<ParamType.INTEGER>;
		tminFilter: ParamTemplate<ParamType.BOOLEAN>;
		minFilter: ParamTemplate<ParamType.INTEGER>;
		tmagFilter: ParamTemplate<ParamType.BOOLEAN>;
		magFilter: ParamTemplate<ParamType.INTEGER>;
		tanisotropy: ParamTemplate<ParamType.BOOLEAN>;
		useRendererMaxAnisotropy: ParamTemplate<ParamType.BOOLEAN>;
		anisotropy: ParamTemplate<ParamType.INTEGER>;
		tflipY: ParamTemplate<ParamType.BOOLEAN>;
		flipY: ParamTemplate<ParamType.BOOLEAN>;
		ttransform: ParamTemplate<ParamType.BOOLEAN>;
		offset: ParamTemplate<ParamType.VECTOR2>;
		repeat: ParamTemplate<ParamType.VECTOR2>;
		rotation: ParamTemplate<ParamType.FLOAT>;
		center: ParamTemplate<ParamType.VECTOR2>;
		tadvanced: ParamTemplate<ParamType.BOOLEAN>;
		tformat: ParamTemplate<ParamType.BOOLEAN>;
		format: ParamTemplate<ParamType.INTEGER>;
		ttype: ParamTemplate<ParamType.BOOLEAN>;
		type: ParamTemplate<ParamType.INTEGER>;
	};
} & {
	new (...args: any[]): {
		/** @param HTML id of the canvas element */
		canvasId: ParamTemplate<ParamType.STRING>;
		/** @param forces the texture to update */
		update: ParamTemplate<ParamType.BUTTON>;
	};
} & typeof NodeParamsConfig;
declare class CanvasCopParamConfig extends CanvasCopParamConfig_base {}
declare class CanvasCopNode extends TypedCopNode<CanvasCopParamConfig> {
	paramsConfig: CanvasCopParamConfig;
	static type(): Readonly<'canvas'>;
	readonly textureParamsController: TextureParamsController;
	cook(): Promise<void>;
	static PARAM_CALLBACK_update(node: CanvasCopNode): void;
	private markTextureNeedsUpdate;
}
declare class ColorCopParamsConfig extends NodeParamsConfig {
	/** @param texture resolution */
	resolution: ParamTemplate<ParamType.VECTOR2>;
	/** @param color to generate */
	color: ParamTemplate<ParamType.COLOR>;
	/** @param alpha */
	alpha: ParamTemplate<ParamType.FLOAT>;
}
declare class ColorCopNode extends TypedCopNode<ColorCopParamsConfig> {
	paramsConfig: ColorCopParamsConfig;
	static type(): string;
	private _dataTexture;
	cook(): void;
	private _createDataTexture;
	private _createPixelBuffer;
	static PARAM_CALLBACK_reset(node: ColorCopNode): void;
	private _reset;
}
declare const CubeMapCopParamsConfig_base: {
	new (...args: any[]): {
		tencoding: ParamTemplate<ParamType.BOOLEAN>;
		encoding: ParamTemplate<ParamType.INTEGER>;
		tmapping: ParamTemplate<ParamType.BOOLEAN>;
		mapping: ParamTemplate<ParamType.INTEGER>;
		twrap: ParamTemplate<ParamType.BOOLEAN>;
		wrapS: ParamTemplate<ParamType.INTEGER>;
		wrapT: ParamTemplate<ParamType.INTEGER>;
		tminFilter: ParamTemplate<ParamType.BOOLEAN>;
		minFilter: ParamTemplate<ParamType.INTEGER>;
		tmagFilter: ParamTemplate<ParamType.BOOLEAN>;
		magFilter: ParamTemplate<ParamType.INTEGER>;
		tanisotropy: ParamTemplate<ParamType.BOOLEAN>;
		useRendererMaxAnisotropy: ParamTemplate<ParamType.BOOLEAN>;
		anisotropy: ParamTemplate<ParamType.INTEGER>;
		tflipY: ParamTemplate<ParamType.BOOLEAN>;
		flipY: ParamTemplate<ParamType.BOOLEAN>;
		ttransform: ParamTemplate<ParamType.BOOLEAN>;
		offset: ParamTemplate<ParamType.VECTOR2>;
		repeat: ParamTemplate<ParamType.VECTOR2>;
		rotation: ParamTemplate<ParamType.FLOAT>;
		center: ParamTemplate<ParamType.VECTOR2>;
		tadvanced: ParamTemplate<ParamType.BOOLEAN>;
		tformat: ParamTemplate<ParamType.BOOLEAN>;
		format: ParamTemplate<ParamType.INTEGER>;
		ttype: ParamTemplate<ParamType.BOOLEAN>;
		type: ParamTemplate<ParamType.INTEGER>;
	};
} & {
	new (...args: any[]): {
		/** @param url prefix */
		prefix: ParamTemplate<ParamType.STRING>;
		/** @param url prefix */
		suffix: ParamTemplate<ParamType.STRING>;
		/** @param reload the image */
		reload: ParamTemplate<ParamType.BUTTON>;
		/** @param px url */
		px: ParamTemplate<ParamType.STRING>;
		/** @param nx url */
		nx: ParamTemplate<ParamType.STRING>;
		/** @param py url */
		py: ParamTemplate<ParamType.STRING>;
		/** @param ny url */
		ny: ParamTemplate<ParamType.STRING>;
		/** @param pz url */
		pz: ParamTemplate<ParamType.STRING>;
		/** @param nz url */
		nz: ParamTemplate<ParamType.STRING>;
	};
} & typeof NodeParamsConfig;
declare class CubeMapCopParamsConfig extends CubeMapCopParamsConfig_base {}
declare class CubeMapCopNode extends TypedCopNode<CubeMapCopParamsConfig> {
	paramsConfig: CubeMapCopParamsConfig;
	static type(): CopType;
	readonly textureParamsController: TextureParamsController;
	initializeNode(): void;
	cook(inputContents: Texture[]): Promise<void>;
	dispose(): void;
	private _loadTexture;
	static PARAM_CALLBACK_reload(node: CubeMapCopNode): void;
	private paramCallbackReload;
}
declare class CubeCameraCopParamsConfig extends NodeParamsConfig {
	/** @param cube camera OBJ node */
	cubeCamera: ParamTemplate<ParamType.NODE_PATH>;
	/** @param defines if the texture is used for reflection or refraction */
	mode: ParamTemplate<ParamType.INTEGER>;
}
declare class CubeCameraCopNode extends TypedCopNode<CubeCameraCopParamsConfig> {
	paramsConfig: CubeCameraCopParamsConfig;
	static type(): CopType;
	cook(): Promise<void>;
}
declare const CubeMapFromSceneCopParamsConfig_base: {
	new (...args: any[]): {
		/** @param force Render */
		blur: ParamTemplate<ParamType.FLOAT>;
		/** @param camera near */
		near: ParamTemplate<ParamType.FLOAT>;
		/** @param camera far */
		far: ParamTemplate<ParamType.FLOAT>;
		/** @param force Render */
		render: ParamTemplate<ParamType.BUTTON>;
	};
} & typeof NodeParamsConfig;
declare class CubeMapFromSceneCopParamsConfig extends CubeMapFromSceneCopParamsConfig_base {}
declare class CubeMapFromSceneCopNode extends TypedCopNode<CubeMapFromSceneCopParamsConfig> {
	paramsConfig: CubeMapFromSceneCopParamsConfig;
	static type(): CopType;
	private _rendererController;
	private _lastGeneratedRenderTarget;
	lastGeneratedRenderTarget(): WebGLRenderTarget | undefined;
	private _setDirtyBound;
	readonly displayNodeController: DisplayNodeController;
	protected _childrenControllerContext: NodeContext;
	initializeNode(): void;
	createNode<S extends keyof GeoNodeChildrenMap>(node_class: S, options?: NodeCreateOptions): GeoNodeChildrenMap[S];
	createNode<K extends valueof<GeoNodeChildrenMap>>(node_class: Constructor<K>, options?: NodeCreateOptions): K;
	children(): BaseGlNodeType[];
	nodesByType<K extends keyof GeoNodeChildrenMap>(type: K): GeoNodeChildrenMap[K][];
	childrenAllowed(): boolean;
	private _setDirty;
	private _cookMainWithoutInputsWhenDirtyBound;
	private _cookMainWithoutInputsWhenDirty;
	cook(): Promise<void>;
	private _renderScene;
	private _renderCubeMap;
	static PARAM_CALLBACK_render(node: CubeMapFromSceneCopNode): Promise<void>;
}
declare class EnvMapCopParamsConfig extends NodeParamsConfig {
	/** @param defines if the shader is rendered via the same camera used to render the scene */
	useCameraRenderer: ParamTemplate<ParamType.BOOLEAN>;
}
declare class EnvMapCopNode extends TypedCopNode<EnvMapCopParamsConfig> {
	paramsConfig: EnvMapCopParamsConfig;
	static type(): CopType;
	private _dataTextureController;
	private _rendererController;
	initializeNode(): void;
	cook(inputTextures: Texture[]): Promise<void>;
	private _convertTextureToEnvMap;
	private _setMapping;
}
declare const GifCopParamsConfig_base: {
	new (...args: any[]): {
		tencoding: ParamTemplate<ParamType.BOOLEAN>;
		encoding: ParamTemplate<ParamType.INTEGER>;
		tmapping: ParamTemplate<ParamType.BOOLEAN>;
		mapping: ParamTemplate<ParamType.INTEGER>;
		twrap: ParamTemplate<ParamType.BOOLEAN>;
		wrapS: ParamTemplate<ParamType.INTEGER>;
		wrapT: ParamTemplate<ParamType.INTEGER>;
		tminFilter: ParamTemplate<ParamType.BOOLEAN>;
		minFilter: ParamTemplate<ParamType.INTEGER>;
		tmagFilter: ParamTemplate<ParamType.BOOLEAN>;
		magFilter: ParamTemplate<ParamType.INTEGER>;
		tanisotropy: ParamTemplate<ParamType.BOOLEAN>;
		useRendererMaxAnisotropy: ParamTemplate<ParamType.BOOLEAN>;
		anisotropy: ParamTemplate<ParamType.INTEGER>;
		tflipY: ParamTemplate<ParamType.BOOLEAN>;
		flipY: ParamTemplate<ParamType.BOOLEAN>;
		ttransform: ParamTemplate<ParamType.BOOLEAN>;
		offset: ParamTemplate<ParamType.VECTOR2>;
		repeat: ParamTemplate<ParamType.VECTOR2>;
		rotation: ParamTemplate<ParamType.FLOAT>;
		center: ParamTemplate<ParamType.VECTOR2>;
		tadvanced: ParamTemplate<ParamType.BOOLEAN>;
		tformat: ParamTemplate<ParamType.BOOLEAN>;
		format: ParamTemplate<ParamType.INTEGER>;
		ttype: ParamTemplate<ParamType.BOOLEAN>;
		type: ParamTemplate<ParamType.INTEGER>;
	};
} & {
	new (...args: any[]): {
		/** @param url to fetch the gif from */
		url: ParamTemplate<ParamType.STRING>;
		/** @param reload the image */
		reload: ParamTemplate<ParamType.BUTTON>;
		/** @param play the gif */
		play: ParamTemplate<ParamType.BOOLEAN>;
		/** @param set the gif frame */
		gifFrame: ParamTemplate<ParamType.INTEGER>;
	};
} & typeof NodeParamsConfig;
declare class GifCopParamsConfig extends GifCopParamsConfig_base {}
declare class GifCopNode extends TypedCopNode<GifCopParamsConfig> {
	paramsConfig: GifCopParamsConfig;
	static type(): CopType;
	readonly textureParamsController: TextureParamsController;
	static displayedInputNames(): string[];
	initializeNode(): void;
	cook(input_contents: Texture[]): Promise<void>;
	private _gifCanvasElement;
	private _gifCanvasContext;
	private _tmpCanvasElement;
	private _tmpCanvasContext;
	private _parsedFrames;
	private _frameDelay;
	private _frameIndex;
	private _frameImageData;
	private _createCanvas;
	private _drawOnCanvas;
	private _drawNextFrame;
	private gifUpdateFrameIndex;
	static PARAM_CALLBACK_reload(node: GifCopNode): void;
	private paramCallbackReload;
	static PARAM_CALLBACK_gifUpdatePlay(node: GifCopNode): void;
	private gifUpdatePlay;
	static PARAM_CALLBACK_gifUpdateFrameIndex(node: GifCopNode): void;
}
declare const BaseImageCopParamsConfig_base: {
	new (...args: any[]): {
		checkFileType: ParamTemplate<ParamType.BOOLEAN>;
	};
} & {
	new (...args: any[]): {
		tencoding: ParamTemplate<ParamType.BOOLEAN>;
		encoding: ParamTemplate<ParamType.INTEGER>;
		tmapping: ParamTemplate<ParamType.BOOLEAN>;
		mapping: ParamTemplate<ParamType.INTEGER>;
		twrap: ParamTemplate<ParamType.BOOLEAN>;
		wrapS: ParamTemplate<ParamType.INTEGER>;
		wrapT: ParamTemplate<ParamType.INTEGER>;
		tminFilter: ParamTemplate<ParamType.BOOLEAN>;
		minFilter: ParamTemplate<ParamType.INTEGER>;
		tmagFilter: ParamTemplate<ParamType.BOOLEAN>;
		magFilter: ParamTemplate<ParamType.INTEGER>;
		tanisotropy: ParamTemplate<ParamType.BOOLEAN>;
		useRendererMaxAnisotropy: ParamTemplate<ParamType.BOOLEAN>;
		anisotropy: ParamTemplate<ParamType.INTEGER>;
		tflipY: ParamTemplate<ParamType.BOOLEAN>;
		flipY: ParamTemplate<ParamType.BOOLEAN>;
		ttransform: ParamTemplate<ParamType.BOOLEAN>;
		offset: ParamTemplate<ParamType.VECTOR2>;
		repeat: ParamTemplate<ParamType.VECTOR2>;
		rotation: ParamTemplate<ParamType.FLOAT>;
		center: ParamTemplate<ParamType.VECTOR2>;
		tadvanced: ParamTemplate<ParamType.BOOLEAN>;
		tformat: ParamTemplate<ParamType.BOOLEAN>;
		format: ParamTemplate<ParamType.INTEGER>;
		ttype: ParamTemplate<ParamType.BOOLEAN>;
		type: ParamTemplate<ParamType.INTEGER>;
	};
} & {
	new (...args: any[]): {
		/** @param url to fetch the image from */
		url: ParamTemplate<ParamType.STRING>;
		/** @param reload the image */
		reload: ParamTemplate<ParamType.BUTTON>;
	};
} & typeof NodeParamsConfig;
declare class BaseImageCopParamsConfig extends BaseImageCopParamsConfig_base {}
declare class copImageNodeFactoryFactoryResult extends TypedCopNode<BaseImageCopParamsConfig> {
	paramsConfig: BaseImageCopParamsConfig;
	readonly textureParamsController: TextureParamsController;
}
declare const ImageCopNode_base: typeof copImageNodeFactoryFactoryResult;
declare class ImageCopNode extends ImageCopNode_base {}
declare const ImageEXRCopNode_base: typeof copImageNodeFactoryFactoryResult;
declare class ImageEXRCopNode extends ImageEXRCopNode_base {}
declare const ImageHDRCopNode_base: typeof copImageNodeFactoryFactoryResult;
declare class ImageHDRCopNode extends ImageHDRCopNode_base {}
declare const ImageKTX2CopNode_base: typeof copImageNodeFactoryFactoryResult;
declare class ImageKTX2CopNode extends ImageKTX2CopNode_base {}
declare class LightMapCopParamConfig extends NodeParamsConfig {
	/** @param click to update shadow, when mode is manual */
	update: ParamTemplate<ParamType.BUTTON>;
	/** @param defines if the shader is rendered via the same camera used to render the scene */
	useCameraRenderer: ParamTemplate<ParamType.BOOLEAN>;
	/** @param shadow resolution */
	lightMapRes: ParamTemplate<ParamType.INTEGER>;
	/** @param iterations */
	iterations: ParamTemplate<ParamType.INTEGER>;
	/** @param blendWindow */
	iterationBlend: ParamTemplate<ParamType.FLOAT>;
	/** @param blurEdges */
	blur: ParamTemplate<ParamType.BOOLEAN>;
	/** @param blurAmount */
	blurAmount: ParamTemplate<ParamType.FLOAT>;
	/** @param lightPositionVariation */
	lightRadius: ParamTemplate<ParamType.FLOAT>;
	objectsMask: ParamTemplate<ParamType.STRING>;
	lightsMask: ParamTemplate<ParamType.STRING>;
	printResolveObjectsList: ParamTemplate<ParamType.BUTTON>;
}
declare class LightMapCopNode extends TypedCopNode<LightMapCopParamConfig> {
	paramsConfig: LightMapCopParamConfig;
	static type(): Readonly<'lightMap'>;
	private lightMapController;
	private _includedObjects;
	private _includedLights;
	private _dataTextureController;
	private _rendererController;
	cook(): Promise<void>;
	private _createLightMapController;
	static PARAM_CALLBACK_update_updateMode(node: LightMapCopNode): void;
	private _updateManual;
	static PARAM_CALLBACK_updateManual(node: LightMapCopNode): void;
	private _updateObjectsAndLightsList;
	static PARAM_CALLBACK_printResolveObjectsList(node: LightMapCopNode): void;
	private _printResolveObjectsList;
}
declare class LutCopParamsConfig extends NodeParamsConfig {
	/** @param url to fetch the lut from */
	url: ParamTemplate<ParamType.STRING>;
	/** @param reload the image */
	reload: ParamTemplate<ParamType.BUTTON>;
}
declare class LutCopNode extends TypedCopNode<LutCopParamsConfig> {
	paramsConfig: LutCopParamsConfig;
	static type(): CopType;
	initializeNode(): void;
	cook(input_contents: Texture[]): Promise<void>;
	static PARAM_CALLBACK_reload(node: LutCopNode): void;
	private paramCallbackReload;
}
declare class MapboxElevationCopParamsConfig extends NodeParamsConfig {
	/** @param longitude */
	longitude: ParamTemplate<ParamType.FLOAT>;
	/** @param latitude */
	latitude: ParamTemplate<ParamType.FLOAT>;
	/** @param zoom value */
	zoom: ParamTemplate<ParamType.INTEGER>;
	/** @param highres */
	highres: ParamTemplate<ParamType.BOOLEAN>;
	/** @param source range */
	sourceRange: ParamTemplate<ParamType.VECTOR2>;
	/** @param updateRange */
	updateRange: ParamTemplate<ParamType.BOOLEAN>;
	/** @param min */
	min: ParamTemplate<ParamType.FLOAT>;
	/** @param mult */
	mult: ParamTemplate<ParamType.FLOAT>;
}
declare class MapboxElevationCopNode extends TypedCopNode<MapboxElevationCopParamsConfig> {
	paramsConfig: MapboxElevationCopParamsConfig;
	static type(): string;
	cook(): Promise<void>;
	private _cookForElevation;
	private _url;
	private _createTexture;
}
declare class MapboxSatelliteCopParamsConfig extends NodeParamsConfig {
	/** @param longitude */
	longitude: ParamTemplate<ParamType.FLOAT>;
	/** @param latitude */
	latitude: ParamTemplate<ParamType.FLOAT>;
	/** @param zoom value */
	zoom: ParamTemplate<ParamType.INTEGER>;
	/** @param highres */
	highres: ParamTemplate<ParamType.BOOLEAN>;
}
declare class MapboxSatelliteCopNode extends TypedCopNode<MapboxSatelliteCopParamsConfig> {
	paramsConfig: MapboxSatelliteCopParamsConfig;
	static type(): string;
	cook(): Promise<void>;
	private _cookForSatellite;
	private _url;
	private _createTexture;
}
declare class NullCopNode extends TypedCopNode<NodeParamsConfig> {
	paramsConfig: NodeParamsConfig;
	static type(): string;
	initializeNode(): void;
	cook(input_contents: Texture[]): Promise<void>;
}
declare class PaletteController<NC extends NodeContext> {
	private node;
	constructor(node: PaletteAbstractNode<NC>);
	static PARAM_CALLBACK_pickNext(node: PaletteAbstractNode<any>): void;
	static PARAM_CALLBACK_pickPrevious(node: PaletteAbstractNode<any>): void;
	static PARAM_CALLBACK_pickRandom(node: PaletteAbstractNode<any>): void;
	static PARAM_CALLBACK_updateColors(node: PaletteAbstractNode<any>): void;
	PARAM_CALLBACK_pickNext(): void;
	PARAM_CALLBACK_pickPrevious(): void;
	PARAM_CALLBACK_pickRandom(): void;
	private _batchUpdatesWithPalette;
	PARAM_CALLBACK_updateColors(): void;
	private _updateColors;
}
declare class PaletteAbstractNodeParamsConfig extends NodeParamsConfig {
	/** @param name of the palette */
	paletteName: ParamTemplate<ParamType.STRING>;
	/** @param click to set the node to the next palette */
	pickNext: ParamTemplate<ParamType.BUTTON>;
	/** @param click to set the node to the previous palette */
	pickPrevious: ParamTemplate<ParamType.BUTTON>;
	/** @param click to set the node to a random palette */
	pickRandom: ParamTemplate<ParamType.BUTTON>;
	colorsCount: ParamTemplate<ParamType.INTEGER>;
	/** @param palette color 1 */
	color1: ParamTemplate<ParamType.COLOR>;
	/** @param palette color 2 */
	color2: ParamTemplate<ParamType.COLOR>;
	/** @param palette color 3 */
	color3: ParamTemplate<ParamType.COLOR>;
	/** @param palette color 4 */
	color4: ParamTemplate<ParamType.COLOR>;
	/** @param palette color 5 */
	color5: ParamTemplate<ParamType.COLOR>;
}
declare class PaletteAbstractNode<NC extends NodeContext> extends TypedNode<NC, PaletteAbstractNodeParamsConfig> {
	paramsConfig: PaletteAbstractNodeParamsConfig;
	readonly paletteController: PaletteController<NC>;
}
declare class PaletteCopParamsConfig extends NodeParamsConfig {
	/** @param texture resolution */
	resolution: ParamTemplate<ParamType.VECTOR2>;
	/** @param name of the palette */
	paletteName: ParamTemplate<ParamType.STRING>;
	/** @param click to set the node to the next palette */
	pickNext: ParamTemplate<ParamType.BUTTON>;
	/** @param click to set the node to the previous palette */
	pickPrevious: ParamTemplate<ParamType.BUTTON>;
	/** @param click to set the node to a random palette */
	pickRandom: ParamTemplate<ParamType.BUTTON>;
	colorsCount: ParamTemplate<ParamType.INTEGER>;
	/** @param palette color 1 */
	color1: ParamTemplate<ParamType.COLOR>;
	/** @param palette color 2 */
	color2: ParamTemplate<ParamType.COLOR>;
	/** @param palette color 3 */
	color3: ParamTemplate<ParamType.COLOR>;
	/** @param palette color 4 */
	color4: ParamTemplate<ParamType.COLOR>;
	/** @param palette color 5 */
	color5: ParamTemplate<ParamType.COLOR>;
}
declare class PaletteCopNode extends TypedCopNode<PaletteCopParamsConfig> {
	paramsConfig: PaletteCopParamsConfig;
	static type(): string;
	readonly paletteController: PaletteController<NodeContext.COP>;
	private _dataTexture;
	private _colorParams;
	initializeNode(): void;
	private _colors;
	cook(): void;
	private _intervalIndex;
	private _createDataTexture;
	private _createPixelBuffer;
	static PARAM_CALLBACK_reset(node: PaletteCopNode): void;
	private _reset;
}
declare class FetchCopParamsConfig extends NodeParamsConfig {
	/** @param sop node */
	node: ParamTemplate<ParamType.NODE_PATH>;
	/** @param group to assign the material to */
	group: ParamTemplate<ParamType.STRING>;
	/** @param texture name */
	name: ParamTemplate<ParamType.STRING>;
}
declare class FetchCopNode extends TypedCopNode<FetchCopParamsConfig> {
	paramsConfig: FetchCopParamsConfig;
	static type(): 'fetch';
	cook(): Promise<void>;
	private _textureFromMaterial;
}
declare const RenderCopParamConfig_base: {
	new (...args: any[]): {
		tencoding: ParamTemplate<ParamType.BOOLEAN>;
		encoding: ParamTemplate<ParamType.INTEGER>;
		tmapping: ParamTemplate<ParamType.BOOLEAN>;
		mapping: ParamTemplate<ParamType.INTEGER>;
		twrap: ParamTemplate<ParamType.BOOLEAN>;
		wrapS: ParamTemplate<ParamType.INTEGER>;
		wrapT: ParamTemplate<ParamType.INTEGER>;
		tminFilter: ParamTemplate<ParamType.BOOLEAN>;
		minFilter: ParamTemplate<ParamType.INTEGER>;
		tmagFilter: ParamTemplate<ParamType.BOOLEAN>;
		magFilter: ParamTemplate<ParamType.INTEGER>;
		tanisotropy: ParamTemplate<ParamType.BOOLEAN>;
		useRendererMaxAnisotropy: ParamTemplate<ParamType.BOOLEAN>;
		anisotropy: ParamTemplate<ParamType.INTEGER>;
		tflipY: ParamTemplate<ParamType.BOOLEAN>;
		flipY: ParamTemplate<ParamType.BOOLEAN>;
		ttransform: ParamTemplate<ParamType.BOOLEAN>;
		offset: ParamTemplate<ParamType.VECTOR2>;
		repeat: ParamTemplate<ParamType.VECTOR2>;
		rotation: ParamTemplate<ParamType.FLOAT>;
		center: ParamTemplate<ParamType.VECTOR2>;
		tadvanced: ParamTemplate<ParamType.BOOLEAN>;
		tformat: ParamTemplate<ParamType.BOOLEAN>;
		format: ParamTemplate<ParamType.INTEGER>;
		ttype: ParamTemplate<ParamType.BOOLEAN>;
		type: ParamTemplate<ParamType.INTEGER>;
	};
} & {
	new (...args: any[]): {
		/** @param camera to render from */
		camera: ParamTemplate<ParamType.NODE_PATH>;
		/** @param render resolution */
		resolution: ParamTemplate<ParamType.VECTOR2>;
		/** @param use a data texture instead of a render target, which can be useful when using that texture as and envMap */
		useDataTexture: ParamTemplate<ParamType.BOOLEAN>;
		/** @param render button */
		render: ParamTemplate<ParamType.BUTTON>;
	};
} & typeof NodeParamsConfig;
declare class RenderCopParamConfig extends RenderCopParamConfig_base {}
declare class RenderCopNode extends TypedCopNode<RenderCopParamConfig> {
	paramsConfig: RenderCopParamConfig;
	static type(): Readonly<'render'>;
	readonly textureParamsController: TextureParamsController;
	private _textureCamera;
	private _cameraNode;
	private _renderTarget;
	private _rendererController;
	private _dataTextureController;
	cook(): Promise<void>;
	renderOnTarget(): Promise<void>;
	renderTarget(): Promise<WebGLRenderTarget>;
	private createRenderTargetIfRequired;
	private _renderTargetResolutionValid;
	private _createRenderTarget;
	static PARAM_CALLBACK_render(node: RenderCopNode): void;
}
declare class SDFBlurCopParamsConfig extends NodeParamsConfig {
	/** @param resolution */
	resolution: ParamTemplate<ParamType.VECTOR3>;
	/** @param boundMin */
	boundMin: ParamTemplate<ParamType.VECTOR3>;
	/** @param boundMax */
	boundMax: ParamTemplate<ParamType.VECTOR3>;
}
declare class SDFBlurCopNode extends TypedCopNode<SDFBlurCopParamsConfig> {
	paramsConfig: SDFBlurCopParamsConfig;
	static type(): CopType;
	initializeNode(): void;
	cook(inputContents: Texture[]): Promise<void>;
}
declare class SDFExporterCopParamsConfig extends NodeParamsConfig {
	/** @param fileName */
	fileName: ParamTemplate<ParamType.STRING>;
	/** @param download texture */
	download: ParamTemplate<ParamType.BUTTON>;
}
declare class SDFExporterCopNode extends TypedCopNode<SDFExporterCopParamsConfig> {
	paramsConfig: SDFExporterCopParamsConfig;
	static type(): string;
	initializeNode(): void;
	cook(inputContents: Texture[]): Promise<void>;
	static PARAM_CALLBACK_download(node: SDFExporterCopNode): void;
	private _downloadTexture;
}
export interface FillTextureOptions {
	resolution: Vector3;
	bbox: Box3;
	bboxSize: Vector3;
	voxelSizes: Vector3;
}
declare class SDFFromObjectCopParamsConfig extends NodeParamsConfig {
	/** @param which SOP node to import from */
	geometry: ParamTemplate<ParamType.NODE_PATH>;
	/** @param voxelSize */
	voxelSize: ParamTemplate<ParamType.FLOAT>;
	/** @param padding */
	padding: ParamTemplate<ParamType.INTEGER>;
	/** @param resolution */
	resolution: ParamTemplate<ParamType.VECTOR3>;
	/** @param boundMin */
	boundMin: ParamTemplate<ParamType.VECTOR3>;
	/** @param boundMax */
	boundMax: ParamTemplate<ParamType.VECTOR3>;
}
declare class SDFFromObjectCopNode extends TypedCopNode<SDFFromObjectCopParamsConfig> {
	paramsConfig: SDFFromObjectCopParamsConfig;
	static type(): CopType;
	cook(inputContents: Texture[]): Promise<void>;
	_fillTexture(object: MeshWithBVH, options: FillTextureOptions): Data3DTexture;
	private __dataTexture;
	private _resolutionUsed;
	_dataTexture(resolution: Vector3): Data3DTexture;
	private createTextureTargetIfRequired;
	private _textureResolutionValid;
	private _createTexture;
}
declare class SDFFromUrlCopParamsConfig extends NodeParamsConfig {
	/** @param url to fetch the image from */
	url: ParamTemplate<ParamType.STRING>;
	/** @param reload */
	reload: ParamTemplate<ParamType.BUTTON>;
	/** @param resolution */
	resolution: ParamTemplate<ParamType.VECTOR3>;
	/** @param boundMin */
	boundMin: ParamTemplate<ParamType.VECTOR3>;
	/** @param boundMax */
	boundMax: ParamTemplate<ParamType.VECTOR3>;
}
declare class SDFFromUrlCopNode extends TypedCopNode<SDFFromUrlCopParamsConfig> {
	paramsConfig: SDFFromUrlCopParamsConfig;
	static type(): CopType;
	cook(inputContents: Texture[]): Promise<void>;
	static PARAM_CALLBACK_reload(node: SDFFromUrlCopNode): void;
}
declare const SnapshotCopParamsConfig_base: {
	new (...args: any[]): {
		/** @param capture */
		capture: ParamTemplate<ParamType.BUTTON>;
	};
} & typeof NodeParamsConfig;
declare class SnapshotCopParamsConfig extends SnapshotCopParamsConfig_base {}
declare class SnapshotCopNode extends TypedCopNode<SnapshotCopParamsConfig> {
	paramsConfig: SnapshotCopParamsConfig;
	static type(): CopType;
	static displayedInputNames(): string[];
	initializeNode(): void;
	cook(inputTextures: Texture[]): Promise<void>;
	static PARAM_CALLBACK_snapshot(node: SnapshotCopNode): void;
	private paramCallbackSnapshot;
	private _videoSnapshotCanvas;
	private _canvas;
	private _canvasTexture;
}
declare class SwitchCopParamsConfig extends NodeParamsConfig {
	/** @param input index */
	input: ParamTemplate<ParamType.INTEGER>;
}
declare class SwitchCopNode extends TypedCopNode<SwitchCopParamsConfig> {
	paramsConfig: SwitchCopParamsConfig;
	static type(): string;
	initializeNode(): void;
	cook(): Promise<void>;
	private _callbackUpdateInputsEvaluation;
	static PARAM_CALLBACK_setInputsEvaluation(node: SwitchCopNode): void;
}
declare const TexturePropertiesCopParamsConfig_base: {
	new (...args: any[]): {
		tencoding: ParamTemplate<ParamType.BOOLEAN>;
		encoding: ParamTemplate<ParamType.INTEGER>;
		tmapping: ParamTemplate<ParamType.BOOLEAN>;
		mapping: ParamTemplate<ParamType.INTEGER>;
		twrap: ParamTemplate<ParamType.BOOLEAN>;
		wrapS: ParamTemplate<ParamType.INTEGER>;
		wrapT: ParamTemplate<ParamType.INTEGER>;
		tminFilter: ParamTemplate<ParamType.BOOLEAN>;
		minFilter: ParamTemplate<ParamType.INTEGER>;
		tmagFilter: ParamTemplate<ParamType.BOOLEAN>;
		magFilter: ParamTemplate<ParamType.INTEGER>;
		tanisotropy: ParamTemplate<ParamType.BOOLEAN>;
		useRendererMaxAnisotropy: ParamTemplate<ParamType.BOOLEAN>;
		anisotropy: ParamTemplate<ParamType.INTEGER>;
		tflipY: ParamTemplate<ParamType.BOOLEAN>;
		flipY: ParamTemplate<ParamType.BOOLEAN>;
		ttransform: ParamTemplate<ParamType.BOOLEAN>;
		offset: ParamTemplate<ParamType.VECTOR2>;
		repeat: ParamTemplate<ParamType.VECTOR2>;
		rotation: ParamTemplate<ParamType.FLOAT>;
		center: ParamTemplate<ParamType.VECTOR2>;
		tadvanced: ParamTemplate<ParamType.BOOLEAN>;
		tformat: ParamTemplate<ParamType.BOOLEAN>;
		format: ParamTemplate<ParamType.INTEGER>;
		ttype: ParamTemplate<ParamType.BOOLEAN>;
		type: ParamTemplate<ParamType.INTEGER>;
	};
} & typeof NodeParamsConfig;
declare class TexturePropertiesCopParamsConfig extends TexturePropertiesCopParamsConfig_base {}
declare class TexturePropertiesCopNode extends TypedCopNode<TexturePropertiesCopParamsConfig> {
	paramsConfig: TexturePropertiesCopParamsConfig;
	static type(): string;
	readonly textureParamsController: TextureParamsController;
	initializeNode(): void;
	cook(input_contents: Texture[]): Promise<void>;
}
declare enum VideoMode {
	FROM_URLS = 'From Urls',
	FROM_HTML_ELEMENT = 'From HTML Element',
}
declare const VideoCopParamsConfig_base: {
	new (...args: any[]): {
		checkFileType: ParamTemplate<ParamType.BOOLEAN>;
	};
} & {
	new (...args: any[]): {
		tencoding: ParamTemplate<ParamType.BOOLEAN>;
		encoding: ParamTemplate<ParamType.INTEGER>;
		tmapping: ParamTemplate<ParamType.BOOLEAN>;
		mapping: ParamTemplate<ParamType.INTEGER>;
		twrap: ParamTemplate<ParamType.BOOLEAN>;
		wrapS: ParamTemplate<ParamType.INTEGER>;
		wrapT: ParamTemplate<ParamType.INTEGER>;
		tminFilter: ParamTemplate<ParamType.BOOLEAN>;
		minFilter: ParamTemplate<ParamType.INTEGER>;
		tmagFilter: ParamTemplate<ParamType.BOOLEAN>;
		magFilter: ParamTemplate<ParamType.INTEGER>;
		tanisotropy: ParamTemplate<ParamType.BOOLEAN>;
		useRendererMaxAnisotropy: ParamTemplate<ParamType.BOOLEAN>;
		anisotropy: ParamTemplate<ParamType.INTEGER>;
		tflipY: ParamTemplate<ParamType.BOOLEAN>;
		flipY: ParamTemplate<ParamType.BOOLEAN>;
		ttransform: ParamTemplate<ParamType.BOOLEAN>;
		offset: ParamTemplate<ParamType.VECTOR2>;
		repeat: ParamTemplate<ParamType.VECTOR2>;
		rotation: ParamTemplate<ParamType.FLOAT>;
		center: ParamTemplate<ParamType.VECTOR2>;
		tadvanced: ParamTemplate<ParamType.BOOLEAN>;
		tformat: ParamTemplate<ParamType.BOOLEAN>;
		format: ParamTemplate<ParamType.INTEGER>;
		ttype: ParamTemplate<ParamType.BOOLEAN>;
		type: ParamTemplate<ParamType.INTEGER>;
	};
} & {
	new (...args: any[]): {
		/** @param mode */
		mode: ParamTemplate<ParamType.INTEGER>;
		/** @param number of video files to fetch */
		urlsCount: ParamTemplate<ParamType.INTEGER>;
		/** @param url to fetch the video from */
		url1: ParamTemplate<ParamType.STRING>;
		/** @param url to fetch the video from */
		url2: ParamTemplate<ParamType.STRING>;
		/** @param url to fetch the video from */
		url3: ParamTemplate<ParamType.STRING>;
		/** @param selector */
		selector: ParamTemplate<ParamType.STRING>;
		/** @param reload the video */
		reload: ParamTemplate<ParamType.BUTTON>;
		/** @param play the video */
		play: ParamTemplate<ParamType.BOOLEAN>;
		/** @param set the video muted attribute */
		muted: ParamTemplate<ParamType.BOOLEAN>;
		/** @param set the video loop attribute */
		loop: ParamTemplate<ParamType.BOOLEAN>;
		/** @param set the video time */
		videoTime: ParamTemplate<ParamType.FLOAT>;
		/** @param seek the video at the time specified in videoTime */
		setVideoTime: ParamTemplate<ParamType.BUTTON>;
	};
} & typeof NodeParamsConfig;
declare class VideoCopParamsConfig extends VideoCopParamsConfig_base {}
declare class VideoCopNode extends TypedCopNode<VideoCopParamsConfig> {
	paramsConfig: VideoCopParamsConfig;
	static type(): CopType;
	private _video;
	HTMLVideoElement(): HTMLVideoElement | undefined;
	readonly textureParamsController: TextureParamsController;
	static displayedInputNames(): string[];
	initializeNode(): void;
	dispose(): void;
	private _disposeHTMLVideoElement;
	setMode(mode: VideoMode): void;
	mode(): VideoMode;
	cook(input_contents: Texture[]): Promise<void>;
	private _videoBoundEvents;
	private _addVideoEvents;
	private _removeVideoEvents;
	private _onVideoEvent;
	private _onVideoEventPlay;
	private _onVideoEventPause;
	private _onVideoEventTimeUpdate;
	private _onVideoEventVolumeChange;
	videoStatePlaying(): boolean;
	videoStateMuted(): boolean;
	videoDuration(): number;
	videoCurrentTime(): number;
	static PARAM_CALLBACK_videoUpdateTime(node: VideoCopNode): void;
	private videoUpdateTime;
	private _videoUpdateTime;
	static PARAM_CALLBACK_videoUpdatePlay(node: VideoCopNode): void;
	private videoUpdatePlay;
	private _videoUpdatePlay;
	static PARAM_CALLBACK_videoUpdateMuted(node: VideoCopNode): void;
	private videoUpdateMuted;
	private _videoUpdateMuted;
	static PARAM_CALLBACK_videoUpdateLoop(node: VideoCopNode): void;
	private videoUpdateLoop;
	private _videoUpdateLoop;
	private _videoTextureFromSelector;
	urlParams(): StringParam[];
	private _urlsToLoad;
	static PARAM_CALLBACK_reload(node: VideoCopNode, param: BaseParamType): void;
	private paramCallbackReload;
	private _loadTexture;
}
declare enum WebCamFacingMode {
	USER = 'user',
	ENVIRONMENT = 'environment',
}
declare const WebCamCopParamsConfig_base: {
	new (...args: any[]): {
		tencoding: ParamTemplate<ParamType.BOOLEAN>;
		encoding: ParamTemplate<ParamType.INTEGER>;
		tmapping: ParamTemplate<ParamType.BOOLEAN>;
		mapping: ParamTemplate<ParamType.INTEGER>;
		twrap: ParamTemplate<ParamType.BOOLEAN>;
		wrapS: ParamTemplate<ParamType.INTEGER>;
		wrapT: ParamTemplate<ParamType.INTEGER>;
		tminFilter: ParamTemplate<ParamType.BOOLEAN>;
		minFilter: ParamTemplate<ParamType.INTEGER>;
		tmagFilter: ParamTemplate<ParamType.BOOLEAN>;
		magFilter: ParamTemplate<ParamType.INTEGER>;
		tanisotropy: ParamTemplate<ParamType.BOOLEAN>;
		useRendererMaxAnisotropy: ParamTemplate<ParamType.BOOLEAN>;
		anisotropy: ParamTemplate<ParamType.INTEGER>;
		tflipY: ParamTemplate<ParamType.BOOLEAN>;
		flipY: ParamTemplate<ParamType.BOOLEAN>;
		ttransform: ParamTemplate<ParamType.BOOLEAN>;
		offset: ParamTemplate<ParamType.VECTOR2>;
		repeat: ParamTemplate<ParamType.VECTOR2>;
		rotation: ParamTemplate<ParamType.FLOAT>;
		center: ParamTemplate<ParamType.VECTOR2>;
		tadvanced: ParamTemplate<ParamType.BOOLEAN>;
		tformat: ParamTemplate<ParamType.BOOLEAN>;
		format: ParamTemplate<ParamType.INTEGER>;
		ttype: ParamTemplate<ParamType.BOOLEAN>;
		type: ParamTemplate<ParamType.INTEGER>;
	};
} & {
	new (...args: any[]): {
		/** @param texture resolution */
		res: ParamTemplate<ParamType.VECTOR2>;
		/** @param facingMode (on a mobile device, 'user' is the front camera, 'environment' is the back one ) */
		facingMode: ParamTemplate<ParamType.INTEGER>;
	};
} & typeof NodeParamsConfig;
declare class WebCamCopParamsConfig extends WebCamCopParamsConfig_base {}
declare class WebCamCopNode extends TypedCopNode<WebCamCopParamsConfig> {
	paramsConfig: WebCamCopParamsConfig;
	static type(): CopType;
	private _video;
	HTMLVideoElement(): HTMLVideoElement | undefined;
	readonly textureParamsController: TextureParamsController;
	static displayedInputNames(): string[];
	initializeNode(): void;
	dispose(): void;
	setFacingMode(facingMode: WebCamFacingMode): void;
	private _stream;
	private _cancelWebcamRequest;
	private _createHTMLVideoElement;
	cook(inputContents: Texture[]): Promise<void>;
}
declare class ParamLessNetworkCopParamsConfig extends NodeParamsConfig {}
declare class BaseNetworkCopNode<K extends NodeParamsConfig> extends TypedNode<NodeContext.COP, K> {
	static context(): NodeContext;
	cook(): void;
}
declare class ParamLessBaseNetworkCopNode extends BaseNetworkCopNode<ParamLessNetworkCopParamsConfig> {}
declare class ActorsNetworkCopNode extends ParamLessBaseNetworkCopNode {
	static type(): NetworkNodeType;
	protected _childrenControllerContext: NodeContext;
	createNode<S extends keyof JsNodeChildrenMap>(node_class: S, options?: NodeCreateOptions): JsNodeChildrenMap[S];
	createNode<K extends valueof<JsNodeChildrenMap>>(node_class: Constructor<K>, options?: NodeCreateOptions): K;
	children(): BaseJsNodeType[];
	nodesByType<K extends keyof JsNodeChildrenMap>(type: K): JsNodeChildrenMap[K][];
	childrenAllowed(): boolean;
	sceneReadonly(): boolean;
	readonly persisted_config: ActorPersistedConfig;
	assemblerController(): JsAssemblerController<JsAssemblerActor> | undefined;
	usedAssembler(): Readonly<AssemblerName.JS_ACTOR>;
	protected _assemblerController: JsAssemblerController<JsAssemblerActor> | undefined;
	private _createAssemblerController;
	readonly compilationController: ActorCompilationController;
	compile(): void;
	cook(): void;
}
declare class AnimationsNetworkCopNode extends ParamLessBaseNetworkCopNode {
	static type(): NetworkNodeType;
	protected _childrenControllerContext: NodeContext;
	createNode<S extends keyof AnimNodeChildrenMap>(node_class: S, options?: NodeCreateOptions): AnimNodeChildrenMap[S];
	createNode<K extends valueof<AnimNodeChildrenMap>>(node_class: Constructor<K>, options?: NodeCreateOptions): K;
	children(): BaseAnimNodeType[];
	nodesByType<K extends keyof AnimNodeChildrenMap>(type: K): AnimNodeChildrenMap[K][];
}
declare class AudioNetworkCopNode extends ParamLessBaseNetworkCopNode {
	static type(): NetworkNodeType;
	protected _childrenControllerContext: NodeContext;
	createNode<S extends keyof AudioNodeChildrenMap>(
		node_class: S,
		options?: NodeCreateOptions
	): AudioNodeChildrenMap[S];
	createNode<K extends valueof<AudioNodeChildrenMap>>(node_class: Constructor<K>, options?: NodeCreateOptions): K;
	children(): BaseAudioNodeType[];
	nodesByType<K extends keyof AudioNodeChildrenMap>(type: K): AudioNodeChildrenMap[K][];
}
declare class EventsNetworkCopNode extends ParamLessBaseNetworkCopNode {
	static type(): NetworkNodeType;
	protected _childrenControllerContext: NodeContext;
	createNode<S extends keyof EventNodeChildrenMap>(
		node_class: S,
		options?: NodeCreateOptions
	): EventNodeChildrenMap[S];
	createNode<K extends valueof<EventNodeChildrenMap>>(node_class: Constructor<K>, options?: NodeCreateOptions): K;
	children(): BaseEventNodeType[];
	nodesByType<K extends keyof EventNodeChildrenMap>(type: K): EventNodeChildrenMap[K][];
}
declare class CopNetworkCopNode extends ParamLessBaseNetworkCopNode {
	static type(): NetworkNodeType;
	protected _childrenControllerContext: NodeContext;
	createNode<S extends keyof CopNodeChildrenMap>(node_class: S, options?: NodeCreateOptions): CopNodeChildrenMap[S];
	createNode<K extends valueof<CopNodeChildrenMap>>(node_class: Constructor<K>, options?: NodeCreateOptions): K;
	children(): BaseCopNodeType[];
	nodesByType<K extends keyof CopNodeChildrenMap>(type: K): CopNodeChildrenMap[K][];
}
declare class MaterialsNetworkCopNode extends ParamLessBaseNetworkCopNode {
	static type(): NetworkNodeType;
	protected _childrenControllerContext: NodeContext;
	createNode<S extends keyof MatNodeChildrenMap>(node_class: S, options?: NodeCreateOptions): MatNodeChildrenMap[S];
	createNode<K extends valueof<MatNodeChildrenMap>>(node_class: Constructor<K>, options?: NodeCreateOptions): K;
	children(): BaseMatNodeType[];
	nodesByType<K extends keyof MatNodeChildrenMap>(type: K): MatNodeChildrenMap[K][];
}
declare const PostProcessNetworkParamsConfig_base: {
	new (...args: any[]): {
		prependRenderPass: ParamTemplate<ParamType.BOOLEAN>;
		depthBuffer: ParamTemplate<ParamType.BOOLEAN>;
		stencilBuffer: ParamTemplate<ParamType.BOOLEAN>;
		sampling: ParamTemplate<ParamType.INTEGER>;
		tTextureType: ParamTemplate<ParamType.BOOLEAN>;
		textureType: ParamTemplate<ParamType.INTEGER>;
	};
} & typeof NodeParamsConfig;
declare class PostProcessNetworkParamsConfig extends PostProcessNetworkParamsConfig_base {}
export interface BaseNetworkPostProcessNodeType extends TypedNode<any, PostProcessNetworkParamsConfig> {
	readonly displayNodeController: DisplayNodeController;
	createNode<S extends keyof PostNodeChildrenMap>(node_class: S): PostNodeChildrenMap[S];
	createNode<K extends valueof<PostNodeChildrenMap>>(node_class: Constructor<K>): K;
	children(): BasePostProcessNodeType[];
	nodesByType<K extends keyof PostNodeChildrenMap>(type: K): PostNodeChildrenMap[K][];
	readonly effectsComposerController: EffectComposerController;
}
export interface CreateEffectsComposerOptions {
	renderer: WebGLRenderer;
	scene: Scene;
	camera: Camera;
	viewer: BaseViewerType;
}
declare class EffectComposerController {
	private node;
	private _composerAndOptionsByCamera;
	constructor(node: BaseNetworkPostProcessNodeType);
	displayNodeControllerCallbacks(): DisplayNodeControllerCallbacks;
	private _nextId;
	createEffectsComposer(options: CreateEffectsComposerOptions): EffectComposer;
	createEffectsComposerAndBuildPasses(options: CreateEffectsComposerOptions): EffectComposer;
	private _updateComposers;
	private _passByNodeInBuildPassesProcess;
	addPassByNodeInBuildPassesProcess(node: BaseNodeType, pass: Pass, composer: EffectComposer): void;
	private _buildPasses;
}
export interface TypedPostNodeContext {
	composerController: EffectComposerController;
	composer: EffectComposer;
	camera: Camera;
	renderer: WebGLRenderer;
	scene: Scene;
	viewer: BaseViewerType;
}
declare class TypedPostNode<P extends Pass, K extends NodeParamsConfig> extends TypedNode<NodeContext.POST, K> {
	static context(): NodeContext;
	readonly flags: FlagsControllerDB;
	protected _passesByEffectsComposer: Map<EffectComposer, P | P[]>;
	static displayedInputNames(): string[];
	initializeNode(): void;
	cook(): void;
	setupComposer(context: TypedPostNodeContext): void;
	protected _setupComposerIfActive(context: TypedPostNodeContext): void;
	passesByComposer(composer: EffectComposer): P | P[] | undefined;
	protected _addPassFromInput(index: number, context: TypedPostNodeContext): void;
	createPassForContext(context: TypedPostNodeContext): P | P[] | undefined;
	createPass(context: TypedPostNodeContext): P | P[] | undefined;
	static PARAM_CALLBACK_updatePasses(node: BasePostProcessNodeType): void;
	protected _updatePasses(): void;
	protected updatePass(pass: P): void;
	protected _postProcessNetworkNode(): BaseNetworkPostProcessNodeType;
}
export declare type BasePostProcessNodeType = TypedPostNode<Pass, NodeParamsConfig>;
declare class AntialiasingPostParamsConfig extends NodeParamsConfig {
	/** @param opacity */
	opacity: ParamTemplate<ParamType.FLOAT>;
}
declare class AntialiasingPostNode extends TypedPostNode<EffectPass, AntialiasingPostParamsConfig> {
	paramsConfig: AntialiasingPostParamsConfig;
	static type(): string;
	createPass(context: TypedPostNodeContext): EffectPass;
	updatePass(pass: EffectPass): void;
}
declare class BloomPostParamsConfig extends NodeParamsConfig {
	/** @param defines if this node applies a bloom to the whole scene or just a selection. Note that for now, it is necessary to reload your scene when toggling this parameter */
	useObjectMask: ParamTemplate<ParamType.BOOLEAN>;
	/** @param object mask of the objects that will be used for the bloom */
	objectsMask: ParamTemplate<ParamType.STRING>;
	/** @param updates the cached objects found by objectMask  */
	refreshObjects: ParamTemplate<ParamType.BUTTON>;
	/** @param effect strength */
	strength: ParamTemplate<ParamType.FLOAT>;
	/** @param effect threshold */
	threshold: ParamTemplate<ParamType.FLOAT>;
	/** @param effect scale */
	scale: ParamTemplate<ParamType.FLOAT>;
	/** @param effect radius */
	/** @param kernel size */
	kernelSize: ParamTemplate<ParamType.INTEGER>;
	/** @param effect luminance Smoothing */
	luminanceSmoothing: ParamTemplate<ParamType.FLOAT>;
	/** @param resolutionScale */
	resolutionScale: ParamTemplate<ParamType.FLOAT>;
	/** @param opacity */
	opacity: ParamTemplate<ParamType.FLOAT>;
	/** @param render mode */
	blendFunction: ParamTemplate<ParamType.INTEGER>;
}
declare class BloomPostNode extends TypedPostNode<EffectPass, BloomPostParamsConfig> {
	paramsConfig: BloomPostParamsConfig;
	static type(): string;
	private _rendererSize;
	createPass(context: TypedPostNodeContext): EffectPass;
	updatePass(pass: EffectPass): void;
	private __selectionController;
	private _selectionController;
	private _setSelectedObjects;
}
declare class BlurPostParamsConfig extends NodeParamsConfig {
	/** @param amount */
	amount: ParamTemplate<ParamType.FLOAT>;
	/** @param kernel size */
	kernelSize: ParamTemplate<ParamType.INTEGER>;
}
declare class BlurPostNode extends TypedPostNode<KawaseBlurPass, BlurPostParamsConfig> {
	paramsConfig: BlurPostParamsConfig;
	static type(): string;
	createPass(context: TypedPostNodeContext): KawaseBlurPass;
	updatePass(pass: KawaseBlurPass): void;
}
declare class BrightnessContrastPostParamsConfig extends NodeParamsConfig {
	/** @param brightness */
	brightness: ParamTemplate<ParamType.FLOAT>;
	/** @param contrast */
	contrast: ParamTemplate<ParamType.FLOAT>;
	/** @param effect opacity */
	opacity: ParamTemplate<ParamType.FLOAT>;
	/** @param render mode */
	blendFunction: ParamTemplate<ParamType.INTEGER>;
}
declare class BrightnessContrastPostNode extends TypedPostNode<EffectPass, BrightnessContrastPostParamsConfig> {
	paramsConfig: BrightnessContrastPostParamsConfig;
	static type(): string;
	createPass(context: TypedPostNodeContext): EffectPass;
	updatePass(pass: EffectPass): void;
}
export interface IUniformsWithTime extends IUniforms {
	time: IUniformN;
}
export interface AddUniformOptions {
	paramConfigs: readonly GlParamConfig<ParamType>[];
	additionalTextureUniforms: PolyDictionary<IUniformTexture>;
	timeDependent: boolean;
	resolutionDependent: boolean;
	raymarchingLightsWorldCoordsDependent: boolean;
}
declare class UniformsController {
	private scene;
	constructor(scene: PolyScene);
	addUniforms(uniforms: IUniforms, options: AddUniformOptions): void;
	addTimeUniform(uniforms: IUniforms): void;
	removeTimeUniform(uniforms: IUniforms): void;
	timeUniformValue(): number;
	addResolutionUniforms(uniforms: IUniforms): void;
	removeResolutionUniform(uniforms: IUniforms): void;
	addRaymarchingUniforms(uniforms: IUniforms): void;
	removeRaymarchingUniform(uniforms: IUniforms): void;
	updateResolution(resolution: Vector2, pixelRatio: number): void;
}
export interface PersistedConfigBasePostData extends PersistedConfigWithShaders {
	uniforms: IUniforms;
	param_uniform_pairs: [string, string][];
	uniforms_time_dependent?: boolean;
	uniforms_resolution_dependent?: boolean;
}
declare class PostPersistedConfig extends BasePersistedConfig {
	protected node: BuilderPostNode;
	constructor(node: BuilderPostNode);
	toData(): Promise<PersistedConfigBasePostData | undefined>;
	load(data: PersistedConfigBasePostData): void;
}
declare enum PostType {
	BUILDER = 'builder',
}
declare class ShaderAssemblerPost extends BaseGlShaderAssembler {
	private _uniforms;
	templateShader(): {
		fragmentShader: string;
		vertexShader: undefined;
		uniforms: undefined;
	};
	fragment_shader(): string | undefined;
	uniforms(): IUniforms | undefined;
	updateFragmentShader(): void;
	add_output_inputs(output_child: OutputGlNode): void;
	add_globals_outputs(globals_node: GlobalsGlNode): void;
	create_shader_configs(): ShaderConfig[];
	create_variable_configs(): VariableConfig[];
	protected insertDefineAfter(shader_name: ShaderName): string;
	protected insertBodyAfter(shader_name: ShaderName): string;
	protected linesToRemove(shader_name: ShaderName): string[];
	private _handle_gl_FragCoord;
	private _handle_resolution;
	private _handleUV;
	set_node_lines_output(output_node: OutputGlNode, shaders_collection_controller: ShadersCollectionController): void;
	set_node_lines_globals(
		globals_node: GlobalsGlNode,
		shaders_collection_controller: ShadersCollectionController
	): void;
}
declare class BuilderPostParamsConfig extends NodeParamsConfig {
	/** @param effect amount */
	useInput1OuputBuffer: ParamTemplate<ParamType.BOOLEAN>;
}
declare class BuilderPostNode extends TypedPostNode<EffectPass, BuilderPostParamsConfig> {
	paramsConfig: BuilderPostParamsConfig;
	static type(): PostType;
	readonly persisted_config: PostPersistedConfig;
	protected _assemblerController: GlAssemblerController<ShaderAssemblerPost> | undefined;
	usedAssembler(): Readonly<AssemblerName.GL_POST>;
	protected _createAssemblerController(): GlAssemblerController<ShaderAssemblerPost> | undefined;
	assemblerController(): GlAssemblerController<ShaderAssemblerPost> | undefined;
	protected _childrenControllerContext: NodeContext;
	initializeNode(): void;
	createNode<S extends keyof GlNodeChildrenMap>(node_class: S, options?: NodeCreateOptions): GlNodeChildrenMap[S];
	createNode<K extends valueof<GlNodeChildrenMap>>(node_class: Constructor<K>, options?: NodeCreateOptions): K;
	children(): BaseGlNodeType[];
	nodesByType<K extends keyof GlNodeChildrenMap>(type: K): GlNodeChildrenMap[K][];
	childrenAllowed(): boolean;
	sceneReadonly(): boolean;
	/**
	 *
	 * FRAGMENT SHADER UPDATE
	 *
	 */
	private _fragmentShader;
	private _uniforms;
	fragmentShader(): string;
	setFragmentShader(fragmentShader: string): void;
	uniforms(): IUniforms;
	setUniforms(uniforms: IUniforms): void;
	shaders_by_name(): {
		fragment: string;
	};
	compileIfRequired(): void;
	private compile;
	static handleDependencies(node: BuilderPostNode, timeDependent: boolean, uniforms?: IUniformsWithTime): void;
	/**
	 *
	 * PASS CREATE / UPDATE
	 *
	 */
	createPass(context: TypedPostNodeContext): EffectPass;
	updatePass(pass: EffectPass): void;
	protected _createEffectComposer(context: TypedPostNodeContext): import('postprocessing').EffectComposer;
}
declare class ChromaticAberrationPostParamsConfig extends NodeParamsConfig {
	/** @param effect amount */
	amount: ParamTemplate<ParamType.FLOAT>;
	/** @param effect dir */
	direction: ParamTemplate<ParamType.VECTOR2>;
}
declare class ChromaticAberrationPostNode extends TypedPostNode<EffectPass, ChromaticAberrationPostParamsConfig> {
	paramsConfig: ChromaticAberrationPostParamsConfig;
	static type(): string;
	createPass(context: TypedPostNodeContext): EffectPass;
	updatePass(pass: EffectPass): void;
}
declare class DepthOfFieldPostParamsConfig extends NodeParamsConfig {
	depthOfField: ParamTemplate<ParamType.FOLDER>;
	/** @param focalDepth */
	focusDistance: ParamTemplate<ParamType.FLOAT>;
	/** @param focalDepth */
	focusRange: ParamTemplate<ParamType.FLOAT>;
	/** @param bokeh scale */
	bokehScale: ParamTemplate<ParamType.FLOAT>;
	vignette: ParamTemplate<ParamType.FOLDER>;
	/** @param vignetting */
	vignetting: ParamTemplate<ParamType.BOOLEAN>;
	/** @param vignette technique */
	vignettingTechnique: ParamTemplate<ParamType.INTEGER>;
	/** @param vignette darkness */
	vignetteDarkness: ParamTemplate<ParamType.FLOAT>;
	/** @param vignette offset */
	vignetteOffset: ParamTemplate<ParamType.FLOAT>;
	debug: ParamTemplate<ParamType.FOLDER>;
	/** @param render mode */
	renderMode: ParamTemplate<ParamType.INTEGER>;
}
declare class DepthOfFieldPostNode extends TypedPostNode<EffectPass, DepthOfFieldPostParamsConfig> {
	paramsConfig: DepthOfFieldPostParamsConfig;
	static type(): string;
	createPass(context: TypedPostNodeContext): EffectPass;
	updatePass(pass: EffectPass): void;
	private _updateSmaaPass;
	private _updateDOFPass;
}
declare class EffectPassPostParamsConfig extends NodeParamsConfig {
	/** @param number of inputs that this node can merge geometries from */
	inputsCount: ParamTemplate<ParamType.INTEGER>;
}
declare class EffectPassPostNode extends TypedPostNode<EffectPass, EffectPassPostParamsConfig> {
	paramsConfig: EffectPassPostParamsConfig;
	static type(): string;
	static displayedInputNames(): string[];
	initializeNode(): void;
	_setupComposerIfActive(context: TypedPostNodeContext): void;
	updatePass(pass: EffectPass): void;
	private _callbackUpdateInputsCount;
	static PARAM_CALLBACK_setInputsCount(node: EffectPassPostNode): void;
}
declare class GlitchPostParamsConfig extends NodeParamsConfig {
	texture: ParamTemplate<ParamType.NODE_PATH>;
	/** @param mode */
	mode: ParamTemplate<ParamType.INTEGER>;
	minDelay: ParamTemplate<ParamType.FLOAT>;
	maxDelay: ParamTemplate<ParamType.FLOAT>;
	minDuration: ParamTemplate<ParamType.FLOAT>;
	maxDuration: ParamTemplate<ParamType.FLOAT>;
	minStrength: ParamTemplate<ParamType.FLOAT>;
	maxStrength: ParamTemplate<ParamType.FLOAT>;
	/** @param columns */
	columns: ParamTemplate<ParamType.INTEGER>;
	/** @param ratio */
	ratio: ParamTemplate<ParamType.FLOAT>;
	/** @param blend function */
	blendFunction: ParamTemplate<ParamType.INTEGER>;
	/** @param if true, the offset parameter will be updated on each render to reflect the intensity of the glitch. This can be used to drive other effects with it */
	updateOffset: ParamTemplate<ParamType.BOOLEAN>;
	offset: ParamTemplate<ParamType.VECTOR2>;
}
declare class GlitchPostNode extends TypedPostNode<EffectPass, GlitchPostParamsConfig> {
	paramsConfig: GlitchPostParamsConfig;
	static type(): string;
	private _rendererSize;
	createPass(context: TypedPostNodeContext): EffectPass;
	updatePass(pass: EffectPass): Promise<void>;
	private _fetchTexture;
	private _lastEffect;
	private _lastViewer;
	private _offsetArray;
	private _onTickCallbackName;
	private _updateOnTickCallback;
	private _onRenderBound;
	private _onRender;
}
declare class GodRaysPostParamsConfig extends NodeParamsConfig {
	/** @param objects to emit godrays from. Note that while the mask can resolve multiple objects, only the first mesh or points will be used */
	objectMask: ParamTemplate<ParamType.STRING>;
	/** @param samples */
	samples: ParamTemplate<ParamType.INTEGER>;
	/** @param density */
	density: ParamTemplate<ParamType.FLOAT>;
	/** @param decay */
	decay: ParamTemplate<ParamType.FLOAT>;
	/** @param weight */
	weight: ParamTemplate<ParamType.FLOAT>;
	/** @param exposure */
	exposure: ParamTemplate<ParamType.FLOAT>;
	/** @param blur */
	blur: ParamTemplate<ParamType.BOOLEAN>;
	/** @param kernel size */
	kernelSize: ParamTemplate<ParamType.INTEGER>;
	/** @param resolutionScale */
	resolutionScale: ParamTemplate<ParamType.FLOAT>;
	/** @param effect opacity */
	opacity: ParamTemplate<ParamType.FLOAT>;
	/** @param render mode */
	blendFunction: ParamTemplate<ParamType.INTEGER>;
}
declare class GodRaysPostNode extends TypedPostNode<EffectPass, GodRaysPostParamsConfig> {
	paramsConfig: GodRaysPostParamsConfig;
	static type(): string;
	private _rendererSize;
	createPass(context: TypedPostNodeContext): EffectPass;
	updatePass(pass: EffectPass): void;
}
export declare type GodRaysVolumetricAcceptedLightType = PointLight | DirectionalLight;
export interface GodraysPassParams {
	/**
	 * The rate of accumulation for the godrays.  Higher values roughly equate to more humid air/denser fog.
	 */
	density: number;
	/**
	 * The maximum density of the godrays.  Limits the maximum brightness of the godrays.
	 */
	maxDensity: number;
	/**
	 * TODO: Document this
	 */
	edgeStrength: number;
	/**
	 * TODO: Document this
	 */
	edgeRadius: number;
	/**
	 * Higher values decrease the accumulation of godrays the further away they are from the light source.
	 */
	distanceAttenuation: number;
	/**
	 * The color of the godrays.
	 */
	color: THREE.Color;
}
declare class GodraysPass extends Pass implements Disposable {
	private props;
	private godraysRenderTarget;
	private illumPass;
	private compositorPass;
	/**
	 * Constructs a new GodraysPass.  Casts godrays from a point light source.  Add to your scene's composer like this:
	 *
	 * ```ts
	 * import { EffectComposer, RenderPass } from 'postprocessing';
	 * import { GodraysPass } from 'three-good-godrays';
	 *
	 * const composer = new EffectComposer(renderer);
	 * const renderPass = new RenderPass(scene, camera);
	 * renderPass.renderToScreen = false;
	 * composer.addPass(renderPass);
	 *
	 * const godraysPass = new GodraysPass(pointLight, camera);
	 * godraysPass.renderToScreen = true;
	 * composer.addPass(godraysPass);
	 *
	 * function animate() {
	 *   composer.render(scene, camera);
	 * }
	 * ```
	 *
	 * @param light The light source to use for the godrays.
	 * @param camera The camera used to render the scene.
	 * @param partialParams The parameters to use for the godrays effect.  Will use default values for any parameters not specified.
	 */
	constructor(
		light: GodRaysVolumetricAcceptedLightType,
		camera: PerspectiveCamera,
		partialParams?: Partial<GodraysPassParams>
	);
	setLight(light: GodRaysVolumetricAcceptedLightType): void;
	/**
	 * Updates the parameters used for the godrays effect.  Will use default values for any parameters not specified.
	 */
	setParams(partialParams: Partial<GodraysPassParams>): void;
	render(
		renderer: WebGLRenderer,
		inputBuffer: WebGLRenderTarget,
		outputBuffer: WebGLRenderTarget,
		_deltaTime?: number | undefined,
		_stencilTest?: boolean | undefined
	): void;
	setDepthTexture(depthTexture: Texture, depthPacking?: DepthPackingStrategies | undefined): void;
	setSize(width: number, height: number): void;
	dispose(): void;
}
declare class GodRaysVolumetricPostParamsConfig extends NodeParamsConfig {
	/** @param light type */
	lightType: ParamTemplate<ParamType.INTEGER>;
	/** @param light to emit godrays from. Note that while the mask can resolve multiple objects, only the first light will be used */
	lightMask: ParamTemplate<ParamType.STRING>;
	/** @param color */
	color: ParamTemplate<ParamType.COLOR>;
	/** @param density */
	density: ParamTemplate<ParamType.FLOAT>;
	/** @param maxDensity */
	maxDensity: ParamTemplate<ParamType.FLOAT>;
	/** @param distanceAttenuation */
	distanceAttenuation: ParamTemplate<ParamType.FLOAT>;
	/** @param edgeStrength */
	edgeStrength: ParamTemplate<ParamType.INTEGER>;
	/** @param edgeRadius */
	edgeRadius: ParamTemplate<ParamType.INTEGER>;
}
declare class GodRaysVolumetricPostNode extends TypedPostNode<GodraysPass, GodRaysVolumetricPostParamsConfig> {
	paramsConfig: GodRaysVolumetricPostParamsConfig;
	static type(): string;
	private _rendererSize;
	createPass(context: TypedPostNodeContext): GodraysPass;
	updatePass(pass: GodraysPass): void;
	private _tmpLightSource;
}
declare class HueSaturationPostParamsConfig extends NodeParamsConfig {
	/** @param hue */
	hue: ParamTemplate<ParamType.FLOAT>;
	/** @param saturation */
	saturation: ParamTemplate<ParamType.FLOAT>;
	/** @param effect opacity */
	opacity: ParamTemplate<ParamType.FLOAT>;
	/** @param render mode */
	blendFunction: ParamTemplate<ParamType.INTEGER>;
}
declare class HueSaturationPostNode extends TypedPostNode<EffectPass, HueSaturationPostParamsConfig> {
	paramsConfig: HueSaturationPostParamsConfig;
	static type(): string;
	createPass(context: TypedPostNodeContext): EffectPass;
	updatePass(pass: EffectPass): void;
}
declare class LuminanceParamsConfig extends NodeParamsConfig {}
declare class LuminancePostNode extends TypedPostNode<LuminancePass, LuminanceParamsConfig> {
	paramsConfig: LuminanceParamsConfig;
	static type(): string;
	createPass(context: TypedPostNodeContext): LuminancePass;
}
declare class LutPostParamsConfig extends NodeParamsConfig {
	/** @param texture */
	texture: ParamTemplate<ParamType.NODE_PATH>;
	/** @param effect opacity */
	opacity: ParamTemplate<ParamType.FLOAT>;
	/** @param render mode */
	blendFunction: ParamTemplate<ParamType.INTEGER>;
}
declare class LutPostNode extends TypedPostNode<EffectPass, LutPostParamsConfig> {
	paramsConfig: LutPostParamsConfig;
	static type(): string;
	createPass(context: TypedPostNodeContext): EffectPass[];
	updatePass(pass: EffectPass): Promise<void>;
	private _fetchTexture;
}
declare class NormalParamsConfig extends NodeParamsConfig {}
declare class NormalPostNode extends TypedPostNode<NormalPass, NormalParamsConfig> {
	paramsConfig: NormalParamsConfig;
	static type(): string;
	createPass(context: TypedPostNodeContext): NormalPass;
}
declare class NoisePostParamsConfig extends NodeParamsConfig {
	/** @param effect strength */
	strength: ParamTemplate<ParamType.FLOAT>;
	/** @param premultiply */
	premultiply: ParamTemplate<ParamType.BOOLEAN>;
}
declare class NoisePostNode extends TypedPostNode<EffectPass, NoisePostParamsConfig> {
	paramsConfig: NoisePostParamsConfig;
	static type(): string;
	private _rendererSize;
	createPass(context: TypedPostNodeContext): EffectPass;
	updatePass(pass: EffectPass): void;
}
declare class NullPostParamsConfig extends NodeParamsConfig {}
declare class NullPostNode extends TypedPostNode<Pass, NullPostParamsConfig> {
	paramsConfig: NullPostParamsConfig;
	static type(): string;
}
declare class OutlinePostParamsConfig extends NodeParamsConfig {
	/** @param object mask of the objects that will have an outline */
	objectsMask: ParamTemplate<ParamType.STRING>;
	/** @param updates the cached objects found by objectMask  */
	refreshObjects: ParamTemplate<ParamType.BUTTON>;
	/** @param edgeStrenth */
	edgeStrength: ParamTemplate<ParamType.FLOAT>;
	/** @param blur */
	blur: ParamTemplate<ParamType.BOOLEAN>;
	kernelSize: ParamTemplate<ParamType.INTEGER>;
	/** @param defines if the edges pulsate */
	pulseSpeed: ParamTemplate<ParamType.FLOAT>;
	/** @param visibleEdgeColor */
	visibleEdgeColor: ParamTemplate<ParamType.COLOR>;
	/** @param shows outline for hidden parts of objects */
	xRay: ParamTemplate<ParamType.BOOLEAN>;
	/** @param hiddenEdgeColor */
	hiddenEdgeColor: ParamTemplate<ParamType.COLOR>;
	/** @param opacity */
	opacity: ParamTemplate<ParamType.FLOAT>;
	/** @param render mode */
	blendFunction: ParamTemplate<ParamType.INTEGER>;
}
declare class OutlinePostNode extends TypedPostNode<EffectPass, OutlinePostParamsConfig> {
	paramsConfig: OutlinePostParamsConfig;
	static type(): string;
	createPass(context: TypedPostNodeContext): EffectPass;
	updatePass(pass: EffectPass): void;
	private _selectionController;
	private _setSelectedObjects;
}
declare class PixelPostParamsConfig extends NodeParamsConfig {
	/** @param pixelSize */
	pixelSize: ParamTemplate<ParamType.INTEGER>;
}
declare class PixelPostNode extends TypedPostNode<EffectPass, PixelPostParamsConfig> {
	paramsConfig: PixelPostParamsConfig;
	static type(): string;
	createPass(context: TypedPostNodeContext): EffectPass;
	updatePass(pass: EffectPass): void;
}
export interface RenderPassContext {
	camera: Camera;
	scene: Scene;
}
declare class RenderPassWithContext extends RenderPass {
	scene: Scene;
	camera: Camera;
	context: RenderPassContext;
	constructor(scene: Scene, camera: Camera);
}
declare class RenderPostParamsConfig extends NodeParamsConfig {
	/** @param overrideScene */
	overrideScene: ParamTemplate<ParamType.BOOLEAN>;
	/** @param scene */
	scene: ParamTemplate<ParamType.NODE_PATH>;
	/** @param overrideCamera */
	overrideCamera: ParamTemplate<ParamType.BOOLEAN>;
	/** @param camera */
	camera: ParamTemplate<ParamType.STRING>;
}
declare class RenderPostNode extends TypedPostNode<RenderPass, RenderPostParamsConfig> {
	paramsConfig: RenderPostParamsConfig;
	static type(): string;
	createPass(context: TypedPostNodeContext): RenderPassWithContext;
	updatePass(pass: RenderPassWithContext): void;
	protected _updateCamera(pass: RenderPassWithContext): Promise<void>;
	protected _updateScene(pass: RenderPassWithContext): Promise<void>;
}
declare class ScreenSpaceAmbientOcclusionParamsConfig extends NodeParamsConfig {
	main: ParamTemplate<ParamType.FOLDER>;
	/** @param samples */
	samples: ParamTemplate<ParamType.INTEGER>;
	/** @param rings */
	rings: ParamTemplate<ParamType.INTEGER>;
	/** @param distanceThreshold */
	distanceThreshold: ParamTemplate<ParamType.FLOAT>;
	/** @param distanceThreshold */
	distanceFalloff: ParamTemplate<ParamType.FLOAT>;
	/** @param rangeThreshold */
	rangeThreshold: ParamTemplate<ParamType.FLOAT>;
	/** @param rangeFalloff */
	rangeFalloff: ParamTemplate<ParamType.FLOAT>;
	/** @param luminanceInfluence */
	luminanceInfluence: ParamTemplate<ParamType.FLOAT>;
	/** @param minRadiusScale */
	minRadiusScale: ParamTemplate<ParamType.FLOAT>;
	/** @param radius */
	radius: ParamTemplate<ParamType.FLOAT>;
	/** @param intensity */
	intensity: ParamTemplate<ParamType.FLOAT>;
	/** @param bias */
	bias: ParamTemplate<ParamType.FLOAT>;
	debug: ParamTemplate<ParamType.FOLDER>;
	/** @param render mode */
	/** @param render mode */
	blendFunction: ParamTemplate<ParamType.INTEGER>;
}
declare class ScreenSpaceAmbientOcclusionPostNode extends TypedPostNode<Pass, ScreenSpaceAmbientOcclusionParamsConfig> {
	paramsConfig: ScreenSpaceAmbientOcclusionParamsConfig;
	static type(): string;
	createPass(context: TypedPostNodeContext): Pass[];
	updatePass(pass: EffectPass): void;
}
declare class SepiaPostParamsConfig extends NodeParamsConfig {
	/** @param amount */
	amount: ParamTemplate<ParamType.FLOAT>;
}
declare class SepiaPostNode extends TypedPostNode<EffectPass, SepiaPostParamsConfig> {
	paramsConfig: SepiaPostParamsConfig;
	static type(): string;
	createPass(context: TypedPostNodeContext): EffectPass;
	updatePass(pass: EffectPass): void;
}
declare class SequencePostParamsConfig extends NodeParamsConfig {}
declare class SequencePostNode extends TypedPostNode<Pass, SequencePostParamsConfig> {
	paramsConfig: SequencePostParamsConfig;
	static type(): string;
	initializeNode(): void;
	setupComposer(context: TypedPostNodeContext): void;
}
declare class TexturePostParamsConfig extends NodeParamsConfig {
	/** @param texture */
	texture: ParamTemplate<ParamType.NODE_PATH>;
	/** @param opacity */
	opacity: ParamTemplate<ParamType.FLOAT>;
	/** @param render mode */
	blendFunction: ParamTemplate<ParamType.INTEGER>;
}
declare class TexturePostNode extends TypedPostNode<EffectPass, TexturePostParamsConfig> {
	paramsConfig: TexturePostParamsConfig;
	static type(): string;
	private _rendererSize;
	createPass(context: TypedPostNodeContext): EffectPass;
	updatePass(pass: EffectPass): Promise<void>;
}
export interface UpdateSceneEffectOptions {
	reset: boolean;
	node: UpdateScenePostNode;
	nodeToReset?: UpdateScenePostNode;
}
declare class UpdateScenePass extends CopyPass {
	reset: boolean;
	node: UpdateScenePostNode;
	nodeToReset?: UpdateScenePostNode;
	constructor(options: UpdateSceneEffectOptions);
	render(
		renderer: WebGLRenderer,
		inputBuffer: WebGLRenderTarget,
		outputBuffer: WebGLRenderTarget,
		deltaTime?: number,
		stencilTest?: boolean
	): void;
}
declare class UpdateScenePostParamsConfig extends NodeParamsConfig {
	/** @param reset */
	reset: ParamTemplate<ParamType.BOOLEAN>;
	/** @param objects Mask */
	objectsMask: ParamTemplate<ParamType.STRING>;
	/** @param invertMask */
	invertMask: ParamTemplate<ParamType.BOOLEAN>;
	/** @param prints which objects are targeted by this node, for debugging */
	/** @param update selected objects material to a matte one */
	setMatteMaterial: ParamTemplate<ParamType.BOOLEAN>;
	/** @param set visible state  */
	setVisible: ParamTemplate<ParamType.BOOLEAN>;
	/** @param set visible state  */
	visible: ParamTemplate<ParamType.BOOLEAN>;
	/** @param reset */
	resetChanges: ParamTemplate<ParamType.BUTTON>;
}
declare class UpdateScenePostNode extends TypedPostNode<UpdateScenePass, UpdateScenePostParamsConfig> {
	paramsConfig: UpdateScenePostParamsConfig;
	static type(): string;
	initializeNode(): void;
	static displayedInputNames(): string[];
	createPass(context: TypedPostNodeContext): UpdateScenePass;
	updatePass(pass: UpdateScenePass): void;
	private _nodeToReset;
	static PARAM_CALLBACK_resetChanges(node: UpdateScenePostNode): void;
	private _objectsList;
	objectsList(): Object3D<Event>[];
	private _materialByMesh;
	private _visibleByObject;
	applyChanges(): void;
	resetChanges(): void;
	private _updateObjectBound;
	private _updateObject;
}
declare class VignettePostParamsConfig extends NodeParamsConfig {
	/** @param offset */
	offset: ParamTemplate<ParamType.FLOAT>;
	/** @param darkness */
	darkness: ParamTemplate<ParamType.FLOAT>;
}
declare class VignettePostNode extends TypedPostNode<EffectPass, VignettePostParamsConfig> {
	paramsConfig: VignettePostParamsConfig;
	static type(): string;
	createPass(context: TypedPostNodeContext): EffectPass;
	updatePass(pass: EffectPass): void;
}
declare class ParamLessNetworkPostParamsConfig extends NodeParamsConfig {}
declare class BaseNetworkPostNode<K extends NodeParamsConfig> extends TypedNode<NodeContext.POST, K> {
	static context(): NodeContext;
	cook(): void;
}
declare class ParamLessBaseNetworkPostNode extends BaseNetworkPostNode<ParamLessNetworkPostParamsConfig> {}
declare class ActorsNetworkPostNode extends ParamLessBaseNetworkPostNode {
	static type(): NetworkNodeType;
	protected _childrenControllerContext: NodeContext;
	createNode<S extends keyof JsNodeChildrenMap>(node_class: S, options?: NodeCreateOptions): JsNodeChildrenMap[S];
	createNode<K extends valueof<JsNodeChildrenMap>>(node_class: Constructor<K>, options?: NodeCreateOptions): K;
	children(): BaseJsNodeType[];
	nodesByType<K extends keyof JsNodeChildrenMap>(type: K): JsNodeChildrenMap[K][];
	childrenAllowed(): boolean;
	sceneReadonly(): boolean;
	readonly persisted_config: ActorPersistedConfig;
	assemblerController(): JsAssemblerController<JsAssemblerActor> | undefined;
	usedAssembler(): Readonly<AssemblerName.JS_ACTOR>;
	protected _assemblerController: JsAssemblerController<JsAssemblerActor> | undefined;
	private _createAssemblerController;
	readonly compilationController: ActorCompilationController;
	compile(): void;
	cook(): void;
}
declare class AnimationsNetworkPostNode extends ParamLessBaseNetworkPostNode {
	static type(): NetworkNodeType;
	protected _childrenControllerContext: NodeContext;
	createNode<S extends keyof AnimNodeChildrenMap>(node_class: S, options?: NodeCreateOptions): AnimNodeChildrenMap[S];
	createNode<K extends valueof<AnimNodeChildrenMap>>(node_class: Constructor<K>, options?: NodeCreateOptions): K;
	children(): BaseAnimNodeType[];
	nodesByType<K extends keyof AnimNodeChildrenMap>(type: K): AnimNodeChildrenMap[K][];
}
declare class AudioNetworkPostNode extends ParamLessBaseNetworkPostNode {
	static type(): NetworkNodeType;
	protected _childrenControllerContext: NodeContext;
	createNode<S extends keyof AudioNodeChildrenMap>(
		node_class: S,
		options?: NodeCreateOptions
	): AudioNodeChildrenMap[S];
	createNode<K extends valueof<AudioNodeChildrenMap>>(node_class: Constructor<K>, options?: NodeCreateOptions): K;
	children(): BaseAudioNodeType[];
	nodesByType<K extends keyof AudioNodeChildrenMap>(type: K): AudioNodeChildrenMap[K][];
}
declare class CopNetworkPostNode extends ParamLessBaseNetworkPostNode {
	static type(): NetworkNodeType;
	protected _childrenControllerContext: NodeContext;
	createNode<S extends keyof CopNodeChildrenMap>(node_class: S, options?: NodeCreateOptions): CopNodeChildrenMap[S];
	createNode<K extends valueof<CopNodeChildrenMap>>(node_class: Constructor<K>, options?: NodeCreateOptions): K;
	children(): BaseCopNodeType[];
	nodesByType<K extends keyof CopNodeChildrenMap>(type: K): CopNodeChildrenMap[K][];
}
declare class EventsNetworkPostNode extends ParamLessBaseNetworkPostNode {
	static type(): NetworkNodeType;
	protected _childrenControllerContext: NodeContext;
	createNode<S extends keyof EventNodeChildrenMap>(
		node_class: S,
		options?: NodeCreateOptions
	): EventNodeChildrenMap[S];
	createNode<K extends valueof<EventNodeChildrenMap>>(node_class: Constructor<K>, options?: NodeCreateOptions): K;
	children(): BaseEventNodeType[];
	nodesByType<K extends keyof EventNodeChildrenMap>(type: K): EventNodeChildrenMap[K][];
}
declare class MaterialsNetworkPostNode extends ParamLessBaseNetworkPostNode {
	static type(): NetworkNodeType;
	protected _childrenControllerContext: NodeContext;
	createNode<S extends keyof MatNodeChildrenMap>(node_class: S, options?: NodeCreateOptions): MatNodeChildrenMap[S];
	createNode<K extends valueof<MatNodeChildrenMap>>(node_class: Constructor<K>, options?: NodeCreateOptions): K;
	children(): BaseMatNodeType[];
	nodesByType<K extends keyof MatNodeChildrenMap>(type: K): MatNodeChildrenMap[K][];
}
declare class PostProcessNetworkPostNode extends BaseNetworkPostNode<PostProcessNetworkParamsConfig> {
	paramsConfig: PostProcessNetworkParamsConfig;
	static type(): NetworkNodeType;
	readonly effectsComposerController: EffectComposerController;
	readonly displayNodeController: DisplayNodeController;
	protected _childrenControllerContext: NodeContext;
	createNode<S extends keyof PostNodeChildrenMap>(node_class: S, options?: NodeCreateOptions): PostNodeChildrenMap[S];
	createNode<K extends valueof<PostNodeChildrenMap>>(node_class: Constructor<K>, options?: NodeCreateOptions): K;
	children(): BasePostProcessNodeType[];
	nodesByType<K extends keyof PostNodeChildrenMap>(type: K): PostNodeChildrenMap[K][];
}
declare class TypedRopNode<K extends NodeParamsConfig> extends TypedNode<NodeContext.ROP, K> {
	static context(): NodeContext;
	readonly flags: FlagsController;
	initializeBaseNode(): void;
	cook(): void;
}
export declare type BaseRopNodeType = TypedRopNode<NodeParamsConfig>;
declare class CSS2DObject extends Object3D {
	element: HTMLDivElement;
	readonly isCSS2DObject = true;
	constructor(element?: HTMLDivElement);
	copy(source: CSS2DObject, recursive: boolean): this;
}
export interface CSS2DParameters {
	element?: HTMLElement;
}
declare class CSS2DRenderer {
	private _width;
	private _height;
	private _widthHalf;
	private _heightHalf;
	private dataByObject;
	domElement: HTMLElement;
	appendedObjects: Set<CSS2DObject>;
	objectsToRender: Set<CSS2DObject>;
	objectsToRemove: Set<CSS2DObject>;
	constructor(parameters?: CSS2DParameters);
	getSize(): {
		width: number;
		height: number;
	};
	render(scene: Scene, camera: Camera): void;
	private removeElementsDeletedFromSceneGraph;
	setSize(width: number, height: number): void;
	renderObject(object: Object3D, scene: Scene, camera: Camera): void;
	getDistanceToSquared(object1: Object3D, object2: Object3D): number;
	filterAndFlatten(scene: Scene): CSS2DObject[];
	zOrder(scene: Scene): void;
}
declare enum RopType {
	CSS2D = 'CSS2DRenderer',
	CSS3D = 'CSS3DRenderer',
	WEBGL = 'WebGLRenderer',
	PATH_TRACING = 'PathTracingRenderer',
}
declare class CSS2DRendererRopParamsConfig extends NodeParamsConfig {
	/** @param css rules to be added in the html document */
	css: ParamTemplate<ParamType.STRING>;
}
declare class CSS2DRendererRopNode extends TypedRopNode<CSS2DRendererRopParamsConfig> {
	paramsConfig: CSS2DRendererRopParamsConfig;
	static type(): Readonly<RopType.CSS2D>;
	private _renderersByCanvasId;
	createRenderer(canvas: HTMLCanvasElement): CSS2DRenderer;
	mountRenderer(canvas: HTMLCanvasElement): void;
	unmountRenderer(canvas: HTMLCanvasElement): void;
	renderer(canvas: HTMLCanvasElement): CSS2DRenderer;
	cook(): void;
	private _updateRenderer;
	private _updateCSS;
	private __CSSElement;
	private _CSSElement;
	private _findElement;
	private _createElement;
	private _CSSElementId;
}
declare class CSS3DObject extends Object3D {
	element: HTMLDivElement;
	readonly isCSS3DObject = true;
	constructor(element?: HTMLDivElement);
	copy(source: CSS3DObject, recursive: boolean): this;
}
export interface CSS3DParameters {
	element?: HTMLElement;
}
declare class CSS3DRenderer {
	private _width;
	private _height;
	private _widthHalf;
	private _heightHalf;
	domElement: HTMLElement;
	cameraElement: HTMLElement;
	private cache;
	appendedObjects: Set<CSS3DObject>;
	objectsToRender: Set<CSS3DObject>;
	objectsToRemove: Set<CSS3DObject>;
	constructor(parameters?: CSS3DParameters);
	getSize(): {
		width: number;
		height: number;
	};
	render(scene: Scene, camera: Camera): void;
	private removeElementsDeletedFromSceneGraph;
	setSize(width: number, height: number): void;
	renderObject(object: Object3D, scene: Scene, camera: Camera, cameraCSSMatrix: string): void;
}
declare class CSS3DRendererRopParamsConfig extends NodeParamsConfig {
	/** @param css rules to be added in the html document */
	css: ParamTemplate<ParamType.STRING>;
}
declare class CSS3DRendererRopNode extends TypedRopNode<CSS3DRendererRopParamsConfig> {
	paramsConfig: CSS3DRendererRopParamsConfig;
	static type(): Readonly<RopType.CSS3D>;
	private _renderersByCanvasId;
	createRenderer(canvas: HTMLCanvasElement): CSS3DRenderer;
	mountRenderer(canvas: HTMLCanvasElement): void;
	unmountRenderer(canvas: HTMLCanvasElement): void;
	renderer(canvas: HTMLCanvasElement): CSS3DRenderer;
	cook(): void;
	private _updateRenderer;
	private _updateCSS;
	private __CSSElement;
	private _CSSElement;
	private _findElement;
	private _createElement;
	private _CSSElementId;
}
declare class WebGLRendererRopParamsConfig extends NodeParamsConfig {
	common: ParamTemplate<ParamType.FOLDER>;
	/** @param tone mapping */
	toneMapping: ParamTemplate<ParamType.INTEGER>;
	/** @param tone mapping exposure */
	toneMappingExposure: ParamTemplate<ParamType.FLOAT>;
	/** @param output encoding */
	outputEncoding: ParamTemplate<ParamType.INTEGER>;
	/** @param physically correct lights */
	physicallyCorrectLights: ParamTemplate<ParamType.BOOLEAN>;
	/** @param sort objects, which can be necessary when rendering transparent objects */
	sortObjects: ParamTemplate<ParamType.BOOLEAN>;
	/** @param toggle to override the default pixel ratio, which is 1 for mobile devices, and Math.max(2, window.devicePixelRatio) for other devices */
	tpixelRatio: ParamTemplate<ParamType.BOOLEAN>;
	/** @param higher pixelRatio improves render sharpness but reduces performance */
	pixelRatio: ParamTemplate<ParamType.FLOAT>;
	shadow: ParamTemplate<ParamType.FOLDER>;
	/** @param toggle on to have shadow maps */
	tshadowMap: ParamTemplate<ParamType.BOOLEAN>;
	/** @param toggle on to recompute the shadow maps on every frame. If all objects are static, you may want to turn this off */
	shadowMapAutoUpdate: ParamTemplate<ParamType.BOOLEAN>;
	/** @param toggle on to trigger shadows update */
	shadowMapNeedsUpdate: ParamTemplate<ParamType.BOOLEAN>;
	/** @param shadows type */
	shadowMapType: ParamTemplate<ParamType.INTEGER>;
	advanced: ParamTemplate<ParamType.FOLDER>;
	/** @param toggle on to have alpha on (change requires page reload) */
	alpha: ParamTemplate<ParamType.BOOLEAN>;
	/** @param toggle on to have antialias on (change requires page reload) */
	antialias: ParamTemplate<ParamType.BOOLEAN>;
	/** @param premultipliedAlpha */
	premultipliedAlpha: ParamTemplate<ParamType.BOOLEAN>;
	/** @param stencil */
	stencil: ParamTemplate<ParamType.BOOLEAN>;
	/** @param depth */
	depth: ParamTemplate<ParamType.BOOLEAN>;
	/** @param logarithmicDepthBuffer */
	logarithmicDepthBuffer: ParamTemplate<ParamType.BOOLEAN>;
	/** @param preserveDrawingBuffer */
	preserveDrawingBuffer: ParamTemplate<ParamType.BOOLEAN>;
	/** @param toggle on to set the precision */
	tprecision: ParamTemplate<ParamType.BOOLEAN>;
	/** @param set the precision */
	precision: ParamTemplate<ParamType.INTEGER>;
	/** @param toggle on to set the power preferenc */
	tpowerPreference: ParamTemplate<ParamType.BOOLEAN>;
	/** @param set the precision */
	powerPreference: ParamTemplate<ParamType.INTEGER>;
}
declare class WebGLRendererRopNode extends TypedRopNode<WebGLRendererRopParamsConfig> {
	paramsConfig: WebGLRendererRopParamsConfig;
	static type(): Readonly<RopType.WEBGL>;
	private _rendererByCanvas;
	createRenderer(canvas: HTMLCanvasElement, gl: WebGLRenderingContext): WebGLRenderer;
	cook(): void;
	private _updateRenderer;
	private _traverseSceneAndUpdateMaterials;
	static PARAM_CALLBACK_updateToneMapping(node: WebGLRendererRopNode): void;
	static PARAM_CALLBACK_updateToneMappingExposure(node: WebGLRendererRopNode): void;
	static PARAM_CALLBACK_updateOutputEncoding(node: WebGLRendererRopNode): void;
	static PARAM_CALLBACK_updateShadow(node: WebGLRendererRopNode): void;
	static PARAM_CALLBACK_updateSortObjects(node: WebGLRendererRopNode): void;
	static PARAM_CALLBACK_updatePhysicallyCorrect(node: WebGLRendererRopNode): void;
	static PARAM_CALLBACK_updatePixelRatio(node: WebGLRendererRopNode): void;
	private _updateRendererToneMapping;
	private _updateRendererToneMappingExposure;
	private _updateRendererOutputEncoding;
	private _updateRendererShadow;
	private _updateRendererSortObjects;
	private _updateRendererPhysicallyCorrect;
	private _updateRendererPixelRatio;
}
declare class ParamLessNetworkRopParamsConfig extends NodeParamsConfig {}
declare class BaseNetworkRopNode<K extends NodeParamsConfig> extends TypedNode<NodeContext.ROP, K> {
	static context(): NodeContext;
	cook(): void;
}
declare class ParamLessBaseNetworkRopNode extends BaseNetworkRopNode<ParamLessNetworkRopParamsConfig> {}
declare class ActorsNetworkRopNode extends ParamLessBaseNetworkRopNode {
	static type(): NetworkNodeType;
	protected _childrenControllerContext: NodeContext;
	createNode<S extends keyof JsNodeChildrenMap>(node_class: S, options?: NodeCreateOptions): JsNodeChildrenMap[S];
	createNode<K extends valueof<JsNodeChildrenMap>>(node_class: Constructor<K>, options?: NodeCreateOptions): K;
	children(): BaseJsNodeType[];
	nodesByType<K extends keyof JsNodeChildrenMap>(type: K): JsNodeChildrenMap[K][];
	childrenAllowed(): boolean;
	sceneReadonly(): boolean;
	readonly persisted_config: ActorPersistedConfig;
	assemblerController(): JsAssemblerController<JsAssemblerActor> | undefined;
	usedAssembler(): Readonly<AssemblerName.JS_ACTOR>;
	protected _assemblerController: JsAssemblerController<JsAssemblerActor> | undefined;
	private _createAssemblerController;
	readonly compilationController: ActorCompilationController;
	compile(): void;
	cook(): void;
}
declare class AnimationsNetworkRopNode extends ParamLessBaseNetworkRopNode {
	static type(): NetworkNodeType;
	protected _childrenControllerContext: NodeContext;
	createNode<S extends keyof AnimNodeChildrenMap>(node_class: S, options?: NodeCreateOptions): AnimNodeChildrenMap[S];
	createNode<K extends valueof<AnimNodeChildrenMap>>(node_class: Constructor<K>, options?: NodeCreateOptions): K;
	children(): BaseAnimNodeType[];
	nodesByType<K extends keyof AnimNodeChildrenMap>(type: K): AnimNodeChildrenMap[K][];
}
declare class AudioNetworkRopNode extends ParamLessBaseNetworkRopNode {
	static type(): NetworkNodeType;
	protected _childrenControllerContext: NodeContext;
	createNode<S extends keyof AudioNodeChildrenMap>(
		node_class: S,
		options?: NodeCreateOptions
	): AudioNodeChildrenMap[S];
	createNode<K extends valueof<AudioNodeChildrenMap>>(node_class: Constructor<K>, options?: NodeCreateOptions): K;
	children(): BaseAudioNodeType[];
	nodesByType<K extends keyof AudioNodeChildrenMap>(type: K): AudioNodeChildrenMap[K][];
}
declare class CopNetworkRopNode extends ParamLessBaseNetworkRopNode {
	static type(): NetworkNodeType;
	protected _childrenControllerContext: NodeContext;
	createNode<S extends keyof CopNodeChildrenMap>(node_class: S, options?: NodeCreateOptions): CopNodeChildrenMap[S];
	createNode<K extends valueof<CopNodeChildrenMap>>(node_class: Constructor<K>, options?: NodeCreateOptions): K;
	children(): BaseCopNodeType[];
	nodesByType<K extends keyof CopNodeChildrenMap>(type: K): CopNodeChildrenMap[K][];
}
declare class EventsNetworkRopNode extends ParamLessBaseNetworkRopNode {
	static type(): NetworkNodeType;
	protected _childrenControllerContext: NodeContext;
	createNode<S extends keyof EventNodeChildrenMap>(
		node_class: S,
		options?: NodeCreateOptions
	): EventNodeChildrenMap[S];
	createNode<K extends valueof<EventNodeChildrenMap>>(node_class: Constructor<K>, options?: NodeCreateOptions): K;
	children(): BaseEventNodeType[];
	nodesByType<K extends keyof EventNodeChildrenMap>(type: K): EventNodeChildrenMap[K][];
}
declare class MaterialsNetworkRopNode extends ParamLessBaseNetworkRopNode {
	static type(): NetworkNodeType;
	protected _childrenControllerContext: NodeContext;
	createNode<S extends keyof MatNodeChildrenMap>(node_class: S, options?: NodeCreateOptions): MatNodeChildrenMap[S];
	createNode<K extends valueof<MatNodeChildrenMap>>(node_class: Constructor<K>, options?: NodeCreateOptions): K;
	children(): BaseMatNodeType[];
	nodesByType<K extends keyof MatNodeChildrenMap>(type: K): MatNodeChildrenMap[K][];
}
declare class PostProcessNetworkRopNode extends BaseNetworkRopNode<PostProcessNetworkParamsConfig> {
	paramsConfig: PostProcessNetworkParamsConfig;
	static type(): NetworkNodeType;
	readonly effectsComposerController: EffectComposerController;
	readonly displayNodeController: DisplayNodeController;
	protected _childrenControllerContext: NodeContext;
	createNode<S extends keyof PostNodeChildrenMap>(node_class: S, options?: NodeCreateOptions): PostNodeChildrenMap[S];
	createNode<K extends valueof<PostNodeChildrenMap>>(node_class: Constructor<K>, options?: NodeCreateOptions): K;
	children(): BasePostProcessNodeType[];
	nodesByType<K extends keyof PostNodeChildrenMap>(type: K): PostNodeChildrenMap[K][];
}
declare class RenderersNetworkRopNode extends ParamLessBaseNetworkRopNode {
	static type(): NetworkNodeType;
	protected _childrenControllerContext: NodeContext;
	createNode<S extends keyof RopNodeChildrenMap>(node_class: S, options?: NodeCreateOptions): RopNodeChildrenMap[S];
	createNode<K extends valueof<RopNodeChildrenMap>>(node_class: Constructor<K>, options?: NodeCreateOptions): K;
	children(): BaseRopNodeType[];
	nodesByType<K extends keyof RopNodeChildrenMap>(type: K): RopNodeChildrenMap[K][];
}
export interface RopNodeChildrenMap {
	CSS2DRenderer: CSS2DRendererRopNode;
	CSS3DRenderer: CSS3DRendererRopNode;
	WebGLRenderer: WebGLRendererRopNode;
	actorsNetwork: ActorsNetworkRopNode;
	animationsNetwork: AnimationsNetworkRopNode;
	audioNetwork: AudioNetworkRopNode;
	copNetwork: CopNetworkRopNode;
	eventsNetwork: EventsNetworkRopNode;
	materialsNetwork: MaterialsNetworkRopNode;
	postProcessNetwork: PostProcessNetworkRopNode;
	renderersNetwork: RenderersNetworkRopNode;
}
declare class RenderersNetworkPostNode extends ParamLessBaseNetworkPostNode {
	static type(): NetworkNodeType;
	protected _childrenControllerContext: NodeContext;
	createNode<S extends keyof RopNodeChildrenMap>(node_class: S, options?: NodeCreateOptions): RopNodeChildrenMap[S];
	createNode<K extends valueof<RopNodeChildrenMap>>(node_class: Constructor<K>, options?: NodeCreateOptions): K;
	children(): BaseRopNodeType[];
	nodesByType<K extends keyof RopNodeChildrenMap>(type: K): RopNodeChildrenMap[K][];
}
export interface PostNodeChildrenMap {
	antialiasing: AntialiasingPostNode;
	bloom: BloomPostNode;
	blur: BlurPostNode;
	brightnessContrast: BrightnessContrastPostNode;
	builder: BuilderPostNode;
	chromaticAberration: ChromaticAberrationPostNode;
	depthOfField: DepthOfFieldPostNode;
	effectPass: EffectPassPostNode;
	glitch: GlitchPostNode;
	godRays: GodRaysPostNode;
	godRaysVolumetric: GodRaysVolumetricPostNode;
	hueSaturation: HueSaturationPostNode;
	luminance: LuminancePostNode;
	lut: LutPostNode;
	noise: NoisePostNode;
	normal: NormalPostNode;
	null: NullPostNode;
	outline: OutlinePostNode;
	pixel: PixelPostNode;
	render: RenderPostNode;
	screenSpaceAmbientOcclusion: ScreenSpaceAmbientOcclusionPostNode;
	sepia: SepiaPostNode;
	sequence: SequencePostNode;
	texture: TexturePostNode;
	updateScene: UpdateScenePostNode;
	vignette: VignettePostNode;
	actorsNetwork: ActorsNetworkPostNode;
	animationsNetwork: AnimationsNetworkPostNode;
	audioNetwork: AudioNetworkPostNode;
	copNetwork: CopNetworkPostNode;
	eventsNetwork: EventsNetworkPostNode;
	materialsNetwork: MaterialsNetworkPostNode;
	postProcessNetwork: PostProcessNetworkPostNode;
	renderersNetwork: RenderersNetworkPostNode;
}
declare class PostProcessNetworkCopNode extends BaseNetworkCopNode<PostProcessNetworkParamsConfig> {
	paramsConfig: PostProcessNetworkParamsConfig;
	static type(): NetworkNodeType;
	readonly effectsComposerController: EffectComposerController;
	readonly displayNodeController: DisplayNodeController;
	protected _childrenControllerContext: NodeContext;
	createNode<S extends keyof PostNodeChildrenMap>(node_class: S, options?: NodeCreateOptions): PostNodeChildrenMap[S];
	createNode<K extends valueof<PostNodeChildrenMap>>(node_class: Constructor<K>, options?: NodeCreateOptions): K;
	children(): BasePostProcessNodeType[];
	nodesByType<K extends keyof PostNodeChildrenMap>(type: K): PostNodeChildrenMap[K][];
}
declare class RenderersNetworkCopNode extends ParamLessBaseNetworkCopNode {
	static type(): NetworkNodeType;
	protected _childrenControllerContext: NodeContext;
	createNode<S extends keyof RopNodeChildrenMap>(node_class: S, options?: NodeCreateOptions): RopNodeChildrenMap[S];
	createNode<K extends valueof<RopNodeChildrenMap>>(node_class: Constructor<K>, options?: NodeCreateOptions): K;
	children(): BaseRopNodeType[];
	nodesByType<K extends keyof RopNodeChildrenMap>(type: K): RopNodeChildrenMap[K][];
}
export interface CopNodeChildrenMap {
	audioAnalyser: AudioAnalyserCopNode;
	builder: BuilderCopNode;
	builder2DArray: Builder2DArrayCopNode;
	canvas: CanvasCopNode;
	color: ColorCopNode;
	cubeMap: CubeMapCopNode;
	cubeCamera: CubeCameraCopNode;
	cubeMapFromScene: CubeMapFromSceneCopNode;
	envMap: EnvMapCopNode;
	gif: GifCopNode;
	image: ImageCopNode;
	imageEXR: ImageEXRCopNode;
	imageHDR: ImageHDRCopNode;
	imageKTX2: ImageKTX2CopNode;
	lightMap: LightMapCopNode;
	lut: LutCopNode;
	mapboxElevation: MapboxElevationCopNode;
	mapboxSatellite: MapboxSatelliteCopNode;
	null: NullCopNode;
	palette: PaletteCopNode;
	fetch: FetchCopNode;
	render: RenderCopNode;
	SDFBlur: SDFBlurCopNode;
	SDFExporter: SDFExporterCopNode;
	SDFFromObject: SDFFromObjectCopNode;
	SDFFromUrl: SDFFromUrlCopNode;
	snapshot: SnapshotCopNode;
	switch: SwitchCopNode;
	textureProperties: TexturePropertiesCopNode;
	video: VideoCopNode;
	webCam: WebCamCopNode;
	actorsNetwork: ActorsNetworkCopNode;
	animationsNetwork: AnimationsNetworkCopNode;
	audioNetwork: AudioNetworkCopNode;
	copNetwork: CopNetworkCopNode;
	eventsNetwork: EventsNetworkCopNode;
	materialsNetwork: MaterialsNetworkCopNode;
	postProcessNetwork: PostProcessNetworkCopNode;
	renderersNetwork: RenderersNetworkCopNode;
}
declare class CopNetworkMatNode extends ParamLessBaseNetworkMatNode {
	static type(): NetworkNodeType;
	protected _childrenControllerContext: NodeContext;
	createNode<S extends keyof CopNodeChildrenMap>(node_class: S, options?: NodeCreateOptions): CopNodeChildrenMap[S];
	createNode<K extends valueof<CopNodeChildrenMap>>(node_class: Constructor<K>, options?: NodeCreateOptions): K;
	children(): BaseCopNodeType[];
	nodesByType<K extends keyof CopNodeChildrenMap>(type: K): CopNodeChildrenMap[K][];
}
declare class EventsNetworkMatNode extends ParamLessBaseNetworkMatNode {
	static type(): NetworkNodeType;
	protected _childrenControllerContext: NodeContext;
	createNode<S extends keyof EventNodeChildrenMap>(
		node_class: S,
		options?: NodeCreateOptions
	): EventNodeChildrenMap[S];
	createNode<K extends valueof<EventNodeChildrenMap>>(node_class: Constructor<K>, options?: NodeCreateOptions): K;
	children(): BaseEventNodeType[];
	nodesByType<K extends keyof EventNodeChildrenMap>(type: K): EventNodeChildrenMap[K][];
}
declare class MaterialsNetworkMatNode extends ParamLessBaseNetworkMatNode {
	static type(): NetworkNodeType;
	protected _childrenControllerContext: NodeContext;
	createNode<S extends keyof MatNodeChildrenMap>(node_class: S, options?: NodeCreateOptions): MatNodeChildrenMap[S];
	createNode<K extends valueof<MatNodeChildrenMap>>(node_class: Constructor<K>, options?: NodeCreateOptions): K;
	children(): BaseMatNodeType[];
	nodesByType<K extends keyof MatNodeChildrenMap>(type: K): MatNodeChildrenMap[K][];
}
declare class PostProcessNetworkMatNode extends BaseNetworkMatNode<PostProcessNetworkParamsConfig> {
	paramsConfig: PostProcessNetworkParamsConfig;
	static type(): NetworkNodeType;
	readonly effectsComposerController: EffectComposerController;
	readonly displayNodeController: DisplayNodeController;
	protected _childrenControllerContext: NodeContext;
	createNode<S extends keyof PostNodeChildrenMap>(node_class: S, options?: NodeCreateOptions): PostNodeChildrenMap[S];
	createNode<K extends valueof<PostNodeChildrenMap>>(node_class: Constructor<K>, options?: NodeCreateOptions): K;
	children(): BasePostProcessNodeType[];
	nodesByType<K extends keyof PostNodeChildrenMap>(type: K): PostNodeChildrenMap[K][];
}
declare class RenderersNetworkMatNode extends ParamLessBaseNetworkMatNode {
	static type(): NetworkNodeType;
	protected _childrenControllerContext: NodeContext;
	createNode<S extends keyof RopNodeChildrenMap>(node_class: S, options?: NodeCreateOptions): RopNodeChildrenMap[S];
	createNode<K extends valueof<RopNodeChildrenMap>>(node_class: Constructor<K>, options?: NodeCreateOptions): K;
	children(): BaseRopNodeType[];
	nodesByType<K extends keyof RopNodeChildrenMap>(type: K): RopNodeChildrenMap[K][];
}
export interface MatNodeChildrenMap {
	code: CodeMatNode;
	color: ColorMatNode;
	envMap: EnvMapMatNode;
	lineBasic: LineBasicMatNode;
	lineBasicBuilder: LineBasicBuilderMatNode;
	meshBasic: MeshBasicMatNode;
	meshBasicBuilder: MeshBasicBuilderMatNode;
	meshDepth: MeshDepthMatNode;
	meshDepthBuilder: MeshDepthBuilderMatNode;
	MeshDistance: MeshDistanceMatNode;
	meshDistanceBuilder: MeshDistanceBuilderMatNode;
	meshLambert: MeshLambertMatNode;
	meshLambertBuilder: MeshLambertBuilderMatNode;
	meshMatcap: MeshMatcapMatNode;
	meshNormal: MeshNormalMatNode;
	meshPhong: MeshPhongMatNode;
	meshPhongBuilder: MeshPhongBuilderMatNode;
	meshPhysical: MeshPhysicalMatNode;
	meshPhysicalBuilder: MeshPhysicalBuilderMatNode;
	meshStandard: MeshStandardMatNode;
	meshStandardBuilder: MeshStandardBuilderMatNode;
	meshToon: MeshToonMatNode;
	points: PointsMatNode;
	pointsBuilder: PointsBuilderMatNode;
	rayMarchingBuilder: RayMarchingBuilderMatNode;
	shadow: ShadowMatNode;
	sky: SkyMatNode;
	volume: VolumeMatNode;
	volumeBuilder: VolumeBuilderMatNode;
	actorsNetwork: ActorsNetworkMatNode;
	animationsNetwork: AnimationsNetworkMatNode;
	audioNetwork: AudioNetworkMatNode;
	copNetwork: CopNetworkMatNode;
	eventsNetwork: EventsNetworkMatNode;
	materialsNetwork: MaterialsNetworkMatNode;
	postProcessNetwork: PostProcessNetworkMatNode;
	renderersNetwork: RenderersNetworkMatNode;
}
declare class MaterialsNetworkAudioNode extends ParamLessBaseNetworkAudioNode {
	static type(): NetworkNodeType;
	protected _childrenControllerContext: NodeContext;
	createNode<S extends keyof MatNodeChildrenMap>(node_class: S, options?: NodeCreateOptions): MatNodeChildrenMap[S];
	createNode<K extends valueof<MatNodeChildrenMap>>(node_class: Constructor<K>, options?: NodeCreateOptions): K;
	children(): BaseMatNodeType[];
	nodesByType<K extends keyof MatNodeChildrenMap>(type: K): MatNodeChildrenMap[K][];
}
declare class PostProcessNetworkAudioNode extends BaseNetworkAudioNode<PostProcessNetworkParamsConfig> {
	paramsConfig: PostProcessNetworkParamsConfig;
	static type(): NetworkNodeType;
	readonly effectsComposerController: EffectComposerController;
	readonly displayNodeController: DisplayNodeController;
	protected _childrenControllerContext: NodeContext;
	createNode<S extends keyof PostNodeChildrenMap>(node_class: S, options?: NodeCreateOptions): PostNodeChildrenMap[S];
	createNode<K extends valueof<PostNodeChildrenMap>>(node_class: Constructor<K>, options?: NodeCreateOptions): K;
	children(): BasePostProcessNodeType[];
	nodesByType<K extends keyof PostNodeChildrenMap>(type: K): PostNodeChildrenMap[K][];
}
declare class RenderersNetworkAudioNode extends ParamLessBaseNetworkAudioNode {
	static type(): NetworkNodeType;
	protected _childrenControllerContext: NodeContext;
	createNode<S extends keyof RopNodeChildrenMap>(node_class: S, options?: NodeCreateOptions): RopNodeChildrenMap[S];
	createNode<K extends valueof<RopNodeChildrenMap>>(node_class: Constructor<K>, options?: NodeCreateOptions): K;
	children(): BaseRopNodeType[];
	nodesByType<K extends keyof RopNodeChildrenMap>(type: K): RopNodeChildrenMap[K][];
}
export interface AudioNodeChildrenMap {
	AMSynth: AMSynthAudioNode;
	autoFilter: AutoFilterAudioNode;
	autoWah: AutoWahAudioNode;
	bitCrusher: BitCrusherAudioNode;
	chebyshev: ChebyshevAudioNode;
	chorus: ChorusAudioNode;
	distortion: DistortionAudioNode;
	envelope: EnvelopeAudioNode;
	FFT: FFTAudioNode;
	FMSynth: FMSynthAudioNode;
	feedbackDelay: FeedbackDelayAudioNode;
	fetch: FetchAudioNode;
	file: FileAudioNode;
	frequencyShifter: FrequencyShifterAudioNode;
	meter: MeterAudioNode;
	monoSynth: MonoSynthAudioNode;
	noise: NoiseAudioNode;
	null: NullAudioNode;
	phaser: PhaserAudioNode;
	pingPongDelay: PingPongDelayAudioNode;
	pitchShift: PitchShiftAudioNode;
	playInstrument: PlayInstrumentAudioNode;
	polySynth: PolySynthAudioNode;
	reverb: ReverbAudioNode;
	sampler: SamplerAudioNode;
	stereoWidener: StereoWidenerAudioNode;
	switch: SwitchAudioNode;
	synth: SynthAudioNode;
	tremolo: TremoloAudioNode;
	userMedia: UserMediaAudioNode;
	vibrato: VibratoAudioNode;
	volume: VolumeAudioNode;
	waveform: WaveformAudioNode;
	actorsNetwork: ActorsNetworkAudioNode;
	animationsNetwork: AnimationsNetworkAudioNode;
	audioNetwork: AudioNetworkAudioNode;
	copNetwork: CopNetworkAudioNode;
	eventsNetwork: EventsNetworkAudioNode;
	materialsNetwork: MaterialsNetworkAudioNode;
	postProcessNetwork: PostProcessNetworkAudioNode;
	renderersNetwork: RenderersNetworkAudioNode;
}
declare class AudioNetworkAnimNode extends ParamLessBaseNetworkAnimNode {
	static type(): NetworkNodeType;
	protected _childrenControllerContext: NodeContext;
	createNode<S extends keyof AudioNodeChildrenMap>(
		node_class: S,
		options?: NodeCreateOptions
	): AudioNodeChildrenMap[S];
	createNode<K extends valueof<AudioNodeChildrenMap>>(node_class: Constructor<K>, options?: NodeCreateOptions): K;
	children(): BaseAudioNodeType[];
	nodesByType<K extends keyof AudioNodeChildrenMap>(type: K): AudioNodeChildrenMap[K][];
}
declare class CopNetworkAnimNode extends ParamLessBaseNetworkAnimNode {
	static type(): NetworkNodeType;
	protected _childrenControllerContext: NodeContext;
	createNode<S extends keyof CopNodeChildrenMap>(node_class: S, options?: NodeCreateOptions): CopNodeChildrenMap[S];
	createNode<K extends valueof<CopNodeChildrenMap>>(node_class: Constructor<K>, options?: NodeCreateOptions): K;
	children(): BaseCopNodeType[];
	nodesByType<K extends keyof CopNodeChildrenMap>(type: K): CopNodeChildrenMap[K][];
}
declare class EventsNetworkAnimNode extends ParamLessBaseNetworkAnimNode {
	static type(): NetworkNodeType;
	protected _childrenControllerContext: NodeContext;
	createNode<S extends keyof EventNodeChildrenMap>(
		node_class: S,
		options?: NodeCreateOptions
	): EventNodeChildrenMap[S];
	createNode<K extends valueof<EventNodeChildrenMap>>(node_class: Constructor<K>, options?: NodeCreateOptions): K;
	children(): BaseEventNodeType[];
	nodesByType<K extends keyof EventNodeChildrenMap>(type: K): EventNodeChildrenMap[K][];
}
declare class MaterialsNetworkAnimNode extends ParamLessBaseNetworkAnimNode {
	static type(): NetworkNodeType;
	protected _childrenControllerContext: NodeContext;
	createNode<S extends keyof MatNodeChildrenMap>(node_class: S, options?: NodeCreateOptions): MatNodeChildrenMap[S];
	createNode<K extends valueof<MatNodeChildrenMap>>(node_class: Constructor<K>, options?: NodeCreateOptions): K;
	children(): BaseMatNodeType[];
	nodesByType<K extends keyof MatNodeChildrenMap>(type: K): MatNodeChildrenMap[K][];
}
declare class PostProcessNetworkAnimNode extends BaseNetworkAnimNode<PostProcessNetworkParamsConfig> {
	paramsConfig: PostProcessNetworkParamsConfig;
	static type(): NetworkNodeType;
	readonly effectsComposerController: EffectComposerController;
	readonly displayNodeController: DisplayNodeController;
	protected _childrenControllerContext: NodeContext;
	createNode<S extends keyof PostNodeChildrenMap>(node_class: S, options?: NodeCreateOptions): PostNodeChildrenMap[S];
	createNode<K extends valueof<PostNodeChildrenMap>>(node_class: Constructor<K>, options?: NodeCreateOptions): K;
	children(): BasePostProcessNodeType[];
	nodesByType<K extends keyof PostNodeChildrenMap>(type: K): PostNodeChildrenMap[K][];
}
declare class RenderersNetworkAnimNode extends ParamLessBaseNetworkAnimNode {
	static type(): NetworkNodeType;
	protected _childrenControllerContext: NodeContext;
	createNode<S extends keyof RopNodeChildrenMap>(node_class: S, options?: NodeCreateOptions): RopNodeChildrenMap[S];
	createNode<K extends valueof<RopNodeChildrenMap>>(node_class: Constructor<K>, options?: NodeCreateOptions): K;
	children(): BaseRopNodeType[];
	nodesByType<K extends keyof RopNodeChildrenMap>(type: K): RopNodeChildrenMap[K][];
}
export interface AnimNodeChildrenMap {
	delay: DelayAnimNode;
	duration: DurationAnimNode;
	easing: EasingAnimNode;
	merge: MergeAnimNode;
	null: NullAnimNode;
	operation: OperationAnimNode;
	play: PlayAnimNode;
	position: PositionAnimNode;
	propertyName: PropertyNameAnimNode;
	propertyValue: PropertyValueAnimNode;
	repeat: RepeatAnimNode;
	subnet: SubnetAnimNode;
	subnetInput: SubnetInputAnimNode;
	subnetOutput: SubnetOutputAnimNode;
	switch: SwitchAnimNode;
	target: TargetAnimNode;
	actorsNetwork: ActorsNetworkAnimNode;
	animationsNetwork: AnimationsNetworkAnimNode;
	audioNetwork: AudioNetworkAnimNode;
	copNetwork: CopNetworkAnimNode;
	eventsNetwork: EventsNetworkAnimNode;
	materialsNetwork: MaterialsNetworkAnimNode;
	postProcessNetwork: PostProcessNetworkAnimNode;
	renderersNetwork: RenderersNetworkAnimNode;
}
declare class AnimationsNetworkEventNode extends ParamLessBaseNetworkEventNode {
	static type(): NetworkNodeType;
	protected _childrenControllerContext: NodeContext;
	createNode<S extends keyof AnimNodeChildrenMap>(node_class: S, options?: NodeCreateOptions): AnimNodeChildrenMap[S];
	createNode<K extends valueof<AnimNodeChildrenMap>>(node_class: Constructor<K>, options?: NodeCreateOptions): K;
	children(): BaseAnimNodeType[];
	nodesByType<K extends keyof AnimNodeChildrenMap>(type: K): AnimNodeChildrenMap[K][];
}
declare class AudioNetworkEventNode extends ParamLessBaseNetworkEventNode {
	static type(): NetworkNodeType;
	protected _childrenControllerContext: NodeContext;
	createNode<S extends keyof AudioNodeChildrenMap>(
		node_class: S,
		options?: NodeCreateOptions
	): AudioNodeChildrenMap[S];
	createNode<K extends valueof<AudioNodeChildrenMap>>(node_class: Constructor<K>, options?: NodeCreateOptions): K;
	children(): BaseAudioNodeType[];
	nodesByType<K extends keyof AudioNodeChildrenMap>(type: K): AudioNodeChildrenMap[K][];
}
declare class CopNetworkEventNode extends ParamLessBaseNetworkEventNode {
	static type(): NetworkNodeType;
	protected _childrenControllerContext: NodeContext;
	createNode<S extends keyof CopNodeChildrenMap>(node_class: S, options?: NodeCreateOptions): CopNodeChildrenMap[S];
	createNode<K extends valueof<CopNodeChildrenMap>>(node_class: Constructor<K>, options?: NodeCreateOptions): K;
	children(): BaseCopNodeType[];
	nodesByType<K extends keyof CopNodeChildrenMap>(type: K): CopNodeChildrenMap[K][];
}
declare class EventsNetworkEventNode extends ParamLessBaseNetworkEventNode {
	static type(): NetworkNodeType;
	protected _childrenControllerContext: NodeContext;
	createNode<S extends keyof EventNodeChildrenMap>(
		node_class: S,
		options?: NodeCreateOptions
	): EventNodeChildrenMap[S];
	createNode<K extends valueof<EventNodeChildrenMap>>(node_class: Constructor<K>, options?: NodeCreateOptions): K;
	children(): BaseEventNodeType[];
	nodesByType<K extends keyof EventNodeChildrenMap>(type: K): EventNodeChildrenMap[K][];
}
declare class MaterialsNetworkEventNode extends ParamLessBaseNetworkEventNode {
	static type(): NetworkNodeType;
	protected _childrenControllerContext: NodeContext;
	createNode<S extends keyof MatNodeChildrenMap>(node_class: S, options?: NodeCreateOptions): MatNodeChildrenMap[S];
	createNode<K extends valueof<MatNodeChildrenMap>>(node_class: Constructor<K>, options?: NodeCreateOptions): K;
	children(): BaseMatNodeType[];
	nodesByType<K extends keyof MatNodeChildrenMap>(type: K): MatNodeChildrenMap[K][];
}
declare class PostProcessNetworkEventNode extends BaseNetworkEventNode<PostProcessNetworkParamsConfig> {
	paramsConfig: PostProcessNetworkParamsConfig;
	static type(): NetworkNodeType;
	readonly effectsComposerController: EffectComposerController;
	readonly displayNodeController: DisplayNodeController;
	protected _childrenControllerContext: NodeContext;
	createNode<S extends keyof PostNodeChildrenMap>(node_class: S, options?: NodeCreateOptions): PostNodeChildrenMap[S];
	createNode<K extends valueof<PostNodeChildrenMap>>(node_class: Constructor<K>, options?: NodeCreateOptions): K;
	children(): BasePostProcessNodeType[];
	nodesByType<K extends keyof PostNodeChildrenMap>(type: K): PostNodeChildrenMap[K][];
}
declare class RenderersNetworkEventNode extends ParamLessBaseNetworkEventNode {
	static type(): NetworkNodeType;
	protected _childrenControllerContext: NodeContext;
	createNode<S extends keyof RopNodeChildrenMap>(node_class: S, options?: NodeCreateOptions): RopNodeChildrenMap[S];
	createNode<K extends valueof<RopNodeChildrenMap>>(node_class: Constructor<K>, options?: NodeCreateOptions): K;
	children(): BaseRopNodeType[];
	nodesByType<K extends keyof RopNodeChildrenMap>(type: K): RopNodeChildrenMap[K][];
}
export interface EventNodeChildrenMap {
	audio: AudioEventNode;
	animation: AnimationEventNode;
	any: AnyEventNode;
	block: BlockEventNode;
	button: ButtonEventNode;
	cameraMapControls: CameraOrbitControlsEventNode;
	cameraOrbitControls: CameraMapControlsEventNode;
	debounce: DebounceEventNode;
	delay: DelayEventNode;
	drag: DragEventNode;
	code: CodeEventNode;
	firstPersonControls: FirstPersonControlsEventNode;
	intersectData: IntersectDataEventNode;
	keyboard: KeyboardEventNode;
	limit: LimitEventNode;
	message: MessageEventNode;
	mobileJoystickControls: MobileJoystickControlsEventNode;
	mouse: MouseEventNode;
	nodeCook: NodeCookEventNode;
	null: NullEventNode;
	param: ParamEventNode;
	pointer: PointerEventNode;
	raycast: RaycastEventNode;
	scene: SceneEventNode;
	scrollTrigger: ScrollTriggerEventNode;
	setFlag: SetFlagEventNode;
	setParam: SetParamEventNode;
	sequence: SequenceEventNode;
	throttle: ThrottleEventNode;
	timer: TimerEventNode;
	touch: TouchEventNode;
	viewer: ViewerEventNode;
	window: WindowEventNode;
	actorsNetwork: ActorsNetworkEventNode;
	animationsNetwork: AnimationsNetworkEventNode;
	audioNetwork: AudioNetworkEventNode;
	copNetwork: CopNetworkEventNode;
	eventsNetwork: EventsNetworkEventNode;
	materialsNetwork: MaterialsNetworkEventNode;
	postProcessNetwork: PostProcessNetworkEventNode;
	renderersNetwork: RenderersNetworkEventNode;
}
declare class CameraControlsSopParamsConfig extends NodeParamsConfig {
	/** @param renderer */
	node: ParamTemplate<ParamType.NODE_PATH>;
}
declare class CameraControlsSopNode extends TypedSopNode<CameraControlsSopParamsConfig> {
	readonly paramsConfig: CameraControlsSopParamsConfig;
	static type(): CameraSopNodeType;
	protected initializeNode(): void;
	private _operation;
	cook(inputCoreGroups: CoreGroup[]): void;
	protected _childrenControllerContext: NodeContext;
	createNode<S extends keyof EventNodeChildrenMap>(
		node_class: S,
		options?: NodeCreateOptions
	): EventNodeChildrenMap[S];
	createNode<K extends valueof<EventNodeChildrenMap>>(node_class: Constructor<K>, options?: NodeCreateOptions): K;
	children(): BaseEventNodeType[];
	nodesByType<K extends keyof EventNodeChildrenMap>(type: K): EventNodeChildrenMap[K][];
}
declare class CameraCSSRendererSopParamsConfig extends NodeParamsConfig {
	/** @param renderer */
	node: ParamTemplate<ParamType.NODE_PATH>;
}
declare class CameraCSSRendererSopNode extends TypedSopNode<CameraCSSRendererSopParamsConfig> {
	readonly paramsConfig: CameraCSSRendererSopParamsConfig;
	static type(): CameraSopNodeType;
	protected initializeNode(): void;
	private _operation;
	cook(inputCoreGroups: CoreGroup[]): void;
	protected _childrenControllerContext: NodeContext;
	createNode<S extends keyof RopNodeChildrenMap>(node_class: S, options?: NodeCreateOptions): RopNodeChildrenMap[S];
	createNode<K extends valueof<RopNodeChildrenMap>>(node_class: Constructor<K>, options?: NodeCreateOptions): K;
	children(): BaseRopNodeType[];
	nodesByType<K extends keyof RopNodeChildrenMap>(type: K): RopNodeChildrenMap[K][];
}
declare const CameraFrameModeSopParamsConfig_base: {
	new (...args: any[]): {
		frameMode: ParamTemplate<ParamType.INTEGER>;
		expectedAspectRatio: ParamTemplate<ParamType.FLOAT>;
	};
} & typeof NodeParamsConfig;
declare class CameraFrameModeSopParamsConfig extends CameraFrameModeSopParamsConfig_base {}
declare class CameraFrameModeSopNode extends TypedSopNode<CameraFrameModeSopParamsConfig> {
	readonly paramsConfig: CameraFrameModeSopParamsConfig;
	static type(): CameraSopNodeType;
	protected initializeNode(): void;
	private _operation;
	cook(inputCoreGroups: CoreGroup[]): void;
}
declare class CameraPlaneSopParamsConfig extends NodeParamsConfig {
	/** @param camera */
	camera: ParamTemplate<ParamType.NODE_PATH>;
	/** @param axis perpendicular to the plane */
	direction: ParamTemplate<ParamType.VECTOR3>;
	/** @param plane offset */
	offset: ParamTemplate<ParamType.FLOAT>;
	/** @param defines if the plane resolution is sets via the number of segments or via the step size */
	useSegmentsCount: ParamTemplate<ParamType.BOOLEAN>;
	/** @param step size */
	stepSize: ParamTemplate<ParamType.FLOAT>;
	/** @param segments count */
	segments: ParamTemplate<ParamType.VECTOR2>;
	/** @param multiplies the size of the plane. This can be useful to scale down the plane. While it would cover a smaller part of the view, it would be faster to create  */
	sizeMult: ParamTemplate<ParamType.FLOAT>;
	/** @param update on window resize  */
	updateOnWindowResize: ParamTemplate<ParamType.BOOLEAN>;
	/** @param update */
	update: ParamTemplate<ParamType.BUTTON>;
}
declare class CameraPlaneSopNode extends TypedSopNode<CameraPlaneSopParamsConfig> {
	paramsConfig: CameraPlaneSopParamsConfig;
	static type(): string;
	private _plane;
	private _raycaster;
	private _planeCorners;
	private _planeCenter;
	private _coreTransform;
	cook(): void;
	private _updateWindowControllerDependency;
	private _computePlaneParams;
	private segments_count;
	private planeSize;
	private _createPlane;
	static PARAM_CALLBACK_update(node: CameraPlaneSopNode): void;
	private _paramCallbackUpdate;
}
declare const CameraPostProcessSopParamsConfig_base: {
	new (...args: any[]): {
		prependRenderPass: ParamTemplate<ParamType.BOOLEAN>;
		depthBuffer: ParamTemplate<ParamType.BOOLEAN>;
		stencilBuffer: ParamTemplate<ParamType.BOOLEAN>;
		sampling: ParamTemplate<ParamType.INTEGER>;
		tTextureType: ParamTemplate<ParamType.BOOLEAN>;
		textureType: ParamTemplate<ParamType.INTEGER>;
	};
} & {
	new (...args: any[]): {
		/** @param set to true to define the post process nodes from a different node than this one */
		useOtherNode: ParamTemplate<ParamType.BOOLEAN>;
		/** @param other parent node containing the post process nodes that will make up the passes used */
		node: ParamTemplate<ParamType.NODE_PATH>;
	};
} & typeof NodeParamsConfig;
declare class CameraPostProcessSopParamsConfig extends CameraPostProcessSopParamsConfig_base {}
declare class CameraPostProcessSopNode extends TypedSopNode<CameraPostProcessSopParamsConfig> {
	readonly paramsConfig: CameraPostProcessSopParamsConfig;
	static type(): CameraSopNodeType;
	protected initializeNode(): void;
	private _operation;
	cook(inputCoreGroups: CoreGroup[]): void;
	readonly effectsComposerController: EffectComposerController;
	readonly displayNodeController: DisplayNodeController;
	protected _childrenControllerContext: NodeContext;
	createNode<S extends keyof PostNodeChildrenMap>(node_class: S, options?: NodeCreateOptions): PostNodeChildrenMap[S];
	createNode<K extends valueof<PostNodeChildrenMap>>(node_class: Constructor<K>, options?: NodeCreateOptions): K;
	children(): BasePostProcessNodeType[];
	nodesByType<K extends keyof PostNodeChildrenMap>(type: K): PostNodeChildrenMap[K][];
}
declare class CameraProjectSopParamsConfig extends NodeParamsConfig {
	/** @param unproject */
	project: ParamTemplate<ParamType.BOOLEAN>;
}
declare class CameraProjectSopNode extends TypedSopNode<CameraProjectSopParamsConfig> {
	paramsConfig: CameraProjectSopParamsConfig;
	static type(): string;
	static displayedInputNames(): string[];
	initializeNode(): void;
	private _operation;
	cook(input_contents: CoreGroup[]): void;
}
declare class CameraRenderSceneSopParamsConfig extends NodeParamsConfig {
	/** @param renderer */
	node: ParamTemplate<ParamType.NODE_PATH>;
}
declare class CameraRenderSceneSopNode extends TypedSopNode<CameraRenderSceneSopParamsConfig> {
	readonly paramsConfig: CameraRenderSceneSopParamsConfig;
	static type(): CameraSopNodeType;
	protected initializeNode(): void;
	private _operation;
	cook(inputCoreGroups: CoreGroup[]): void;
}
declare class CameraRendererSopParamsConfig extends NodeParamsConfig {
	/** @param renderer */
	node: ParamTemplate<ParamType.NODE_PATH>;
}
declare class CameraRendererSopNode extends TypedSopNode<CameraRendererSopParamsConfig> {
	readonly paramsConfig: CameraRendererSopParamsConfig;
	static type(): CameraSopNodeType;
	protected initializeNode(): void;
	private _operation;
	cook(inputCoreGroups: CoreGroup[]): void;
	protected _childrenControllerContext: NodeContext;
	createNode<S extends keyof RopNodeChildrenMap>(node_class: S, options?: NodeCreateOptions): RopNodeChildrenMap[S];
	createNode<K extends valueof<RopNodeChildrenMap>>(node_class: Constructor<K>, options?: NodeCreateOptions): K;
	children(): BaseRopNodeType[];
	nodesByType<K extends keyof RopNodeChildrenMap>(type: K): RopNodeChildrenMap[K][];
}
declare const CameraWebXRARMarkerTrackingSopParamsConfig_base: {
	new (...args: any[]): {
		sourceMode: ParamTemplate<ParamType.INTEGER>;
		sourceUrl: ParamTemplate<ParamType.STRING>;
		transformMode: ParamTemplate<ParamType.INTEGER>;
		smooth: ParamTemplate<ParamType.BOOLEAN>;
		smoothCount: ParamTemplate<ParamType.INTEGER>;
		barCodeType: ParamTemplate<ParamType.STRING>;
		barCodeValue: ParamTemplate<ParamType.INTEGER>;
	};
} & typeof NodeParamsConfig;
declare class CameraWebXRARMarkerTrackingSopParamsConfig extends CameraWebXRARMarkerTrackingSopParamsConfig_base {}
declare class CameraWebXRARMarkerTrackingSopNode extends TypedSopNode<CameraWebXRARMarkerTrackingSopParamsConfig> {
	readonly paramsConfig: CameraWebXRARMarkerTrackingSopParamsConfig;
	static type(): CameraSopNodeType;
	protected initializeNode(): void;
	private _operation;
	cook(inputCoreGroups: CoreGroup[]): void;
	setSourceMode(sourceMode: MarkerTrackingSourceMode): void;
	sourceMode(): MarkerTrackingSourceMode;
	setTransformMode(sourceMode: MarkerTrackingTransformMode): void;
	transformMode(): MarkerTrackingTransformMode;
}
declare const CameraWebXRARSopParamsConfig_base: {
	new (...args: any[]): {
		hitTest: ParamTemplate<ParamType.INTEGER>;
		lightEstimation: ParamTemplate<ParamType.INTEGER>;
		cameraAccess: ParamTemplate<ParamType.INTEGER>;
		overrideReferenceSpaceType: ParamTemplate<ParamType.BOOLEAN>;
		referenceSpaceType: ParamTemplate<ParamType.INTEGER>;
	};
} & typeof NodeParamsConfig;
declare class CameraWebXRARSopParamsConfig extends CameraWebXRARSopParamsConfig_base {}
declare class CameraWebXRARSopNode extends TypedSopNode<CameraWebXRARSopParamsConfig> {
	readonly paramsConfig: CameraWebXRARSopParamsConfig;
	static type(): CameraSopNodeType;
	protected initializeNode(): void;
	private _operation;
	cook(inputCoreGroups: CoreGroup[]): void;
}
declare const CameraWebXRVRSopParamsConfig_base: {
	new (...args: any[]): {
		localFloor: ParamTemplate<ParamType.INTEGER>;
		boundedFloor: ParamTemplate<ParamType.INTEGER>;
		handTracking: ParamTemplate<ParamType.INTEGER>;
		layers: ParamTemplate<ParamType.INTEGER>;
		overrideReferenceSpaceType: ParamTemplate<ParamType.BOOLEAN>;
		referenceSpaceType: ParamTemplate<ParamType.INTEGER>;
	};
} & typeof NodeParamsConfig;
declare class CameraWebXRVRSopParamsConfig extends CameraWebXRVRSopParamsConfig_base {}
declare class CameraWebXRVRSopNode extends TypedSopNode<CameraWebXRVRSopParamsConfig> {
	readonly paramsConfig: CameraWebXRVRSopParamsConfig;
	static type(): CameraSopNodeType;
	protected initializeNode(): void;
	private _operation;
	cook(inputCoreGroups: CoreGroup[]): void;
}
declare class CapsuleSopParamsConfig extends NodeParamsConfig {
	/** @param radius */
	radius: ParamTemplate<ParamType.FLOAT>;
	/** @param height */
	height: ParamTemplate<ParamType.FLOAT>;
	/** @param divisions */
	divisions: ParamTemplate<ParamType.INTEGER>;
	/** @param center */
	center: ParamTemplate<ParamType.VECTOR3>;
}
declare class CapsuleSopNode extends TypedSopNode<CapsuleSopParamsConfig> {
	paramsConfig: CapsuleSopParamsConfig;
	static type(): SopType;
	initializeNode(): void;
	private _operation;
	cook(inputCoreGroups: CoreGroup[]): void;
}
declare class CenterSopParamsConfig extends NodeParamsConfig {}
declare class CenterSopNode extends TypedSopNode<CenterSopParamsConfig> {
	paramsConfig: CenterSopParamsConfig;
	static type(): string;
	initializeNode(): void;
	private _operation;
	cook(input_contents: CoreGroup[]): void;
}
declare class CircleSopParamsConfig extends NodeParamsConfig {
	/** @param circle radius */
	radius: ParamTemplate<ParamType.FLOAT>;
	/** @param segments count */
	segments: ParamTemplate<ParamType.INTEGER>;
	/** @param toggle on to have an arc instead of a closed circle */
	open: ParamTemplate<ParamType.BOOLEAN>;
	/** @param connects last dot for open circle */
	connectLastPoint: ParamTemplate<ParamType.BOOLEAN>;
	/** @param angle fo the arc */
	arcAngle: ParamTemplate<ParamType.FLOAT>;
	/** @param direction of the axis perpendicular to the circle plane */
	direction: ParamTemplate<ParamType.VECTOR3>;
	/** @param center */
	center: ParamTemplate<ParamType.VECTOR3>;
}
declare class CircleSopNode extends TypedSopNode<CircleSopParamsConfig> {
	paramsConfig: CircleSopParamsConfig;
	static type(): SopType;
	private _operation;
	cook(): void;
}
declare enum PointsCountMode {
	SEGMENTS_COUNT = 'segments count',
	SEGMENTS_LENGTH = 'segments length',
}
declare class Circle3PointsSopParamsConfig extends NodeParamsConfig {
	/** @param toggle on to create the arc */
	arc: ParamTemplate<ParamType.BOOLEAN>;
	/** @param sets the mode how the points count is computed */
	pointsCountMode: ParamTemplate<ParamType.INTEGER>;
	/** @param length of each segment */
	segmentsLength: ParamTemplate<ParamType.FLOAT>;
	/** @param count of the number of segments */
	segmentsCount: ParamTemplate<ParamType.INTEGER>;
	/** @param toggle on to create a full circle */
	full: ParamTemplate<ParamType.BOOLEAN>;
	/** @param TBD */
	joinMode: ParamTemplate<ParamType.INTEGER>;
	/** @param add an id attribute for the generated points */
	addIdAttribute: ParamTemplate<ParamType.BOOLEAN>;
	/** @param add an idn attribute (same as id attribute, but normalized between 0 and 1) */
	addIdnAttribute: ParamTemplate<ParamType.BOOLEAN>;
	/** @param toggle on to create a point in the center */
	center: ParamTemplate<ParamType.BOOLEAN>;
}
declare class Circle3PointsSopNode extends TypedSopNode<Circle3PointsSopParamsConfig> {
	paramsConfig: Circle3PointsSopParamsConfig;
	static type(): SopType;
	initializeNode(): void;
	setPointsCountMode(mode: PointsCountMode): void;
	pointsCountMode(): PointsCountMode;
	cook(inputCoreGroups: CoreGroup[]): void;
	private a;
	private b;
	private c;
	private _create_circle;
}
declare class ClipSopParamsConfig extends NodeParamsConfig {
	/** @param origin */
	origin: ParamTemplate<ParamType.VECTOR3>;
	/** @param distance */
	distance: ParamTemplate<ParamType.FLOAT>;
	/** @param direction */
	direction: ParamTemplate<ParamType.VECTOR3>;
	/** @param intersectionEdges */
	intersectionEdges: ParamTemplate<ParamType.BOOLEAN>;
	/** @param keepBelowPlane */
	keepBelowPlane: ParamTemplate<ParamType.BOOLEAN>;
	/** @param keepAbovePlane */
	keepAbovePlane: ParamTemplate<ParamType.BOOLEAN>;
}
declare class ClipSopNode extends TypedSopNode<ClipSopParamsConfig> {
	paramsConfig: ClipSopParamsConfig;
	static type(): string;
	initializeNode(): void;
	private _operation;
	cook(inputCoreGroups: CoreGroup[]): void;
}
declare class BaseCodeSopProcessor extends BaseCodeProcessor {
	protected node: CodeSopNode;
	constructor(node: CodeSopNode);
	get pv(): ParamsValueAccessorType<CodeSopParamsConfig>;
	get p(): ParamsAccessorType<CodeSopParamsConfig>;
	initializeProcessor(): void;
	cook(inputCoreGroups: CoreGroup[]): void;
	protected setCoreGroup(coreGroup: CoreGroup): void;
	protected setObjects(objects: Object3D[]): void;
}
declare class CodeSopParamsConfig extends NodeParamsConfig {
	codeTypescript: ParamTemplate<ParamType.STRING>;
	codeJavascript: ParamTemplate<ParamType.STRING>;
}
declare class CodeSopNode extends TypedSopNode<CodeSopParamsConfig> {
	paramsConfig: CodeSopParamsConfig;
	static BaseCodeSopProcessor: typeof BaseCodeSopProcessor;
	static type(): string;
	private _lastCompiledCode;
	private _processor;
	initializeNode(): void;
	cook(inputCoreGroups: CoreGroup[]): void;
	private _compileIfRequired;
	private _compile;
}
declare class ColorSopParamsConfig extends NodeParamsConfig {
	/** @param toggle on if the color should be copied from another attribute */
	fromAttribute: ParamTemplate<ParamType.BOOLEAN>;
	/** @param attribute name to copy value from */
	attribName: ParamTemplate<ParamType.STRING>;
	/** @param color valu */
	color: ParamTemplate<ParamType.COLOR>;
	/** @param toggle on if the value should be set with hsv values rather than rgb */
	asHsv: ParamTemplate<ParamType.BOOLEAN>;
}
declare class ColorSopNode extends TypedSopNode<ColorSopParamsConfig> {
	paramsConfig: ColorSopParamsConfig;
	static type(): string;
	private _arrayByGeometryUUID;
	static displayedInputNames(): string[];
	initializeNode(): void;
	cook(inputCoreGroups: CoreGroup[]): Promise<void>;
	_setFromAttribute(coreObject: CoreObject): void;
	private _createInitColor;
	_evalSimpleValues(coreObject: CoreObject): void;
	_evalExpressions(core_object: CoreObject): Promise<void>;
	private _updateFromParam;
	private _initArrayIfRequired;
	private _commitTmpValues;
}
declare class ConeSopParamsConfig extends NodeParamsConfig {
	/** @param cone radius */
	radius: ParamTemplate<ParamType.FLOAT>;
	/** @param cone height */
	height: ParamTemplate<ParamType.FLOAT>;
	/** @param radial segments count */
	segmentsRadial: ParamTemplate<ParamType.INTEGER>;
	/** @param height segments count */
	segmentsHeight: ParamTemplate<ParamType.INTEGER>;
	/** @param adds a cap */
	cap: ParamTemplate<ParamType.BOOLEAN>;
	/** @param theta start */
	thetaStart: ParamTemplate<ParamType.FLOAT>;
	/** @param start length */
	thetaLength: ParamTemplate<ParamType.FLOAT>;
	/** @param center */
	center: ParamTemplate<ParamType.VECTOR3>;
	/** @param direction */
	direction: ParamTemplate<ParamType.VECTOR3>;
}
declare class ConeSopNode extends TypedSopNode<ConeSopParamsConfig> {
	paramsConfig: ConeSopParamsConfig;
	static type(): SopType;
	cook(): void;
}
declare class BoxSopParamsConfig extends NodeParamsConfig {}
declare class ConvexHullSopNode extends TypedSopNode<BoxSopParamsConfig> {
	readonly paramsConfig: BoxSopParamsConfig;
	static type(): string;
	protected initializeNode(): void;
	private _operation;
	cook(inputCoreGroups: CoreGroup[]): void;
}
declare class BaseCopyStamp extends CoreGraphNode {
	protected _globalIndex: number | undefined;
	constructor(scene: PolyScene);
	reset(): void;
	setGlobalIndex(index: number): void;
	value(attribName?: string): AttribValue | undefined;
}
declare class SopCopyStamp extends BaseCopyStamp {
	protected _point: CorePoint | undefined;
	reset(): void;
	setPoint(point?: CorePoint): void;
	value(
		attribName?: string
	): string | number | boolean | Number3 | Number2 | Vector2Like | ColorLike | Number4 | undefined;
}
declare class CopySopParamsConfig extends NodeParamsConfig {
	/** @param copies count, used when the second input is not given */
	count: ParamTemplate<ParamType.INTEGER>;
	/** @param translate each copy */
	t: ParamTemplate<ParamType.VECTOR3>;
	/** @param rotate each copy */
	r: ParamTemplate<ParamType.VECTOR3>;
	/** @param scale each copy */
	s: ParamTemplate<ParamType.VECTOR3>;
	/** @param scale multiplier for each copy */
	scale: ParamTemplate<ParamType.FLOAT>;
	/** @param transforms every input object each on a single input point */
	transformOnly: ParamTemplate<ParamType.BOOLEAN>;
	/** @param defines if the objects or the geometries are transformed */
	transformMode: ParamTemplate<ParamType.INTEGER>;
	/** @param defines how the objects are transformed */
	objectTransformSpace: ParamTemplate<ParamType.INTEGER>;
	/** @param toggles on to copy attributes from the input points to the created objects. Note that the vertex attributes from the points become object attributes */
	copyAttributes: ParamTemplate<ParamType.BOOLEAN>;
	/** @param names of attributes to copy */
	attributesToCopy: ParamTemplate<ParamType.STRING>;
	/** @param toggle on to use the `copy` expression, which allows to change how the left input is evaluated for each point */
	useCopyExpr: ParamTemplate<ParamType.BOOLEAN>;
}
declare class CopySopNode extends TypedSopNode<CopySopParamsConfig> {
	paramsConfig: CopySopParamsConfig;
	static type(): SopType;
	private _attribNamesToCopy;
	private _objects;
	private _stampNode;
	static displayedInputNames(): string[];
	initializeNode(): void;
	setTransformMode(transformMode: TransformTargetType): void;
	setObjectTransformSpace(transformSpace: ObjectTransformSpace): void;
	cook(inputCoreGroups: CoreGroup[]): Promise<void>;
	private _instancer;
	private cookWithTemplate;
	private _copyMovedObjectsOnTemplatePoints;
	private _instanceMatrix;
	private _copyMovedObjectOnTemplatePoint;
	private _getMovedObjectsForTemplatePoint;
	private _stampInstanceGroupIfRequired;
	private _copyMovedObjectsForEachInstance;
	private _copyMovedObjectsForInstance;
	private cookWithoutTemplate;
	private _copyAttributes_from_template;
	stampValue(
		attribName?: string
	): string | number | boolean | Number3 | Number2 | Vector2Like | ColorLike | Number4 | undefined;
	stampNode(): SopCopyStamp;
	private _createStampNode;
	dispose(): void;
	private _coreTransform;
	private _transformAccumulatedMatrix;
	private _transformMatrix;
	private _initAccumulatedTransform;
	private _accumulateTransform;
	private _applyMatrixToObject;
	private _applyAccumulatedTransform;
}
declare class CurveFromPointsSopParamsConfig extends NodeParamsConfig {
	/** @param points Count */
	pointsCount: ParamTemplate<ParamType.INTEGER>;
	/** @param closed */
	closed: ParamTemplate<ParamType.BOOLEAN>;
	/** @param curve type */
	curveType: ParamTemplate<ParamType.INTEGER>;
	/** @param tension */
	tension: ParamTemplate<ParamType.FLOAT>;
	/** @param add tangent attribute */
	tTangent: ParamTemplate<ParamType.BOOLEAN>;
	/** @param tangent attribute name */
	tangentName: ParamTemplate<ParamType.STRING>;
}
declare class CurveFromPointsSopNode extends TypedSopNode<CurveFromPointsSopParamsConfig> {
	readonly paramsConfig: CurveFromPointsSopParamsConfig;
	static type(): SopType;
	protected initializeNode(): void;
	private _operation;
	cook(inputCoreGroups: CoreGroup[]): void;
}
declare class CurveGetPointSopParamsConfig extends NodeParamsConfig {
	/** @param t */
	t: ParamTemplate<ParamType.FLOAT>;
	/** @param closed */
	closed: ParamTemplate<ParamType.BOOLEAN>;
	/** @param curve type */
	curveType: ParamTemplate<ParamType.INTEGER>;
	/** @param tension */
	tension: ParamTemplate<ParamType.FLOAT>;
	/** @param add tangent attribute */
	tTangent: ParamTemplate<ParamType.BOOLEAN>;
	/** @param tangent attribute name */
	tangentName: ParamTemplate<ParamType.STRING>;
}
declare class CurveGetPointSopNode extends TypedSopNode<CurveGetPointSopParamsConfig> {
	readonly paramsConfig: CurveGetPointSopParamsConfig;
	static type(): string;
	protected initializeNode(): void;
	private _operation;
	cook(inputCoreGroups: CoreGroup[]): void;
}
declare class CSGSopNode<K extends NodeParamsConfig> extends TypedSopNode<K> {
	dataType(): string;
	requiredModules(): ModuleName[];
	setCSGGeometry<T extends CsgGeometryType>(geometry: CsgTypeMap[T]): void;
	setCSGGeometries(geometries: CsgGeometry[]): void;
	setCSGObjects(csgObjects: CsgObject<CsgGeometryType>[]): void;
	setCSGObject(csgObject: CsgObject<CsgGeometryType>): void;
	protected _setContainerCadObjects(objects: CsgObject<CsgGeometryType>[]): void;
}
declare class CSGArcSopParamsConfig extends NodeParamsConfig {
	/** @param radius */
	radius: ParamTemplate<ParamType.FLOAT>;
	/** @param segments */
	segments: ParamTemplate<ParamType.INTEGER>;
	/** @param center */
	center: ParamTemplate<ParamType.VECTOR2>;
	/** @param make tangents */
	makeTangent: ParamTemplate<ParamType.BOOLEAN>;
	/** @param start angle */
	startAngle: ParamTemplate<ParamType.FLOAT>;
	/** @param end angle */
	endAngle: ParamTemplate<ParamType.FLOAT>;
}
declare class CSGArcSopNode extends CSGSopNode<CSGArcSopParamsConfig> {
	paramsConfig: CSGArcSopParamsConfig;
	static type(): SopType;
	private _center;
	cook(inputCoreGroups: CoreGroup[]): void;
}
declare enum BooleanCsgOperationType {
	INTERSECT = 'intersect',
	SUBTRACT = 'subtract',
	UNION = 'union',
}
declare class CSGBooleanSopParamsConfig extends NodeParamsConfig {
	/** @param operation */
	operation: ParamTemplate<ParamType.INTEGER>;
}
declare class CSGBooleanSopNode extends CSGSopNode<CSGBooleanSopParamsConfig> {
	paramsConfig: CSGBooleanSopParamsConfig;
	static type(): SopType;
	protected initializeNode(): void;
	setOperation(operation: BooleanCsgOperationType): void;
	cook(inputCoreGroups: CoreGroup[]): void;
	private _applyOperation;
	private _method;
}
declare class CSGBoxSopParamsConfig extends NodeParamsConfig {
	/** @param size */
	size: ParamTemplate<ParamType.FLOAT>; /** @param sizes */
	sizes: ParamTemplate<ParamType.VECTOR3>;
	/** @param center */
	center: ParamTemplate<ParamType.VECTOR3>;
	/** @param bevel */
	rounded: ParamTemplate<ParamType.BOOLEAN>;
	/** @param bevel radius */
	roundedRadius: ParamTemplate<ParamType.FLOAT>;
	/** @param bevel segments */
	roundedSegments: ParamTemplate<ParamType.INTEGER>;
}
declare class CSGBoxSopNode extends CSGSopNode<CSGBoxSopParamsConfig> {
	paramsConfig: CSGBoxSopParamsConfig;
	static type(): SopType;
	private _center;
	private _sizes;
	cook(inputCoreGroups: CoreGroup[]): void;
}
declare class CSGCenterSopParamsConfig extends NodeParamsConfig {
	/** @param x */
	x: ParamTemplate<ParamType.BOOLEAN>;
	/** @param y */
	y: ParamTemplate<ParamType.BOOLEAN>;
	/** @param z */
	z: ParamTemplate<ParamType.BOOLEAN>;
	/** @param relativeTo */
	relativeTo: ParamTemplate<ParamType.VECTOR3>;
}
declare class CSGCenterSopNode extends CSGSopNode<CSGCenterSopParamsConfig> {
	paramsConfig: CSGCenterSopParamsConfig;
	static type(): SopType;
	protected initializeNode(): void;
	private _relativeTo;
	private _axes;
	cook(inputCoreGroups: CoreGroup[]): void;
}
declare class CSGCircleSopParamsConfig extends NodeParamsConfig {
	/** @param radius */
	radius: ParamTemplate<ParamType.FLOAT>;
	/** @param segments */
	segments: ParamTemplate<ParamType.INTEGER>;
	/** @param center */
	center: ParamTemplate<ParamType.VECTOR2>;
	/** @param open */
	open: ParamTemplate<ParamType.BOOLEAN>;
	/** @param start angle */
	startAngle: ParamTemplate<ParamType.FLOAT>;
	/** @param end angle */
	endAngle: ParamTemplate<ParamType.FLOAT>;
}
declare class CSGCircleSopNode extends CSGSopNode<CSGCircleSopParamsConfig> {
	paramsConfig: CSGCircleSopParamsConfig;
	static type(): SopType;
	private _center;
	cook(inputCoreGroups: CoreGroup[]): void;
}
declare class CSGDodecahedronSopParamsConfig extends NodeParamsConfig {
	/** @param radius */
	radius: ParamTemplate<ParamType.FLOAT>;
}
declare class CSGDodecahedronSopNode extends CSGSopNode<CSGDodecahedronSopParamsConfig> {
	paramsConfig: CSGDodecahedronSopParamsConfig;
	static type(): SopType;
	protected initializeNode(): void;
	cook(inputCoreGroups: CoreGroup[]): void;
}
declare class CSGEllipseSopParamsConfig extends NodeParamsConfig {
	/** @param radius */
	radius: ParamTemplate<ParamType.VECTOR2>;
	/** @param segments */
	segments: ParamTemplate<ParamType.INTEGER>;
	/** @param center */
	center: ParamTemplate<ParamType.VECTOR2>;
	/** @param open */
	open: ParamTemplate<ParamType.BOOLEAN>;
	/** @param start angle */
	startAngle: ParamTemplate<ParamType.FLOAT>;
	/** @param end angle */
	endAngle: ParamTemplate<ParamType.FLOAT>;
}
declare class CSGEllipseSopNode extends CSGSopNode<CSGEllipseSopParamsConfig> {
	paramsConfig: CSGEllipseSopParamsConfig;
	static type(): SopType;
	private _center;
	private _radius;
	cook(inputCoreGroups: CoreGroup[]): void;
}
declare class CSGEllipsoidSopParamsConfig extends NodeParamsConfig {
	/** @param center */
	center: ParamTemplate<ParamType.VECTOR3>;
	/** @param radius */
	radius: ParamTemplate<ParamType.VECTOR3>;
	/** @param segments */
	segments: ParamTemplate<ParamType.INTEGER>;
}
declare class CSGEllipsoidSopNode extends CSGSopNode<CSGEllipsoidSopParamsConfig> {
	paramsConfig: CSGEllipsoidSopParamsConfig;
	static type(): SopType;
	private _center;
	private _radius;
	cook(inputCoreGroups: CoreGroup[]): void;
}
declare enum ExpandMode {
	_2D_ONLY = '2D Only',
	_2D_AND_3D_ONLY = '2D & 3D (Slow)',
}
declare class CSGExpandSopParamsConfig extends NodeParamsConfig {
	/** @param mode */
	mode: ParamTemplate<ParamType.INTEGER>;
	/** @param delta */
	delta: ParamTemplate<ParamType.FLOAT>;
	/** @param corners */
	corners: ParamTemplate<ParamType.INTEGER>;
	/** @param segments */
	segments: ParamTemplate<ParamType.INTEGER>;
	/** @param allow 3D expand (can be very slow) */
	allowExpand3D: ParamTemplate<ParamType.BOOLEAN>;
}
declare class CSGExpandSopNode extends CSGSopNode<CSGExpandSopParamsConfig> {
	paramsConfig: CSGExpandSopParamsConfig;
	static type(): SopType;
	protected initializeNode(): void;
	setMode(mode: ExpandMode): void;
	cook(inputCoreGroups: CoreGroup[]): void;
}
declare class CSGExtrudeLinearSopParamsConfig extends NodeParamsConfig {
	/** @param height */
	height: ParamTemplate<ParamType.FLOAT>;
	/** @param twistAngle */
	twistAngle: ParamTemplate<ParamType.FLOAT>;
	/** @param twistSteps */
	twistSteps: ParamTemplate<ParamType.INTEGER>;
}
declare class CSGExtrudeLinearSopNode extends CSGSopNode<CSGExtrudeLinearSopParamsConfig> {
	paramsConfig: CSGExtrudeLinearSopParamsConfig;
	static type(): SopType;
	protected initializeNode(): void;
	cook(inputCoreGroups: CoreGroup[]): void;
}
declare class CSGExtrudeRectangularSopParamsConfig extends NodeParamsConfig {
	/** @param size */
	size: ParamTemplate<ParamType.FLOAT>;
	/** @param height */
	height: ParamTemplate<ParamType.FLOAT>;
}
declare class CSGExtrudeRectangularSopNode extends CSGSopNode<CSGExtrudeRectangularSopParamsConfig> {
	paramsConfig: CSGExtrudeRectangularSopParamsConfig;
	static type(): SopType;
	protected initializeNode(): void;
	cook(inputCoreGroups: CoreGroup[]): void;
}
declare class CSGExtrudeRotateSopParamsConfig extends NodeParamsConfig {
	/** @param angle */
	angle: ParamTemplate<ParamType.FLOAT>;
	/** @param start angle */
	startAngle: ParamTemplate<ParamType.FLOAT>;
	/** @param segments */
	segments: ParamTemplate<ParamType.INTEGER>;
}
declare class CSGExtrudeRotateSopNode extends CSGSopNode<CSGExtrudeRotateSopParamsConfig> {
	paramsConfig: CSGExtrudeRotateSopParamsConfig;
	static type(): SopType;
	protected initializeNode(): void;
	cook(inputCoreGroups: CoreGroup[]): void;
}
declare class CSGHullSopParamsConfig extends NodeParamsConfig {
	/** @param chain */
	chain: ParamTemplate<ParamType.BOOLEAN>;
}
declare class CSGHullSopNode extends CSGSopNode<CSGHullSopParamsConfig> {
	paramsConfig: CSGHullSopParamsConfig;
	static type(): SopType;
	protected initializeNode(): void;
	cook(inputCoreGroups: CoreGroup[]): void;
}
declare class CSGLineSopParamsConfig extends NodeParamsConfig {
	/** @param length */
	length: ParamTemplate<ParamType.FLOAT>;
	/** @param points count */
	pointsCount: ParamTemplate<ParamType.INTEGER>;
	/** @param origin */
	origin: ParamTemplate<ParamType.VECTOR2>;
	/** @param direction */
	direction: ParamTemplate<ParamType.VECTOR2>;
}
declare class CSGLineSopNode extends CSGSopNode<CSGLineSopParamsConfig> {
	paramsConfig: CSGLineSopParamsConfig;
	static type(): SopType;
	cook(inputCoreGroups: CoreGroup[]): void;
}
declare class CSGMirrorSopParamsConfig extends NodeParamsConfig {
	/** @param origin */
	origin: ParamTemplate<ParamType.VECTOR3>;
	/** @param normal */
	normal: ParamTemplate<ParamType.VECTOR3>;
	/** @param invert */
	invert: ParamTemplate<ParamType.BOOLEAN>;
}
declare class CSGMirrorSopNode extends CSGSopNode<CSGMirrorSopParamsConfig> {
	paramsConfig: CSGMirrorSopParamsConfig;
	static type(): SopType;
	protected initializeNode(): void;
	private _origin;
	private _normal;
	cook(inputCoreGroups: CoreGroup[]): void;
}
declare class CSGOffsetSopParamsConfig extends NodeParamsConfig {
	/** @param delta */
	delta: ParamTemplate<ParamType.FLOAT>;
	/** @param corners */
	corners: ParamTemplate<ParamType.INTEGER>;
	/** @param segments */
	segments: ParamTemplate<ParamType.INTEGER>;
}
declare class CSGOffsetSopNode extends CSGSopNode<CSGOffsetSopParamsConfig> {
	paramsConfig: CSGOffsetSopParamsConfig;
	static type(): SopType;
	protected initializeNode(): void;
	cook(inputCoreGroups: CoreGroup[]): void;
}
declare class CSGPolygonSopParamsConfig extends NodeParamsConfig {
	/** @param points */
	points: ParamTemplate<ParamType.STRING>;
	/** @param paths */
	paths: ParamTemplate<ParamType.STRING>;
}
declare class CSGPolygonSopNode extends CSGSopNode<CSGPolygonSopParamsConfig> {
	paramsConfig: CSGPolygonSopParamsConfig;
	static type(): SopType;
	cook(inputCoreGroups: CoreGroup[]): void;
}
declare class CSGPolyhedronSopParamsConfig extends NodeParamsConfig {
	/** @param points */
	points: ParamTemplate<ParamType.STRING>;
	/** @param paths */
	faces: ParamTemplate<ParamType.STRING>;
	/** @param outward */
	outward: ParamTemplate<ParamType.BOOLEAN>;
}
declare class CSGPolyhedronSopNode extends CSGSopNode<CSGPolyhedronSopParamsConfig> {
	paramsConfig: CSGPolyhedronSopParamsConfig;
	static type(): SopType;
	cook(inputCoreGroups: CoreGroup[]): void;
}
declare class CSGProjectSopParamsConfig extends NodeParamsConfig {
	/** @param axis */
	axis: ParamTemplate<ParamType.VECTOR3>;
	/** @param origin */
	origin: ParamTemplate<ParamType.VECTOR3>;
}
declare class CSGProjectSopNode extends CSGSopNode<CSGProjectSopParamsConfig> {
	paramsConfig: CSGProjectSopParamsConfig;
	static type(): SopType;
	protected initializeNode(): void;
	private _axis;
	private _origin;
	cook(inputCoreGroups: CoreGroup[]): void;
}
declare class CSGRectangleSopParamsConfig extends NodeParamsConfig {
	/** @param size */
	size: ParamTemplate<ParamType.FLOAT>;
	/** @param sizes */
	sizes: ParamTemplate<ParamType.VECTOR2>;
	/** @param center */
	center: ParamTemplate<ParamType.VECTOR2>;
	/** @param rounded */
	rounded: ParamTemplate<ParamType.BOOLEAN>;
	/** @param rounded radius */
	roundedRadius: ParamTemplate<ParamType.FLOAT>;
	/** @param rounded segments */
	roundedSegments: ParamTemplate<ParamType.INTEGER>;
}
declare class CSGRectangleSopNode extends CSGSopNode<CSGRectangleSopParamsConfig> {
	paramsConfig: CSGRectangleSopParamsConfig;
	static type(): SopType;
	private _center;
	private _sizes;
	cook(inputCoreGroups: CoreGroup[]): void;
}
declare class CSGTransformResetSopParamsConfig extends NodeParamsConfig {
	/** @param bake matrix onto points */
	extract: ParamTemplate<ParamType.BOOLEAN>;
}
declare class CSGTransformResetSopNode extends CSGSopNode<CSGTransformResetSopParamsConfig> {
	paramsConfig: CSGTransformResetSopParamsConfig;
	static type(): SopType;
	protected initializeNode(): void;
	cook(inputCoreGroups: CoreGroup[]): void;
}
declare class CSGSphereSopParamsConfig extends NodeParamsConfig {
	/** @param radius */
	radius: ParamTemplate<ParamType.FLOAT>;
	/** @param center */
	center: ParamTemplate<ParamType.VECTOR3>;
	/** @param geodesic */
	geodesic: ParamTemplate<ParamType.BOOLEAN>;
	/** @param segments */
	segments: ParamTemplate<ParamType.INTEGER>;
	/** @param frequency */
	frequency: ParamTemplate<ParamType.INTEGER>;
}
declare class CSGSphereSopNode extends CSGSopNode<CSGSphereSopParamsConfig> {
	paramsConfig: CSGSphereSopParamsConfig;
	static type(): SopType;
	private _center;
	private _matrix4;
	cook(inputCoreGroups: CoreGroup[]): void;
	private _createSphere;
	private _createGeodesicSphere;
}
declare class CSGStarSopParamsConfig extends NodeParamsConfig {
	/** @param center */
	center: ParamTemplate<ParamType.VECTOR2>;
	/** @param vertices */
	vertices: ParamTemplate<ParamType.INTEGER>;
	/** @param outer radius */
	innerRadius: ParamTemplate<ParamType.FLOAT>;
	/** @param outer radius */
	outerRadius: ParamTemplate<ParamType.FLOAT>;
	/** @param start angle */
	startAngle: ParamTemplate<ParamType.FLOAT>;
}
declare class CSGStarSopNode extends CSGSopNode<CSGStarSopParamsConfig> {
	paramsConfig: CSGStarSopParamsConfig;
	static type(): SopType;
	private _center;
	cook(inputCoreGroups: CoreGroup[]): void;
}
declare class CSGTorusSopParamsConfig extends NodeParamsConfig {
	/** @param inner radius */
	innerRadius: ParamTemplate<ParamType.FLOAT>;
	/** @param outer radius */
	outerRadius: ParamTemplate<ParamType.FLOAT>;
	/** @param inner segments */
	innerSegments: ParamTemplate<ParamType.INTEGER>;
	/** @param outer segments */
	outerSegments: ParamTemplate<ParamType.INTEGER>;
	/** @param inner rotation */
	innerRotation: ParamTemplate<ParamType.FLOAT>;
	/** @param open */
	open: ParamTemplate<ParamType.BOOLEAN>;
	/** @param start angle */
	startAngle: ParamTemplate<ParamType.FLOAT>; /** @param outer rotation */
	outerRotation: ParamTemplate<ParamType.FLOAT>;
}
declare class CSGTorusSopNode extends CSGSopNode<CSGTorusSopParamsConfig> {
	paramsConfig: CSGTorusSopParamsConfig;
	static type(): SopType;
	cook(inputCoreGroups: CoreGroup[]): void;
}
declare class CSGTransform2DSopParamsConfig extends NodeParamsConfig {
	/** @param translate */
	t: ParamTemplate<ParamType.VECTOR2>;
	/** @param rotation */
	r: ParamTemplate<ParamType.FLOAT>;
	/** @param scale (as a float) */
	s: ParamTemplate<ParamType.FLOAT>;
}
declare class CSGTransform2DSopNode extends CSGSopNode<CSGTransform2DSopParamsConfig> {
	paramsConfig: CSGTransform2DSopParamsConfig;
	static type(): SopType.CSG_TRANSFORM_2D;
	protected initializeNode(): void;
	cook(inputCoreGroups: CoreGroup[]): Promise<void>;
}
declare const CSGTriangulateSopParamsConfig_base: {
	new (...args: any[]): {
		facetAngle: ParamTemplate<ParamType.FLOAT>;
		linesColor: ParamTemplate<ParamType.COLOR>;
		meshesColor: ParamTemplate<ParamType.COLOR>;
		wireframe: ParamTemplate<ParamType.BOOLEAN>;
	};
} & typeof NodeParamsConfig;
declare class CSGTriangulateSopParamsConfig extends CSGTriangulateSopParamsConfig_base {}
declare class CSGTriangulateSopNode extends CSGSopNode<CSGTriangulateSopParamsConfig> {
	readonly paramsConfig: CSGTriangulateSopParamsConfig;
	static type(): SopType;
	protected initializeNode(): void;
	cook(inputCoreGroups: CoreGroup[]): Promise<void>;
}
declare class CSGTriangleSopParamsConfig extends NodeParamsConfig {
	/** @param type */
	type: ParamTemplate<ParamType.INTEGER>;
	/** @param angles */
	angles: ParamTemplate<ParamType.VECTOR2>;
}
declare class CSGTriangleSopNode extends CSGSopNode<CSGTriangleSopParamsConfig> {
	paramsConfig: CSGTriangleSopParamsConfig;
	static type(): SopType;
	private _angles;
	cook(inputCoreGroups: CoreGroup[]): void;
}
declare class CSGTubeSopParamsConfig extends NodeParamsConfig {
	/** @param height */
	height: ParamTemplate<ParamType.FLOAT>;
	/** @param radius */
	radius: ParamTemplate<ParamType.FLOAT>;
	/** @param segments */
	segments: ParamTemplate<ParamType.INTEGER>;
	/** @param center */
	center: ParamTemplate<ParamType.VECTOR3>;
	/** @param rounded */
	rounded: ParamTemplate<ParamType.BOOLEAN>;
	/** @param rounded radius */
	roundedRadius: ParamTemplate<ParamType.FLOAT>;
}
declare class CSGTubeSopNode extends CSGSopNode<CSGTubeSopParamsConfig> {
	paramsConfig: CSGTubeSopParamsConfig;
	static type(): SopType;
	private _center;
	cook(inputCoreGroups: CoreGroup[]): void;
}
declare class CSGTubeEllipticSopParamsConfig extends NodeParamsConfig {
	/** @param height */
	height: ParamTemplate<ParamType.FLOAT>;
	/** @param start radius */
	startRadius: ParamTemplate<ParamType.FLOAT>;
	/** @param start radiuses */
	startRadiuses: ParamTemplate<ParamType.VECTOR2>;
	/** @param end radius */
	endRadius: ParamTemplate<ParamType.FLOAT>;
	/** @param end radius */
	endRadiuses: ParamTemplate<ParamType.VECTOR2>;
	/** @param segments */
	segments: ParamTemplate<ParamType.INTEGER>;
	/** @param center */
	center: ParamTemplate<ParamType.VECTOR3>;
	/** @param open */
	open: ParamTemplate<ParamType.BOOLEAN>;
	/** @param start angle */
	startAngle: ParamTemplate<ParamType.FLOAT>;
	/** @param end angle */
	endAngle: ParamTemplate<ParamType.FLOAT>;
}
declare class CSGTubeEllipticSopNode extends CSGSopNode<CSGTubeEllipticSopParamsConfig> {
	paramsConfig: CSGTubeEllipticSopParamsConfig;
	static type(): SopType;
	private _center;
	private _startRadiuses;
	private _endRadiuses;
	cook(inputCoreGroups: CoreGroup[]): void;
}
declare class CSS2DObjectSopParamsConfig extends NodeParamsConfig {
	/** @param toggles on if attributes are copied from the geometry to the html element */
	copyAttributes: ParamTemplate<ParamType.BOOLEAN>;
	/** @param names of the attributes that are copied from the geometry to the html element */
	attributesToCopy: ParamTemplate<ParamType.STRING>;
	/** @param defines if the vertex id attribute is used to create the html id attribute */
	useIdAttrib: ParamTemplate<ParamType.BOOLEAN>;
	/** @param value of the html element id attribute */
	id: ParamTemplate<ParamType.STRING>;
	/** @param defines if the vertex class attribute is used to create the html class */
	useClassAttrib: ParamTemplate<ParamType.BOOLEAN>;
	/** @param value of the html class */
	className: ParamTemplate<ParamType.STRING>;
	/** @param defines if the vertex html attribute is used to create the html content */
	useHTMLAttrib: ParamTemplate<ParamType.BOOLEAN>;
	/** @param value of the html content */
	html: ParamTemplate<ParamType.STRING>;
}
declare class CSS2DObjectSopNode extends TypedSopNode<CSS2DObjectSopParamsConfig> {
	paramsConfig: CSS2DObjectSopParamsConfig;
	static type(): SopType;
	initializeNode(): void;
	private _operation;
	cook(input_contents: CoreGroup[]): void;
}
declare class CSS3DObjectSopParamsConfig extends NodeParamsConfig {
	/** @param toggles on if attributes are copied from the geometry to the html element */
	copyAttributes: ParamTemplate<ParamType.BOOLEAN>;
	/** @param names of the attributes that are copied from the geometry to the html element */
	attributesToCopy: ParamTemplate<ParamType.STRING>;
	/** @param HTML elements may appear to large at first, so this gives you a quick way to scale them down */
	scale: ParamTemplate<ParamType.FLOAT>;
	/** @param defines if the vertex id attribute is used to create the html id attribute */
	useIdAttrib: ParamTemplate<ParamType.BOOLEAN>;
	/** @param value of the html element id attribute */
	id: ParamTemplate<ParamType.STRING>;
	/** @param defines if the vertex class attribute is used to create the html class */
	useClassAttrib: ParamTemplate<ParamType.BOOLEAN>;
	/** @param value of the html class */
	className: ParamTemplate<ParamType.STRING>;
	/** @param defines if the vertex html attribute is used to create the html content */
	useHTMLAttrib: ParamTemplate<ParamType.BOOLEAN>;
	/** @param value of the html content */
	html: ParamTemplate<ParamType.STRING>;
}
declare class CSS3DObjectSopNode extends TypedSopNode<CSS3DObjectSopParamsConfig> {
	paramsConfig: CSS3DObjectSopParamsConfig;
	static type(): SopType;
	initializeNode(): void;
	private _operation;
	cook(input_contents: CoreGroup[]): void;
}
declare class DataSopParamsConfig extends NodeParamsConfig {
	/** @param json object used to create the geometry */
	data: ParamTemplate<ParamType.STRING>;
}
declare class DataSopNode extends TypedSopNode<DataSopParamsConfig> {
	paramsConfig: DataSopParamsConfig;
	static type(): SopType;
	cook(): void;
}
declare class DataUrlSopParamsConfig extends NodeParamsConfig {
	/** @param sets if the data is interpreted as json or csv */
	dataType: ParamTemplate<ParamType.INTEGER>;
	/** @param the url to fetch the data from */
	url: ParamTemplate<ParamType.STRING>;
	/** @param if the data is inside the payload, defines the prefix to read it from here */
	jsonDataKeysPrefix: ParamTemplate<ParamType.STRING>;
	/** @param which entries are skipped */
	skipEntries: ParamTemplate<ParamType.STRING>;
	/** @param sets if some attributes should be converted */
	convert: ParamTemplate<ParamType.BOOLEAN>;
	/** @param sets which attributes should be converted from string to numeric */
	convertToNumeric: ParamTemplate<ParamType.STRING>;
	/** @param when fetching from a csv, the attribute names will not be present. Those can then be mentioned here */
	readAttribNamesFromFile: ParamTemplate<ParamType.BOOLEAN>;
	/** @param list of attributes names when fetching from a csv */
	attribNames: ParamTemplate<ParamType.STRING>;
	/** @param reload the url */
	reload: ParamTemplate<ParamType.BUTTON>;
}
declare class DataUrlSopNode extends TypedSopNode<DataUrlSopParamsConfig> {
	paramsConfig: DataUrlSopParamsConfig;
	static type(): SopType;
	cook(): Promise<void>;
	private _load;
	dispose(): void;
	private _url;
	private _loadJSON;
	private _onLoad;
	private _onError;
	private _loadCSV;
	static PARAM_CALLBACK_reload(node: DataUrlSopNode, param: BaseParamType): void;
	param_callback_reload(): void;
}
declare class DecalSopParamsConfig extends NodeParamsConfig {
	/** @param decal position */
	t: ParamTemplate<ParamType.VECTOR3>;
	/** @param decal rotation */
	r: ParamTemplate<ParamType.VECTOR3>;
	/** @param decal scale */
	s: ParamTemplate<ParamType.VECTOR3>;
	/** @param decal scale multipler */
	scale: ParamTemplate<ParamType.FLOAT>;
}
declare class DecalSopNode extends TypedSopNode<DecalSopParamsConfig> {
	paramsConfig: DecalSopParamsConfig;
	static type(): string;
	static displayedInputNames(): string[];
	initializeNode(): void;
	private _operation;
	cook(input_contents: CoreGroup[]): void;
}
declare class SopSubnetOutputSopParamsConfig extends NodeParamsConfig {}
declare class SubnetOutputSopNode extends TypedSopNode<SopSubnetOutputSopParamsConfig> {
	paramsConfig: SopSubnetOutputSopParamsConfig;
	static type(): Readonly<NetworkChildNodeType.OUTPUT>;
	initializeNode(): void;
	cook(inputCoreGroups: CoreGroup[]): void;
}
declare class SubnetSopNodeLike<T extends NodeParamsConfig> extends TypedSopNode<T> {
	initializeBaseNode(): void;
	readonly childrenDisplayController: SopSubnetChildrenDisplayController;
	readonly displayNodeController: DisplayNodeController;
	protected _childrenControllerContext: NodeContext;
	createNode<S extends keyof GeoNodeChildrenMap>(node_class: S, options?: NodeCreateOptions): GeoNodeChildrenMap[S];
	createNode<K extends valueof<GeoNodeChildrenMap>>(node_class: Constructor<K>, options?: NodeCreateOptions): K;
	children(): BaseSopNodeType[];
	nodesByType<K extends keyof GeoNodeChildrenMap>(type: K): GeoNodeChildrenMap[K][];
	cook(inputCoreGroups: CoreGroup[]): Promise<void>;
}
export interface SopSubnetChildrenDisplayControllerOptions {
	dependsOnDisplayNode: boolean;
}
declare class SopSubnetChildrenDisplayController {
	private node;
	private options;
	private _outputNodeNeedsUpdate;
	private _outputNode;
	private _graphNode;
	constructor(node: SubnetSopNodeLike<any>, options?: SopSubnetChildrenDisplayControllerOptions);
	dispose(): void;
	displayNodeControllerCallbacks(): DisplayNodeControllerCallbacks;
	outputNode(): SubnetOutputSopNode | undefined;
	initializeNode(): void;
	private _updateOutputNode;
	private _createGraphNode;
}
declare class DecomposeSopParamsConfig extends NodeParamsConfig {
	/** @param decompose the input object */
	decompose: ParamTemplate<ParamType.BUTTON>;
}
declare class DecomposeSopNode extends SubnetSopNodeLike<DecomposeSopParamsConfig> {
	paramsConfig: DecomposeSopParamsConfig;
	static type(): NetworkNodeType;
	initializeNode(): void;
	static PARAM_CALLBACK_decompose(node: DecomposeSopNode): void;
	private _paramCallbackDecompose;
}
declare class DelaySopParamsConfig extends NodeParamsConfig {
	/** @param duration in milliseconds */
	duration: ParamTemplate<ParamType.INTEGER>;
}
declare class DelaySopNode extends TypedSopNode<DelaySopParamsConfig> {
	paramsConfig: DelaySopParamsConfig;
	static type(): string;
	initializeNode(): void;
	cook(inputs_contents: CoreGroup[]): void;
}
declare class EntitySelectionHelper {
	protected node: DeleteSopNode;
	readonly selected_state: Map<CoreEntity, boolean>;
	private _entities_count;
	private _selected_entities_count;
	constructor(node: DeleteSopNode);
	init(entities: CoreEntity[]): void;
	select(entity: CoreEntity): void;
	entities_to_keep(): CoreEntity[];
	entities_to_delete(): CoreEntity[];
	private _entities_for_state;
}
declare class ByAttributeHelper {
	private node;
	constructor(node: DeleteSopNode);
	evalForEntities(entities: CoreEntity[]): void;
	private _evalForString;
	private _evalForNumeric;
	private _evalForPointsNumericFloat;
	private _evalForPointsNumericVector2;
	private _evalForPointsNumericVector3;
	private _evalForPointsNumericVector4;
}
declare class ByExpressionHelper {
	private node;
	constructor(node: DeleteSopNode);
	evalForEntities(entities: CoreEntity[]): Promise<void>;
	private _evalEntityDependentExpression;
	private _evalExpressionsWithoutEntityDependentExpression;
}
declare class ByBboxHelper {
	private node;
	private _point_position;
	constructor(node: DeleteSopNode);
	evalForPoints(points: CorePoint[]): void;
	private _createBbox;
}
declare class ByObjectTypeHelper {
	private node;
	constructor(node: DeleteSopNode);
	eval_for_objects(core_objects: BaseCoreObject<CoreObjectType>[]): void;
}
declare class ByBoundingObjectHelper {
	private node;
	private _matDoubleSideTmpSetter;
	private _point_position;
	private _raycaster;
	private _intersections;
	constructor(node: DeleteSopNode);
	evalForPoints(points: CorePoint[], core_group2?: CoreGroup): void;
	private _isPositionInObject;
}
declare class DeleteSopParamsConfig extends NodeParamsConfig {
	/** @param defines the class that should be deleted (objects or vertices) */
	class: ParamTemplate<ParamType.INTEGER>;
	/** @param invert the selection created in the parameters below */
	invert: ParamTemplate<ParamType.BOOLEAN>;
	/** @param deletes objects by object type */
	byObjectType: ParamTemplate<ParamType.BOOLEAN>;
	/** @param sets which object types should be deleted */
	objectType: ParamTemplate<ParamType.INTEGER>;
	/** @param deletes objects by an expression */
	byExpression: ParamTemplate<ParamType.BOOLEAN>;
	/** @param sets the expression to select what should be deleted */
	expression: ParamTemplate<ParamType.BOOLEAN>;
	/** @param deletes objects by an attribute */
	byAttrib: ParamTemplate<ParamType.BOOLEAN>;
	/** @param sets the type of the attribute for which items should be deleted */
	attribType: ParamTemplate<ParamType.INTEGER>;
	/** @param name of the attribute used */
	attribName: ParamTemplate<ParamType.STRING>;
	/** @param size of the attribute used */
	attribSize: ParamTemplate<ParamType.INTEGER>;
	/** @param comparison operator */
	attribComparisonOperator: ParamTemplate<ParamType.INTEGER>;
	/** @param value of the attribute to compare with (when using float attribute) */
	attribValue1: ParamTemplate<ParamType.FLOAT>;
	/** @param value of the attribute to compare with (when using vector2 attribute) */
	attribValue2: ParamTemplate<ParamType.VECTOR2>;
	/** @param value of the attribute to compare with (when using vector3 attribute) */
	attribValue3: ParamTemplate<ParamType.VECTOR3>;
	/** @param value of the attribute to compare with (when using vector4 attribute) */
	attribValue4: ParamTemplate<ParamType.VECTOR4>;
	/** @param value of the attribute to compare with (when using string attribute) */
	attribString: ParamTemplate<ParamType.STRING>;
	/** @param deletes objects that are inside a bounding box */
	byBbox: ParamTemplate<ParamType.BOOLEAN>;
	/** @param the bounding box size */
	bboxSize: ParamTemplate<ParamType.VECTOR3>;
	/** @param the bounding box center */
	bboxCenter: ParamTemplate<ParamType.VECTOR3>;
	/** @param deletes objects that are inside an object. This uses the object from the 2nd input */
	byBoundingObject: ParamTemplate<ParamType.BOOLEAN>;
	/** @param keeps points */
	keepPoints: ParamTemplate<ParamType.BOOLEAN>;
}
declare class DeleteSopNode extends TypedSopNode<DeleteSopParamsConfig> {
	paramsConfig: DeleteSopParamsConfig;
	static type(): string;
	private _marked_for_deletion_per_object_index;
	readonly entitySelectionHelper: EntitySelectionHelper;
	readonly byExpressionHelper: ByExpressionHelper;
	readonly byAttributeHelper: ByAttributeHelper;
	readonly byObjectTypeHelper: ByObjectTypeHelper;
	readonly byBboxHelper: ByBboxHelper;
	readonly byBoundingObjectHelper: ByBoundingObjectHelper;
	static displayedInputNames(): string[];
	initializeNode(): void;
	cook(inputCoreGroups: CoreGroup[]): Promise<void>;
	setAttribClass(attribClass: AttribClass): void;
	attribClass(): AttribClass;
	setAttribType(attribType: AttribType): void;
	attribType(): AttribType;
	private _evalForObjects;
	private _evalForPoints;
	private _pointObject;
}
declare const DirectionalLightSopParamsConfig_base: {
	new (...args: any[]): {
		light: ParamTemplate<ParamType.FOLDER>;
		color: ParamTemplate<ParamType.COLOR>;
		intensity: ParamTemplate<ParamType.FLOAT>;
		distance: ParamTemplate<ParamType.FLOAT>;
		showHelper: ParamTemplate<ParamType.BOOLEAN>;
		name: ParamTemplate<ParamType.STRING>;
		shadow: ParamTemplate<ParamType.FOLDER>;
		castShadow: ParamTemplate<ParamType.BOOLEAN>;
		shadowAutoUpdate: ParamTemplate<ParamType.BOOLEAN>;
		shadowUpdateOnNextRender: ParamTemplate<ParamType.BOOLEAN>;
		shadowRes: ParamTemplate<ParamType.VECTOR2>;
		shadowSize: ParamTemplate<ParamType.VECTOR2>;
		shadowBias: ParamTemplate<ParamType.FLOAT>;
		shadowRadius: ParamTemplate<ParamType.FLOAT>;
		raymarching: ParamTemplate<ParamType.FOLDER>;
		raymarchingPenumbra: ParamTemplate<ParamType.FLOAT>;
	};
} & typeof NodeParamsConfig;
declare class DirectionalLightSopParamsConfig extends DirectionalLightSopParamsConfig_base {}
declare class DirectionalLightSopNode extends TypedSopNode<DirectionalLightSopParamsConfig> {
	paramsConfig: DirectionalLightSopParamsConfig;
	static type(): LightType;
	initializeNode(): void;
	private _operation;
	cook(input_contents: CoreGroup[]): void;
}
declare class DrawRangeSopParamsConfig extends NodeParamsConfig {
	/** @param start of the draw range */
	start: ParamTemplate<ParamType.INTEGER>;
	/** @param defines if count is used */
	useCount: ParamTemplate<ParamType.BOOLEAN>;
	/** @param number of items in the draw range */
	count: ParamTemplate<ParamType.INTEGER>;
}
declare class DrawRangeSopNode extends TypedSopNode<DrawRangeSopParamsConfig> {
	paramsConfig: DrawRangeSopParamsConfig;
	static type(): string;
	initializeNode(): void;
	cook(input_contents: CoreGroup[]): void;
}
declare class EmptyObjectSopParamsConfig extends NodeParamsConfig {
	type: ParamTemplate<ParamType.STRING>;
}
declare class EmptyObjectSopNode extends TypedSopNode<EmptyObjectSopParamsConfig> {
	readonly paramsConfig: EmptyObjectSopParamsConfig;
	static type(): string;
	protected initializeNode(): void;
	private _operation;
	cook(input_contents: CoreGroup[]): void;
	setObjectType(objectType: ObjectType): void;
	objectType(): ObjectType | undefined;
}
declare class ExporterGLTFSopParamsConfig extends BaseExporterSopParamsConfig {}
declare class ExporterGLTFSopNode extends ExporterSopNode<ExporterGLTFSopParamsConfig> {
	paramsConfig: ExporterGLTFSopParamsConfig;
	static type(): SopExporter;
	fileExtension(): string;
	createBlob(): Promise<Blob>;
}
declare class ExporterOBJSopParamsConfig extends BaseExporterSopParamsConfig {}
declare class ExporterOBJSopNode extends ExporterSopNode<ExporterOBJSopParamsConfig> {
	paramsConfig: ExporterOBJSopParamsConfig;
	static type(): SopExporter;
	fileExtension(): string;
	createBlob(): Promise<Blob>;
}
declare class ExporterPLYSopParamsConfig extends BaseExporterSopParamsConfig {}
declare class ExporterPLYSopNode extends ExporterSopNode<ExporterPLYSopParamsConfig> {
	paramsConfig: ExporterPLYSopParamsConfig;
	static type(): SopExporter;
	fileExtension(): string;
	createBlob(): Promise<Blob>;
}
declare class ExporterSTLSopParamsConfig extends BaseExporterSopParamsConfig {}
declare class ExporterSTLSopNode extends ExporterSopNode<ExporterSTLSopParamsConfig> {
	paramsConfig: ExporterSTLSopParamsConfig;
	static type(): SopExporter;
	fileExtension(): string;
	createBlob(): Promise<Blob>;
}
declare class FaceSopParamsConfig extends NodeParamsConfig {
	/** @param makes faces unique */
	makeFacesUnique: ParamTemplate<ParamType.BOOLEAN>;
	/** @param adds a vector3 attribute that represents the center of a face */
	addFaceCenterAttribute: ParamTemplate<ParamType.BOOLEAN>;
	/** @param add an id attribute for each face */
	addFaceId: ParamTemplate<ParamType.BOOLEAN>;
	/** @param allows to transform each face */
	transform: ParamTemplate<ParamType.BOOLEAN>;
	/** @param scales the faces indepedently */
	scale: ParamTemplate<ParamType.FLOAT>;
}
declare class FaceSopNode extends TypedSopNode<FaceSopParamsConfig> {
	paramsConfig: FaceSopParamsConfig;
	static type(): string;
	initializeNode(): void;
	cook(input_contents: CoreGroup[]): void;
	private _makeFacesUnique;
	private _addFaceCenterAttribute;
	private _addFaceId;
	private _transform_faces;
}
declare class FacetSopParamsConfig extends NodeParamsConfig {
	/** @param angle threshold to separate vertices */
	angle: ParamTemplate<ParamType.FLOAT>;
}
declare class FacetSopNode extends TypedSopNode<FacetSopParamsConfig> {
	paramsConfig: FacetSopParamsConfig;
	static type(): string;
	static displayedInputNames(): string[];
	initializeNode(): void;
	cook(inputCoreGroups: CoreGroup[]): void;
}
declare class BaseFileParamsConfigResult extends NodeParamsConfig {
	url: ParamTemplate<ParamType.STRING>;
	matrixAutoUpdate: ParamTemplate<ParamType.BOOLEAN>;
	reload: ParamTemplate<ParamType.BUTTON>;
}
declare class BaseFileSopNodeFactoryResult extends TypedSopNode<BaseFileParamsConfigResult> {}
declare const FileDRCSopNode_base: typeof BaseFileSopNodeFactoryResult;
declare class FileDRCSopNode extends FileDRCSopNode_base {}
declare const FileFBXSopNode_base: typeof BaseFileSopNodeFactoryResult;
declare class FileFBXSopNode extends FileFBXSopNode_base {}
declare const FileGEOJSONSopNode_base: typeof BaseFileSopNodeFactoryResult;
declare class FileGEOJSONSopNode extends FileGEOJSONSopNode_base {}
declare class FileGLTFParamsConfig extends NodeParamsConfig {
	/** @param url to load the geometry from */
	url: ParamTemplate<ParamType.STRING>;
	/** @param uses draco compression */
	draco: ParamTemplate<ParamType.BOOLEAN>;
	/** @param uses ktx2 compression */
	ktx2: ParamTemplate<ParamType.BOOLEAN>;
	/** @param sets the matrixAutoUpdate attribute for the objects loaded */
	matrixAutoUpdate: ParamTemplate<ParamType.BOOLEAN>;
	/** @param reload the geometry */
	reload: ParamTemplate<ParamType.BUTTON>;
}
declare class FileGLTFSopNode extends TypedSopNode<FileGLTFParamsConfig> {
	paramsConfig: FileGLTFParamsConfig;
	static type(): SopTypeFile;
	dispose(): void;
	private _operation;
	private operation;
	cook(inputCoreGroups: CoreGroup[]): Promise<void>;
	static PARAM_CALLBACK_reload(node: FileGLTFSopNode): void;
	private _paramCallbackReload;
}
declare const FileJSONSopNode_base: typeof BaseFileSopNodeFactoryResult;
declare class FileJSONSopNode extends FileJSONSopNode_base {}
declare const FileMPDSopNode_base: typeof BaseFileSopNodeFactoryResult;
declare class FileMPDSopNode extends FileMPDSopNode_base {}
declare class BaseFileMultiParamsConfig extends NodeParamsConfig {
	/** @param url to load the geometry from */
	url: ParamTemplate<ParamType.STRING>;
	/** @param sets the matrixAutoUpdate attribute for the objects loaded */
	matrixAutoUpdate: ParamTemplate<ParamType.BOOLEAN>;
	/** @param reload the geometry */
	reload: ParamTemplate<ParamType.BUTTON>;
}
declare abstract class BaseFileMultiSopNode<
	O extends BaseGeoLoaderOutput,
	K extends BaseFileMultiParamsConfig
> extends TypedSopNode<K> {
	protected abstract _createLoader(url: string): BaseObject3DLoaderHandler<O>;
	dispose(): void;
	initializeNode(): void;
	private _instancer;
	private _instanceMatrix;
	cook(inputCoreGroups: CoreGroup[]): Promise<void>;
	private static _incrementUrlUsageCount;
	private _loadFromUrlPromises;
	private _loadObject;
	protected _loadWithLoader(loader: BaseObject3DLoaderHandler<O>): Promise<Object3D<Event>[] | undefined>;
	static PARAM_CALLBACK_reload(node: BaseFileMultiSopNode<BaseGeoLoaderOutput, BaseFileMultiParamsConfig>): void;
	private _paramCallbackReload;
}
export interface GLTFLoaderLoadOptions extends BaseLoaderLoadOptions {
	draco: boolean;
	ktx2: boolean;
}
declare class GLTFLoaderHandler extends BaseObject3DLoaderHandler<GLTF> {
	private _gltfLoader;
	private _gltfdracoLoader;
	private _ktx2gltfLoader;
	private _ktx2gltfdracoLoader;
	private _dracoLoader;
	private _ktx2Loader;
	reset(): void;
	load(options: GLTFLoaderLoadOptions): Promise<Object3D[] | undefined>;
	protected _getLoader(options: GLTFLoaderLoadOptions): Promise<BaseGeoLoader<GLTF>>;
	private _createGLTFLoader;
	private _setupDRACO;
	protected _setupKTX2(gltfLoader: GLTFLoader, options: BaseLoaderLoadOptions): Promise<void>;
	private _createDRACOLoader;
	protected _onLoadSuccess(gltf: GLTF): Object3D[];
}
declare class FileMultiGLTFParamsConfig extends NodeParamsConfig {
	/** @param url to load the geometry from */
	url: ParamTemplate<ParamType.STRING>;
	/** @param uses draco compression */
	draco: ParamTemplate<ParamType.BOOLEAN>;
	/** @param uses ktx2 compression */
	ktx2: ParamTemplate<ParamType.BOOLEAN>;
	/** @param sets the matrixAutoUpdate attribute for the objects loaded */
	matrixAutoUpdate: ParamTemplate<ParamType.BOOLEAN>;
	/** @param reload the geometry */
	reload: ParamTemplate<ParamType.BUTTON>;
}
declare class FileMultiGLTFSopNode extends BaseFileMultiSopNode<GLTF, FileMultiGLTFParamsConfig> {
	paramsConfig: FileMultiGLTFParamsConfig;
	static type(): SopTypeFileMulti;
	protected _createLoader(url: string): GLTFLoaderHandler;
	protected _loadWithLoader(loader: GLTFLoaderHandler): Promise<Object3D<Event>[] | undefined>;
}
declare class OBJLoaderHandler extends BaseObject3DLoaderHandler<Object3D> {
	protected _getLoader(): Promise<BaseGeoLoader<Object3D>>;
}
declare class FileMultiOBJParamsConfig extends NodeParamsConfig {
	/** @param url to load the geometry from */
	url: ParamTemplate<ParamType.STRING>;
	/** @param sets the matrixAutoUpdate attribute for the objects loaded */
	matrixAutoUpdate: ParamTemplate<ParamType.BOOLEAN>;
	/** @param reload the geometry */
	reload: ParamTemplate<ParamType.BUTTON>;
}
declare class FileMultiOBJSopNode extends BaseFileMultiSopNode<Object3D, FileMultiOBJParamsConfig> {
	paramsConfig: FileMultiOBJParamsConfig;
	static type(): SopTypeFileMulti;
	protected _createLoader(url: string): OBJLoaderHandler;
}
declare const FileOBJSopNode_base: typeof BaseFileSopNodeFactoryResult;
declare class FileOBJSopNode extends FileOBJSopNode_base {}
declare const FilePDBSopNode_base: typeof BaseFileSopNodeFactoryResult;
declare class FilePDBSopNode extends FilePDBSopNode_base {}
declare const FilePLYSopNode_base: typeof BaseFileSopNodeFactoryResult;
declare class FilePLYSopNode extends FilePLYSopNode_base {}
declare const FileSTLSopNode_base: typeof BaseFileSopNodeFactoryResult;
declare class FileSTLSopNode extends FileSTLSopNode_base {}
declare class FileSVGSopParamsConfig extends NodeParamsConfig {
	/** @param url to load the geometry from */
	url: ParamTemplate<ParamType.STRING>;
	/** @param reload the geometry */
	reload: ParamTemplate<ParamType.BUTTON>;
	/** @param toggle on to draw the fillShapes */
	drawFillShapes: ParamTemplate<ParamType.BOOLEAN>;
	/** @param toggle on to draw the fillShapes as wireframe */
	fillShapesWireframe: ParamTemplate<ParamType.BOOLEAN>;
	/** @param toggle on to draw the strokes */
	drawStrokes: ParamTemplate<ParamType.BOOLEAN>;
	/** @param toggle on to draw the strokes as wireframe */
	strokesWireframe: ParamTemplate<ParamType.BOOLEAN>;
	/** @param style override */
	tStyleOverride: ParamTemplate<ParamType.BOOLEAN>;
	/** @param stroke width */
	strokeWidth: ParamTemplate<ParamType.FLOAT>;
	/** @param advanced */
	tadvanced: ParamTemplate<ParamType.BOOLEAN>;
	/** @param is counter clock wise: defines the vertex order when parsing the font */
	isCCW: ParamTemplate<ParamType.BOOLEAN>;
}
declare class FileSVGSopNode extends TypedSopNode<FileSVGSopParamsConfig> {
	paramsConfig: FileSVGSopParamsConfig;
	static type(): SopTypeFile;
	dispose(): void;
	private _operation;
	cook(inputCoreGroups: CoreGroup[]): Promise<void>;
	static PARAM_CALLBACK_reload(node: FileSVGSopNode): void;
	private param_callback_reload;
}
declare const FileUSDZSopNode_base: typeof BaseFileSopNodeFactoryResult;
declare class FileUSDZSopNode extends FileUSDZSopNode_base {}
declare class FuseSopParamsConfig extends NodeParamsConfig {
	/** @param distance threshold */
	dist: ParamTemplate<ParamType.FLOAT>;
	/** @param recompute normals */
	computeNormals: ParamTemplate<ParamType.BOOLEAN>;
}
declare class FuseSopNode extends TypedSopNode<FuseSopParamsConfig> {
	paramsConfig: FuseSopParamsConfig;
	static type(): string;
	static displayedInputNames(): string[];
	initializeNode(): void;
	cook(inputCoreGroups: CoreGroup[]): void;
	private _filterObject;
	private _filterMesh;
	private _filterLineSegments;
	private _filterPoints;
	private _fuseGeometry;
}
declare class HexagonsSopParamsConfig extends NodeParamsConfig {
	/** @param plane size */
	size: ParamTemplate<ParamType.VECTOR2>;
	/** @param hexagons size */
	hexagonRadius: ParamTemplate<ParamType.FLOAT>;
	/** @param axis perpendicular to the plane */
	direction: ParamTemplate<ParamType.VECTOR3>;
	/** @param do not create polygons, only points */
	pointsOnly: ParamTemplate<ParamType.BOOLEAN>;
}
declare class HexagonsSopNode extends TypedSopNode<HexagonsSopParamsConfig> {
	paramsConfig: HexagonsSopParamsConfig;
	static type(): string;
	initializeNode(): void;
	private _operation;
	cook(input_contents: CoreGroup[]): void;
}
declare enum HierarchyMode {
	ADD_PARENT = 'add parent',
	REMOVE_PARENT = 'remove parent',
	ADD_CHILD = 'add child',
}
declare enum AddChildMode {
	ONE_CHILD_PER_PARENT = 'one child per parent',
	ALL_CHILDREN_UNDER_FIRST_PARENT = 'all children under first parent',
	ALL_CHILDREN_UNDER_ALL_PARENTS = 'all children under all parents',
}
declare class HierarchySopParamsConfig extends NodeParamsConfig {
	/** @param defines if parent objects will be added or removed */
	mode: ParamTemplate<ParamType.INTEGER>;
	/** @param defines how many parent objects will be added or removed */
	levels: ParamTemplate<ParamType.INTEGER>;
	/** @param when the mode is set to add_child, the mask defines which parent the children are added to. If the mask is an empty string, the children will be added to the objects at the top of the hierarchy. Also, the children are taken from the second input. */
	objectMask: ParamTemplate<ParamType.STRING>;
	/** @param defines how the children are added to the parents */
	addChildMode: ParamTemplate<ParamType.INTEGER>;
}
declare class HierarchySopNode extends TypedSopNode<HierarchySopParamsConfig> {
	paramsConfig: HierarchySopParamsConfig;
	static type(): string;
	static displayedInputNames(): string[];
	initializeNode(): void;
	private _operation;
	cook(inputCoreGroups: CoreGroup[]): void;
	setMode(mode: HierarchyMode): void;
	setAddChildMode(mode: AddChildMode): void;
}
declare class HeightMapSopParamsConfig extends NodeParamsConfig {
	/** @param texture node to load the heightmap from */
	texture: ParamTemplate<ParamType.NODE_PATH>;
	/** @param values multiplier */
	mult: ParamTemplate<ParamType.FLOAT>;
}
declare class HeightMapSopNode extends TypedSopNode<HeightMapSopParamsConfig> {
	paramsConfig: HeightMapSopParamsConfig;
	static type(): string;
	initializeNode(): void;
	cook(inputCoreGroups: CoreGroup[]): Promise<void>;
	private _set_position_from_data_texture;
	private _data_from_texture;
	private _data_from_default_texture;
	private _data_from_data_texture;
}
declare const HemisphereLightSopParamsConfig_base: {
	new (...args: any[]): {
		skyColor: ParamTemplate<ParamType.COLOR>;
		groundColor: ParamTemplate<ParamType.COLOR>;
		intensity: ParamTemplate<ParamType.FLOAT>;
		position: ParamTemplate<ParamType.VECTOR3>;
		name: ParamTemplate<ParamType.STRING>;
	};
} & typeof NodeParamsConfig;
declare class HemisphereLightSopParamsConfig extends HemisphereLightSopParamsConfig_base {}
declare class HemisphereLightSopNode extends TypedSopNode<HemisphereLightSopParamsConfig> {
	paramsConfig: HemisphereLightSopParamsConfig;
	static type(): string;
	initializeNode(): void;
	private _operation;
	cook(inputCoreGroups: CoreGroup[]): void;
}
declare class IcosahedronSopParamsConfig extends NodeParamsConfig {
	/** @param radius of the icosahedron */
	radius: ParamTemplate<ParamType.FLOAT>;
	/** @param resolution of the icosahedron */
	detail: ParamTemplate<ParamType.INTEGER>;
	/** @param do not create polygons, only points. */
	pointsOnly: ParamTemplate<ParamType.BOOLEAN>;
	/** @param center of the icosahedron */
	center: ParamTemplate<ParamType.VECTOR3>;
}
declare class IcosahedronSopNode extends TypedSopNode<IcosahedronSopParamsConfig> {
	paramsConfig: IcosahedronSopParamsConfig;
	static type(): SopType;
	private _operation;
	cook(): void;
}
declare class InstanceSopParamsConfig extends NodeParamsConfig {
	/** @param attributes to copy to the instance */
	attributesToCopy: ParamTemplate<ParamType.STRING>;
	/** @param toggles on to apply a material. This is useful in most cases, but there may be situations where the material would be apply later, such as when you are feeding this node to a particles system */
	applyMaterial: ParamTemplate<ParamType.BOOLEAN>;
	/** @param material to apply */
	material: ParamTemplate<ParamType.NODE_PATH>;
}
declare class InstanceSopNode extends TypedSopNode<InstanceSopParamsConfig> {
	paramsConfig: InstanceSopParamsConfig;
	static type(): SopType;
	static displayedInputNames(): string[];
	initializeNode(): void;
	private _operation;
	cook(input_contents: CoreGroup[]): Promise<void>;
}
declare enum InstanceUpdateMode {
	GEO = 'geo',
	POINTS = 'points',
}
declare class InstanceUpdateSopParamsConfig extends NodeParamsConfig {
	/** @param defines what this node updates, either the instanced geometry or the instance points. */
	mode: ParamTemplate<ParamType.INTEGER>;
	/** @param which attributes will be updated on the instanced geometry */
	geoAttributes: ParamTemplate<ParamType.STRING>;
	/** @param which attributes will be updated ont the instance points */
	pointAttributes: ParamTemplate<ParamType.STRING>;
}
declare class InstanceUpdateSopNode extends TypedSopNode<InstanceUpdateSopParamsConfig> {
	paramsConfig: InstanceUpdateSopParamsConfig;
	static type(): string;
	static displayedInputNames(): string[];
	initializeNode(): void;
	setMode(mode: InstanceUpdateMode): void;
	private _operation;
	cook(input_contents: CoreGroup[]): void;
}
declare class InstancesCountSopParamsConfig extends NodeParamsConfig {
	/** @param sets if max is used */
	useMax: ParamTemplate<ParamType.BOOLEAN>;
	/** @param max number of instances to display */
	max: ParamTemplate<ParamType.INTEGER>;
}
declare class InstancesCountSopNode extends TypedSopNode<InstancesCountSopParamsConfig> {
	paramsConfig: InstancesCountSopParamsConfig;
	static type(): string;
	initializeNode(): void;
	cook(input_contents: CoreGroup[]): void;
}
declare class JitterSopParamsConfig extends NodeParamsConfig {
	/** @param amount of jitter */
	amount: ParamTemplate<ParamType.FLOAT>;
	/** @param mult of each axis */
	mult: ParamTemplate<ParamType.VECTOR3>;
	/** @param seed used to set the direction each point is moved to */
	seed: ParamTemplate<ParamType.INTEGER>;
}
declare class JitterSopNode extends TypedSopNode<JitterSopParamsConfig> {
	paramsConfig: JitterSopParamsConfig;
	static type(): string;
	static displayedInputNames(): string[];
	initializeNode(): void;
	private _operation;
	cook(input_contents: CoreGroup[]): void;
}
declare class LayerSopParamsConfig extends NodeParamsConfig {
	/** @param the layer that the objects will be assigned to */
	layer: ParamTemplate<ParamType.INTEGER>;
}
declare class LayerSopNode extends TypedSopNode<LayerSopParamsConfig> {
	paramsConfig: LayerSopParamsConfig;
	static type(): string;
	static displayedInputNames(): string[];
	initializeNode(): void;
	cook(input_contents: CoreGroup[]): void;
}
declare class LightMixerParamsConfig extends NodeParamsConfig {
	/** @param size of the box */
	setup: ParamTemplate<ParamType.BUTTON>;
}
declare class LightMixerSopNode extends TypedSopNode<LightMixerParamsConfig> {
	readonly paramsConfig: LightMixerParamsConfig;
	static type(): string;
	protected initializeNode(): void;
	private _lightsByName;
	cook(inputCoreGroups: CoreGroup[]): void;
	private _findLights;
	static PARAM_CALLBACK_setup(node: LightMixerSopNode): void;
	private _paramCallbackSetup;
}
declare const LightProbeSopParamsConfig_base: {
	new (...args: any[]): {
		cubeMap: ParamTemplate<ParamType.NODE_PATH>;
		intensity: ParamTemplate<ParamType.FLOAT>;
		name: ParamTemplate<ParamType.STRING>;
	};
} & typeof NodeParamsConfig;
declare class LightProbeSopParamsConfig extends LightProbeSopParamsConfig_base {}
declare class LightProbeSopNode extends TypedSopNode<LightProbeSopParamsConfig> {
	paramsConfig: LightProbeSopParamsConfig;
	static type(): string;
	initializeNode(): void;
	private _operation;
	cook(inputCoreGroups: CoreGroup[]): Promise<void>;
}
declare class LineSopParamsConfig extends NodeParamsConfig {
	/** @param length of the line */
	length: ParamTemplate<ParamType.FLOAT>;
	/** @param number of points */
	pointsCount: ParamTemplate<ParamType.INTEGER>;
	/** @param start position of the line */
	origin: ParamTemplate<ParamType.VECTOR3>;
	/** @param direction of the line */
	direction: ParamTemplate<ParamType.VECTOR3>;
}
declare class LineSopNode extends TypedSopNode<LineSopParamsConfig> {
	paramsConfig: LineSopParamsConfig;
	static type(): string;
	initializeNode(): void;
	private _lastPt;
	private _current;
	cook(): void;
}
declare class LODSopParamsConfig extends NodeParamsConfig {
	/** @param distance when switching between high res and mid res (first input and second input) */
	distance0: ParamTemplate<ParamType.FLOAT>;
	/** @param distance when switching between mid res and low res (second input and third input) */
	distance1: ParamTemplate<ParamType.FLOAT>;
	/** @param Threshold used to avoid flickering at LOD boundaries, as a fraction of distance */
	hysteresis: ParamTemplate<ParamType.FLOAT>;
	/** @param sets if the switch is done automatically */
	autoUpdate: ParamTemplate<ParamType.BOOLEAN>;
	/** @param updates which object is displayed manually */
	update: ParamTemplate<ParamType.BUTTON>;
	/** @param sets which camera will be used when the switch is to be done manually */
	camera: ParamTemplate<ParamType.NODE_PATH>;
}
declare class LodSopNode extends TypedSopNode<LODSopParamsConfig> {
	paramsConfig: LODSopParamsConfig;
	static type(): string;
	static displayedInputNames(): string[];
	private _lod;
	initializeNode(): void;
	private _createLOD;
	cook(inputCoreGroups: CoreGroup[]): void;
	_addLevel(coreGroup: CoreGroup | undefined, level: number): void;
	private _clearLOD;
	static PARAM_CALLBACK_update(node: LodSopNode): void;
	private _updateLOD;
}
declare class LookAtSopParamConfig extends NodeParamsConfig {
	/** @param target */
	target: ParamTemplate<ParamType.VECTOR3>;
	/** @param up vector */
	up: ParamTemplate<ParamType.VECTOR3>;
	/** @param lerp */
	lerp: ParamTemplate<ParamType.FLOAT>;
	/** @param invertDirection */
	invertDirection: ParamTemplate<ParamType.BOOLEAN>;
}
declare class LookAtSopNode extends TypedSopNode<LookAtSopParamConfig> {
	paramsConfig: LookAtSopParamConfig;
	static type(): string;
	static displayedInputNames(): string[];
	initializeNode(): void;
	private _operation;
	cook(inputCoreGroups: CoreGroup[]): void;
}
declare class MapboxCameraSopParamsConfig extends NodeParamsConfig {
	style: ParamTemplate<ParamType.STRING>;
	/** @param longitude */
	longitude: ParamTemplate<ParamType.FLOAT>;
	/** @param latitude */
	latitude: ParamTemplate<ParamType.FLOAT>;
	pitch: ParamTemplate<ParamType.FLOAT>;
	bearing: ParamTemplate<ParamType.FLOAT>;
	zoom: ParamTemplate<ParamType.FLOAT>;
	minZoom: ParamTemplate<ParamType.FLOAT>;
	maxZoom: ParamTemplate<ParamType.FLOAT>;
	allowDragRotate: ParamTemplate<ParamType.BOOLEAN>;
	addZoomControl: ParamTemplate<ParamType.BOOLEAN>;
	tlayerBuildings: ParamTemplate<ParamType.BOOLEAN>;
	tlayer3D: ParamTemplate<ParamType.BOOLEAN>;
	tlayerSky: ParamTemplate<ParamType.BOOLEAN>;
	/** @param camera name */
	name: ParamTemplate<ParamType.STRING>;
	updateFromMap: ParamTemplate<ParamType.BUTTON>;
}
declare class MapboxCameraSopNode extends TypedSopNode<MapboxCameraSopParamsConfig> {
	readonly paramsConfig: MapboxCameraSopParamsConfig;
	static type(): CameraNodeType;
	static onRegister: OnNodeRegisterCallback;
	protected initializeNode(): void;
	private _operation;
	cook(inputCoreGroups: CoreGroup[]): Promise<void>;
	static PARAM_CALLBACK_updateFromMap(node: MapboxCameraSopNode): void;
	private _paramCallbackUpdateFromMap;
}
declare class MapboxLayerSopParamsConfig extends NodeParamsConfig {
	/** @param names of layers to create */
	updateLayers: ParamTemplate<ParamType.BUTTON>;
}
declare class MapboxLayerSopNode extends TypedSopNode<MapboxLayerSopParamsConfig> {
	paramsConfig: MapboxLayerSopParamsConfig;
	static type(): string;
	cook(): Promise<void>;
	private _featuresByName;
	private _groupFeaturesByName;
	private _feature_name;
	private _id_from_feature;
	static PARAM_CALLBACK_reload(node: MapboxLayerSopNode): void;
	private _paramCallbackReload;
}
declare class MapboxPlaneSopParamsConfig extends NodeParamsConfig {
	/** @param camera lng lat */
	/** @param type of plane (grid or hexagons) */
	type: ParamTemplate<ParamType.INTEGER>;
	/** @param plane resolution */
	resolution: ParamTemplate<ParamType.INTEGER>;
	/** @param multiplies the size of the plane. This can be useful to scale down the plane. While it would cover a smaller part of the view, it would be faster to create  */
	sizeMult: ParamTemplate<ParamType.FLOAT>;
	/** @param toggle on to make sure the plane will cover the full view */
	fullView: ParamTemplate<ParamType.BOOLEAN>;
	/** @param do not create polygons, only points */
	asPoints: ParamTemplate<ParamType.BOOLEAN>;
}
declare class MapboxPlaneSopNode extends TypedSopNode<MapboxPlaneSopParamsConfig> {
	paramsConfig: MapboxPlaneSopParamsConfig;
	static type(): string;
	private _hexagonsController;
	private transformer;
	cook(): Promise<void>;
	_buildPlane(map: mapboxgl.Map): BufferGeometry | undefined;
	private _mirrorLngLat;
	private _asHexagons;
}
declare class MapboxTransformSopParamsConfig extends NodeParamsConfig {
	/** @param sets if this node should transform objects or geometries */
	applyOn: ParamTemplate<ParamType.INTEGER>;
	/** @param camera longitude */
	longitude: ParamTemplate<ParamType.FLOAT>;
	/** @param camera latitude */
	latitude: ParamTemplate<ParamType.FLOAT>;
}
declare class MapboxTransformSopNode extends TypedSopNode<MapboxTransformSopParamsConfig> {
	paramsConfig: MapboxTransformSopParamsConfig;
	static type(): SopType;
	static displayedInputNames(): string[];
	initializeNode(): void;
	private _transformer;
	cook(inputContents: CoreGroup[]): void;
	private _applyTransform;
	private _updateGeometries;
	private _updateObjects;
}
declare class MaterialSopParamsConfig extends NodeParamsConfig {
	/** @param group to assign the material to */
	group: ParamTemplate<ParamType.STRING>;
	/** @param toggle on to also assign the material to children */
	applyToChildren: ParamTemplate<ParamType.BOOLEAN>;
	/** @param toggle on to assign the new material */
	assignMat: ParamTemplate<ParamType.BOOLEAN>;
	/** @param the material node */
	material: ParamTemplate<ParamType.NODE_PATH>;
	/** @param Cloning the material would prevent the material node to have any effect on the processed geometries. But it would allow to have multiple materials, if this was used with a Copy SOP for instance */
	cloneMat: ParamTemplate<ParamType.BOOLEAN>;
	/** @param while cloning the material, you may only want to change basic properties (such as depthWrite or transparent), but you would want to still use the same custom uniforms created by GL/param nodes */
	shareCustomUniforms: ParamTemplate<ParamType.BOOLEAN>;
	/** @param swap one texture with another */
	swapCurrentTex: ParamTemplate<ParamType.BOOLEAN>;
	/** @param texture to swap */
	texSrc0: ParamTemplate<ParamType.STRING>;
	/** @param texture to swap */
	texDest0: ParamTemplate<ParamType.STRING>;
}
declare class MaterialSopNode extends TypedSopNode<MaterialSopParamsConfig> {
	paramsConfig: MaterialSopParamsConfig;
	static type(): SopType;
	static displayedInputNames(): string[];
	protected initializeNode(): void;
	private _operation;
	cook(inputCoreGroups: CoreGroup[]): Promise<void>;
}
declare class MaterialPropertiesSopParamsConfig extends NodeParamsConfig {
	/** @param group to assign the material to */
	group: ParamTemplate<ParamType.STRING>;
	/** @param sets if this node should search through the materials inside the whole hierarchy */
	applyToChildren: ParamTemplate<ParamType.BOOLEAN>;
	/** @param toggle on to allow updating the side properties of the materials */
	tside: ParamTemplate<ParamType.BOOLEAN>;
	/** @param defines if the material is double sided or not */
	doubleSided: ParamTemplate<ParamType.BOOLEAN>;
	/** @param if the material is not double sided, it can be front sided, or back sided */
	front: ParamTemplate<ParamType.BOOLEAN>;
	/** @param override the default shadowSide behavior */
	overrideShadowSide: ParamTemplate<ParamType.BOOLEAN>;
	/** @param defines which side(s) are used when rendering shadows */
	shadowDoubleSided: ParamTemplate<ParamType.BOOLEAN>;
	/** @param if the material is not double sided, it can be front sided, or back sided, when computing shadows */
	shadowFront: ParamTemplate<ParamType.BOOLEAN>;
	/** @param toggle on to allow updating the wireframe properties of the materials */
	twireframe: ParamTemplate<ParamType.BOOLEAN>;
	/** @param defines if the material is double sided or not */
	wireframe: ParamTemplate<ParamType.BOOLEAN>;
}
declare class MaterialPropertiesSopNode extends TypedSopNode<MaterialPropertiesSopParamsConfig> {
	paramsConfig: MaterialPropertiesSopParamsConfig;
	static type(): string;
	static displayedInputNames(): string[];
	initializeNode(): void;
	private _operation;
	cook(inputCoreGroups: CoreGroup[]): void;
}
declare class MergeSopParamsConfig extends NodeParamsConfig {
	/** @param When off, input objects remain separate. When on, they are merged together by type (mesh, points and lines). In order to merge them correctly, you'll have to make sure they have the same attributes */
	compact: ParamTemplate<ParamType.BOOLEAN>;
	/** @param When off, objects with same type (mesh, points, lines) will be merged together, regardless of their material. When on, only objects with same type and same material will be merged */
	preserveMaterials: ParamTemplate<ParamType.BOOLEAN>;
	/** @param number of inputs that this node can merge geometries from */
	inputsCount: ParamTemplate<ParamType.INTEGER>;
}
declare class MergeSopNode extends TypedSopNode<MergeSopParamsConfig> {
	paramsConfig: MergeSopParamsConfig;
	static type(): string;
	static displayedInputNames(): string[];
	setCompactMode(compact: boolean): void;
	initializeNode(): void;
	private _operation;
	cook(inputCoreGroups: CoreGroup[]): void;
	private _callbackUpdateInputsCount;
	static PARAM_CALLBACK_setInputsCount(node: MergeSopNode): void;
}
declare class MetaballSopParamsConfig extends NodeParamsConfig {
	/** @param resolution */
	resolution: ParamTemplate<ParamType.FLOAT>;
	/** @param isolation */
	isolation: ParamTemplate<ParamType.FLOAT>;
	/** @param useMetaStrengthAttrib */
	useMetaStrengthAttrib: ParamTemplate<ParamType.BOOLEAN>;
	/** @param metaStrength */
	metaStrength: ParamTemplate<ParamType.FLOAT>;
	/** @param useMetaSubtractAttrib */
	useMetaSubtractAttrib: ParamTemplate<ParamType.BOOLEAN>;
	/** @param metaStrength */
	metaSubtract: ParamTemplate<ParamType.FLOAT>;
	/** @param enableUVs */
	enableUVs: ParamTemplate<ParamType.BOOLEAN>;
	/** @param enableColors */
	enableColors: ParamTemplate<ParamType.BOOLEAN>;
}
declare class MetaballSopNode extends TypedSopNode<MetaballSopParamsConfig> {
	paramsConfig: MetaballSopParamsConfig;
	static type(): string;
	static displayedInputNames(): string[];
	initializeNode(): void;
	private _operation;
	cook(input_contents: CoreGroup[]): void;
}
declare enum NoiseOperation {
	ADD = 'add',
	SET = 'set',
	MULT = 'mult',
	SUBTRACT = 'subtract',
	DIVIDE = 'divide',
}
declare class NoiseSopParamsConfig extends NodeParamsConfig {
	/** @param noise amplitude */
	amplitude: ParamTemplate<ParamType.FLOAT>;
	/** @param toggle on to multiply the amplitude by a vertex attribute */
	tamplitudeAttrib: ParamTemplate<ParamType.BOOLEAN>;
	/** @param which vertex attribute to use */
	amplitudeAttrib: ParamTemplate<ParamType.STRING>;
	/** @param noise frequency */
	freq: ParamTemplate<ParamType.VECTOR3>;
	/** @param noise offset */
	offset: ParamTemplate<ParamType.VECTOR3>;
	/** @param noise octaves */
	octaves: ParamTemplate<ParamType.INTEGER>;
	/** @param amplitude attenuation for higher octaves */
	ampAttenuation: ParamTemplate<ParamType.FLOAT>;
	/** @param frequency increase for higher octaves */
	freqIncrease: ParamTemplate<ParamType.FLOAT>;
	/** @param noise seed */
	seed: ParamTemplate<ParamType.INTEGER>;
	/** @param toggle on to have the noise be multiplied by the normal */
	useNormals: ParamTemplate<ParamType.BOOLEAN>;
	/** @param set which attribute will be affected by the noise */
	attribName: ParamTemplate<ParamType.STRING>;
	/** @param toggle on to use rest attributes. This can be useful when the noise is animated and this node does not clone the input geometry. Without using rest attributes, the noise would be based on an already modified position, and would therefore accumulate on itself after each cook. This may be what you are after, but for a more conventional result, using a rest attribute will ensure that the noise remains stable. Note that the rest attribute can be created by a RestAttributes node */
	useRestAttributes: ParamTemplate<ParamType.BOOLEAN>;
	/** @param name of rest position */
	restP: ParamTemplate<ParamType.STRING>;
	/** @param name of rest normal */
	restN: ParamTemplate<ParamType.STRING>;
	/** @param operation done when applying the noise (add, set, mult, subtract, divide) */
	operation: ParamTemplate<ParamType.INTEGER>;
	/** @param toggle on to recompute normals if the position has been updated */
	computeNormals: ParamTemplate<ParamType.BOOLEAN>;
}
declare class NoiseSopNode extends TypedSopNode<NoiseSopParamsConfig> {
	paramsConfig: NoiseSopParamsConfig;
	static type(): SopType;
	private _simplexBySeed;
	private _restPos;
	private _restValue2;
	private _restValue4;
	private _noiseValueV;
	private _currentAttribValueF;
	private _currentAttribValueV2;
	private _currentAttribValueV3;
	private _currentAttribValueV4;
	static displayedInputNames(): string[];
	initializeNode(): void;
	setOperation(operation: NoiseOperation): void;
	cook(input_contents: CoreGroup[]): void;
	private _cookForFloat;
	private _cookForV2;
	private _cookForV3;
	private _cookForV4;
	private _noiseValue;
	private static _newAttribValueFromFloat;
	private static _newAttribValueFromVector2;
	private static _newAttribValueFromVector3;
	private static _newAttribValueFromVector4;
	private _amplitudeFromAttrib;
	private _fbm;
	private _getSimplex;
	private _createSimplex;
}
declare class NormalsSopParamsConfig extends NodeParamsConfig {
	/** @param toggle on if normals can be updated via expressions */
	edit: ParamTemplate<ParamType.BOOLEAN>;
	/** @param toggle on to update the x component */
	updateX: ParamTemplate<ParamType.BOOLEAN>;
	/** @param expression or value for the x component */
	x: ParamTemplate<ParamType.FLOAT>;
	/** @param toggle on to update the y component */
	updateY: ParamTemplate<ParamType.BOOLEAN>;
	/** @param expression or value for the y component */
	y: ParamTemplate<ParamType.FLOAT>;
	/** @param toggle on to update the z component */
	updateZ: ParamTemplate<ParamType.BOOLEAN>;
	/** @param expression or value for the z component */
	z: ParamTemplate<ParamType.FLOAT>;
	/** @param recompute the normals based on the position */
	recompute: ParamTemplate<ParamType.BOOLEAN>;
	/** @param invert normals */
	invert: ParamTemplate<ParamType.BOOLEAN>;
}
declare class NormalsSopNode extends TypedSopNode<NormalsSopParamsConfig> {
	paramsConfig: NormalsSopParamsConfig;
	static type(): string;
	static displayedInputNames(): string[];
	initializeNode(): void;
	cook(inputCoreGroups: CoreGroup[]): Promise<void>;
	private _eval_expressions_for_core_group;
	private _eval_expressions_for_core_object;
	private _invert_normals;
}
declare class NormalsHelperSopParamsConfig extends NodeParamsConfig {
	/** @param keep input */
	keepInput: ParamTemplate<ParamType.BOOLEAN>;
	/** @param size of the box */
	size: ParamTemplate<ParamType.FLOAT>;
}
declare class NormalsHelperSopNode extends TypedSopNode<NormalsHelperSopParamsConfig> {
	paramsConfig: NormalsHelperSopParamsConfig;
	static type(): string;
	static displayedInputNames(): string[];
	initializeNode(): void;
	cook(inputCoreGroups: CoreGroup[]): void;
}
declare class NullSopParamsConfig extends NodeParamsConfig {}
declare class NullSopNode extends TypedSopNode<NullSopParamsConfig> {
	paramsConfig: NullSopParamsConfig;
	static type(): string;
	initializeNode(): void;
	private _operation;
	cook(input_contents: CoreGroup[]): void;
}
declare class ObjectMergeSopParamsConfig extends NodeParamsConfig {
	/** @param which SOP node to import from */
	geometry: ParamTemplate<ParamType.NODE_PATH>;
}
declare class ObjectMergeSopNode extends TypedSopNode<ObjectMergeSopParamsConfig> {
	paramsConfig: ObjectMergeSopParamsConfig;
	static type(): string;
	cook(input_containers: CoreGroup[]): Promise<void>;
	importInput(geometry_node: BaseSopNodeType, container: GeometryContainer): void;
}
declare class ObjectPropertiesSopParamsConfig extends NodeParamsConfig {
	/** @param toggle on to apply recursively to children */
	applyToChildren: ParamTemplate<ParamType.BOOLEAN>;
	/** @param toggle on to set a new name */
	tname: ParamTemplate<ParamType.BOOLEAN>;
	/** @param new name */
	name: ParamTemplate<ParamType.STRING>;
	/** @param toggle on to set a new render order */
	trenderOrder: ParamTemplate<ParamType.BOOLEAN>;
	/** @param render order */
	renderOrder: ParamTemplate<ParamType.INTEGER>;
	/** @param toggle on to allow to set frustrumCulled */
	tfrustumCulled: ParamTemplate<ParamType.BOOLEAN>;
	/** @param sets frustrumCulled */
	frustumCulled: ParamTemplate<ParamType.BOOLEAN>;
	/** @param toggle on to allow to set matrixAutoUpdate */
	tmatrixAutoUpdate: ParamTemplate<ParamType.BOOLEAN>;
	/** @param sets matrixAutoUpdate */
	matrixAutoUpdate: ParamTemplate<ParamType.BOOLEAN>;
	/** @param toggle on to allow to set visible */
	tvisible: ParamTemplate<ParamType.BOOLEAN>;
	/** @param sets visible */
	visible: ParamTemplate<ParamType.BOOLEAN>;
	/** @param toggle on to allow to set castShadow */
	tcastShadow: ParamTemplate<ParamType.BOOLEAN>;
	/** @param sets castShadow */
	castShadow: ParamTemplate<ParamType.BOOLEAN>;
	/** @param toggle on to allow to set receiveShadow */
	treceiveShadow: ParamTemplate<ParamType.BOOLEAN>;
	/** @param sets receiveShadow */
	receiveShadow: ParamTemplate<ParamType.BOOLEAN>;
}
declare class ObjectPropertiesSopNode extends TypedSopNode<ObjectPropertiesSopParamsConfig> {
	paramsConfig: ObjectPropertiesSopParamsConfig;
	static type(): string;
	static displayedInputNames(): string[];
	initializeNode(): void;
	private _operation;
	cook(inputCoreGroups: CoreGroup[]): Promise<void>;
	private _cookWithExpressions;
	private _cookWithExpressionsForCoreGroup;
}
declare class ObjectsLayoutSopParamConfig extends NodeParamsConfig {
	/** @param layout width */
	maxLayoutWidth: ParamTemplate<ParamType.FLOAT>;
	/** @param row height */
	rowHeight: ParamTemplate<ParamType.FLOAT>;
	/** @param padding between objects */
	padding: ParamTemplate<ParamType.VECTOR2>;
	/** @param addAttribs */
	addAttribs: ParamTemplate<ParamType.BOOLEAN>;
	/** @param add row index attribute */
	addRowAttrib: ParamTemplate<ParamType.BOOLEAN>;
	/** @param add rowWidthInner attribute */
	addRowWidthInner: ParamTemplate<ParamType.BOOLEAN>;
	/** @param add rowWidthOuter attribute */
	addRowWidthOuter: ParamTemplate<ParamType.BOOLEAN>;
}
declare class ObjectsLayoutSopNode extends TypedSopNode<ObjectsLayoutSopParamConfig> {
	paramsConfig: ObjectsLayoutSopParamConfig;
	static type(): string;
	static displayedInputNames(): string[];
	initializeNode(): void;
	private _operation;
	cook(inputCoreGroups: CoreGroup[]): void;
}
declare class OceanPlaneSopParamsConfig extends NodeParamsConfig {
	main: ParamTemplate<ParamType.FOLDER>;
	/** @param reflection direction */
	direction: ParamTemplate<ParamType.VECTOR3>;
	/** @param sun direction */
	sunDirection: ParamTemplate<ParamType.VECTOR3>;
	/** @param sun color */
	sunColor: ParamTemplate<ParamType.COLOR>;
	/** @param water color */
	waterColor: ParamTemplate<ParamType.COLOR>;
	/** @param reflection color */
	reflectionColor: ParamTemplate<ParamType.COLOR>;
	/** @param reflection fresnel */
	reflectionFresnel: ParamTemplate<ParamType.FLOAT>;
	/** @param waves Height */
	wavesHeight: ParamTemplate<ParamType.FLOAT>;
	/** @param distortion scale */
	distortionScale: ParamTemplate<ParamType.FLOAT>;
	/** @param distortion speed */
	timeScale: ParamTemplate<ParamType.FLOAT>;
	/** @param size */
	size: ParamTemplate<ParamType.FLOAT>;
	advanced: ParamTemplate<ParamType.FOLDER>;
	/** @param render reflection */
	renderReflection: ParamTemplate<ParamType.BOOLEAN>;
	/** @param normal Bias - adjusts this if the reflections are too grainy */
	normalBias: ParamTemplate<ParamType.FLOAT>;
	/** @param multisamples */
	multisamples: ParamTemplate<ParamType.INTEGER>;
	/** @param reacts to fog */
	useFog: ParamTemplate<ParamType.BOOLEAN>;
}
declare class OceanPlaneSopNode extends TypedSopNode<OceanPlaneSopParamsConfig> {
	paramsConfig: OceanPlaneSopParamsConfig;
	static type(): string;
	initializeNode(): void;
	private _operation;
	cook(input_contents: CoreGroup[]): void;
}
export declare type OperationInputsMap = WeakMap<SopOperationContainer, Map<number, number>>;
declare class SopOperationContainer extends BaseOperationContainer<NodeContext.SOP> {
	protected operation: BaseSopOperation;
	protected name: string;
	protected init_params: ParamsInitData;
	constructor(operation: BaseSopOperation, name: string, init_params: ParamsInitData);
	operationType(): string;
	protected _inputs: SopOperationContainer[];
	private _currentInputIndex;
	addInput(input: SopOperationContainer): void;
	incrementInputIndex(): void;
	currentInputIndex(): number;
	private _computeResult;
	private _dirty;
	setDirty(): void;
	compute(input_contents: CoreGroup[], operation_inputs_map: OperationInputsMap): Promise<CoreGroup | undefined>;
}
declare class OperationsComposerSopParamConfig extends NodeParamsConfig {}
export interface OperationContainerInputConfig {
	operation_input_index: number;
	node_input_index: number;
}
declare class OperationsComposerSopNode extends TypedSopNode<OperationsComposerSopParamConfig> {
	paramsConfig: OperationsComposerSopParamConfig;
	static type(): string;
	initializeNode(): void;
	private _outputOperationContainer;
	private _inputConfigsByOperationContainer;
	setOutputOperationContainer(operationContainer: SopOperationContainer): void;
	outputOperationContainer(): SopOperationContainer | undefined;
	addInputConfig(operation: SopOperationContainer, inputConfig: OperationContainerInputConfig): void;
	private _operationContainersRequiringResolve;
	addOperationContainerWithPathParamResolveRequired(
		operationContainer: BaseOperationContainer<NodeContext.SOP>
	): void;
	resolveOperationContainersPathParams(): void;
	cook(inputCoreGroups: CoreGroup[]): Promise<void>;
}
declare class OrthographicCameraSopParamsConfig extends NodeParamsConfig {
	/** @param camera view size */
	size: ParamTemplate<ParamType.FLOAT>;
	/** @param camera near */
	near: ParamTemplate<ParamType.FLOAT>;
	/** @param camera far */
	far: ParamTemplate<ParamType.FLOAT>;
	/** @param camera position */
	position: ParamTemplate<ParamType.VECTOR3>;
	/** @param camera rotation */
	rotation: ParamTemplate<ParamType.VECTOR3>;
	/** @param show helper */
	showHelper: ParamTemplate<ParamType.BOOLEAN>;
	/** @param matrixAutoUpdate */
	matrixAutoUpdate: ParamTemplate<ParamType.BOOLEAN>;
	/** @param camera name */
	name: ParamTemplate<ParamType.STRING>;
	/** @param set main camera */
	updateTransformFromCamera: ParamTemplate<ParamType.BUTTON>;
}
declare class OrthographicCameraSopNode extends TypedSopNode<OrthographicCameraSopParamsConfig> {
	readonly paramsConfig: OrthographicCameraSopParamsConfig;
	static type(): CameraNodeType;
	static onRegister: OnNodeRegisterCallback;
	protected initializeNode(): void;
	private _operation;
	cook(inputCoreGroups: CoreGroup[]): void;
}
declare class PaletteSopParamsConfig extends NodeParamsConfig {
	/** @param the attribute class (geometry or object) */
	class: ParamTemplate<ParamType.INTEGER>;
	/** @param name of the palette */
	paletteName: ParamTemplate<ParamType.STRING>;
	/** @param click to set the node to the next palette */
	pickNext: ParamTemplate<ParamType.BUTTON>;
	/** @param click to set the node to the previous palette */
	pickPrevious: ParamTemplate<ParamType.BUTTON>;
	/** @param click to set the node to a random palette */
	pickRandom: ParamTemplate<ParamType.BUTTON>;
	colorsCount: ParamTemplate<ParamType.INTEGER>;
	/** @param palette color 1 */
	color1: ParamTemplate<ParamType.COLOR>;
	/** @param palette color 2 */
	color2: ParamTemplate<ParamType.COLOR>;
	/** @param palette color 3 */
	color3: ParamTemplate<ParamType.COLOR>;
	/** @param palette color 4 */
	color4: ParamTemplate<ParamType.COLOR>;
	/** @param palette color 5 */
	color5: ParamTemplate<ParamType.COLOR>;
}
declare class PaletteSopNode extends TypedSopNode<PaletteSopParamsConfig> {
	paramsConfig: PaletteSopParamsConfig;
	static type(): string;
	readonly paletteController: PaletteController<NodeContext.SOP>;
	initializeNode(): void;
	private _operation;
	cook(input_contents: CoreGroup[]): void;
	setAttribClass(attribClass: AttribClass): void;
	attribClass(): AttribClass;
}
export interface GPUComputationRendererVariable {
	name: string;
	renderTargets: WebGLRenderTarget[];
	material: ShaderMaterial;
}
declare class GPUComputationRenderer {
	constructor(x: number, y: number, renderer: AbstractRenderer);
	compute(): void;
	init(): string | null;
	dispose(): void;
	setDataType(type: TextureDataType): void;
	addVariable(name: string, fragment_shader: string, variable: DataTexture): GPUComputationRendererVariable;
	setVariableDependencies(variable: GPUComputationRendererVariable, vars: GPUComputationRendererVariable[]): void;
	renderTexture(texture: DataTexture, render_target: WebGLRenderTarget): void;
	createTexture(): DataTexture;
	getCurrentRenderTarget(variable: GPUComputationRendererVariable): WebGLRenderTarget;
}
export interface TextureVariableData {
	name: string;
	size: number;
	nodes: string[];
}
declare class TextureVariable {
	private _name;
	private _size;
	private _allocation;
	private _position;
	private _readonly;
	private _graphNodeIds;
	constructor(_name: string, _size: number);
	merge(variable: TextureVariable): void;
	setReadonly(state: boolean): void;
	readonly(): boolean;
	setAllocation(allocation: TextureAllocation): void;
	allocation(): TextureAllocation | undefined;
	graphNodeIds(): Set<number> | undefined;
	addGraphNodeId(id: CoreGraphNodeId): void;
	name(): string;
	size(): number;
	setPosition(position: number): void;
	position(): number;
	component(): string;
	static fromJSON(data: TextureVariableData): TextureVariable;
	toJSON(scene: PolyScene): TextureVariableData;
}
export declare type TextureAllocationData = TextureVariableData[];
declare class TextureAllocation {
	private _variables;
	private _size;
	constructor();
	addVariable(variable: TextureVariable): void;
	hasSpaceForVariable(variable: TextureVariable): boolean;
	shaderName(): ShaderName;
	textureName(): string;
	variables(): TextureVariable[] | undefined;
	variablesForInputNode(root_node: BaseGlNodeType): TextureVariable[] | undefined;
	inputNamesForNode(root_node: BaseGlNodeType): string[] | undefined;
	variable(variable_name: string): TextureVariable | undefined;
	static fromJSON(data: TextureAllocationData): TextureAllocation;
	toJSON(scene: PolyScene): TextureAllocationData;
}
export declare type TextureAllocationsControllerData = {
	writable: PolyDictionary<TextureAllocationData>[];
	readonly: PolyDictionary<TextureAllocationData>[];
};
declare class TextureAllocationsController {
	private _writableAllocations;
	private _readonlyAllocations;
	constructor();
	dispose(): void;
	private static _sortNodes;
	allocateConnectionsFromRootNodes(root_nodes: BaseGlNodeType[], leaf_nodes: BaseGlNodeType[]): void;
	private _allocateVariables;
	private _ensureVariablesAreUnique;
	private _allocateVariable;
	private _addWritableAllocation;
	private _addReadonlyAllocation;
	readonlyAllocations(): TextureAllocation[];
	shaderNames(): ShaderName[];
	createShaderConfigs(): ShaderConfig[];
	allocationForShaderName(shader_name: ShaderName): TextureAllocation | undefined;
	inputNamesForShaderName(root_node: BaseGlNodeType, shader_name: ShaderName): string[] | undefined;
	variable(variable_name: string): TextureVariable | undefined;
	variables(): TextureVariable[];
	hasVariable(name: string): boolean;
	static fromJSON(data: TextureAllocationsControllerData): TextureAllocationsController;
	toJSON(scene: PolyScene): TextureAllocationsControllerData;
	print(scene: PolyScene): void;
}
declare class CoreParticlesGpuComputeController {
	private mainController;
	protected _gpuCompute: GPUComputationRenderer | undefined;
	private _variablesByName;
	private _allVariables;
	private _createdTexturesByName;
	protected _lastSimulatedFrame: number | undefined;
	private _texturesSize;
	private _persistedTextureAllocationsController;
	constructor(mainController: CoreParticlesController);
	dispose(): void;
	setPersistedTextureAllocationController(controller: TextureAllocationsController): void;
	allVariables(): GPUComputationRendererVariable[];
	init(): void;
	private _initPoints;
	private _initParticlesUVs;
	createGPUCompute(): void;
	computeSimulation(delta: number): void;
	getCurrentRenderTarget(shader_name: ShaderName): WebGLRenderTarget | undefined;
	private _textureNameForShaderName;
	materials(): ShaderMaterial[];
	private _createSimulationMaterialUniforms;
	private _assignReadonlyTextures;
	private _updateSimulationMaterialUniforms;
	createdTexturesByName(): Readonly<Map<ShaderName, DataTexture>>;
	private _fillTextures;
	reset(): void;
	private resetGpuCompute;
	private _createTextureRenderTargets;
	private _textureAllocationsController;
	private _readonlyAllocations;
}
declare class CoreParticlesRenderController {
	private mainController;
	private _renderMaterial;
	private _uniformByShaderName;
	private _texture_allocations_json;
	private _materialGlobalsHandler;
	private _matNodeAssembler;
	constructor(mainController: CoreParticlesController);
	dispose(): void;
	reset(): void;
	assignRenderMaterial(): void;
	updateRenderMaterialUniforms(): void;
	material(): Material | undefined;
	init(): Promise<void>;
}
declare class CoreParticlesController {
	readonly scene: PolyScene;
	private _node;
	readonly gpuController: CoreParticlesGpuComputeController;
	readonly renderController: CoreParticlesRenderController;
	private _shadersByName;
	private _shaderNames;
	private _uniformNames;
	protected _object: Object3D | undefined;
	protected _renderer: AbstractRenderer | undefined;
	constructor(scene: PolyScene, _node: ParticlesSystemGpuSopNode);
	object(): Object3D<Event> | undefined;
	renderer(): AbstractRenderer | undefined;
	dispose(): void;
	init(object: Object3D, renderer: AbstractRenderer): Promise<void>;
	stepSimulation(delta: number): void;
	reset(): void;
	setError(message: string): void;
	node(): ParticlesSystemGpuSopNode;
	setShadersByName(shadersByName: Map<ShaderName, string>): void;
	shadersByName(): Map<ShaderName, string>;
	shaderNames(): ShaderName[];
	uniformNames(): string[];
	setPersistedTextureAllocationController(controller: TextureAllocationsController): void;
	private _debugCook;
	debugMessage(message: string): void;
}
export interface PersistedConfigBaseParticlesData extends PersistedConfigWithShaders {
	texture_allocations: TextureAllocationsControllerData;
	param_uniform_pairs: [string, string][];
	uniforms_owner: object;
}
declare class ParticlesPersistedConfig extends BasePersistedConfig {
	protected node: ParticlesSystemGpuSopNode;
	private _loaded_data;
	constructor(node: ParticlesSystemGpuSopNode);
	toData(): Promise<PersistedConfigBaseParticlesData | undefined>;
	load(data: PersistedConfigBaseParticlesData): void;
	loaded_data(): PersistedConfigBaseParticlesData | undefined;
	shaders_by_name(): Map<ShaderName, string> | undefined;
	texture_allocations_controller(): TextureAllocationsController | undefined;
	uniforms():
		| {
				[uniform: string]: IUniform<any>;
		  }
		| undefined;
}
declare class ShaderAssemblerParticles extends BaseGlShaderAssembler {
	private _textureAllocationsController;
	templateShader(): undefined;
	protected _template_shader_for_shader_name(shader_name: ShaderName): string;
	compile(): void;
	rootNodesByShaderName(shader_name: ShaderName, rootNodes: BaseGlNodeType[]): BaseGlNodeType[];
	setup_shader_names_and_variables(): void;
	private _updateShaders;
	add_output_inputs(output_child: OutputGlNode): void;
	add_globals_outputs(globals_node: GlobalsGlNode): void;
	allow_attribute_exports(): boolean;
	textureAllocationsController(): TextureAllocationsController;
	create_shader_configs(): ShaderConfig[];
	create_variable_configs(): never[];
	shaderNames(): ShaderName[];
	inputNamesForShaderName(root_node: BaseGlNodeType, shader_name: ShaderName): string[];
	protected insertDefineAfter(shader_name: ShaderName): string;
	protected insertBodyAfter(shader_name: ShaderName): string;
	protected linesToRemove(shader_name: ShaderName): string[];
	add_export_body_line(
		export_node: BaseGlNodeType,
		input_name: string,
		input: BaseGlNodeType,
		variable_name: string,
		shaders_collection_controller: ShadersCollectionController
	): void;
	set_node_lines_output(
		output_node: BaseGlNodeType,
		shaders_collection_controller: ShadersCollectionController
	): void;
	setNodeLinesAttribute(
		attribute_node: AttributeGlNode,
		shaders_collection_controller: ShadersCollectionController
	): void;
	set_node_lines_globals(
		globals_node: GlobalsGlNode,
		shaders_collection_controller: ShadersCollectionController
	): void;
	private _handle_globals_time;
	private _handle_globals_default;
}
declare class ParticlesSystemGpuSopParamsConfig extends NodeParamsConfig {
	/** @param frame the particles simulation starts */
	/** @param auto sets the resolution of the textures used by the GPU shaders */
	autoTexturesSize: ParamTemplate<ParamType.BOOLEAN>;
	/** @param max texture size. This is important to set a limit, as some systems may not handle large textures for particle sims */
	maxTexturesSize: ParamTemplate<ParamType.VECTOR2>;
	/** @param sets the texture size manually */
	texturesSize: ParamTemplate<ParamType.VECTOR2>;
	/** @param data type used by the solver */
	dataType: ParamTemplate<ParamType.INTEGER>;
	/** @param number of frames to run before scene plays */
	preRollFramesCount: ParamTemplate<ParamType.INTEGER>;
	/** @param resets the sim */
	/** @param material used to render the particles */
	material: ParamTemplate<ParamType.NODE_PATH>;
}
declare class ParticlesSystemGpuSopNode extends TypedSopNode<ParticlesSystemGpuSopParamsConfig> {
	paramsConfig: ParticlesSystemGpuSopParamsConfig;
	static type(): SopType;
	dispose(): void;
	assemblerController(): GlAssemblerController<ShaderAssemblerParticles> | undefined;
	usedAssembler(): Readonly<AssemblerName.GL_PARTICLES>;
	protected _assemblerController: GlAssemblerController<ShaderAssemblerParticles> | undefined;
	private _createAssemblerController;
	readonly persisted_config: ParticlesPersistedConfig;
	private _particlesGlobalsHandler;
	private _shadersByName;
	shadersByName(): Map<ShaderName, string>;
	static require_webgl2(): boolean;
	static displayedInputNames(): string[];
	protected _childrenControllerContext: NodeContext;
	initializeNode(): void;
	createNode<S extends keyof GlNodeChildrenMap>(node_class: S, options?: NodeCreateOptions): GlNodeChildrenMap[S];
	createNode<K extends valueof<GlNodeChildrenMap>>(node_class: Constructor<K>, options?: NodeCreateOptions): K;
	children(): BaseGlNodeType[];
	nodesByType<K extends keyof GlNodeChildrenMap>(type: K): GlNodeChildrenMap[K][];
	childrenAllowed(): boolean;
	sceneReadonly(): boolean;
	cook(inputContents: CoreGroup[]): Promise<void>;
	traverseObjectOnSopGroupAdd(object: Object3D): void;
	compileIfRequired(): void;
	run_assembler(): void;
	private _setShaderNames;
	init_with_persisted_config(): void;
	initCoreParticlesControllerFromPersistedConfig(coreParticlesController: CoreParticlesController): void;
	private _findExportNodes;
}
declare class PeakSopParamsConfig extends NodeParamsConfig {
	/** @param amount the points will be moved */
	amount: ParamTemplate<ParamType.FLOAT>;
}
declare class PeakSopNode extends TypedSopNode<PeakSopParamsConfig> {
	paramsConfig: PeakSopParamsConfig;
	static type(): string;
	initializeNode(): void;
	private _operation;
	cook(input_contents: CoreGroup[]): void;
}
declare class PerspectiveCameraSopParamsConfig extends NodeParamsConfig {
	/** @param camera fov */
	fov: ParamTemplate<ParamType.FLOAT>;
	/** @param camera near */
	near: ParamTemplate<ParamType.FLOAT>;
	/** @param camera far */
	far: ParamTemplate<ParamType.FLOAT>;
	/** @param camera position */
	position: ParamTemplate<ParamType.VECTOR3>;
	/** @param camera rotation */
	rotation: ParamTemplate<ParamType.VECTOR3>;
	/** @param show helper */
	showHelper: ParamTemplate<ParamType.BOOLEAN>;
	/** @param matrixAutoUpdate */
	matrixAutoUpdate: ParamTemplate<ParamType.BOOLEAN>;
	/** @param camera name */
	name: ParamTemplate<ParamType.STRING>;
	/** @param set main camera */
	updateTransformFromCamera: ParamTemplate<ParamType.BUTTON>;
}
declare class PerspectiveCameraSopNode extends TypedSopNode<PerspectiveCameraSopParamsConfig> {
	readonly paramsConfig: PerspectiveCameraSopParamsConfig;
	static type(): CameraNodeType;
	static onRegister: OnNodeRegisterCallback;
	protected initializeNode(): void;
	private _operation;
	cook(inputCoreGroups: CoreGroup[]): void;
}
declare class PhysicsGroundSopParamsConfig extends NodeParamsConfig {
	/** @param size */
	size: ParamTemplate<ParamType.VECTOR2>;
	/** @param center */
	center: ParamTemplate<ParamType.VECTOR2>;
	/** @param height */
	height: ParamTemplate<ParamType.FLOAT>;
	/** @param direction */
	direction: ParamTemplate<ParamType.VECTOR3>;
	/** @param thickness */
	thickness: ParamTemplate<ParamType.FLOAT>;
	/** @param friction */
	friction: ParamTemplate<ParamType.FLOAT>;
	/** @param restitution */
	restitution: ParamTemplate<ParamType.FLOAT>;
}
declare class PhysicsGroundSopNode extends TypedSopNode<PhysicsGroundSopParamsConfig> {
	readonly paramsConfig: PhysicsGroundSopParamsConfig;
	static type(): SopType;
	protected initializeNode(): void;
	cook(): void;
}
declare class PhysicsPlayerSopParamsConfig extends NodeParamsConfig {
	main: ParamTemplate<ParamType.FOLDER>;
	/** @param radius */
	radius: ParamTemplate<ParamType.FLOAT>;
	/** @param density */
	density: ParamTemplate<ParamType.FLOAT>;
	/** @param friction */
	friction: ParamTemplate<ParamType.FLOAT>;
	/** @param restitution */
	restitution: ParamTemplate<ParamType.FLOAT>;
	/** @param linear damping (affects velocity) */
	linearDamping: ParamTemplate<ParamType.FLOAT>;
	/** @param angular damping (affects rotations) */
	angularDamping: ParamTemplate<ParamType.FLOAT>;
	/** @param linear velocity */
	linearVelocity: ParamTemplate<ParamType.VECTOR3>;
	/** @param angular velocity */
	angularVelocity: ParamTemplate<ParamType.VECTOR3>;
	/** @param gravity Scale */
	gravityScale: ParamTemplate<ParamType.FLOAT>;
	details: ParamTemplate<ParamType.FOLDER>;
	/** @param id */
	id: ParamTemplate<ParamType.STRING>;
}
declare class PhysicsPlayerSopNode extends TypedActorSopNode<PhysicsPlayerSopParamsConfig> {
	readonly paramsConfig: PhysicsPlayerSopParamsConfig;
	static type(): SopType.PHYSICS_PLAYER;
	static displayedInputNames(): string[];
	protected initializeNode(): void;
	cook(inputCoreGroups: CoreGroup[]): void;
	private _updatePlayerObject;
	private _createDefaultInputObjects;
	private _findActorNode;
}
declare enum PhysicsRBDType {
	FIXED = 'fixed',
	DYNAMIC = 'dynamic',
	KINEMATIC_VEL = 'kinematicVelocityBased',
	KINEMATIC_POS = 'kinematicPositionBased',
}
declare enum PhysicsRBDColliderType {
	CAPSULE = 'capsule',
	CONE = 'cone',
	CONVEX_HULL = 'convex hull',
	CUBOID = 'cuboid',
	CYLINDER = 'cylinder',
	SPHERE = 'sphere',
	TRIMESH = 'trimesh',
	HEIGHT_FIELD = 'heightField',
}
declare enum PhysicsJointType {
	FIXED = 'fixed',
	SPHERICAL = 'spherical',
	REVOLUT = 'revolute',
	PRISMATIC = 'prismatic',
}
declare class PhysicsRBDJointsSopParamsConfig extends NodeParamsConfig {
	/** @param group to assign the material to */
	group: ParamTemplate<ParamType.STRING>;
	/** @param maxDistance */
	maxDistance: ParamTemplate<ParamType.FLOAT>;
	/** @param max number of joints per object */
	maxJointsCount: ParamTemplate<ParamType.INTEGER>;
	/** @param joint type */
	jointType: ParamTemplate<ParamType.INTEGER>;
	/** @param limit */
	limit: ParamTemplate<ParamType.VECTOR2>;
	/** @param up */
	up: ParamTemplate<ParamType.VECTOR3>;
	/** @param center */
	center: ParamTemplate<ParamType.FLOAT>;
	/** @param anchors at objects center */
	anchorsAtCenter: ParamTemplate<ParamType.BOOLEAN>;
	/** @param anchor position 1 */
	anchorsPos1: ParamTemplate<ParamType.VECTOR3>;
	/** @param anchor position 2 */
	anchorsPos2: ParamTemplate<ParamType.VECTOR3>;
	/** @param do not output input RBDs with joints */
	ouputsJointsOnly: ParamTemplate<ParamType.BOOLEAN>;
}
declare class PhysicsRBDJointsSopNode extends TypedSopNode<PhysicsRBDJointsSopParamsConfig> {
	readonly paramsConfig: PhysicsRBDJointsSopParamsConfig;
	static type(): string;
	static displayedInputNames(): string[];
	protected initializeNode(): void;
	setJointType(RBDtype: PhysicsJointType): void;
	jointType(): PhysicsJointType;
	cook(inputCoreGroups: CoreGroup[]): void;
	private _createJoint;
}
declare enum SizeComputationMethod {
	AUTO = 'auto',
	MANUAL = 'manual',
}
declare class PhysicsRBDAttributesSopParamsConfig extends NodeParamsConfig {
	main: ParamTemplate<ParamType.FOLDER>;
	/** @param Rigid body type */
	RBDType: ParamTemplate<ParamType.INTEGER>;
	/** @param collider type */
	colliderType: ParamTemplate<ParamType.INTEGER>;
	/** @param Rigid body type */
	sizeMethod: ParamTemplate<ParamType.INTEGER>;
	/** @param border radius */
	borderRadius: ParamTemplate<ParamType.FLOAT>;
	/** @param sizes */
	sizes: ParamTemplate<ParamType.VECTOR3>;
	/** @param sizes */
	size: ParamTemplate<ParamType.FLOAT>;
	/** @param radius */
	radius: ParamTemplate<ParamType.FLOAT>;
	/** @param half height */
	height: ParamTemplate<ParamType.FLOAT>;
	/** @param heightField rows */
	rows: ParamTemplate<ParamType.INTEGER>;
	/** @param heightField cols */
	cols: ParamTemplate<ParamType.INTEGER>;
	/** @param density */
	density: ParamTemplate<ParamType.FLOAT>;
	/** @param friction */
	friction: ParamTemplate<ParamType.FLOAT>;
	/** @param restitution */
	restitution: ParamTemplate<ParamType.FLOAT>;
	/** @param linear damping (affects velocity) */
	linearDamping: ParamTemplate<ParamType.FLOAT>;
	/** @param angular damping (affects rotations) */
	angularDamping: ParamTemplate<ParamType.FLOAT>;
	/** @param linear velocity */
	linearVelocity: ParamTemplate<ParamType.VECTOR3>;
	/** @param angular velocity */
	angularVelocity: ParamTemplate<ParamType.VECTOR3>;
	/** @param gravity Scale */
	gravityScale: ParamTemplate<ParamType.FLOAT>;
	/** @param can sleep */
	canSleep: ParamTemplate<ParamType.BOOLEAN>;
	details: ParamTemplate<ParamType.FOLDER>;
	/** @param add id */
	addId: ParamTemplate<ParamType.BOOLEAN>;
	/** @param id */
	id: ParamTemplate<ParamType.STRING>;
}
declare class PhysicsRBDAttributesSopNode extends TypedSopNode<PhysicsRBDAttributesSopParamsConfig> {
	readonly paramsConfig: PhysicsRBDAttributesSopParamsConfig;
	static type(): SopType;
	static displayedInputNames(): string[];
	protected initializeNode(): void;
	setRBDType(RBDtype: PhysicsRBDType): void;
	RBDType(): PhysicsRBDType;
	setColliderType(colliderType: PhysicsRBDColliderType): void;
	colliderType(): PhysicsRBDColliderType;
	setSizeMethod(sizeMethod: SizeComputationMethod): void;
	sizeMethod(): SizeComputationMethod;
	cook(inputCoreGroups: CoreGroup[]): Promise<void>;
	protected _applyColliderType(
		colliderType: PhysicsRBDColliderType,
		sizeMethod: SizeComputationMethod,
		coreObjects: CoreObject[], //BaseCoreObject<CoreObjectType>[],
		promises: Array<Promise<void>>
	): void;
	protected _computeStringParam(
		param: StringParam,
		coreObjects: BaseCoreObject<CoreObjectType>[],
		applyMethod: (object: ObjectContent<CoreObjectType>, value: string) => void
	): Promise<void>;
	protected _computeVector3Param(
		vectorParam: Vector3Param,
		coreObjects: BaseCoreObject<CoreObjectType>[],
		applyMethod: (object: ObjectContent<CoreObjectType>, value: Vector3) => void
	): Promise<void>;
	protected _computeNumberParam(
		param: FloatParam | IntegerParam,
		coreObjects: BaseCoreObject<CoreObjectType>[],
		applyMethod: (object: ObjectContent<CoreObjectType>, value: number) => void
	): Promise<void>;
	protected _computeBooleanParam(
		param: BooleanParam,
		coreObjects: BaseCoreObject<CoreObjectType>[],
		applyMethod: (object: ObjectContent<CoreObjectType>, value: boolean) => void
	): Promise<void>;
}
declare class PhysicsWorldSopParamsConfig extends NodeParamsConfig {
	/** @param gravity */
	gravity: ParamTemplate<ParamType.VECTOR3>;
	/** @param display debug information */
	debug: ParamTemplate<ParamType.BOOLEAN>;
}
declare class PhysicsWorldSopNode extends TypedActorSopNode<PhysicsWorldSopParamsConfig> {
	readonly paramsConfig: PhysicsWorldSopParamsConfig;
	static type(): SopType.PHYSICS_WORLD;
	protected initializeNode(): void;
	cook(inputCoreGroups: CoreGroup[]): Promise<void>;
	traverseObjectOnSopGroupAdd(object: Object3D): void;
	private _findActorNode;
}
declare class PlaneSopParamsConfig extends NodeParamsConfig {
	/** @param size of the plane */
	size: ParamTemplate<ParamType.VECTOR2>;
	/** @param defines if the plane resolution is sets via the number of segments or via the step size */
	useSegmentsCount: ParamTemplate<ParamType.BOOLEAN>;
	/** @param step size */
	stepSize: ParamTemplate<ParamType.FLOAT>;
	/** @param segments count */
	segments: ParamTemplate<ParamType.VECTOR2>;
	/** @param axis perpendicular to the plane */
	direction: ParamTemplate<ParamType.VECTOR3>;
	/** @param center of the plane */
	center: ParamTemplate<ParamType.VECTOR3>;
	/** @param create lines instead of polygons */
	asLines: ParamTemplate<ParamType.BOOLEAN>;
}
declare class PlaneSopNode extends TypedSopNode<PlaneSopParamsConfig> {
	paramsConfig: PlaneSopParamsConfig;
	static type(): SopType;
	static displayedInputNames(): string[];
	initializeNode(): void;
	private _operation;
	cook(input_contents: CoreGroup[]): void;
}
declare class PlaneHelperSopParamsConfig extends NodeParamsConfig {
	/** @param size of the plane */
	size: ParamTemplate<ParamType.FLOAT>;
	/** @param colorCenterLine */
	colorCenterLine: ParamTemplate<ParamType.COLOR>;
	/** @param colorGrid */
	colorGrid: ParamTemplate<ParamType.COLOR>;
}
declare class PlaneHelperSopNode extends TypedSopNode<PlaneHelperSopParamsConfig> {
	paramsConfig: PlaneHelperSopParamsConfig;
	static type(): string;
	initializeNode(): void;
	private _operation;
	cook(input_contents: CoreGroup[]): void;
}
declare class PointSopParamsConfig extends NodeParamsConfig {
	/** @param toggle on to update the x component */
	updateX: ParamTemplate<ParamType.BOOLEAN>;
	/** @param expression the x component */
	x: ParamTemplate<ParamType.FLOAT>;
	/** @param toggle on to update the y component */
	updateY: ParamTemplate<ParamType.BOOLEAN>;
	/** @param expression the y component */
	y: ParamTemplate<ParamType.FLOAT>;
	/** @param toggle on to update the z component */
	updateZ: ParamTemplate<ParamType.BOOLEAN>;
	/** @param expression the z component */
	z: ParamTemplate<ParamType.FLOAT>;
	/** @param toggle on to update the normals */
	updateNormals: ParamTemplate<ParamType.BOOLEAN>;
}
declare class PointSopNode extends TypedSopNode<PointSopParamsConfig> {
	paramsConfig: PointSopParamsConfig;
	static type(): string;
	private _x_arrays_by_geometry_uuid;
	private _y_arrays_by_geometry_uuid;
	private _z_arrays_by_geometry_uuid;
	static displayedInputNames(): string[];
	initializeNode(): void;
	cook(inputCoreGroups: CoreGroup[]): Promise<void>;
	_evalExpressionsForCoreGroup(coreGroup: CoreGroup): Promise<void>;
	_evalExpressionsForCoreObject(coreObject: CoreObject): Promise<void>;
	private _updateFromParam;
	private _initArrayIfRequired;
	private _array_for_component;
	private _commit_tmp_values;
}
declare const PointLightSopParamsConfig_base: {
	new (...args: any[]): {
		light: ParamTemplate<ParamType.FOLDER>;
		color: ParamTemplate<ParamType.COLOR>;
		intensity: ParamTemplate<ParamType.FLOAT>;
		decay: ParamTemplate<ParamType.FLOAT>;
		distance: ParamTemplate<ParamType.FLOAT>;
		showHelper: ParamTemplate<ParamType.BOOLEAN>;
		helperSize: ParamTemplate<ParamType.FLOAT>;
		name: ParamTemplate<ParamType.STRING>;
		shadow: ParamTemplate<ParamType.FOLDER>;
		castShadow: ParamTemplate<ParamType.BOOLEAN>;
		shadowAutoUpdate: ParamTemplate<ParamType.BOOLEAN>;
		shadowUpdateOnNextRender: ParamTemplate<ParamType.BOOLEAN>;
		shadowRes: ParamTemplate<ParamType.VECTOR2>;
		shadowBias: ParamTemplate<ParamType.FLOAT>;
		shadowNear: ParamTemplate<ParamType.FLOAT>;
		shadowFar: ParamTemplate<ParamType.FLOAT>;
		raymarching: ParamTemplate<ParamType.FOLDER>;
		raymarchingPenumbra: ParamTemplate<ParamType.FLOAT>;
	};
} & typeof NodeParamsConfig;
declare class PointLightSopParamsConfig extends PointLightSopParamsConfig_base {}
declare class PointLightSopNode extends TypedSopNode<PointLightSopParamsConfig> {
	paramsConfig: PointLightSopParamsConfig;
	static type(): LightType;
	initializeNode(): void;
	private _operation;
	cook(input_contents: CoreGroup[]): void;
}
declare class PolarTransformSopParamConfig extends NodeParamsConfig {
	/** @param sets if this node should transform objects or geometries */
	applyOn: ParamTemplate<ParamType.INTEGER>;
	/** @param center of the transform */
	center: ParamTemplate<ParamType.VECTOR3>;
	/** @param moves the objects along the longitude, which is equivalent to a rotation on the y axis */
	longitude: ParamTemplate<ParamType.FLOAT>;
	/** @param moves the objects along the latitude, which is equivalent to a rotation on the z or x axis */
	latitude: ParamTemplate<ParamType.FLOAT>;
	/** @param moves the point aways from the center */
	depth: ParamTemplate<ParamType.FLOAT>;
}
declare class PolarTransformSopNode extends TypedSopNode<PolarTransformSopParamConfig> {
	paramsConfig: PolarTransformSopParamConfig;
	static type(): SopType;
	static displayedInputNames(): string[];
	initializeNode(): void;
	private _operation;
	cook(input_contents: CoreGroup[]): void;
	setApplyOn(mode: TransformTargetType): void;
}
declare class PolywireSopParamsConfig extends NodeParamsConfig {
	/** @param radius */
	radius: ParamTemplate<ParamType.FLOAT>;
	/** @param segments count on the circle used */
	segmentsRadial: ParamTemplate<ParamType.INTEGER>;
	/** @param toggle on for the geometry to close back on itself */
	closed: ParamTemplate<ParamType.BOOLEAN>;
	/** @param attributesToCopy */
	attributesToCopy: ParamTemplate<ParamType.STRING>;
}
declare class PolywireSopNode extends TypedSopNode<PolywireSopParamsConfig> {
	paramsConfig: PolywireSopParamsConfig;
	static type(): SopType;
	static displayedInputNames(): string[];
	initializeNode(): void;
	private _operation;
	cook(inputCoreGroups: CoreGroup[]): void;
}
declare enum RaySopMode {
	PROJECT_RAY = 'project rays',
	MIN_DIST = 'minimum distance',
}
declare class RaySopParamsConfig extends NodeParamsConfig {
	/** @param method used to ray points onto the collision geometry */
	mode: ParamTemplate<ParamType.INTEGER>;
	/** @param toggle on to use the normals as the ray direction */
	useNormals: ParamTemplate<ParamType.BOOLEAN>;
	/** @param if the normals are not used as the ray direction, this define the direction used */
	direction: ParamTemplate<ParamType.VECTOR3>;
	/** @param moves the points or leaves them in place */
	transformPoints: ParamTemplate<ParamType.BOOLEAN>;
	/** @param copies the normals from the right geometry to the left one */
	transferFaceNormals: ParamTemplate<ParamType.BOOLEAN>;
	/** @param adds an attribute with the distance to the hit position on the target geometry */
	addDistAttribute: ParamTemplate<ParamType.BOOLEAN>;
}
declare class RaySopNode extends TypedSopNode<RaySopParamsConfig> {
	paramsConfig: RaySopParamsConfig;
	static type(): SopType;
	static displayedInputNames(): string[];
	initializeNode(): void;
	private _operation;
	cook(inputCoreGroups: CoreGroup[]): void;
	setMode(mode: RaySopMode): void;
}
declare class ReflectorSopParamsConfig extends NodeParamsConfig {
	/** @param direction the objects reflects */
	direction: ParamTemplate<ParamType.VECTOR3>;
	/** @param direction offset */
	directionOffset: ParamTemplate<ParamType.FLOAT>;
	/** @param when active is off, the mirror is not rendered */
	active: ParamTemplate<ParamType.BOOLEAN>;
	/** @param bias to ensure the mirror does not reflect itself */
	clipBias: ParamTemplate<ParamType.FLOAT>;
	/** @param color */
	color: ParamTemplate<ParamType.COLOR>;
	/** @param useVertexColor */
	useVertexColor: ParamTemplate<ParamType.BOOLEAN>;
	/** @param reflectionBlend */
	reflectionBlend: ParamTemplate<ParamType.FLOAT>;
	/** @param pixelRatio */
	/** @param opacity */
	opacity: ParamTemplate<ParamType.FLOAT>;
	pixelRatio: ParamTemplate<ParamType.INTEGER>;
	/** @param multisamples */
	multisamples: ParamTemplate<ParamType.INTEGER>;
	/** @param toggle to activate blur */
	tblur: ParamTemplate<ParamType.BOOLEAN>;
	/** @param blur amount */
	blur: ParamTemplate<ParamType.FLOAT>;
	/** @param vertical blur multiplier */
	verticalBlurMult: ParamTemplate<ParamType.FLOAT>;
	/** @param toggle to activate a second blur, which can be useful to reduce artefacts */
	tblur2: ParamTemplate<ParamType.BOOLEAN>;
	/** @param blur2 amount */
	blur2: ParamTemplate<ParamType.FLOAT>;
	/** @param vertical blur2 multiplier */
	verticalBlur2Mult: ParamTemplate<ParamType.FLOAT>;
}
declare class ReflectorSopNode extends TypedSopNode<ReflectorSopParamsConfig> {
	paramsConfig: ReflectorSopParamsConfig;
	static type(): string;
	static displayedInputNames(): string[];
	initializeNode(): void;
	private _operation;
	cook(input_contents: CoreGroup[]): void;
}
declare enum SplineCurveType {
	CATMULLROM = 'catmullrom',
	CENTRIPETAL = 'centripetal',
	CHORDAL = 'chordal',
}
declare class ResampleSopParamsConfig extends NodeParamsConfig {
	/** @param resampling method */
	method: ParamTemplate<ParamType.INTEGER>;
	/** @param type of curve this will generate */
	curveType: ParamTemplate<ParamType.INTEGER>;
	/** @param curve tension */
	tension: ParamTemplate<ParamType.FLOAT>;
	/** @param points count */
	pointsCount: ParamTemplate<ParamType.INTEGER>;
	/** @param segments length */
	segmentLength: ParamTemplate<ParamType.FLOAT>;
}
declare class ResampleSopNode extends TypedSopNode<ResampleSopParamsConfig> {
	paramsConfig: ResampleSopParamsConfig;
	static type(): string;
	initializeNode(): void;
	cook(inputCoreGroups: CoreGroup[]): void;
	setCurveType(curveType: SplineCurveType): void;
	_resample(lineSegment: LineSegments): LineSegments<BufferGeometry, Material | Material[]>;
	_create_curve_from_points(points: CorePoint[]): BufferGeometry | undefined;
	_get_points_from_curve(curve: CatmullRomCurve3): Vector3[];
}
declare class RestAttributesSopParamsConfig extends NodeParamsConfig {
	/** @param toggle on to create a rest position */
	tposition: ParamTemplate<ParamType.BOOLEAN>;
	/** @param name of the position attribute */
	position: ParamTemplate<ParamType.STRING>;
	/** @param name of the rest position attribute, on which the position will be copied on */
	restP: ParamTemplate<ParamType.STRING>;
	/** @param toggle on to create a rest normal */
	tnormal: ParamTemplate<ParamType.BOOLEAN>;
	/** @param name of the normal attribute */
	normal: ParamTemplate<ParamType.STRING>;
	/** @param name of the rest normal attribute, on which the normal will be copied on */
	restN: ParamTemplate<ParamType.STRING>;
}
declare class RestAttributesSopNode extends TypedSopNode<RestAttributesSopParamsConfig> {
	paramsConfig: RestAttributesSopParamsConfig;
	static type(): string;
	initializeNode(): void;
	private _operation;
	cook(input_contents: CoreGroup[]): void;
}
declare class RingSopParamsConfig extends NodeParamsConfig {
	/** @param inner radius of the ring */
	innerRadius: ParamTemplate<ParamType.FLOAT>;
	/** @param outer radius of the ring */
	outerRadius: ParamTemplate<ParamType.FLOAT>;
	/** @param segments count */
	thetaSegments: ParamTemplate<ParamType.INTEGER>;
	/** @param segments count */
	phiSegments: ParamTemplate<ParamType.INTEGER>;
	/** @param if set to 1, you can then set the phiStart, phi_end, thetaStart and theta_end */
	open: ParamTemplate<ParamType.BOOLEAN>;
	/** @param start of phi angle */
	angleStart: ParamTemplate<ParamType.FLOAT>;
	/** @param length of phi opening */
	angleLength: ParamTemplate<ParamType.FLOAT>;
	/** @param axis perpendicular to the plane */
	direction: ParamTemplate<ParamType.VECTOR3>;
	/** @param center of the plane */
	center: ParamTemplate<ParamType.VECTOR3>;
}
declare class RingSopNode extends TypedSopNode<RingSopParamsConfig> {
	paramsConfig: RingSopParamsConfig;
	static type(): SopType;
	initializeNode(): void;
	private _operation;
	cook(inputCoreGroups: CoreGroup[]): void;
}
declare class RoundedBoxSopParamsConfig extends NodeParamsConfig {
	/** @param size of the box */
	size: ParamTemplate<ParamType.FLOAT>;
	/** @param size of the box */
	sizes: ParamTemplate<ParamType.VECTOR3>;
	/** @param divisions count */
	divisions: ParamTemplate<ParamType.INTEGER>;
	/** @param bevel size */
	bevel: ParamTemplate<ParamType.FLOAT>;
	/** @param center of the box */
	center: ParamTemplate<ParamType.VECTOR3>;
}
declare class RoundedBoxSopNode extends TypedSopNode<RoundedBoxSopParamsConfig> {
	paramsConfig: RoundedBoxSopParamsConfig;
	static type(): SopType;
	static displayedInputNames(): string[];
	initializeNode(): void;
	private _operation;
	cook(inputCoreGroups: CoreGroup[]): void;
}
declare class ScatterSopParamsConfig extends NodeParamsConfig {
	/** @param number of points to create */
	pointsCount: ParamTemplate<ParamType.INTEGER>;
	/** @param seed */
	seed: ParamTemplate<ParamType.INTEGER>;
	/** @param attribute which will influence the distribution of points */
	useWeightAttribute: ParamTemplate<ParamType.BOOLEAN>;
	/** @param attribute which will influence the distribution of points */
	weightAttribute: ParamTemplate<ParamType.STRING>;
	/** @param toggle on to transfer attribute from the input geometry to the created points */
	transferAttributes: ParamTemplate<ParamType.BOOLEAN>;
	/** @param names of the attributes to transfer */
	attributesToTransfer: ParamTemplate<ParamType.STRING>;
	/** @param add an id attribute, starting at 0, incrementing by 1 for each point (0,1,2,3...) */
	addIdAttribute: ParamTemplate<ParamType.BOOLEAN>;
	/** @param add an idn attribute, which is the id normalized between 0 and 1 */
	addIdnAttribute: ParamTemplate<ParamType.BOOLEAN>;
}
declare class ScatterSopNode extends TypedSopNode<ScatterSopParamsConfig> {
	paramsConfig: ScatterSopParamsConfig;
	static type(): string;
	static displayedInputNames(): string[];
	initializeNode(): void;
	private _operation;
	cook(inputCoreGroups: CoreGroup[]): void;
}
declare class JsAssemblerSDF extends BaseJsShaderAssembler {
	templateShader(): {
		fragmentShader: string;
		vertexShader: undefined;
		uniforms: undefined;
	};
	spareParamsOptions(): ParamOptions;
	functionData(): FunctionData | undefined;
	updateFunction(): void;
	add_output_inputs(output_child: OutputJsNode): void;
	add_globals_outputs(globals_node: GlobalsJsNode): void;
	create_shader_configs(): ShaderConfig[];
	create_variable_configs(): VariableConfig[];
	set_node_lines_output(outputNode: OutputJsNode, shadersCollectionController: ShadersCollectionController): void;
	set_node_lines_globals(globalsNode: GlobalsJsNode, shadersCollectionController: ShadersCollectionController): void;
}
export interface SDFPersistedConfigBaseJsData extends PersistedConfigBaseJsData {
	functionBody: string;
	variableNames: string[];
	variables: SerializedVariable<SerializedVariableType>[];
	functionNames: Array<keyof NamedFunctionMap>;
	serializedParamConfigs: JsParamConfigJSON<ParamType>[];
}
declare class SDFPersistedConfig extends BasePersistedConfig {
	protected node: SDFBuilderSopNode;
	constructor(node: SDFBuilderSopNode);
	toData(): Promise<SDFPersistedConfigBaseJsData | undefined>;
	load(data: SDFPersistedConfigBaseJsData): void;
}
declare class SDFBuilderSopParamsConfig extends NodeParamsConfig {
	/** @param stepSize */
	stepSize: ParamTemplate<ParamType.FLOAT>;
	/** @param level */
	level: ParamTemplate<ParamType.FLOAT>;
	/** @param min bound */
	min: ParamTemplate<ParamType.VECTOR3>;
	/** @param max bound */
	max: ParamTemplate<ParamType.VECTOR3>;
	/** @param linear Tolerance */
	facetAngle: ParamTemplate<ParamType.FLOAT>;
	/** @param meshes color */
	meshesColor: ParamTemplate<ParamType.COLOR>;
	/** @param wireframe */
	wireframe: ParamTemplate<ParamType.BOOLEAN>;
}
declare class SDFBuilderSopNode extends TypedSopNode<SDFBuilderSopParamsConfig> {
	paramsConfig: SDFBuilderSopParamsConfig;
	static type(): SopType;
	requiredModules(): ModuleName[];
	readonly persisted_config: SDFPersistedConfig;
	assemblerController(): JsAssemblerController<JsAssemblerSDF> | undefined;
	usedAssembler(): Readonly<AssemblerName.JS_SDF>;
	protected _assemblerController: JsAssemblerController<JsAssemblerSDF> | undefined;
	private _createAssemblerController;
	protected _childrenControllerContext: NodeContext;
	initializeNode(): void;
	createNode<S extends keyof JsNodeChildrenMap>(node_class: S, options?: NodeCreateOptions): JsNodeChildrenMap[S];
	createNode<K extends valueof<JsNodeChildrenMap>>(node_class: Constructor<K>, options?: NodeCreateOptions): K;
	children(): BaseJsNodeType[];
	nodesByType<K extends keyof JsNodeChildrenMap>(type: K): JsNodeChildrenMap[K][];
	childrenAllowed(): boolean;
	sceneReadonly(): boolean;
	cook(inputCoreGroups: CoreGroup[]): Promise<void>;
	compileIfRequired(): Promise<void>;
	private _position;
	private _paramConfigs;
	private _functionData;
	private _functionCreationArgs;
	private _functionEvalArgs;
	private _function;
	functionData(): FunctionData | undefined;
	compile(): Promise<void>;
	updateFromFunctionData(functionData: FunctionData): void;
	functionEvalArgsWithParamConfigs(): (number | boolean | Function | RegisterableVariable)[];
}
declare class SetChildrenSopParamsConfig extends NodeParamsConfig {
	clearExistingChildren: ParamTemplate<ParamType.BOOLEAN>;
}
declare class SetChildrenSopNode extends TypedSopNode<SetChildrenSopParamsConfig> {
	paramsConfig: SetChildrenSopParamsConfig;
	static type(): string;
	static displayedInputNames(): string[];
	initializeNode(): void;
	private _operation;
	cook(inputCoreGroups: CoreGroup[]): void;
}
declare enum SetGeometryMode {
	ONE_GEO_PER_OBJECT = 'One Geometry Per Object',
	FIRST_GEO_TO_EACH_OBJECT = 'First Geometry To Each Object',
}
declare class SetGeometrySopParamsConfig extends NodeParamsConfig {
	mode: ParamTemplate<ParamType.INTEGER>;
}
declare class SetGeometrySopNode extends TypedSopNode<SetGeometrySopParamsConfig> {
	paramsConfig: SetGeometrySopParamsConfig;
	static type(): string;
	static displayedInputNames(): string[];
	initializeNode(): void;
	setMode(mode: SetGeometryMode): void;
	private _operation;
	cook(inputCoreGroups: CoreGroup[]): void;
}
declare enum ShearMode {
	MATRIX = 'matrix',
	AXIS = 'axis',
}
declare class ShearSopParamConfig extends NodeParamsConfig {
	/** @param mode */
	mode: ParamTemplate<ParamType.INTEGER>;
	/** @param matrixMode XY */
	xy: ParamTemplate<ParamType.FLOAT>;
	/** @param matrixMode XZ */
	xz: ParamTemplate<ParamType.FLOAT>;
	/** @param matrixMode YX */
	yx: ParamTemplate<ParamType.FLOAT>;
	/** @param matrixMode YZ */
	yz: ParamTemplate<ParamType.FLOAT>;
	/** @param matrixMode ZX */
	zx: ParamTemplate<ParamType.FLOAT>;
	/** @param matrixMode ZY */
	zy: ParamTemplate<ParamType.FLOAT>;
	/** @param centerMode defines how the center of the shear in axis mode is computed */
	centerMode: ParamTemplate<ParamType.INTEGER>;
	/** @param centerOffset */
	centerOffset: ParamTemplate<ParamType.VECTOR3>;
	/** @param center */
	center: ParamTemplate<ParamType.VECTOR3>;
	/** @param PlaneAxis */
	planeAxis: ParamTemplate<ParamType.VECTOR3>;
	/** @param axis */
	axis: ParamTemplate<ParamType.VECTOR3>;
	/** @param axisAmount */
	axisAmount: ParamTemplate<ParamType.FLOAT>;
}
declare class ShearSopNode extends TypedSopNode<ShearSopParamConfig> {
	paramsConfig: ShearSopParamConfig;
	static type(): SopType;
	static displayedInputNames(): string[];
	initializeNode(): void;
	setMode(mode: ShearMode): void;
	private _operation;
	cook(input_contents: CoreGroup[]): void;
}
declare class SkeletonHelperSopParamsConfig extends NodeParamsConfig {}
declare class SkeletonHelperSopNode extends TypedSopNode<SkeletonHelperSopParamsConfig> {
	paramsConfig: SkeletonHelperSopParamsConfig;
	static type(): string;
	static displayedInputNames(): string[];
	initializeNode(): void;
	cook(inputCoreGroups: CoreGroup[]): void;
}
declare class SkinSopParamsConfig extends NodeParamsConfig {}
declare class SkinSopNode extends TypedSopNode<SkinSopParamsConfig> {
	paramsConfig: SkinSopParamsConfig;
	static type(): string;
	static displayedInputNames(): string[];
	initializeNode(): void;
	cook(input_contents: CoreGroup[]): void;
	process_one_input(input_contents: CoreGroup[]): void;
	process_two_inputs(input_contents: CoreGroup[]): void;
	_getLineSegments(core_group: CoreGroup): Object3D<Event>[];
	_skin(geometry1: BufferGeometry, geometry0: BufferGeometry): BufferGeometry;
}
declare enum SortMode {
	RANDOM = 'random',
	AXIS = 'axis',
}
declare class SortSopParamsConfig extends NodeParamsConfig {
	/** @param criteria used to sort */
	mode: ParamTemplate<ParamType.INTEGER>;
	/** @param defines if this node will sort points or objects */
	targetType: ParamTemplate<ParamType.INTEGER>;
	/** @param seed used by the random mode */
	seed: ParamTemplate<ParamType.INTEGER>;
	/** @param axis along which points will be sorted */
	axis: ParamTemplate<ParamType.INTEGER>;
	/** @param invert the sort */
	invert: ParamTemplate<ParamType.BOOLEAN>;
}
declare class SortSopNode extends TypedSopNode<SortSopParamsConfig> {
	paramsConfig: SortSopParamsConfig;
	static type(): string;
	static displayedInputNames(): string[];
	initializeNode(): void;
	private _operation;
	cook(input_contents: CoreGroup[]): void;
	setSortMode(mode: SortMode): void;
	setTargetType(targetType: AttribClass.VERTEX | AttribClass.OBJECT): void;
}
declare class SolverIterationStamp extends CoreGraphNode {
	protected _iteration: number;
	constructor(scene: PolyScene);
	reset(): void;
	setIteration(iteration: number): void;
	iteration(): number;
}
declare class SolverSopParamsConfig extends NodeParamsConfig {
	/** @param number of times the nodes inside this node will process the input */
	iterations: ParamTemplate<ParamType.INTEGER>;
	/** @param Currently, when the child nodes are updated, the solver node does not know that it should recook. Clicking this button forces it to recompute */
	reload: ParamTemplate<ParamType.BUTTON>;
}
declare class SolverSopNode extends SubnetSopNodeLike<SolverSopParamsConfig> {
	paramsConfig: SolverSopParamsConfig;
	static type(): NetworkNodeType;
	private _iterationStamp;
	readonly childrenDisplayController: SopSubnetChildrenDisplayController;
	readonly displayNodeController: DisplayNodeController;
	initializeNode(): void;
	iterationStamp(): SolverIterationStamp;
	private _createStampNode;
	private _previousFrameCoreGroup;
	previousFrameCoreGroup(): CoreGroup | undefined;
	cook(inputCoreGroups: CoreGroup[]): Promise<void>;
	private _reset;
	private _computeSolverMultipleTimes;
	private computeSolver;
	static PARAM_CALLBACK_reload(node: SolverSopNode): void;
	private param_callback_reload;
}
declare class SolverPreviousFrameSopParamsConfig extends NodeParamsConfig {}
declare class SolverPreviousFrameSopNode extends TypedSopNode<SolverPreviousFrameSopParamsConfig> {
	paramsConfig: SolverPreviousFrameSopParamsConfig;
	static type(): string;
	cook(): void;
	private _solverNodeDependencyCreated;
	private _createSolverNodeDependencyIfRequired;
	private _solverNode;
}
declare class SphereSopParamsConfig extends NodeParamsConfig {
	/** @param type of sphere (default sphere or isocahedron) */
	type: ParamTemplate<ParamType.INTEGER>;
	/** @param radius of the sphere when the type is default */
	radius: ParamTemplate<ParamType.FLOAT>;
	/** @param resolution - number of segments in x and y */
	resolution: ParamTemplate<ParamType.VECTOR2>;
	/** @param if set to 1, you can then set the phiStart, phi_end, thetaStart and theta_end */
	open: ParamTemplate<ParamType.BOOLEAN>;
	/** @param start of phi angle */
	phiStart: ParamTemplate<ParamType.FLOAT>;
	/** @param length of phi opening */
	phiLength: ParamTemplate<ParamType.FLOAT>;
	/** @param start of theta angle */
	thetaStart: ParamTemplate<ParamType.FLOAT>;
	/** @param length of theta opening */
	thetaLength: ParamTemplate<ParamType.FLOAT>;
	/** @param resolution of the sphere when the type is isocahedron */
	detail: ParamTemplate<ParamType.INTEGER>;
	/** @param center of the sphere */
	center: ParamTemplate<ParamType.VECTOR3>;
	/** @param create lines instead of polygons */
	asLines: ParamTemplate<ParamType.BOOLEAN>;
}
declare class SphereSopNode extends TypedSopNode<SphereSopParamsConfig> {
	paramsConfig: SphereSopParamsConfig;
	static type(): SopType;
	initializeNode(): void;
	private _operation;
	cook(input_contents: CoreGroup[]): void;
}
declare class SplitSopParamsConfig extends NodeParamsConfig {
	/** @param type of attribute to use */
	attribType: ParamTemplate<ParamType.INTEGER>;
	/** @param name of the attribute */
	attribName: ParamTemplate<ParamType.STRING>;
}
declare class SplitSopNode extends TypedSopNode<SplitSopParamsConfig> {
	paramsConfig: SplitSopParamsConfig;
	static type(): string;
	static displayedInputNames(): string[];
	initializeNode(): void;
	private _new_objects;
	cook(input_contents: CoreGroup[]): void;
	_split_core_group(core_group: CoreGroup): void;
	private _split_core_object;
}
declare const SpotLightSopParamsConfig_base: {
	new (...args: any[]): {
		light: ParamTemplate<ParamType.FOLDER>;
		color: ParamTemplate<ParamType.COLOR>;
		intensity: ParamTemplate<ParamType.FLOAT>;
		angle: ParamTemplate<ParamType.FLOAT>;
		penumbra: ParamTemplate<ParamType.FLOAT>;
		decay: ParamTemplate<ParamType.FLOAT>;
		distance: ParamTemplate<ParamType.FLOAT>;
		showHelper: ParamTemplate<ParamType.BOOLEAN>;
		helperSize: ParamTemplate<ParamType.FLOAT>;
		name: ParamTemplate<ParamType.STRING>;
		shadow: ParamTemplate<ParamType.FOLDER>;
		castShadow: ParamTemplate<ParamType.BOOLEAN>;
		shadowAutoUpdate: ParamTemplate<ParamType.BOOLEAN>;
		shadowUpdateOnNextRender: ParamTemplate<ParamType.BOOLEAN>;
		shadowRes: ParamTemplate<ParamType.VECTOR2>;
		shadowBias: ParamTemplate<ParamType.FLOAT>;
		shadowNear: ParamTemplate<ParamType.FLOAT>;
		shadowFar: ParamTemplate<ParamType.FLOAT>;
		shadowRadius: ParamTemplate<ParamType.FLOAT>;
		volumetric: ParamTemplate<ParamType.FOLDER>;
		tvolumetric: ParamTemplate<ParamType.BOOLEAN>;
		volAttenuation: ParamTemplate<ParamType.FLOAT>;
		volAnglePower: ParamTemplate<ParamType.FLOAT>;
		raymarching: ParamTemplate<ParamType.FOLDER>;
		raymarchingPenumbra: ParamTemplate<ParamType.FLOAT>;
	};
} & typeof NodeParamsConfig;
declare class SpotLightSopParamsConfig extends SpotLightSopParamsConfig_base {}
declare class SpotLightSopNode extends TypedSopNode<SpotLightSopParamsConfig> {
	paramsConfig: SpotLightSopParamsConfig;
	static type(): LightType;
	initializeNode(): void;
	private _operation;
	cook(input_contents: CoreGroup[]): void;
}
declare class SubdivideSopParamsConfig extends NodeParamsConfig {
	/** @param number of subdivisions */
	subdivisions: ParamTemplate<ParamType.INTEGER>;
	/** @param merge vertices */
	mergeVertices: ParamTemplate<ParamType.BOOLEAN>;
}
declare class SubdivideSopNode extends TypedSopNode<SubdivideSopParamsConfig> {
	paramsConfig: SubdivideSopParamsConfig;
	static type(): SopType;
	initializeNode(): void;
	private _operation;
	cook(input_contents: CoreGroup[]): void;
}
declare class SubnetSopParamsConfig extends NodeParamsConfig {}
declare class SubnetSopNode extends SubnetSopNodeLike<SubnetSopParamsConfig> {
	paramsConfig: SubnetSopParamsConfig;
	static type(): NetworkNodeType;
	initializeNode(): void;
}
declare class SubnetInputSopParamsConfig extends NodeParamsConfig {
	/** @param sets which input of the parent subnet node is used */
	input: ParamTemplate<ParamType.INTEGER>;
}
declare class SubnetInputSopNode extends TypedSopNode<SubnetInputSopParamsConfig> {
	paramsConfig: SubnetInputSopParamsConfig;
	static type(): NetworkChildNodeType;
	private _currentParentInputGraphNode;
	initializeNode(): void;
	cook(): Promise<void>;
	static PARAM_CALLBACK_reset(node: SubnetInputSopNode): void;
	private _setParentInputDependency;
}
declare class SwitchSopParamsConfig extends NodeParamsConfig {
	/** @param sets which input is used */
	input: ParamTemplate<ParamType.INTEGER>;
}
declare class SwitchSopNode extends TypedSopNode<SwitchSopParamsConfig> {
	paramsConfig: SwitchSopParamsConfig;
	static type(): SopType;
	static displayedInputNames(): string[];
	initializeNode(): void;
	cook(): Promise<void>;
	private _callbackUpdateInputsEvaluation;
	static PARAM_CALLBACK_setInputsEvaluation(node: SwitchSopNode): void;
}
declare class TangentSopParamsConfig extends NodeParamsConfig {
	/** @param closed */
	closed: ParamTemplate<ParamType.BOOLEAN>;
	/** @param tangent attribute name */
	tangentName: ParamTemplate<ParamType.STRING>;
}
declare class TangentSopNode extends TypedSopNode<TangentSopParamsConfig> {
	readonly paramsConfig: TangentSopParamsConfig;
	static type(): SopType;
	protected initializeNode(): void;
	private _operation;
	cook(inputCoreGroups: CoreGroup[]): void;
}
declare class TetrahedronSopParamsConfig extends NodeParamsConfig {
	/** @param radius of the tetrahedron */
	radius: ParamTemplate<ParamType.FLOAT>;
	/** @param resolution of the tetrahedron */
	detail: ParamTemplate<ParamType.INTEGER>;
	/** @param sets to create only points */
	pointsOnly: ParamTemplate<ParamType.BOOLEAN>;
	/** @param center of the tetrahedron */
	center: ParamTemplate<ParamType.VECTOR3>;
}
declare class TetrahedronSopNode extends TypedSopNode<TetrahedronSopParamsConfig> {
	paramsConfig: TetrahedronSopParamsConfig;
	static type(): SopType;
	cook(): void;
}
declare enum TextType {
	MESH = 'mesh',
	FLAT = 'flat',
	LINE = 'line',
	STROKE = 'stroke',
}
declare class TextSopParamsConfig extends NodeParamsConfig {
	/** @param font used */
	font: ParamTemplate<ParamType.STRING>;
	/** @param text created */
	text: ParamTemplate<ParamType.STRING>;
	/** @param type of geometry created */
	type: ParamTemplate<ParamType.INTEGER>;
	/** @param font size */
	size: ParamTemplate<ParamType.FLOAT>;
	/** @param extrude depth */
	extrude: ParamTemplate<ParamType.FLOAT>;
	/** @param segments count */
	segments: ParamTemplate<ParamType.INTEGER>;
	/** @param bevelEnabled */
	bevelEnabled: ParamTemplate<ParamType.BOOLEAN>;
	/** @param bevelThickness */
	bevelThickness: ParamTemplate<ParamType.FLOAT>;
	/** @param bevelSize */
	bevelSize: ParamTemplate<ParamType.FLOAT>;
	/** @param bevelOffset */
	bevelOffset: ParamTemplate<ParamType.FLOAT>;
	/** @param bevelSegments */
	bevelSegments: ParamTemplate<ParamType.INTEGER>;
	/** @param stroke width */
	strokeWidth: ParamTemplate<ParamType.FLOAT>;
	/** @param line height */
	lineHeight: ParamTemplate<ParamType.FLOAT>;
	/** @param create one object per letter */
	splitPerLetter: ParamTemplate<ParamType.BOOLEAN>;
	/** @param when creating one object per letter, define if the characters like space create an object */
	keepEmptyGeometries: ParamTemplate<ParamType.BOOLEAN>;
	/** @param justify mode */
	justifyMode: ParamTemplate<ParamType.INTEGER>;
	/** @param open advanced options */
	tadvanced: ParamTemplate<ParamType.BOOLEAN>;
	/** @param is counter clock wise: defines the vertex order when parsing the font */
	isCCW: ParamTemplate<ParamType.BOOLEAN>;
}
declare class TextSopNode extends TypedSopNode<TextSopParamsConfig> {
	paramsConfig: TextSopParamsConfig;
	static type(): SopType;
	dispose(): void;
	setTextType(type: TextType): void;
	private _loadedFonts;
	cook(): Promise<void>;
}
declare class TextureCopySopParamsConfig extends NodeParamsConfig {
	textureName: ParamTemplate<ParamType.STRING>;
}
declare class TextureCopySopNode extends TypedSopNode<TextureCopySopParamsConfig> {
	paramsConfig: TextureCopySopParamsConfig;
	static type(): string;
	static displayedInputNames(): string[];
	initializeNode(): void;
	private _operation;
	cook(input_contents: CoreGroup[]): Promise<void>;
}
declare class TexturePropertiesSopParamsConfig extends NodeParamsConfig {
	/** @param sets if this node should search through the materials inside the whole hierarchy */
	applyToChildren: ParamTemplate<ParamType.BOOLEAN>;
	/** @param toggle on to allow updating the texture encoding */
	tencoding: ParamTemplate<ParamType.BOOLEAN>;
	/** @param sets the texture encoding */
	encoding: ParamTemplate<ParamType.INTEGER>;
	/** @param toggle on to allow updating the texture mapping */
	tmapping: ParamTemplate<ParamType.BOOLEAN>;
	/** @param sets the texture mapping */
	mapping: ParamTemplate<ParamType.INTEGER>;
	/** @param toggle on to allow updating the texture wrap */
	twrap: ParamTemplate<ParamType.BOOLEAN>;
	/** @param sets the texture wrapS */
	wrapS: ParamTemplate<ParamType.INTEGER>;
	/** @param sets the texture wrapT */
	wrapT: ParamTemplate<ParamType.INTEGER>;
	/** @param toggle on to update the anisotropy */
	tanisotropy: ParamTemplate<ParamType.BOOLEAN>;
	/** @param sets if the anisotropy should be set to the max capabilities of the renderer */
	useRendererMaxAnisotropy: ParamTemplate<ParamType.BOOLEAN>;
	/** @param anisotropy value */
	anisotropy: ParamTemplate<ParamType.INTEGER>;
	/** @param toggle on to update min filter */
	tminFilter: ParamTemplate<ParamType.BOOLEAN>;
	/** @param min filter value */
	minFilter: ParamTemplate<ParamType.INTEGER>;
	/** @param toggle on to update mag filter */
	tmagFilter: ParamTemplate<ParamType.BOOLEAN>;
	/** @param mag filter value */
	magFilter: ParamTemplate<ParamType.INTEGER>;
}
declare class TexturePropertiesSopNode extends TypedSopNode<TexturePropertiesSopParamsConfig> {
	paramsConfig: TexturePropertiesSopParamsConfig;
	static type(): string;
	static displayedInputNames(): string[];
	initializeNode(): void;
	private _operation;
	cook(input_contents: CoreGroup[]): Promise<void>;
}
declare class TorusSopParamsConfig extends NodeParamsConfig {
	/** @param large radius */
	radius: ParamTemplate<ParamType.FLOAT>;
	/** @param radius of the tube */
	radiusTube: ParamTemplate<ParamType.FLOAT>;
	/** @param number of segments along the length of the torus */
	segmentsRadial: ParamTemplate<ParamType.INTEGER>;
	/** @param number of segments along the tube */
	segmentsTube: ParamTemplate<ParamType.INTEGER>;
	/** @param open */
	open: ParamTemplate<ParamType.BOOLEAN>;
	/** @param arc */
	arc: ParamTemplate<ParamType.FLOAT>;
	/** @param create caps */
	cap: ParamTemplate<ParamType.BOOLEAN>;
	/** @param axis perpendicular to the torus */
	direction: ParamTemplate<ParamType.VECTOR3>;
	/** @param center of the torus */
	center: ParamTemplate<ParamType.VECTOR3>;
}
declare class TorusSopNode extends TypedSopNode<TorusSopParamsConfig> {
	paramsConfig: TorusSopParamsConfig;
	static type(): SopType;
	private _operation;
	cook(input_contents: CoreGroup[]): void;
}
declare class TorusKnotSopParamsConfig extends NodeParamsConfig {
	/** @param large radius */
	radius: ParamTemplate<ParamType.FLOAT>;
	/** @param radius of the tube */
	radiusTube: ParamTemplate<ParamType.FLOAT>;
	/** @param number of segments along the length of the torus */
	segmentsRadial: ParamTemplate<ParamType.INTEGER>;
	/** @param number of segments along the tube */
	segmentsTube: ParamTemplate<ParamType.INTEGER>;
	/** @param change this to create more interesting shapes. Don't ask me what it is exactly, I don't know! */
	p: ParamTemplate<ParamType.INTEGER>;
	/** @param change this to create more interesting shapes. Don't ask me what it is exactly, I don't know! */
	q: ParamTemplate<ParamType.INTEGER>;
	/** @param center of the torus knot */
	center: ParamTemplate<ParamType.VECTOR3>;
}
declare class TorusKnotSopNode extends TypedSopNode<TorusKnotSopParamsConfig> {
	paramsConfig: TorusKnotSopParamsConfig;
	static type(): SopType;
	initializeNode(): void;
	private _operation;
	cook(input_contents: CoreGroup[]): void;
}
declare const TrackingLandmarksFaceSopParamsConfig_base: {
	new (...args: any[]): {
		selfieMode: ParamTemplate<ParamType.BOOLEAN>;
		maxNumFaces: ParamTemplate<ParamType.INTEGER>;
		refineLandmarks: ParamTemplate<ParamType.BOOLEAN>;
		minDetectionConfidence: ParamTemplate<ParamType.FLOAT>;
		minTrackingConfidence: ParamTemplate<ParamType.FLOAT>;
	};
} & typeof NodeParamsConfig;
declare class TrackingLandmarksFaceSopParamsConfig extends TrackingLandmarksFaceSopParamsConfig_base {}
declare class TrackingLandmarksFaceSopNode extends TypedSopNode<TrackingLandmarksFaceSopParamsConfig> {
	paramsConfig: TrackingLandmarksFaceSopParamsConfig;
	static type(): string;
	private _uv;
	cook(): void;
}
declare const TrackingLandmarksFaceAttributesSopParamsConfig_base: {
	new (...args: any[]): {
		selfieMode: ParamTemplate<ParamType.BOOLEAN>;
		maxNumFaces: ParamTemplate<ParamType.INTEGER>;
		refineLandmarks: ParamTemplate<ParamType.BOOLEAN>;
		minDetectionConfidence: ParamTemplate<ParamType.FLOAT>;
		minTrackingConfidence: ParamTemplate<ParamType.FLOAT>;
	};
} & typeof NodeParamsConfig;
declare class TrackingLandmarksFaceAttributesSopParamsConfig extends TrackingLandmarksFaceAttributesSopParamsConfig_base {}
declare class TrackingLandmarksFaceAttributesSopNode extends TypedSopNode<TrackingLandmarksFaceAttributesSopParamsConfig> {
	paramsConfig: TrackingLandmarksFaceAttributesSopParamsConfig;
	static type(): string;
	initializeNode(): void;
	cook(inputCoreGroups: CoreGroup[]): void;
}
declare const TrackingLandmarksHandSopParamsConfig_base: {
	new (...args: any[]): {
		selfieMode: ParamTemplate<ParamType.BOOLEAN>;
		maxNumHands: ParamTemplate<ParamType.INTEGER>;
		modelComplexity: ParamTemplate<ParamType.BOOLEAN>;
		minDetectionConfidence: ParamTemplate<ParamType.FLOAT>;
		minTrackingConfidence: ParamTemplate<ParamType.FLOAT>;
	};
} & typeof NodeParamsConfig;
declare class TrackingLandmarksHandSopParamsConfig extends TrackingLandmarksHandSopParamsConfig_base {}
declare class TrackingLandmarksHandSopNode extends TypedSopNode<TrackingLandmarksHandSopParamsConfig> {
	paramsConfig: TrackingLandmarksHandSopParamsConfig;
	static type(): string;
	cook(): void;
}
declare const TrackingLandmarksHandAttributesSopParamsConfig_base: {
	new (...args: any[]): {
		selfieMode: ParamTemplate<ParamType.BOOLEAN>;
		maxNumHands: ParamTemplate<ParamType.INTEGER>;
		modelComplexity: ParamTemplate<ParamType.BOOLEAN>;
		minDetectionConfidence: ParamTemplate<ParamType.FLOAT>;
		minTrackingConfidence: ParamTemplate<ParamType.FLOAT>;
	};
} & typeof NodeParamsConfig;
declare class TrackingLandmarksHandAttributesSopParamsConfig extends TrackingLandmarksHandAttributesSopParamsConfig_base {}
declare class TrackingLandmarksHandAttributesSopNode extends TypedSopNode<TrackingLandmarksHandAttributesSopParamsConfig> {
	paramsConfig: TrackingLandmarksHandAttributesSopParamsConfig;
	static type(): string;
	initializeNode(): void;
	cook(inputCoreGroups: CoreGroup[]): void;
}
declare enum TransformObjectMode {
	SET = 'set matrix',
	MULT = 'multiply matrix',
}
declare class TransformSopParamConfig extends NodeParamsConfig {
	/** @param sets if this node should transform objects or geometries */
	applyOn: ParamTemplate<ParamType.INTEGER>;
	/** @param if applyOn is set to object, the transform can then be applied in 2 different ways on those objects. Either the .position, .rotation and .scale attributes are set, or the matrix is set directly. */
	objectMode: ParamTemplate<ParamType.INTEGER>;
	/** @param defines how the objects are transformed */
	objectTransformSpace: ParamTemplate<ParamType.INTEGER>;
	/** @param group this applies to */
	group: ParamTemplate<ParamType.STRING>;
	/** @param rotation order */
	rotationOrder: ParamTemplate<ParamType.INTEGER>;
	/** @param translate */
	t: ParamTemplate<ParamType.VECTOR3>;
	/** @param rotation */
	r: ParamTemplate<ParamType.VECTOR3>;
	/** @param scale */
	s: ParamTemplate<ParamType.VECTOR3>;
	/** @param scale (as a float) */
	scale: ParamTemplate<ParamType.FLOAT>;
	/** @param pivot */
	pivot: ParamTemplate<ParamType.VECTOR3>;
}
declare class TransformSopNode extends TypedSopNode<TransformSopParamConfig> {
	paramsConfig: TransformSopParamConfig;
	static type(): SopType;
	static displayedInputNames(): string[];
	initializeNode(): void;
	setApplyOn(type: TransformTargetType): void;
	applyOn(): TransformTargetType;
	setObjectMode(mode: TransformObjectMode): void;
	private _operation;
	cook(inputCoreGroups: CoreGroup[]): void;
}
declare class TransformCopySopParamConfig extends NodeParamsConfig {
	/** @param toggle on if the second input should be used */
	useSecondInput: ParamTemplate<ParamType.BOOLEAN>;
	/** @param use a reference object */
	reference: ParamTemplate<ParamType.NODE_PATH>;
}
declare class TransformCopySopNode extends TypedSopNode<TransformCopySopParamConfig> {
	paramsConfig: TransformCopySopParamConfig;
	static type(): string;
	static displayedInputNames(): string[];
	initializeNode(): void;
	cook(input_contents: CoreGroup[]): void;
	private _copy_from_src_objects;
	private _copy_from_found_node;
}
declare class TransformMultiSopParamConfig extends NodeParamsConfig {
	/** @param defines if this applies to objects or geometries */
	applyOn: ParamTemplate<ParamType.INTEGER>;
	/** @param number of transformations this can apply */
	count: ParamTemplate<ParamType.INTEGER>;
	/** @param transform 0 rotation order */
	rotationOrder0: ParamTemplate<ParamType.INTEGER>;
	/** @param rotation 0 */
	r0: ParamTemplate<ParamType.VECTOR3>;
	/** @param transform 1 rotation order */
	rotationOrder1: ParamTemplate<ParamType.INTEGER>;
	/** @param rotation 1 */
	r1: ParamTemplate<ParamType.VECTOR3>;
	/** @param transform 2 rotation order */
	rotationOrder2: ParamTemplate<ParamType.INTEGER>;
	/** @param rotation 2 */
	r2: ParamTemplate<ParamType.VECTOR3>;
	/** @param transform 3 rotation order */
	rotationOrder3: ParamTemplate<ParamType.INTEGER>;
	/** @param rotation 3 */
	r3: ParamTemplate<ParamType.VECTOR3>;
	/** @param transform 4 rotation order */
	rotationOrder4: ParamTemplate<ParamType.INTEGER>;
	/** @param rotation 4 */
	r4: ParamTemplate<ParamType.VECTOR3>;
	/** @param transform 5 rotation order */
	rotationOrder5: ParamTemplate<ParamType.INTEGER>;
	/** @param rotation 5 */
	r5: ParamTemplate<ParamType.VECTOR3>;
}
declare class TransformMultiSopNode extends TypedSopNode<TransformMultiSopParamConfig> {
	paramsConfig: TransformMultiSopParamConfig;
	static type(): string;
	static displayedInputNames(): string[];
	initializeNode(): void;
	private _core_transform;
	private __rotAndIndexPairs;
	private _createRotAndIndexPairs;
	private _rotAndIndexPairs;
	cook(input_contents: CoreGroup[]): void;
	private _apply_transforms;
	private _apply_matrix_to_geometries;
	private _apply_matrix_to_objects;
	private _t;
	private _s;
	private _scale;
	private _matrix;
}
declare enum TransformResetMode {
	RESET_OBJECT = 'reset objects transform',
	CENTER_GEO = 'center geometries',
	CENTER_GEO_RESET_OBJECT = 'center geometry and reset object',
}
declare class TransformResetSopParamConfig extends NodeParamsConfig {
	/** @param mode to reset the geometry and object */
	mode: ParamTemplate<ParamType.INTEGER>;
}
declare class TransformResetSopNode extends TypedSopNode<TransformResetSopParamConfig> {
	paramsConfig: TransformResetSopParamConfig;
	static type(): string;
	static displayedInputNames(): string[];
	initializeNode(): void;
	setMode(mode: TransformResetMode): void;
	private _operation;
	cook(inputCoreGroups: CoreGroup[]): void;
}
declare class TubeSopParamsConfig extends NodeParamsConfig {
	/** @param top radius */
	radiusTop: ParamTemplate<ParamType.FLOAT>;
	/** @param bottom radius */
	radiusBottom: ParamTemplate<ParamType.FLOAT>;
	/** @param tube height */
	height: ParamTemplate<ParamType.FLOAT>;
	/** @param number of segments in the radial direction */
	segmentsRadial: ParamTemplate<ParamType.INTEGER>;
	/** @param number of segments in the height direction */
	segmentsHeight: ParamTemplate<ParamType.INTEGER>;
	/** @param adds caps */
	cap: ParamTemplate<ParamType.BOOLEAN>;
	/** @param center of the tube */
	center: ParamTemplate<ParamType.VECTOR3>;
	/** @param direction of the tube */
	direction: ParamTemplate<ParamType.VECTOR3>;
}
declare class TubeSopNode extends TypedSopNode<TubeSopParamsConfig> {
	paramsConfig: TubeSopParamsConfig;
	static type(): SopType;
	private _operation;
	cook(input_contents: CoreGroup[]): void;
}
declare class UvProjectSopParamsConfig extends NodeParamsConfig {
	/** @param camera node to use as projection */
	camera: ParamTemplate<ParamType.NODE_PATH>;
}
declare class UvProjectSopNode extends TypedSopNode<UvProjectSopParamsConfig> {
	paramsConfig: UvProjectSopParamsConfig;
	static type(): string;
	private _cameraController;
	private _processed_core_group;
	private _camera_object;
	initializeNode(): void;
	cook(core_groups: CoreGroup[]): void;
	_updateUVsFromCamera(look_at_target: Object3D): void;
	private _vectorInCameraSpace;
}
declare class UvTransformSopParamsConfig extends NodeParamsConfig {
	/** @param attribName */
	attribName: ParamTemplate<ParamType.STRING>;
	/** @param translate */
	t: ParamTemplate<ParamType.VECTOR2>;
	/** @param scale */
	s: ParamTemplate<ParamType.VECTOR2>;
	/** @param pivot */
	pivot: ParamTemplate<ParamType.VECTOR2>;
}
declare class UvTransformSopNode extends TypedSopNode<UvTransformSopParamsConfig> {
	paramsConfig: UvTransformSopParamsConfig;
	static type(): SopType;
	initializeNode(): void;
	private _operation;
	cook(input_contents: CoreGroup[]): void;
}
declare enum UvUnwrapMethod {
	POTPACK = 'potpack',
	XATLAS = 'xatlas',
}
declare class UvUnwrapSopParamConfig extends NodeParamsConfig {
	/** @param method */
	method: ParamTemplate<ParamType.INTEGER>;
	/** @param attribute to unwrap */
	uv: ParamTemplate<ParamType.STRING>;
}
declare class UvUnwrapSopNode extends TypedSopNode<UvUnwrapSopParamConfig> {
	paramsConfig: UvUnwrapSopParamConfig;
	static type(): SopType;
	static displayedInputNames(): string[];
	initializeNode(): void;
	private _operation;
	cook(inputCoreGroups: CoreGroup[]): Promise<void>;
	setMethod(method: UvUnwrapMethod): void;
}
declare class WebXRAREstimatedLightSopParamsConfig extends NodeParamsConfig {
	/** @param default environment map */
	/** @param apply computed environment */
	applyEnv: ParamTemplate<ParamType.BOOLEAN>;
	/** @param apply computed light Probe */
	applyLightProbe: ParamTemplate<ParamType.BOOLEAN>;
	/** @param apply computed directional Light */
	applyDirectionalLight: ParamTemplate<ParamType.BOOLEAN>;
}
declare class WebXRAREstimatedLightSopNode extends TypedSopNode<WebXRAREstimatedLightSopParamsConfig> {
	paramsConfig: WebXRAREstimatedLightSopParamsConfig;
	static type(): string;
	static displayedInputNames(): string[];
	initializeNode(): void;
	cook(inputCoreGroups: CoreGroup[]): void;
}
declare class ParamLessNetworkSopParamsConfig extends NodeParamsConfig {}
declare class BaseNetworkSopNode<K extends NodeParamsConfig> extends TypedNode<NodeContext.SOP, K> {
	static context(): NodeContext;
	cook(): void;
}
declare class ParamLessBaseNetworkSopNode extends BaseNetworkSopNode<ParamLessNetworkSopParamsConfig> {}
declare class ActorsNetworkSopNode extends ParamLessBaseNetworkSopNode {
	static type(): NetworkNodeType;
	protected _childrenControllerContext: NodeContext;
	createNode<S extends keyof JsNodeChildrenMap>(node_class: S, options?: NodeCreateOptions): JsNodeChildrenMap[S];
	createNode<K extends valueof<JsNodeChildrenMap>>(node_class: Constructor<K>, options?: NodeCreateOptions): K;
	children(): BaseJsNodeType[];
	nodesByType<K extends keyof JsNodeChildrenMap>(type: K): JsNodeChildrenMap[K][];
	childrenAllowed(): boolean;
	sceneReadonly(): boolean;
	readonly persisted_config: ActorPersistedConfig;
	assemblerController(): JsAssemblerController<JsAssemblerActor> | undefined;
	usedAssembler(): Readonly<AssemblerName.JS_ACTOR>;
	protected _assemblerController: JsAssemblerController<JsAssemblerActor> | undefined;
	private _createAssemblerController;
	readonly compilationController: ActorCompilationController;
	compile(): void;
	cook(): void;
}
declare class AnimationsNetworkSopNode extends ParamLessBaseNetworkSopNode {
	static type(): NetworkNodeType;
	protected _childrenControllerContext: NodeContext;
	createNode<S extends keyof AnimNodeChildrenMap>(node_class: S, options?: NodeCreateOptions): AnimNodeChildrenMap[S];
	createNode<K extends valueof<AnimNodeChildrenMap>>(node_class: Constructor<K>, options?: NodeCreateOptions): K;
	children(): BaseAnimNodeType[];
	nodesByType<K extends keyof AnimNodeChildrenMap>(type: K): AnimNodeChildrenMap[K][];
}
declare class AudioNetworkSopNode extends ParamLessBaseNetworkSopNode {
	static type(): NetworkNodeType;
	protected _childrenControllerContext: NodeContext;
	createNode<S extends keyof AudioNodeChildrenMap>(
		node_class: S,
		options?: NodeCreateOptions
	): AudioNodeChildrenMap[S];
	createNode<K extends valueof<AudioNodeChildrenMap>>(node_class: Constructor<K>, options?: NodeCreateOptions): K;
	children(): BaseAnimNodeType[];
	nodesByType<K extends keyof AudioNodeChildrenMap>(type: K): AudioNodeChildrenMap[K][];
}
declare class CopNetworkSopNode extends ParamLessBaseNetworkSopNode {
	static type(): NetworkNodeType;
	protected _childrenControllerContext: NodeContext;
	createNode<S extends keyof CopNodeChildrenMap>(node_class: S, options?: NodeCreateOptions): CopNodeChildrenMap[S];
	createNode<K extends valueof<CopNodeChildrenMap>>(node_class: Constructor<K>, options?: NodeCreateOptions): K;
	children(): BaseCopNodeType[];
	nodesByType<K extends keyof CopNodeChildrenMap>(type: K): CopNodeChildrenMap[K][];
}
declare class EventsNetworkSopNode extends ParamLessBaseNetworkSopNode {
	static type(): NetworkNodeType;
	protected _childrenControllerContext: NodeContext;
	createNode<S extends keyof EventNodeChildrenMap>(
		node_class: S,
		options?: NodeCreateOptions
	): EventNodeChildrenMap[S];
	createNode<K extends valueof<EventNodeChildrenMap>>(node_class: Constructor<K>, options?: NodeCreateOptions): K;
	children(): BaseEventNodeType[];
	nodesByType<K extends keyof EventNodeChildrenMap>(type: K): EventNodeChildrenMap[K][];
}
declare class MaterialsNetworkSopNode extends ParamLessBaseNetworkSopNode {
	static type(): NetworkNodeType;
	protected _childrenControllerContext: NodeContext;
	createNode<S extends keyof MatNodeChildrenMap>(node_class: S, options?: NodeCreateOptions): MatNodeChildrenMap[S];
	createNode<K extends valueof<MatNodeChildrenMap>>(node_class: Constructor<K>, options?: NodeCreateOptions): K;
	children(): BaseMatNodeType[];
	nodesByType<K extends keyof MatNodeChildrenMap>(type: K): MatNodeChildrenMap[K][];
}
declare class PostProcessNetworkSopNode extends BaseNetworkSopNode<PostProcessNetworkParamsConfig> {
	paramsConfig: PostProcessNetworkParamsConfig;
	static type(): NetworkNodeType;
	readonly effectsComposerController: EffectComposerController;
	readonly displayNodeController: DisplayNodeController;
	protected _childrenControllerContext: NodeContext;
	createNode<S extends keyof PostNodeChildrenMap>(node_class: S, options?: NodeCreateOptions): PostNodeChildrenMap[S];
	createNode<K extends valueof<PostNodeChildrenMap>>(node_class: Constructor<K>, options?: NodeCreateOptions): K;
	children(): BasePostProcessNodeType[];
	nodesByType<K extends keyof PostNodeChildrenMap>(type: K): PostNodeChildrenMap[K][];
}
declare class RenderersNetworkSopNode extends ParamLessBaseNetworkSopNode {
	static type(): NetworkNodeType;
	protected _childrenControllerContext: NodeContext;
	createNode<S extends keyof RopNodeChildrenMap>(node_class: S, options?: NodeCreateOptions): RopNodeChildrenMap[S];
	createNode<K extends valueof<RopNodeChildrenMap>>(node_class: Constructor<K>, options?: NodeCreateOptions): K;
	children(): BaseRopNodeType[];
	nodesByType<K extends keyof RopNodeChildrenMap>(type: K): RopNodeChildrenMap[K][];
}
export interface GeoNodeChildrenMap {
	actor: ActorSopNode;
	add: AddSopNode;
	ambientLight: AmbientLightSopNode;
	animationCopy: AnimationCopySopNode;
	areaLight: AreaLightSopNode;
	attribAddMult: AttribAddMultSopNode;
	attribCast: AttribCastSopNode;
	attribCopy: AttribCopySopNode;
	attribCreate: AttribCreateSopNode;
	attribDelete: AttribDeleteSopNode;
	attribFromTexture: AttribFromTextureSopNode;
	attribId: AttribIdSopNode;
	attribNormalize: AttribNormalizeSopNode;
	attribPromote: AttribPromoteSopNode;
	attribRemap: AttribRemapSopNode;
	attribRename: AttribRenameSopNode;
	attribSetAtIndex: AttribSetAtIndexSopNode;
	attribTransfer: AttribTransferSopNode;
	audioNotes: AudioNotesSopNode;
	axesHelper: AxesHelperSopNode;
	bboxScatter: BboxScatterSopNode;
	blend: BlendSopNode;
	boolean: BooleanSopNode;
	box: BoxSopNode;
	boxLines: BoxLinesSopNode;
	BVH: BVHSopNode;
	BVHVisualizer: BVHVisualizerSopNode;
	cache: CacheSopNode;
	CADBoolean: CADBooleanSopNode;
	CADBox: CADBoxSopNode;
	CADCircle: CADCircleSopNode;
	CADCircle2D: CADCircle2DSopNode;
	CADCircle3Points: CADCircle3PointsSopNode;
	CADCone: CADConeSopNode;
	CADConvertDimension: CADConvertDimensionSopNode;
	CADCurve2DToSurface: CADCurve2DToSurfaceSopNode;
	CADCurveFromPoints: CADCurveFromPointsSopNode;
	CADCurveFromPoints2D: CADCurveFromPoints2DSopNode;
	CADCurveTrim: CADCurveTrimSopNode;
	CADEllipse: CADEllipseSopNode;
	CADEllipse2D: CADEllipse2DSopNode;
	CADExporterSTEP: CADExporterSTEPSopNode;
	CADExtrude: CADExtrudeSopNode;
	CADFileSTEP: CADFileSTEPSopNode;
	CADFillet: CADFilletSopNode;
	CADGroup: CADGroupSopNode;
	CADLoft: CADLoftSopNode;
	CADMirror: CADMirrorSopNode;
	CADPipe: CADPipeSopNode;
	CADPoint: CADPointSopNode;
	CADPoint2D: CADPoint2DSopNode;
	CADPointsFromCurve: CADPointsFromCurveSopNode;
	CADRectangle: CADRectangleSopNode;
	CADRevolution: CADRevolutionSopNode;
	CADSegment: CADSegmentSopNode;
	CADSphere: CADSphereSopNode;
	CADThickness: CADThicknessSopNode;
	CADTorus: CADTorusSopNode;
	CADTransform: CADTransformSopNode;
	CADTransform2D: CADTransform2DSopNode;
	CADTriangulate: CADTriangulateSopNode;
	CADTube: CADTubeSopNode;
	CADUnpack: CADUnpackSopNode;
	CADWedge: CADWedgeSopNode;
	cameraControls: CameraControlsSopNode;
	cameraCSSRenderer: CameraCSSRendererSopNode;
	cameraFrameMode: CameraFrameModeSopNode;
	cameraPlane: CameraPlaneSopNode;
	cameraPostProcess: CameraPostProcessSopNode;
	cameraProject: CameraProjectSopNode;
	cameraRenderer: CameraRendererSopNode;
	cameraRenderScene: CameraRenderSceneSopNode;
	cameraWebXRAR: CameraWebXRARSopNode;
	cameraWebXRARMarkerTracking: CameraWebXRARMarkerTrackingSopNode;
	cameraWebXRVR: CameraWebXRVRSopNode;
	capsule: CapsuleSopNode;
	center: CenterSopNode;
	circle: CircleSopNode;
	circle3Points: Circle3PointsSopNode;
	clip: ClipSopNode;
	code: CodeSopNode;
	color: ColorSopNode;
	cone: ConeSopNode;
	convexHull: ConvexHullSopNode;
	copy: CopySopNode;
	curveFromPoints: CurveFromPointsSopNode;
	curveGetPoint: CurveGetPointSopNode;
	CSGArc: CSGArcSopNode;
	CSGBoolean: CSGBooleanSopNode;
	CSGBox: CSGBoxSopNode;
	CSGCenter: CSGCenterSopNode;
	CSGCircle: CSGCircleSopNode;
	CSGDodecahedron: CSGDodecahedronSopNode;
	CSGEllipse: CSGEllipseSopNode;
	CSGEllipsoid: CSGEllipsoidSopNode;
	CSGExpand: CSGExpandSopNode;
	CSGExtrudeLinear: CSGExtrudeLinearSopNode;
	CSGExtrudeRectangular: CSGExtrudeRectangularSopNode;
	CSGExtrudeRotate: CSGExtrudeRotateSopNode;
	CSGHull: CSGHullSopNode;
	CSGLine: CSGLineSopNode;
	CSGMirror: CSGMirrorSopNode;
	CSGOffset: CSGOffsetSopNode;
	CSGPolygon: CSGPolygonSopNode;
	CSGPolyhedron: CSGPolyhedronSopNode;
	CSGProject: CSGProjectSopNode;
	CSGRectangle: CSGRectangleSopNode;
	CSGTransformReset: CSGTransformResetSopNode;
	CSGSphere: CSGSphereSopNode;
	CSGStar: CSGStarSopNode;
	CSGTorus: CSGTorusSopNode;
	CSGTransform2D: CSGTransform2DSopNode;
	CSGTriangulate: CSGTriangulateSopNode;
	CSGTriangle: CSGTriangleSopNode;
	CSGTube: CSGTubeSopNode;
	CSGTubeElliptic: CSGTubeEllipticSopNode;
	CSS2DObject: CSS2DObjectSopNode;
	CSS3DObject: CSS3DObjectSopNode;
	data: DataSopNode;
	dataUrl: DataUrlSopNode;
	decal: DecalSopNode;
	decompose: DecomposeSopNode;
	delay: DelaySopNode;
	delete: DeleteSopNode;
	directionalLight: DirectionalLightSopNode;
	drawRange: DrawRangeSopNode;
	emptyObject: EmptyObjectSopNode;
	exporterGLTF: ExporterGLTFSopNode;
	exporterOBJ: ExporterOBJSopNode;
	exporterPLY: ExporterPLYSopNode;
	exporterSTL: ExporterSTLSopNode;
	face: FaceSopNode;
	facet: FacetSopNode;
	fileDRC: FileDRCSopNode;
	fileFBX: FileFBXSopNode;
	fileGEOJSON: FileGEOJSONSopNode;
	fileGLTF: FileGLTFSopNode;
	fileJSON: FileJSONSopNode;
	fileMPD: FileMPDSopNode;
	fileMultiGLTF: FileMultiGLTFSopNode;
	fileMultiOBJ: FileMultiOBJSopNode;
	fileOBJ: FileOBJSopNode;
	filePDB: FilePDBSopNode;
	filePLY: FilePLYSopNode;
	fileSTL: FileSTLSopNode;
	fileSVG: FileSVGSopNode;
	fileUSDZ: FileUSDZSopNode;
	fuse: FuseSopNode;
	heightMap: HeightMapSopNode;
	hexagons: HexagonsSopNode;
	hierarchy: HierarchySopNode;
	hemisphereLight: HemisphereLightSopNode;
	icosahedron: IcosahedronSopNode;
	instance: InstanceSopNode;
	instanceUpdate: InstanceUpdateSopNode;
	instancesCount: InstancesCountSopNode;
	jitter: JitterSopNode;
	layer: LayerSopNode;
	lightMixer: LightMixerSopNode;
	lightProbe: LightProbeSopNode;
	line: LineSopNode;
	lod: LodSopNode;
	lookAt: LookAtSopNode;
	mapboxCamera: MapboxCameraSopNode;
	mapboxLayer: MapboxLayerSopNode;
	mapboxPlane: MapboxPlaneSopNode;
	mapboxTransform: MapboxTransformSopNode;
	material: MaterialSopNode;
	materialProperties: MaterialPropertiesSopNode;
	merge: MergeSopNode;
	metaball: MetaballSopNode;
	noise: NoiseSopNode;
	normals: NormalsSopNode;
	normalsHelper: NormalsHelperSopNode;
	null: NullSopNode;
	objectMerge: ObjectMergeSopNode;
	objectProperties: ObjectPropertiesSopNode;
	objectsLayout: ObjectsLayoutSopNode;
	oceanPlane: OceanPlaneSopNode;
	operationsComposer: OperationsComposerSopNode;
	orthographicCamera: OrthographicCameraSopNode;
	palette: PaletteSopNode;
	particlesSystemGpu: ParticlesSystemGpuSopNode;
	peak: PeakSopNode;
	perspectiveCamera: PerspectiveCameraSopNode;
	physicsGround: PhysicsGroundSopNode;
	physicsPlayer: PhysicsPlayerSopNode;
	physicsRBDJoints: PhysicsRBDJointsSopNode;
	physicsRBDAttributes: PhysicsRBDAttributesSopNode;
	physicsWorld: PhysicsWorldSopNode;
	plane: PlaneSopNode;
	planeHelper: PlaneHelperSopNode;
	point: PointSopNode;
	pointLight: PointLightSopNode;
	polarTransform: PolarTransformSopNode;
	polywire: PolywireSopNode;
	ray: RaySopNode;
	reflector: ReflectorSopNode;
	resample: ResampleSopNode;
	restAttributes: RestAttributesSopNode;
	ring: RingSopNode;
	roundedBox: RoundedBoxSopNode;
	scatter: ScatterSopNode;
	SDFBuilder: SDFBuilderSopNode;
	setChildren: SetChildrenSopNode;
	setGeometry: SetGeometrySopNode;
	shear: ShearSopNode;
	skin: SkinSopNode;
	skeletonHelper: SkeletonHelperSopNode;
	solver: SolverSopNode;
	solverPreviousFrame: SolverPreviousFrameSopNode;
	sort: SortSopNode;
	sphere: SphereSopNode;
	split: SplitSopNode;
	spotLight: SpotLightSopNode;
	subdivide: SubdivideSopNode;
	subnet: SubnetSopNode;
	subnetInput: SubnetInputSopNode;
	subnetOutput: SubnetOutputSopNode;
	switch: SwitchSopNode;
	tangent: TangentSopNode;
	tetrahedron: TetrahedronSopNode;
	text: TextSopNode;
	textureCopy: TextureCopySopNode;
	textureProperties: TexturePropertiesSopNode;
	torus: TorusSopNode;
	torusKnot: TorusKnotSopNode;
	trackingLandmarksFace: TrackingLandmarksFaceSopNode;
	trackingLandmarksFaceAttributes: TrackingLandmarksFaceAttributesSopNode;
	trackingLandmarksHand: TrackingLandmarksHandSopNode;
	trackingLandmarksHandAttributes: TrackingLandmarksHandAttributesSopNode;
	transform: TransformSopNode;
	transformCopy: TransformCopySopNode;
	transformMulti: TransformMultiSopNode;
	transformReset: TransformResetSopNode;
	tube: TubeSopNode;
	uvLayout: UvProjectSopNode;
	uvProject: UvProjectSopNode;
	uvTransform: UvTransformSopNode;
	uvUnwrap: UvUnwrapSopNode;
	webXRAREstimatedLight: WebXRAREstimatedLightSopNode;
	actorsNetwork: ActorsNetworkSopNode;
	animationsNetwork: AnimationsNetworkSopNode;
	audioNetwork: AudioNetworkSopNode;
	copNetwork: CopNetworkSopNode;
	eventsNetwork: EventsNetworkSopNode;
	materialsNetwork: MaterialsNetworkSopNode;
	postProcessNetwork: PostProcessNetworkSopNode;
	renderersNetwork: RenderersNetworkSopNode;
}
declare const TesselationParamParamsConfig_base: {
	new (...args: any[]): {
		SDFFacetAngle: ParamTemplate<ParamType.FLOAT>;
		SDFMeshesColor: ParamTemplate<ParamType.COLOR>;
		SDFWireframe: ParamTemplate<ParamType.BOOLEAN>;
		SDF: ParamTemplate<ParamType.FOLDER>;
		CSGFacetAngle: ParamTemplate<ParamType.FLOAT>;
		CSGLinesColor: ParamTemplate<ParamType.COLOR>;
		CSGMeshesColor: ParamTemplate<ParamType.COLOR>;
		CSGWireframe: ParamTemplate<ParamType.BOOLEAN>;
		CSG: ParamTemplate<ParamType.FOLDER>;
		CADLinearTolerance: ParamTemplate<ParamType.FLOAT>;
		CADAngularTolerance: ParamTemplate<ParamType.FLOAT>;
		CADCurveAbscissa: ParamTemplate<ParamType.FLOAT>;
		CADCurveTolerance: ParamTemplate<ParamType.FLOAT>;
		CADDisplayEdges: ParamTemplate<ParamType.BOOLEAN>;
		CADEdgesColor: ParamTemplate<ParamType.COLOR>;
		CADDisplayMeshes: ParamTemplate<ParamType.BOOLEAN>;
		CADMeshesColor: ParamTemplate<ParamType.COLOR>;
		CADWireframe: ParamTemplate<ParamType.BOOLEAN>;
		CAD: ParamTemplate<ParamType.FOLDER>;
	};
} & typeof NodeParamsConfig;
declare class TesselationParamParamsConfig extends TesselationParamParamsConfig_base {}
declare class TesselationParamsObjNode extends TypedObjNode<Object3D, TesselationParamParamsConfig> {}
export interface BaseObjNodeClassWithDisplayNode extends TesselationParamsObjNode {
	displayNodeController: DisplayNodeController;
}
declare class ChildrenDisplayControllerSpecialized extends ChildrenDisplayController {
	protected node: BaseObjNodeClassWithDisplayNode;
	constructor(node: BaseObjNodeClassWithDisplayNode);
	_addSpecializedObjects(displayNode: BaseSopNodeType, coreGroup: CoreGroup, newObjects: Object3D[]): void;
}
declare const GeoObjParamConfig_base: {
	new (...args: any[]): {
		SDFFacetAngle: ParamTemplate<ParamType.FLOAT>;
		SDFMeshesColor: ParamTemplate<ParamType.COLOR>;
		SDFWireframe: ParamTemplate<ParamType.BOOLEAN>;
		SDF: ParamTemplate<ParamType.FOLDER>;
		CSGFacetAngle: ParamTemplate<ParamType.FLOAT>;
		CSGLinesColor: ParamTemplate<ParamType.COLOR>;
		CSGMeshesColor: ParamTemplate<ParamType.COLOR>;
		CSGWireframe: ParamTemplate<ParamType.BOOLEAN>;
		CSG: ParamTemplate<ParamType.FOLDER>;
		CADLinearTolerance: ParamTemplate<ParamType.FLOAT>;
		CADAngularTolerance: ParamTemplate<ParamType.FLOAT>;
		CADCurveAbscissa: ParamTemplate<ParamType.FLOAT>;
		CADCurveTolerance: ParamTemplate<ParamType.FLOAT>;
		CADDisplayEdges: ParamTemplate<ParamType.BOOLEAN>;
		CADEdgesColor: ParamTemplate<ParamType.COLOR>;
		CADDisplayMeshes: ParamTemplate<ParamType.BOOLEAN>;
		CADMeshesColor: ParamTemplate<ParamType.COLOR>;
		CADWireframe: ParamTemplate<ParamType.BOOLEAN>;
		CAD: ParamTemplate<ParamType.FOLDER>;
	};
} & {
	new (...args: any[]): {
		/** @param toggle off to hide */
		display: ParamTemplate<ParamType.BOOLEAN>;
		/** @param set render order */
		renderOrder: ParamTemplate<ParamType.INTEGER>;
	};
} & {
	new (...args: any[]): {
		transform: ParamTemplate<ParamType.FOLDER>;
		keepPosWhenParenting: ParamTemplate<ParamType.BOOLEAN>;
		rotationOrder: ParamTemplate<ParamType.INTEGER>;
		t: ParamTemplate<ParamType.VECTOR3>;
		r: ParamTemplate<ParamType.VECTOR3>;
		s: ParamTemplate<ParamType.VECTOR3>;
		scale: ParamTemplate<ParamType.FLOAT>;
		matrixAutoUpdate: ParamTemplate<ParamType.BOOLEAN>;
		updateTransformFromObject: ParamTemplate<ParamType.BUTTON>;
	};
} & typeof NodeParamsConfig;
declare class GeoObjParamConfig extends GeoObjParamConfig_base {}
declare class GeoObjNode extends TypedObjNode<Group, GeoObjParamConfig> {
	paramsConfig: GeoObjParamConfig;
	static type(): ObjType;
	readonly hierarchyController: HierarchyController;
	readonly transformController: TransformController;
	readonly flags: FlagsControllerD;
	createObject(): Group;
	readonly childrenDisplayController: ChildrenDisplayControllerSpecialized;
	readonly displayNodeController: DisplayNodeController;
	protected _childrenControllerContext: NodeContext;
	private _onChildAddBound;
	initializeNode(): void;
	createNode<S extends keyof GeoNodeChildrenMap>(node_class: S, options?: NodeCreateOptions): GeoNodeChildrenMap[S];
	createNode<K extends valueof<GeoNodeChildrenMap>>(node_class: Constructor<K>, options?: NodeCreateOptions): K;
	children(): BaseSopNodeType[];
	nodesByType<K extends keyof GeoNodeChildrenMap>(type: K): GeoNodeChildrenMap[K][];
	private _onChildAdd;
	cook(): void;
}
declare const NullObjParamConfig_base: {
	new (...args: any[]): {
		transform: ParamTemplate<ParamType.FOLDER>;
		keepPosWhenParenting: ParamTemplate<ParamType.BOOLEAN>;
		rotationOrder: ParamTemplate<ParamType.INTEGER>;
		t: ParamTemplate<ParamType.VECTOR3>;
		r: ParamTemplate<ParamType.VECTOR3>;
		s: ParamTemplate<ParamType.VECTOR3>;
		scale: ParamTemplate<ParamType.FLOAT>;
		matrixAutoUpdate: ParamTemplate<ParamType.BOOLEAN>;
		updateTransformFromObject: ParamTemplate<ParamType.BUTTON>;
	};
} & typeof NodeParamsConfig;
declare class NullObjParamConfig extends NullObjParamConfig_base {}
declare class NullObjNode extends TypedObjNode<Group, NullObjParamConfig> {
	paramsConfig: NullObjParamConfig;
	static type(): string;
	readonly hierarchyController: HierarchyController;
	readonly transformController: TransformController;
	readonly flags: FlagsControllerD;
	private _helper;
	createObject(): Group;
	initializeNode(): void;
	private _updateHelperHierarchy;
	cook(): void;
}
declare class PolarTransformObjParamConfig extends NodeParamsConfig {
	/** @param center of the transform */
	center: ParamTemplate<ParamType.VECTOR3>;
	/** @param moves the objects along the longitude, which is equivalent to a rotation on the y axis */
	longitude: ParamTemplate<ParamType.FLOAT>;
	/** @param moves the objects along the latitude, which is equivalent to a rotation on the z or x axis */
	latitude: ParamTemplate<ParamType.FLOAT>;
	/** @param moves the point aways from the center */
	depth: ParamTemplate<ParamType.FLOAT>;
}
declare class PolarTransformObjNode extends TypedObjNode<Group, PolarTransformObjParamConfig> {
	paramsConfig: PolarTransformObjParamConfig;
	static type(): string;
	readonly hierarchyController: HierarchyController;
	readonly flags: FlagsControllerD;
	private _helper;
	createObject(): Group;
	initializeNode(): void;
	private _updateHelperHierarchy;
	private _displayedHelper;
	private __axisHelper__;
	private _axisHelper;
	private _createAxisHelper;
	private __polarGridHelper__;
	private _polarGridHelper;
	private _createPolarGridHelper;
	private _createHelper;
	private _cook_main_without_inputs_when_dirty_bound;
	private _cook_main_without_inputs_when_dirty;
	private _centerMatrix;
	private _longitudeMatrix;
	private _latitudeMatrix;
	private _depthMatrix;
	private _fullMatrix;
	private _decomposed;
	cook(): void;
	private _updateHelper;
}
declare const PositionalAudioParamConfig_base: {
	new (...args: any[]): {
		transform: ParamTemplate<ParamType.FOLDER>;
		keepPosWhenParenting: ParamTemplate<ParamType.BOOLEAN>;
		rotationOrder: ParamTemplate<ParamType.INTEGER>;
		t: ParamTemplate<ParamType.VECTOR3>;
		r: ParamTemplate<ParamType.VECTOR3>;
		s: ParamTemplate<ParamType.VECTOR3>;
		scale: ParamTemplate<ParamType.FLOAT>;
		matrixAutoUpdate: ParamTemplate<ParamType.BOOLEAN>;
		updateTransformFromObject: ParamTemplate<ParamType.BUTTON>;
	};
} & typeof NodeParamsConfig;
declare class PositionalAudioParamConfig extends PositionalAudioParamConfig_base {
	audio: ParamTemplate<ParamType.FOLDER>;
	/** @param audio node */
	audioNode: ParamTemplate<ParamType.NODE_PATH>;
	/** @param refDistance. See https://developer.mozilla.org/en-US/docs/Web/API/PannerNode/refDistance*/
	refDistance: ParamTemplate<ParamType.FLOAT>;
	/** @param rolloffFactor. See https://developer.mozilla.org/en-US/docs/Web/API/PannerNode/rolloffFactor */
	rolloffFactor: ParamTemplate<ParamType.FLOAT>;
	/** @param maxDistance. See https://developer.mozilla.org/en-US/docs/Web/API/PannerNode/maxDistance */
	maxDistance: ParamTemplate<ParamType.FLOAT>;
	/** @param distanceModel. See https://developer.mozilla.org/en-US/docs/Web/API/PannerNode/distanceModel */
	distanceModel: ParamTemplate<ParamType.INTEGER>;
	/** @param coneInnerAngle. See https://developer.mozilla.org/en-US/docs/Web/API/PannerNode */
	coneInnerAngle: ParamTemplate<ParamType.FLOAT>;
	/** @param coneOuterAngle. See https://developer.mozilla.org/en-US/docs/Web/API/PannerNode */
	coneOuterAngle: ParamTemplate<ParamType.FLOAT>;
	/** @param coneOuterGain. See https://developer.mozilla.org/en-US/docs/Web/API/PannerNode */
	coneOuterGain: ParamTemplate<ParamType.FLOAT>;
	/** @param ensures the transform of the audio listener is updated on very frame */
	listenerTransformAutoUpdate: ParamTemplate<ParamType.BOOLEAN>;
	/** @param show helper */
	showHelper: ParamTemplate<ParamType.BOOLEAN>;
	/** @param helper size */
	helperSize: ParamTemplate<ParamType.FLOAT>;
}
declare class PositionalAudioObjNode extends TypedObjNode<Group, PositionalAudioParamConfig> {
	paramsConfig: PositionalAudioParamConfig;
	static type(): ObjType;
	readonly hierarchyController: HierarchyController;
	readonly transformController: TransformController;
	readonly flags: FlagsControllerD;
	private _positionalAudio;
	private _helper;
	createObject(): Group;
	initializeNode(): void;
	private _updateToDestination;
	private _updateHelperHierarchy;
	cook(): Promise<void>;
	private _updatePositionalAudio;
	private _createHelper;
	private _resetAudioNode;
	private _connectAudioNode;
	static PARAM_CALLBACK_updatePositionalAudio(node: PositionalAudioObjNode): void;
	protected _childrenControllerContext: NodeContext;
	createNode<S extends keyof AudioNodeChildrenMap>(
		node_class: S,
		options?: NodeCreateOptions
	): AudioNodeChildrenMap[S];
	createNode<K extends valueof<AudioNodeChildrenMap>>(node_class: Constructor<K>, options?: NodeCreateOptions): K;
	children(): BaseAudioNodeType[];
	nodesByType<K extends keyof AudioNodeChildrenMap>(type: K): AudioNodeChildrenMap[K][];
}
declare class RivetObjParamConfig extends NodeParamsConfig {
	object: ParamTemplate<ParamType.NODE_PATH>;
	pointIndex: ParamTemplate<ParamType.INTEGER>;
	updateMode: ParamTemplate<ParamType.INTEGER>;
	update: ParamTemplate<ParamType.BUTTON>;
}
declare class RivetObjNode extends TypedObjNode<Mesh, RivetObjParamConfig> {
	paramsConfig: RivetObjParamConfig;
	static type(): Readonly<'rivet'>;
	readonly hierarchyController: HierarchyController;
	readonly flags: FlagsControllerD;
	private _helper;
	private _resolvedSopGroup;
	private _found_point_post;
	createObject(): Mesh<BufferGeometry, Material | Material[]>;
	initializeNode(): void;
	private _updateHelperHierarchy;
	cook(): Promise<void>;
	private _updateRenderHook;
	private _addRenderHook;
	private _removeRenderHook;
	private _on_object_before_render_bound;
	private _update;
	static PARAM_CALLBACK_update_resolved_object(node: RivetObjNode): void;
	private _update_resolved_object;
	private _resolvedObject;
	static PARAM_CALLBACK_update_updateMode(node: RivetObjNode): void;
	static PARAM_CALLBACK_update(node: RivetObjNode): void;
}
declare class SceneAutoUpdateController {
	protected node: RootManagerNode;
	constructor(node: RootManagerNode);
	update(): Promise<void>;
	static update(node: RootManagerNode): Promise<void>;
}
declare enum BackgroundMode {
	NONE = 'none',
	COLOR = 'color',
	TEXTURE = 'texture',
}
declare class SceneBackgroundController {
	protected node: RootManagerNode;
	constructor(node: RootManagerNode);
	addHooks(): void;
	setMode(mode: BackgroundMode): void;
	backgroundMode(): BackgroundMode;
	private _updateBound;
	update(): Promise<void>;
	private _setBackgroundNone;
	private _setBackgroundColor;
	private _setBackgroundTexture;
	static update(node: RootManagerNode): void;
}
declare class SceneEnvController {
	protected node: RootManagerNode;
	constructor(node: RootManagerNode);
	addHooks(): void;
	private _updateBound;
	update(): Promise<void>;
	static update(node: RootManagerNode): Promise<void>;
}
declare const SceneFogParamsConfig_base: {
	new (...args: any[]): {
		/** @param toggle on to use fog */
		useFog: ParamTemplate<ParamType.BOOLEAN>;
		/** @param fog type */
		fogType: ParamTemplate<ParamType.INTEGER>;
		/** @param fog color */
		fogColor: ParamTemplate<ParamType.COLOR>;
		/** @param fog near */
		fogNear: ParamTemplate<ParamType.FLOAT>;
		/** @param fog far */
		fogFar: ParamTemplate<ParamType.FLOAT>;
		/** @param fog density */
		fogDensity: ParamTemplate<ParamType.FLOAT>;
	};
} & typeof NodeParamsConfig;
declare class SceneFogParamsConfig extends SceneFogParamsConfig_base {}
declare class SceneFogController {
	protected node: RootManagerNode;
	constructor(node: RootManagerNode);
	private _fog;
	private _fogExp2;
	update(): Promise<void>;
	fog2(pv: ParamsValueAccessorType<SceneFogParamsConfig>): Fog;
	fogExp2(pv: ParamsValueAccessorType<SceneFogParamsConfig>): FogExp2;
	static update(node: RootManagerNode): Promise<void>;
}
declare class SceneMaterialOverrideController {
	protected node: RootManagerNode;
	constructor(node: RootManagerNode);
	update(): Promise<void>;
	static update(node: RootManagerNode): Promise<void>;
}
declare const SceneObjParamConfig_base: {
	new (...args: any[]): {
		useOverrideMaterial: ParamTemplate<ParamType.BOOLEAN>;
		overrideMaterial: ParamTemplate<ParamType.NODE_PATH>;
	};
} & {
	new (...args: any[]): {
		useFog: ParamTemplate<ParamType.BOOLEAN>;
		fogType: ParamTemplate<ParamType.INTEGER>;
		fogColor: ParamTemplate<ParamType.COLOR>;
		fogNear: ParamTemplate<ParamType.FLOAT>;
		fogFar: ParamTemplate<ParamType.FLOAT>;
		fogDensity: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		useEnvironment: ParamTemplate<ParamType.BOOLEAN>;
		environment: ParamTemplate<ParamType.NODE_PATH>;
	};
} & {
	new (...args: any[]): {
		backgroundMode: ParamTemplate<ParamType.INTEGER>;
		bgColor: ParamTemplate<ParamType.COLOR>;
		bgTexture: ParamTemplate<ParamType.NODE_PATH>;
		bgBlur: ParamTemplate<ParamType.FLOAT>;
		bgIntensity: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		autoUpdate: ParamTemplate<ParamType.BOOLEAN>;
	};
} & typeof NodeParamsConfig;
declare class SceneObjParamConfig extends SceneObjParamConfig_base {}
declare class SceneObjNode extends TypedObjNode<Scene, SceneObjParamConfig> {
	paramsConfig: SceneObjParamConfig;
	static type(): Readonly<ObjType.SCENE>;
	readonly hierarchyController: HierarchyController;
	createObject(): Scene;
	initializeNode(): void;
	private _cook_main_without_inputs_when_dirty_bound;
	private _cook_main_without_inputs_when_dirty;
	readonly sceneAutoUpdateController: SceneAutoUpdateController;
	readonly sceneBackgroundController: SceneBackgroundController;
	readonly sceneEnvController: SceneEnvController;
	readonly sceneFogController: SceneFogController;
	readonly sceneMaterialOverrideController: SceneMaterialOverrideController;
	cook(): void;
}
declare class LayersController {
	private node;
	constructor(node: BaseObjNodeType);
	update(): void;
}
export interface ThreejsViewerOptions<C extends Camera> extends TypedViewerOptions<C> {}
declare class ThreejsViewer<C extends Camera> extends TypedViewer<C> {
	private _requestAnimationFrameId;
	private _webXRConfig;
	private _markerTrackingConfig;
	private _renderer;
	private _rendererConfig;
	private _renderFunc;
	private _renderCSSFunc;
	private _cssRendererConfig;
	private _effectComposer;
	private _errorMessage;
	static _canvasIdPrefix(): string;
	constructor(options: ThreejsViewerOptions<C>);
	private _setupFunctions;
	/**
	 * mounts the viewer onto an element
	 *
	 *
	 */
	mount(element: HTMLElement): void;
	_build(): void;
	/**
	 * disposes the viewer
	 *
	 *
	 */
	dispose(): void;
	private _setEvents;
	private _disposeEvents;
	private _onResizeBound;
	onResize(): void;
	private _initDisplay;
	/**
	 * setAutoRender to false will stop the rendering. This can be useful if you know that nothing has changed in the scene, or if the renderer is currently not visible.
	 *
	 *
	 */
	setAutoRender(state?: boolean): void;
	isXR(): boolean;
	private _startAnimate;
	private _cancelAnimate;
	private _animateWebBound;
	private _animateWeb;
	private _animateWebXR;
	private __animateCommon__;
	private _cancelAnimateCommon;
	render(delta: number): void;
	/**
	 * returns the current renderer
	 *
	 *
	 */
	renderer(): AbstractRenderer | undefined;
	effectComposer(): EffectComposer | undefined;
	preCompile(): void;
	markAsReady(): void;
}
export interface OrthoOrPerspCamera extends Camera {
	near: number;
	far: number;
	updateProjectionMatrix: () => void;
	getFocalLength?: () => void;
}
declare const BaseCameraObjParamsConfig_base: {
	new (...args: any[]): {
		setMainCamera: ParamTemplate<ParamType.BUTTON>;
	};
} & typeof NodeParamsConfig;
declare class BaseCameraObjParamsConfig extends BaseCameraObjParamsConfig_base {}
declare const BaseThreejsCameraObjParamsConfig_base: {
	new (...args: any[]): {
		doPostProcess: ParamTemplate<ParamType.BOOLEAN>;
		postProcessNode: ParamTemplate<ParamType.NODE_PATH>;
	};
} & {
	new (...args: any[]): {
		render: ParamTemplate<ParamType.FOLDER>;
		setScene: ParamTemplate<ParamType.BOOLEAN>;
		scene: ParamTemplate<ParamType.NODE_PATH>;
		setRenderer: ParamTemplate<ParamType.BOOLEAN>;
		renderer: ParamTemplate<ParamType.NODE_PATH>;
		setCSSRenderer: ParamTemplate<ParamType.BOOLEAN>;
		CSSRenderer: ParamTemplate<ParamType.NODE_PATH>;
	};
} & {
	new (...args: any[]): {
		frameMode: ParamTemplate<ParamType.INTEGER>;
		expectedAspectRatio: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		transform: ParamTemplate<ParamType.FOLDER>;
		keepPosWhenParenting: ParamTemplate<ParamType.BOOLEAN>;
		rotationOrder: ParamTemplate<ParamType.INTEGER>;
		t: ParamTemplate<ParamType.VECTOR3>;
		r: ParamTemplate<ParamType.VECTOR3>;
		s: ParamTemplate<ParamType.VECTOR3>;
		scale: ParamTemplate<ParamType.FLOAT>;
		matrixAutoUpdate: ParamTemplate<ParamType.BOOLEAN>;
		updateTransformFromObject: ParamTemplate<ParamType.BUTTON>;
	};
} & {
	new (...args: any[]): {
		layer: ParamTemplate<ParamType.INTEGER>;
	};
} & {
	new (...args: any[]): {
		camera: ParamTemplate<ParamType.FOLDER>;
		/** @param controls node to allow the camera to be moved by user input */
		controls: ParamTemplate<ParamType.NODE_PATH>;
		/** @param define when the camera node transform parameters are updated after the controls have moved the internal camera object */
		updateFromControlsMode: ParamTemplate<ParamType.INTEGER>;
		/** @param near */
		near: ParamTemplate<ParamType.FLOAT>;
		/** @param far */
		far: ParamTemplate<ParamType.FLOAT>;
		/** @param display */
		display: ParamTemplate<ParamType.BOOLEAN>;
		/** @param show helper */
		showHelper: ParamTemplate<ParamType.BOOLEAN>;
	};
} & {
	new (...args: any[]): {
		setMainCamera: ParamTemplate<ParamType.BUTTON>;
	};
} & typeof NodeParamsConfig;
declare class BaseThreejsCameraObjParamsConfig extends BaseThreejsCameraObjParamsConfig_base {}
export interface BaseViewerOptions {
	element?: HTMLElement;
}
declare abstract class TypedCameraObjNode<
	O extends OrthoOrPerspCamera,
	K extends BaseCameraObjParamsConfig
> extends TypedObjNode<O, K> {
	readonly renderOrder: number;
	protected _object: O;
	protected _aspect: number;
	get object(): O;
	cook(): Promise<void>;
	camera(): O;
	updateCamera(): void;
	static PARAM_CALLBACK_setMainCamera(node: BaseCameraObjNodeType): void;
	setAsMainCamera(): void;
	setupForAspectRatio(aspect: number): void;
	update_transform_params_from_object(): void;
	abstract createViewer(options?: BaseViewerOptions | HTMLElement): Promise<BaseViewerType | undefined>;
	static PARAM_CALLBACK_update_from_param(node: BaseCameraObjNodeType, param: BaseParamType): void;
}
declare class TypedThreejsCameraObjNode<
	O extends OrthoOrPerspCamera,
	K extends BaseThreejsCameraObjParamsConfig
> extends TypedCameraObjNode<O, K> {
	readonly flags: FlagsControllerD;
	readonly hierarchyController: HierarchyController;
	readonly transformController: TransformController;
	protected __layersController__: LayersController | undefined;
	private _layersController;
	readonly childrenDisplayController: ChildrenDisplayController;
	readonly displayNodeController: DisplayNodeController;
	protected _childrenControllerContext: NodeContext;
	initializeBaseNode(): void;
	createNode<S extends keyof GeoNodeChildrenMap>(node_class: S, options?: NodeCreateOptions): GeoNodeChildrenMap[S];
	createNode<K extends valueof<GeoNodeChildrenMap>>(node_class: Constructor<K>, options?: NodeCreateOptions): K;
	children(): BaseSopNodeType[];
	nodesByType<K extends keyof GeoNodeChildrenMap>(type: K): GeoNodeChildrenMap[K][];
	cook(): Promise<void>;
	static PARAM_CALLBACK_update_near_far_from_param(node: BaseThreejsCameraObjNodeType, param: BaseParamType): void;
	updateNearFar(): void;
	createViewer(options?: BaseViewerOptions | HTMLElement): Promise<ThreejsViewer<Camera> | undefined>;
	private _helper;
	initHelperHook(): void;
	helperVisible(): boolean;
	private _createHelper;
	_updateHelper(): void;
}
export declare type BaseCameraObjNodeType = TypedCameraObjNode<OrthoOrPerspCamera, BaseCameraObjParamsConfig>;
export declare type BaseThreejsCameraObjNodeType = TypedThreejsCameraObjNode<
	OrthoOrPerspCamera,
	BaseThreejsCameraObjParamsConfig
>;
declare const OrthographicCameraObjParamConfig_base: {
	new (...args: any[]): {
		doPostProcess: ParamTemplate<ParamType.BOOLEAN>;
		postProcessNode: ParamTemplate<ParamType.NODE_PATH>;
	};
} & {
	new (...args: any[]): {
		render: ParamTemplate<ParamType.FOLDER>;
		setScene: ParamTemplate<ParamType.BOOLEAN>;
		scene: ParamTemplate<ParamType.NODE_PATH>;
		setRenderer: ParamTemplate<ParamType.BOOLEAN>;
		renderer: ParamTemplate<ParamType.NODE_PATH>;
		setCSSRenderer: ParamTemplate<ParamType.BOOLEAN>;
		CSSRenderer: ParamTemplate<ParamType.NODE_PATH>;
	};
} & {
	new (...args: any[]): {
		layer: ParamTemplate<ParamType.INTEGER>;
	};
} & {
	new (...args: any[]): {
		setMainCamera: ParamTemplate<ParamType.BUTTON>;
	};
} & {
	new (...args: any[]): {
		frameMode: ParamTemplate<ParamType.INTEGER>;
		expectedAspectRatio: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		size: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		camera: ParamTemplate<ParamType.FOLDER>;
		controls: ParamTemplate<ParamType.NODE_PATH>;
		updateFromControlsMode: ParamTemplate<ParamType.INTEGER>;
		near: ParamTemplate<ParamType.FLOAT>;
		far: ParamTemplate<ParamType.FLOAT>;
		display: ParamTemplate<ParamType.BOOLEAN>;
		showHelper: ParamTemplate<ParamType.BOOLEAN>;
	};
} & {
	new (...args: any[]): {
		transform: ParamTemplate<ParamType.FOLDER>;
		keepPosWhenParenting: ParamTemplate<ParamType.BOOLEAN>;
		rotationOrder: ParamTemplate<ParamType.INTEGER>;
		t: ParamTemplate<ParamType.VECTOR3>;
		r: ParamTemplate<ParamType.VECTOR3>;
		s: ParamTemplate<ParamType.VECTOR3>;
		scale: ParamTemplate<ParamType.FLOAT>;
		matrixAutoUpdate: ParamTemplate<ParamType.BOOLEAN>;
		updateTransformFromObject: ParamTemplate<ParamType.BUTTON>;
	};
} & typeof NodeParamsConfig;
declare class OrthographicCameraObjParamConfig extends OrthographicCameraObjParamConfig_base {}
declare class OrthographicCameraObjNode extends TypedThreejsCameraObjNode<
	OrthographicCamera,
	OrthographicCameraObjParamConfig
> {
	paramsConfig: OrthographicCameraObjParamConfig;
	static type(): Readonly<CameraNodeType.ORTHOGRAPHIC>;
	static onRegister: OnNodeRegisterCallback;
	createObject(): OrthographicCamera;
	updateCamera(): void;
}
declare const PerspectiveCameraObjParamConfig_base: {
	new (...args: any[]): {
		useWebXR: ParamTemplate<ParamType.BOOLEAN>;
		useAR: ParamTemplate<ParamType.BOOLEAN>;
		useVR: ParamTemplate<ParamType.BOOLEAN>;
	};
} & {
	new (...args: any[]): {
		doPostProcess: ParamTemplate<ParamType.BOOLEAN>;
		postProcessNode: ParamTemplate<ParamType.NODE_PATH>;
	};
} & {
	new (...args: any[]): {
		render: ParamTemplate<ParamType.FOLDER>;
		setScene: ParamTemplate<ParamType.BOOLEAN>;
		scene: ParamTemplate<ParamType.NODE_PATH>;
		setRenderer: ParamTemplate<ParamType.BOOLEAN>;
		renderer: ParamTemplate<ParamType.NODE_PATH>;
		setCSSRenderer: ParamTemplate<ParamType.BOOLEAN>;
		CSSRenderer: ParamTemplate<ParamType.NODE_PATH>;
	};
} & {
	new (...args: any[]): {
		layer: ParamTemplate<ParamType.INTEGER>;
	};
} & {
	new (...args: any[]): {
		setMainCamera: ParamTemplate<ParamType.BUTTON>;
	};
} & {
	new (...args: any[]): {
		frameMode: ParamTemplate<ParamType.INTEGER>;
		expectedAspectRatio: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		fov: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		camera: ParamTemplate<ParamType.FOLDER>;
		controls: ParamTemplate<ParamType.NODE_PATH>;
		updateFromControlsMode: ParamTemplate<ParamType.INTEGER>;
		near: ParamTemplate<ParamType.FLOAT>;
		far: ParamTemplate<ParamType.FLOAT>;
		display: ParamTemplate<ParamType.BOOLEAN>;
		showHelper: ParamTemplate<ParamType.BOOLEAN>;
	};
} & {
	new (...args: any[]): {
		transform: ParamTemplate<ParamType.FOLDER>;
		keepPosWhenParenting: ParamTemplate<ParamType.BOOLEAN>;
		rotationOrder: ParamTemplate<ParamType.INTEGER>;
		t: ParamTemplate<ParamType.VECTOR3>;
		r: ParamTemplate<ParamType.VECTOR3>;
		s: ParamTemplate<ParamType.VECTOR3>;
		scale: ParamTemplate<ParamType.FLOAT>;
		matrixAutoUpdate: ParamTemplate<ParamType.BOOLEAN>;
		updateTransformFromObject: ParamTemplate<ParamType.BUTTON>;
	};
} & typeof NodeParamsConfig;
declare class PerspectiveCameraObjParamConfig extends PerspectiveCameraObjParamConfig_base {}
declare class PerspectiveCameraObjNode extends TypedThreejsCameraObjNode<
	PerspectiveCamera,
	PerspectiveCameraObjParamConfig
> {
	paramsConfig: PerspectiveCameraObjParamConfig;
	static type(): Readonly<CameraNodeType.PERSPECTIVE>;
	static onRegister: OnNodeRegisterCallback;
	createObject(): PerspectiveCamera;
	updateCamera(): void;
}
declare const CubeCameraObjParamsConfig_base: {
	new (...args: any[]): {
		main: ParamTemplate<ParamType.FOLDER>;
		/** @param render resolution of each of the 6 faces */
		resolution: ParamTemplate<ParamType.INTEGER>;
		/** @param objects to exclude in the render */
		excludedObjects: ParamTemplate<ParamType.STRING>;
		/** @param object masks to select what will be visible in the scene */
		printResolve: ParamTemplate<ParamType.BUTTON>;
		/** @param camera near */
		near: ParamTemplate<ParamType.FLOAT>;
		/** @param camera far */
		far: ParamTemplate<ParamType.FLOAT>;
		/** @param render button */
		render: ParamTemplate<ParamType.BUTTON>;
		renderTarget: ParamTemplate<ParamType.FOLDER>;
		/** @param toggle on to allow updating the texture encoding */
		tencoding: ParamTemplate<ParamType.BOOLEAN>;
		/** @param sets the texture encoding */
		encoding: ParamTemplate<ParamType.INTEGER>;
		/** @param toggle on to allow updating the texture min filter */
		tminFilter: ParamTemplate<ParamType.BOOLEAN>;
		/** @param sets the texture min filter. Nearest is currently recommended to be supported on all devices. */
		minFilter: ParamTemplate<ParamType.INTEGER>;
		/** @param toggle on to allow updating the texture mag filter */
		tmagFilter: ParamTemplate<ParamType.BOOLEAN>;
		/** @param sets the texture mag filter. Nearest is currently recommended to be supported on all devices. */
		magFilter: ParamTemplate<ParamType.INTEGER>;
	};
} & {
	new (...args: any[]): {
		transform: ParamTemplate<ParamType.FOLDER>;
		keepPosWhenParenting: ParamTemplate<ParamType.BOOLEAN>;
		rotationOrder: ParamTemplate<ParamType.INTEGER>;
		t: ParamTemplate<ParamType.VECTOR3>;
		r: ParamTemplate<ParamType.VECTOR3>;
		s: ParamTemplate<ParamType.VECTOR3>;
		scale: ParamTemplate<ParamType.FLOAT>;
		matrixAutoUpdate: ParamTemplate<ParamType.BOOLEAN>;
		updateTransformFromObject: ParamTemplate<ParamType.BUTTON>;
	};
} & typeof NodeParamsConfig;
declare class CubeCameraObjParamsConfig extends CubeCameraObjParamsConfig_base {}
declare class CubeCameraObjNode extends TypedObjNode<Group, CubeCameraObjParamsConfig> {
	paramsConfig: CubeCameraObjParamsConfig;
	static type(): ObjType;
	readonly hierarchyController: HierarchyController;
	readonly transformController: TransformController;
	readonly flags: FlagsControllerD;
	private _excludedObjects;
	private _cubeCamera;
	private _previousVisibleStateByUuid;
	private _helper;
	initializeNode(): void;
	createObject(): Group;
	cook(): void;
	private _updateHelperHierarchy;
	private _setupCubeCamera;
	private _createCubeCamera;
	renderTarget(): WebGLCubeRenderTarget | undefined;
	render(): void;
	private _resolveObjects;
	static PARAM_CALLBACK_printResolve(node: CubeCameraObjNode): void;
	private param_callback_printResolve;
	static PARAM_CALLBACK_render(node: CubeCameraObjNode): void;
	private param_callback_render;
}
declare class BaseManagerObjNode<K extends NodeParamsConfig> extends TypedObjNode<Group, K> {
	protected _attachableToHierarchy: boolean;
	createObject(): Group;
	cook(): void;
}
declare class ParamLessObjParamsConfig extends NodeParamsConfig {}
declare class ParamLessBaseManagerObjNode extends BaseManagerObjNode<ParamLessObjParamsConfig> {}
declare class ActorsNetworkObjNode extends ParamLessBaseManagerObjNode {
	static type(): NetworkNodeType;
	protected _childrenControllerContext: NodeContext;
	createNode<S extends keyof JsNodeChildrenMap>(node_class: S, options?: NodeCreateOptions): JsNodeChildrenMap[S];
	createNode<K extends valueof<JsNodeChildrenMap>>(node_class: Constructor<K>, options?: NodeCreateOptions): K;
	children(): BaseJsNodeType[];
	nodesByType<K extends keyof JsNodeChildrenMap>(type: K): JsNodeChildrenMap[K][];
	childrenAllowed(): boolean;
	sceneReadonly(): boolean;
	readonly persisted_config: ActorPersistedConfig;
	assemblerController(): JsAssemblerController<JsAssemblerActor> | undefined;
	usedAssembler(): Readonly<AssemblerName.JS_ACTOR>;
	protected _assemblerController: JsAssemblerController<JsAssemblerActor> | undefined;
	private _createAssemblerController;
	readonly compilationController: ActorCompilationController;
	compile(): void;
	cook(): void;
}
declare class BaseAnimationsObjNode extends ParamLessBaseManagerObjNode {
	static type(): NetworkNodeType;
	protected _childrenControllerContext: NodeContext;
	createNode<S extends keyof AnimNodeChildrenMap>(node_class: S, options?: NodeCreateOptions): AnimNodeChildrenMap[S];
	createNode<K extends valueof<AnimNodeChildrenMap>>(node_class: Constructor<K>, options?: NodeCreateOptions): K;
	children(): BaseAnimNodeType[];
	nodesByType<K extends keyof AnimNodeChildrenMap>(type: K): AnimNodeChildrenMap[K][];
}
declare class AnimationsNetworkObjNode extends BaseAnimationsObjNode {
	readonly renderOrder: number;
}
declare class BaseAudioObjNode extends ParamLessBaseManagerObjNode {
	static type(): NetworkNodeType;
	protected _childrenControllerContext: NodeContext;
	createNode<S extends keyof AudioNodeChildrenMap>(
		node_class: S,
		options?: NodeCreateOptions
	): AudioNodeChildrenMap[S];
	createNode<K extends valueof<AudioNodeChildrenMap>>(node_class: Constructor<K>, options?: NodeCreateOptions): K;
	children(): BaseAudioNodeType[];
	nodesByType<K extends keyof AudioNodeChildrenMap>(type: K): AudioNodeChildrenMap[K][];
}
declare class AudioNetworkObjNode extends BaseAudioObjNode {
	readonly renderOrder: number;
}
declare class CopNetworkObjNode extends ParamLessBaseManagerObjNode {
	static type(): NetworkNodeType;
	protected _childrenControllerContext: NodeContext;
	createNode<S extends keyof CopNodeChildrenMap>(node_class: S, options?: NodeCreateOptions): CopNodeChildrenMap[S];
	createNode<K extends valueof<CopNodeChildrenMap>>(node_class: Constructor<K>, options?: NodeCreateOptions): K;
	children(): BaseCopNodeType[];
	nodesByType<K extends keyof CopNodeChildrenMap>(type: K): CopNodeChildrenMap[K][];
}
declare class EventsNetworkObjNode extends ParamLessBaseManagerObjNode {
	readonly renderOrder: number;
	static type(): NetworkNodeType;
	protected _childrenControllerContext: NodeContext;
	createNode<S extends keyof EventNodeChildrenMap>(
		node_class: S,
		options?: NodeCreateOptions
	): EventNodeChildrenMap[S];
	createNode<K extends valueof<EventNodeChildrenMap>>(node_class: Constructor<K>, options?: NodeCreateOptions): K;
	children(): BaseEventNodeType[];
	nodesByType<K extends keyof EventNodeChildrenMap>(type: K): EventNodeChildrenMap[K][];
}
declare class MaterialsNetworkObjNode extends ParamLessBaseManagerObjNode {
	readonly renderOrder: number;
	static type(): Readonly<NetworkNodeType.MAT>;
	protected _childrenControllerContext: NodeContext;
	createNode<S extends keyof MatNodeChildrenMap>(node_class: S, options?: NodeCreateOptions): MatNodeChildrenMap[S];
	createNode<K extends valueof<MatNodeChildrenMap>>(node_class: Constructor<K>, options?: NodeCreateOptions): K;
	children(): BaseMatNodeType[];
	nodesByType<K extends keyof MatNodeChildrenMap>(type: K): MatNodeChildrenMap[K][];
}
declare class PostProcessNetworkObjNode extends BaseManagerObjNode<PostProcessNetworkParamsConfig> {
	paramsConfig: PostProcessNetworkParamsConfig;
	static type(): NetworkNodeType;
	readonly effectsComposerController: EffectComposerController;
	readonly displayNodeController: DisplayNodeController;
	protected _childrenControllerContext: NodeContext;
	createNode<S extends keyof PostNodeChildrenMap>(node_class: S, options?: NodeCreateOptions): PostNodeChildrenMap[S];
	createNode<K extends valueof<PostNodeChildrenMap>>(node_class: Constructor<K>, options?: NodeCreateOptions): K;
	children(): BasePostProcessNodeType[];
	nodesByType<K extends keyof PostNodeChildrenMap>(type: K): PostNodeChildrenMap[K][];
}
declare class RenderersNetworkObjNode extends ParamLessBaseManagerObjNode {
	readonly renderOrder: number;
	static type(): NetworkNodeType;
	protected _childrenControllerContext: NodeContext;
	createNode<S extends keyof RopNodeChildrenMap>(node_class: S, options?: NodeCreateOptions): RopNodeChildrenMap[S];
	createNode<K extends valueof<RopNodeChildrenMap>>(node_class: Constructor<K>, options?: NodeCreateOptions): K;
	children(): BaseRopNodeType[];
	nodesByType<K extends keyof RopNodeChildrenMap>(type: K): RopNodeChildrenMap[K][];
}
export interface ObjNodeChildrenMap {
	ambientLight: AmbientLightObjNode;
	areaLight: AreaLightObjNode;
	audioListener: AudioListenerObjNode;
	blend: BlendObjNode;
	contactShadow: ContactShadowObjNode;
	cubeCamera: CubeCameraObjNode;
	directionalLight: DirectionalLightObjNode;
	geo: GeoObjNode;
	hemisphereLight: HemisphereLightObjNode;
	lightProbe: LightProbeObjNode;
	null: NullObjNode;
	orthographicCamera: OrthographicCameraObjNode;
	perspectiveCamera: PerspectiveCameraObjNode;
	polarTransform: PolarTransformObjNode;
	pointLight: PointLightObjNode;
	positionalAudio: PositionalAudioObjNode;
	rivet: RivetObjNode;
	scene: SceneObjNode;
	spotLight: SpotLightObjNode;
	actorsNetwork: ActorsNetworkObjNode;
	animationsNetwork: AnimationsNetworkObjNode;
	audioNetwork: AudioNetworkObjNode;
	copNetwork: CopNetworkObjNode;
	eventsNetwork: EventsNetworkObjNode;
	materialsNetwork: MaterialsNetworkObjNode;
	postProcessNetwork: PostProcessNetworkObjNode;
	renderersNetwork: RenderersNetworkObjNode;
}
export declare type onToggleSoundCallback = (soundOn: boolean) => void;
declare class RootAudioController {
	protected node: RootManagerNode;
	constructor(node: RootManagerNode);
	toggleSound(): Promise<void>;
	soundOn(): boolean;
	update(): void;
	audioListeners(): AudioListenerObjNode[];
	private _updateViewers;
	static update(node: RootManagerNode): void;
	private _callbacksByName;
	onToggleSound(callbackName: string, callback: onToggleSoundCallback): void;
	private _runOnToggleSoundCallbacks;
}
declare class NodeGroup {
	readonly nodes: BaseNodeType[];
	readonly totalCount: number;
	private _processed;
	private _remaining;
	constructor(nodes: BaseNodeType[]);
	markNodeAsProcessed(node: BaseNodeType): void;
	isNodeProcessed(node: BaseNodeType): boolean;
	processedCount(): number;
}
export interface NodeGroups {
	toCook: NodeGroup;
	sopGroupToUpdate: NodeGroup;
}
export interface OnProgressArguments {
	scene: PolyScene;
	triggerNode?: BaseNodeType;
	groups: NodeGroups;
}
export declare type OnProgressUpdateCallback = (progressRatio: number, args: OnProgressArguments) => void;
declare class RootLoadProgressController {
	protected node: RootManagerNode;
	constructor(node: RootManagerNode);
	static PARAM_CALLBACK_printResolve(node: RootManagerNode): Promise<void>;
	resolvedNodes(): Promise<BaseNodeType[]>;
	private _loadDisplayNodes;
	private _displayNodes;
	private _objectNodesWithDisplayNodeController;
	cameraCreatorNode(): Promise<BaseNodeType | null>;
	private _nodeGroups;
	private _onProgressUpdateCallback;
	private _runCallback;
	private _updateProgressAndRunCallback;
	watchNodesProgress(callback: OnProgressUpdateCallback): Promise<void>;
	private _watchNodesToCook;
	private _watchNodesWithSopGroup;
	protected static debugActive(): boolean;
	static debug(arg0: any): void;
	static debug2(arg0: any, arg1: any): void;
	protected _debug(arg0: any): void;
	protected _debug2(arg0: any, arg1: any): void;
}
declare class RootMainCameraController {
	protected node: RootManagerNode;
	constructor(node: RootManagerNode);
	setCamera(object: Camera): void;
	setCameraPath(path: string): void;
	mainCameraPathParam(): StringParam;
	rawCameraPath(): string;
	cameraPath(): Promise<string>;
	private _cameraPathSync;
	cameraSync(): Camera | undefined;
	dummyPerspectiveCamera(): PerspectiveCamera;
	cameraSyncOrDummy(): Camera | undefined;
	camera(): Promise<Camera | undefined>;
	cameraCreatorNode(): Promise<BaseNodeType | null>;
}
declare const ObjectsManagerParamsConfig_base: {
	new (...args: any[]): {
		nodesMask: ParamTemplate<ParamType.STRING>;
		printNodes: ParamTemplate<ParamType.BUTTON>;
	};
} & {
	new (...args: any[]): {
		displayAudioIcon: ParamTemplate<ParamType.BOOLEAN>;
		audioIconColor: ParamTemplate<ParamType.COLOR>;
		audioIconStyle: ParamTemplate<ParamType.STRING>;
	};
} & {
	new (...args: any[]): {
		useOverrideMaterial: ParamTemplate<ParamType.BOOLEAN>;
		overrideMaterial: ParamTemplate<ParamType.NODE_PATH>;
	};
} & {
	new (...args: any[]): {
		useEnvironment: ParamTemplate<ParamType.BOOLEAN>;
		environment: ParamTemplate<ParamType.NODE_PATH>;
	};
} & {
	new (...args: any[]): {
		useFog: ParamTemplate<ParamType.BOOLEAN>;
		fogType: ParamTemplate<ParamType.INTEGER>;
		fogColor: ParamTemplate<ParamType.COLOR>;
		fogNear: ParamTemplate<ParamType.FLOAT>;
		fogFar: ParamTemplate<ParamType.FLOAT>;
		fogDensity: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		mainCameraPath: ParamTemplate<ParamType.STRING>;
	};
} & {
	new (...args: any[]): {
		backgroundMode: ParamTemplate<ParamType.INTEGER>;
		bgColor: ParamTemplate<ParamType.COLOR>;
		bgTexture: ParamTemplate<ParamType.NODE_PATH>;
		bgBlur: ParamTemplate<ParamType.FLOAT>;
		bgIntensity: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		autoUpdate: ParamTemplate<ParamType.BOOLEAN>;
	};
} & typeof NodeParamsConfig;
declare class ObjectsManagerParamsConfig extends ObjectsManagerParamsConfig_base {}
declare class RootManagerNode extends TypedBaseManagerNode<ObjectsManagerParamsConfig> {
	paramsConfig: ObjectsManagerParamsConfig;
	static type(): string;
	protected _object: Scene;
	private _queuedNodesById;
	readonly audioController: RootAudioController;
	readonly sceneAutoUpdateController: SceneAutoUpdateController;
	readonly sceneBackgroundController: SceneBackgroundController;
	readonly sceneEnvController: SceneEnvController;
	readonly sceneFogController: SceneFogController;
	readonly loadProgress: RootLoadProgressController;
	readonly sceneMaterialOverrideController: SceneMaterialOverrideController;
	readonly mainCameraController: RootMainCameraController;
	cook(): void;
	protected _childrenControllerContext: NodeContext;
	initializeNode(): void;
	private _createScene;
	get object(): Scene;
	createNode<S extends keyof ObjNodeChildrenMap>(nodeClass: S, options?: NodeCreateOptions): ObjNodeChildrenMap[S];
	createNode<K extends valueof<ObjNodeChildrenMap>>(nodeClass: Constructor<K>, options?: NodeCreateOptions): K;
	children(): BaseObjNodeType[];
	nodesByType<K extends keyof ObjNodeChildrenMap>(type: K): ObjNodeChildrenMap[K][];
	private _updateScene;
	private _addToQueue;
	processQueue(): void;
	private _updateObject;
	getParentForNode(node: BaseObjNodeType): Scene | Group | null;
	private _addToScene;
	private _removeFromScene;
	areChildrenCooking(): boolean;
	addToParentTransform(node: HierarchyObjNode): void;
	removeFromParentTransform(node: HierarchyObjNode): void;
	private _onChildAdd;
	private _onChildRemove;
}
export interface IUniforms {
	[uniform: string]: IUniform;
}
declare enum CustomMaterialName {
	DISTANCE = 'customDistanceMaterial',
	DEPTH = 'customDepthMaterial',
	DEPTH_DOF = 'customDepthDOFMaterial',
}
export interface MaterialWithCustomMaterials extends Material {
	customMaterials: {
		[key in CustomMaterialName]?: Material;
	};
}
export interface ShaderMaterialWithCustomMaterials extends ShaderMaterial {
	customMaterials: {
		[key in CustomMaterialName]?: Material;
	};
}
export declare type StringArrayByShaderName = Map<ShaderName, string[]>;
export interface FunctionData {
	functionBody: string;
	variableNames: string[];
	variablesByName: Record<string, RegisterableVariable>;
	functionNames: Array<keyof NamedFunctionMap>;
	functionsByName: Record<string, Function>;
	paramConfigs: JsParamConfig<ParamType>[];
}
export interface ITemplateShader {
	vertexShader?: string;
	fragmentShader?: string;
	uniforms?: IUniforms;
}
declare abstract class BaseJsShaderAssembler extends TypedAssembler<NodeContext.JS> {
	protected _gl_parent_node: AssemblerControllerNode<BaseJsShaderAssembler>;
	protected _shaders_by_name: Map<ShaderName, string>;
	protected _lines: StringArrayByShaderName;
	protected _codeBuilder: CodeBuilder | undefined;
	private _param_config_owner;
	protected _root_nodes: BaseJsNodeType[];
	protected _leaf_nodes: BaseJsNodeType[];
	protected _material: ShaderMaterial | undefined;
	private _shader_configs;
	private _variable_configs;
	private _uniformsTimeDependent;
	private _uniformsResolutionDependent;
	private _computedVarNames;
	constructor(_gl_parent_node: AssemblerControllerNode<BaseJsShaderAssembler>);
	protected _overriden_gl_parent_node: AssemblerControllerNode<BaseJsShaderAssembler> | undefined;
	setGlParentNode(gl_parent_node: AssemblerControllerNode<BaseJsShaderAssembler>): void;
	currentGlParentNode(): AssemblerControllerNode<BaseJsShaderAssembler>;
	addComputedVarName(varName: string): void;
	registeredAsComputed(varName: string): boolean;
	computedVariablesAllowed(): boolean;
	abstract spareParamsOptions(): ParamOptions;
	compile(): void;
	protected _template_shader_for_shader_name(shader_name: ShaderName): string | undefined;
	globalsHandler(): GlobalsBaseController | undefined;
	compileAllowed(): boolean;
	shaders_by_name(): Map<ShaderName, string>;
	protected _buildLines(): void;
	set_root_nodes(root_nodes: BaseJsNodeType[]): void;
	protected templateShader(): ITemplateShader | undefined;
	protected _reset(): void;
	updateFunction(): void;
	rootNodesByShaderName(shaderName: ShaderName, rootNodes: BaseJsNodeType[]): BaseJsNodeType[];
	set_node_lines_globals(
		globals_node: GlobalsJsNode,
		shaders_collection_controller: ShadersCollectionController
	): void;
	set_node_lines_output(output_node: OutputJsNode, shaders_collection_controller: ShadersCollectionController): void;
	setNodeLinesAttribute(
		attribute_node: AttributeJsNode,
		shaders_collection_controller: ShadersCollectionController
	): void;
	codeBuilder(): CodeBuilder;
	private _createCodeBuilder;
	protected buildCodeFromNodes(
		rootNodes: BaseJsNodeType[],
		codeBuilderOptions?: CodeBuilderSetCodeLinesOptions
	): void;
	allow_new_param_configs(): void;
	disallow_new_param_configs(): void;
	builder_param_configs(): readonly JsParamConfig<ParamType>[];
	builder_lines(shader_name: ShaderName, line_type: LineType): string[];
	all_builder_lines(): Map<ShaderName, Map<LineType, string[]>>;
	param_configs(): readonly JsParamConfig<ParamType>[];
	set_param_configs_owner(param_config_owner: CodeBuilder): void;
	static output_input_connection_points(): JsConnectionPoint<JsConnectionPointType>[];
	add_output_inputs(output_child: OutputJsNode): void;
	static create_globals_node_output_connections(): never[];
	create_globals_node_output_connections(): never[];
	add_globals_outputs(globals_node: GlobalsJsNode): void;
	allow_attribute_exports(): boolean;
	resetConfigs(): void;
	shaderConfigs(): ShaderConfig[];
	set_shader_configs(shader_configs: ShaderConfig[]): void;
	shaderNames(): ShaderName[];
	protected _reset_shader_configs(): void;
	create_shader_configs(): ShaderConfig[];
	shader_config(name: string): ShaderConfig | undefined;
	variable_configs(): VariableConfig[];
	set_variable_configs(variable_configs: VariableConfig[]): void;
	variable_config(name: string): VariableConfig;
	static create_variable_configs(): VariableConfig[];
	create_variable_configs(): VariableConfig[];
	protected _reset_variable_configs(): void;
	inputNamesForShaderName(root_node: BaseJsNodeType, shader_name: ShaderName): string[];
	protected _resetUniformsTimeDependency(): void;
	setUniformsTimeDependent(): void;
	uniformsTimeDependent(): boolean;
	protected _resetUniformsResolutionDependency(): void;
	setUniformsResolutionDependent(): void;
	uniformsResolutionDependent(): boolean;
	protected _raymarchingLightsWorldCoordsDependent(): boolean;
	protected insertMemberAfter(shaderName: ShaderName): string | undefined;
	protected insertDefineAfter(shaderName: ShaderName): string | undefined;
	protected insertConstructorAfter(shaderName: ShaderName): string | undefined;
	protected insertBodyAfter(shaderName: ShaderName): string | undefined;
	protected linesToRemove(shaderName: ShaderName): string[] | undefined;
	private _replaceTemplate;
	private _insertLines;
	private _registeredVariables;
	addVariable(node: BaseJsNodeType, varName: string, variable: RegisterableVariable): void;
	traverseRegisteredVariables(callback: (variable: RegisterableVariable, varName: string) => void): void;
	protected _resetRegisteredVariables(): void;
	private _registeredFunctions;
	addFunction(node: BaseJsNodeType, namedFunction: BaseNamedFunction): void;
	traverseRegisteredFunctions(callback: (variable: BaseNamedFunction) => void): void;
	protected _resetRegisteredFunctions(): void;
}
export interface ComputedValueJsDefinitionData {
	dataType: JsConnectionPointType;
	varName: string;
	value: string;
}
export interface TriggeringJsDefinitionOptionsExtended {
	gatherable: boolean;
	triggeringMethodName?: EvaluatorMethodName;
}
export interface TriggerableJsDefinitionOptionsExtended extends TriggerableJsDefinitionOptions {
	addTriggeredLines?: boolean;
}
declare class ShadersCollectionController {
	private _shaderNames;
	private _currentShaderName;
	private _assembler;
	private _linesControllerByShaderName;
	constructor(_shaderNames: ShaderName[], _currentShaderName: ShaderName, _assembler: BaseJsShaderAssembler);
	assembler(): BaseJsShaderAssembler;
	linesController(shaderName: ShaderName): JsLinesController | undefined;
	shaderNames(): ShaderName[];
	setCurrentShaderName(shaderName: ShaderName): void;
	currentShaderName(): ShaderName;
	addVariable(node: BaseJsNodeType, varName: string, variable: RegisterableVariable): void;
	addFunction(node: BaseJsNodeType, namedFunction: BaseNamedFunction): void;
	addTriggeringLines(
		node: BaseJsNodeType,
		triggeringLines: string[],
		options: TriggeringJsDefinitionOptionsExtended
	): void;
	addTriggerableLines(
		node: BaseJsNodeType,
		triggerableLines: string[],
		options?: TriggerableJsDefinitionOptionsExtended
	): void;
	addComputedVarName(varName: string): void;
	registeredAsComputed(varName: string): boolean;
	addBodyOrComputed(node: BaseJsNodeType, linesData: ComputedValueJsDefinitionData[]): void;
	addComputed(node: BaseJsNodeType, linesData: ComputedValueJsDefinitionData[]): void;
	addDefinitions(node: BaseJsNodeType, definitions: BaseJsDefinition[], shaderName?: ShaderName): void;
	definitions(shaderName: ShaderName, node: BaseJsNodeType): BaseJsDefinition[] | undefined;
	traverseDefinitions(shaderName: ShaderName, callback: DefinitionTraverseCallback): void;
	_addBodyLines(node: BaseJsNodeType, lines: string[], shaderName?: ShaderName, options?: AddBodyLinesOptions): void;
	bodyLines(shaderName: ShaderName, node: BaseJsNodeType): string[] | undefined;
}
declare class TypedJsNode<K extends NodeParamsConfig> extends TypedNode<NodeContext.JS, K> {
	static context(): NodeContext;
	protected _param_configs_controller: ParamConfigsController<JsParamConfig<ParamType>> | undefined;
	private _paramsEditableStatesController;
	eventData(): EvaluatorEventData | Array<EvaluatorEventData> | undefined;
	isTriggering(): boolean;
	initializeBaseNode(): void;
	cook(): void;
	protected _setFunctionNodeToRecompile(): void;
	functionNode(): AssemblerControllerNode<BaseJsShaderAssembler> | undefined;
	jsVarName(name: string): string;
	inputVarName(inputName: string): string;
	variableForInputParam(
		shadersCollectionController: ShadersCollectionController,
		param:
			| IntegerParam
			| FloatParam
			| Vector2Param
			| Vector3Param
			| Vector4Param
			| ColorParam
			| BooleanParam
			| StringParam
	): string;
	variableForInput(shadersCollectionController: ShadersCollectionController, inputName: string): string;
	private _variableForInput;
	setLines(shadersCollectionController: ShadersCollectionController): void;
	setTriggeringLines(shadersCollectionController: ShadersCollectionController, triggeredMethods: string): void;
	setTriggerableLines(shadersCollectionController: ShadersCollectionController): void;
	reset_code(): void;
	paramsGenerating(): boolean;
	setParamConfigs(): void;
	param_configs(): readonly JsParamConfig<ParamType>[] | undefined;
}
export declare type BaseJsNodeType = TypedJsNode<NodeParamsConfig>;
declare class ParamlessJsParamsConfig extends NodeParamsConfig {}
declare class ParamlessTypedJsNode extends TypedJsNode<ParamlessJsParamsConfig> {
	paramsConfig: ParamlessJsParamsConfig;
}
export declare type InputNamesByShaderNameMethod<NC extends NodeContext> = (
	root_node: BaseNodeByContextMap[NC],
	shader_name: ShaderName
) => string[];
export interface NodeTraverserOptions {
	traverseChildren?: boolean;
}
declare class TypedNodeTraverser<NC extends NodeContext> {
	private _parent_node;
	private _shader_names;
	private _inputNamesForShaderNameMethod;
	private _options?;
	private _leaves_graph_id;
	private _graph_ids_by_shader_name;
	private _outputs_by_graph_id;
	private _depth_by_graph_id;
	private _graph_id_by_depth;
	private _graph;
	private _shaderName;
	constructor(
		_parent_node: TypedNode<NC, any>,
		_shader_names: ShaderName[],
		_inputNamesForShaderNameMethod: InputNamesByShaderNameMethod<NC>,
		_options?: NodeTraverserOptions | undefined
	);
	private _traverseChildren;
	private reset;
	shaderNames(): ShaderName[];
	inputNamesForShaderName(root_node: BaseNodeByContextMap[NC], shader_name: ShaderName): string[];
	traverse(rootNodes: BaseNodeByContextMap[NC][]): void;
	leavesFromNodes(nodes: BaseNodeByContextMap[NC][]): BaseNodeByContextMap[NC][];
	nodesForShaderName(shaderName: ShaderName): BaseNodeByContextMap[NC][];
	sortedNodes(): BaseNodeByContextMap[NC][];
	private _addNodesWithChildren;
	private _findLeavesFromRootNode;
	private _blockedInputNames;
	setBlockedInputNames(nodeType: string, inputNames: string[]): void;
	private _findLeaves;
	getNodeInputs(
		node: BaseNodeByContextMap[NC]
	): (
		| BaseObjNodeType
		| TypedNode<NodeContext.ACTOR, any>
		| BaseAnimNodeType
		| BaseAudioNodeType
		| BaseCopNodeType
		| BaseEventNodeType
		| BaseGlNodeType
		| BaseJsNodeType
		| BaseManagerNodeType
		| BaseMatNodeType
		| BasePostProcessNodeType
		| BaseRopNodeType
		| BaseSopNodeType
		| null
	)[];
	private _findInputs;
	private _setNodesDepth;
	private _setNodeDepth;
}
export declare type RootNodesForShaderMethod = (
	shader_name: ShaderName,
	rootNodes: BaseGlNodeType[]
) => BaseGlNodeType[];
export interface CodeBuilderSetCodeLinesOptions {
	otherFragmentShaderCollectionController?: ShadersCollectionController;
}
declare class CodeBuilder {
	private _nodeTraverser;
	private _root_nodes_for_shader_method;
	private _assembler;
	private _param_configs_controller;
	private _param_configs_set_allowed;
	private _shadersCollectionController;
	private _lines;
	constructor(
		_nodeTraverser: TypedNodeTraverser<NodeContext.GL>,
		_root_nodes_for_shader_method: RootNodesForShaderMethod,
		_assembler: TypedAssembler<NodeContext.GL>
	);
	nodeTraverser(): TypedNodeTraverser<NodeContext.GL>;
	shaderNames(): ShaderName[];
	buildFromNodes(
		rootNodes: BaseGlNodeType[],
		paramNodes: BaseGlNodeType[],
		setCodeLinesOptions?: CodeBuilderSetCodeLinesOptions
	): void;
	shadersCollectionController(): ShadersCollectionController | undefined;
	disallow_new_param_configs(): void;
	allow_new_param_configs(): void;
	private reset;
	param_configs(): readonly GlParamConfig<ParamType>[];
	lines(shader_name: ShaderName, line_type: LineType): string[];
	all_lines(): Map<ShaderName, Map<LineType, string[]>>;
	setParamConfigs(nodes: BaseGlNodeType[]): void;
	private _setCodeLines;
	private _addCodeLines;
	private addDefinitions;
	add_code_line_for_nodes_and_line_type(nodes: BaseGlNodeType[], shader_name: ShaderName, line_type: LineType): void;
	add_code_line_for_node_and_line_type(
		node: BaseGlNodeType,
		shader_name: ShaderName,
		line_type: LineType,
		is_last: boolean
	): void;
}
declare abstract class GlobalsBaseController {
	private static __next_id;
	private _id;
	constructor();
	id(): number;
	handle_globals_node(
		globals_node: GlobalsGlNode,
		output_name: string,
		shaders_collection_controller: ShadersCollectionController
	): void;
	handleGlobalVar(
		globals_node: BaseGlNodeType,
		output_name: string,
		glType: GlConnectionPointType,
		shaders_collection_controller: ShadersCollectionController
	): void;
	abstract readAttribute(
		node: BaseGlNodeType,
		gl_type: GlConnectionPointType,
		attrib_name: string,
		shaders_collection_controller: ShadersCollectionController
	): string | undefined;
}
export declare type StringArrayByShaderName = Map<ShaderName, string[]>;
export interface ITemplateShader {
	vertexShader?: string;
	fragmentShader?: string;
	uniforms?: IUniforms;
}
declare class BaseGlShaderAssembler extends TypedAssembler<NodeContext.GL> {
	protected _gl_parent_node: AssemblerControllerNode;
	protected _shaders_by_name: Map<ShaderName, string>;
	protected _lines: StringArrayByShaderName;
	protected _codeBuilder: CodeBuilder | undefined;
	private _param_config_owner;
	protected _root_nodes: BaseGlNodeType[];
	protected _leaf_nodes: BaseGlNodeType[];
	protected _material: ShaderMaterial | undefined;
	private _shader_configs;
	private _variable_configs;
	private _uniformsTimeDependent;
	private _uniformsResolutionDependent;
	constructor(_gl_parent_node: AssemblerControllerNode);
	protected _overriden_gl_parent_node: AssemblerControllerNode | undefined;
	setGlParentNode(gl_parent_node: AssemblerControllerNode): void;
	currentGlParentNode(): AssemblerControllerNode;
	compile(): void;
	protected _template_shader_for_shader_name(shader_name: ShaderName): string | undefined;
	globalsHandler(): GlobalsBaseController | undefined;
	compileAllowed(): boolean;
	shaders_by_name(): Map<ShaderName, string>;
	protected _buildLines(): void;
	set_root_nodes(root_nodes: BaseGlNodeType[]): void;
	protected templateShader(): ITemplateShader | undefined;
	rootNodesByShaderName(shaderName: ShaderName, rootNodes: BaseGlNodeType[]): BaseGlNodeType[];
	set_node_lines_globals(
		globals_node: GlobalsGlNode,
		shaders_collection_controller: ShadersCollectionController
	): void;
	set_node_lines_output(output_node: OutputGlNode, shaders_collection_controller: ShadersCollectionController): void;
	setNodeLinesAttribute(
		attribute_node: AttributeGlNode,
		shaders_collection_controller: ShadersCollectionController
	): void;
	codeBuilder(): CodeBuilder;
	protected _resetCodeBuilder(): void;
	private _createCodeBuilder;
	protected buildCodeFromNodes(
		rootNodes: BaseGlNodeType[],
		codeBuilderOptions?: CodeBuilderSetCodeLinesOptions
	): void;
	allow_new_param_configs(): void;
	disallow_new_param_configs(): void;
	builder_param_configs(): readonly GlParamConfig<ParamType>[];
	builder_lines(shader_name: ShaderName, line_type: LineType): string[];
	all_builder_lines(): Map<ShaderName, Map<LineType, string[]>>;
	param_configs(): readonly GlParamConfig<ParamType>[];
	set_param_configs_owner(param_config_owner: CodeBuilder): void;
	static output_input_connection_points(): GlConnectionPoint<GlConnectionPointType>[];
	add_output_inputs(output_child: OutputGlNode): void;
	static create_globals_node_output_connections(): (
		| GlConnectionPoint<GlConnectionPointType.VEC3>
		| GlConnectionPoint<GlConnectionPointType.VEC2>
		| GlConnectionPoint<GlConnectionPointType.VEC4>
		| GlConnectionPoint<GlConnectionPointType.FLOAT>
	)[];
	create_globals_node_output_connections(): (
		| GlConnectionPoint<GlConnectionPointType.VEC3>
		| GlConnectionPoint<GlConnectionPointType.VEC2>
		| GlConnectionPoint<GlConnectionPointType.VEC4>
		| GlConnectionPoint<GlConnectionPointType.FLOAT>
	)[];
	add_globals_outputs(globals_node: GlobalsGlNode): void;
	allow_attribute_exports(): boolean;
	reset_configs(): void;
	shaderConfigs(): ShaderConfig[];
	set_shader_configs(shader_configs: ShaderConfig[]): void;
	shaderNames(): ShaderName[];
	protected _reset_shader_configs(): void;
	create_shader_configs(): ShaderConfig[];
	shader_config(name: string): ShaderConfig | undefined;
	variable_configs(): VariableConfig[];
	set_variable_configs(variable_configs: VariableConfig[]): void;
	variable_config(name: string): VariableConfig;
	static create_variable_configs(): VariableConfig[];
	create_variable_configs(): VariableConfig[];
	protected _reset_variable_configs(): void;
	inputNamesForShaderName(root_node: BaseGlNodeType, shader_name: ShaderName): string[];
	protected _resetUniformsTimeDependency(): void;
	setUniformsTimeDependent(): void;
	uniformsTimeDependent(): boolean;
	protected _resetUniformsResolutionDependency(): void;
	setUniformsResolutionDependent(): void;
	uniformsResolutionDependent(): boolean;
	protected _raymarchingLightsWorldCoordsDependent(): boolean;
	protected insertDefineAfter(shaderName: ShaderName): string | undefined;
	protected insertBodyAfter(shaderName: ShaderName): string | undefined;
	protected linesToRemove(shaderName: ShaderName): string[] | undefined;
	private _replaceTemplate;
	private _insertLines;
	_addFilterFragmentShaderCallback(callbackName: string, callback: (s: string) => string): void;
	_removeFilterFragmentShaderCallback(callbackName: string): void;
	getCustomMaterials(): Map<CustomMaterialName, ShaderMaterial>;
	static expandShader(shader_string: string): string;
}
declare class BaseGlParentNode extends TypedNode<any, any> {
	createNode<S extends keyof GlNodeChildrenMap>(node_class: S, options?: NodeCreateOptions): GlNodeChildrenMap[S];
	createNode<K extends valueof<GlNodeChildrenMap>>(node_class: Constructor<K>, options?: NodeCreateOptions): K;
	children(): BaseGlNodeType[];
	nodesByType<K extends keyof GlNodeChildrenMap>(type: K): GlNodeChildrenMap[K][];
}
declare abstract class AssemblerControllerNode extends BaseGlParentNode {
	abstract assemblerController(): GlAssemblerController<BaseGlShaderAssembler> | undefined;
}
export declare type BaseGlShaderAssemblerConstructor<A extends BaseGlShaderAssembler> = new (...args: any[]) => A;
declare class GlAssemblerController<A extends BaseGlShaderAssembler> {
	private node;
	protected _assembler: A;
	private _spareParamsController;
	private _globalsHandler;
	private _compile_required;
	constructor(node: AssemblerControllerNode, assembler_class: BaseGlShaderAssemblerConstructor<A>);
	setAssemblerGlobalsHandler(globalsHandler: GlobalsBaseController): void;
	get assembler(): A;
	globalsHandler(): GlobalsBaseController | undefined;
	add_output_inputs(output_child: OutputGlNode): void;
	add_globals_outputs(globals_node: GlobalsGlNode): void;
	allow_attribute_exports(): boolean;
	setCompilationRequired(newState?: boolean): void;
	setCompilationRequiredAndDirty(triggerNode?: BaseGlNodeType): void;
	compileRequired(): boolean;
	post_compile(): void;
	createSpareParameters(): void;
	addFilterFragmentShaderCallback(callbackName: string, callback: (s: string) => string): void;
	removeFilterFragmentShaderCallback(callbackName: string): void;
}
export interface AssemblersMap extends PolyDictionary<ControllerAssemblerPair> {
	[AssemblerName.GL_MESH_BASIC]: {
		controller: GlAssemblerController<ShaderAssemblerBasic>;
		assembler: typeof ShaderAssemblerBasic;
	};
	[AssemblerName.GL_MESH_LAMBERT]: {
		controller: GlAssemblerController<ShaderAssemblerLambert>;
		assembler: typeof ShaderAssemblerLambert;
	};
	[AssemblerName.GL_MESH_PHONG]: {
		controller: GlAssemblerController<ShaderAssemblerPhong>;
		assembler: typeof ShaderAssemblerPhong;
	};
	[AssemblerName.GL_MESH_STANDARD]: {
		controller: GlAssemblerController<ShaderAssemblerStandard>;
		assembler: typeof ShaderAssemblerStandard;
	};
	[AssemblerName.GL_MESH_PHYSICAL]: {
		controller: GlAssemblerController<ShaderAssemblerPhysical>;
		assembler: typeof ShaderAssemblerPhysical;
	};
	[AssemblerName.GL_MESH_DEPTH]: {
		controller: GlAssemblerController<ShaderAssemblerCustomMeshDepthForRender>;
		assembler: typeof ShaderAssemblerCustomMeshDepthForRender;
	};
	[AssemblerName.GL_MESH_DISTANCE]: {
		controller: GlAssemblerController<ShaderAssemblerCustomMeshDistanceForRender>;
		assembler: typeof ShaderAssemblerCustomMeshDistanceForRender;
	};
	[AssemblerName.GL_PARTICLES]: {
		controller: GlAssemblerController<ShaderAssemblerParticles>;
		assembler: typeof ShaderAssemblerParticles;
	};
	[AssemblerName.GL_POINTS]: {
		controller: GlAssemblerController<ShaderAssemblerPoints>;
		assembler: typeof ShaderAssemblerPoints;
	};
	[AssemblerName.GL_LINE]: {
		controller: GlAssemblerController<ShaderAssemblerLine>;
		assembler: typeof ShaderAssemblerLine;
	};
	[AssemblerName.GL_POST]: {
		controller: GlAssemblerController<ShaderAssemblerPost>;
		assembler: typeof ShaderAssemblerPost;
	};
	[AssemblerName.GL_RAYMARCHING]: {
		controller: GlAssemblerController<ShaderAssemblerRayMarching>;
		assembler: typeof ShaderAssemblerRayMarching;
	};
	[AssemblerName.GL_TEXTURE]: {
		controller: GlAssemblerController<ShaderAssemblerTexture>;
		assembler: typeof ShaderAssemblerTexture;
	};
	[AssemblerName.GL_TEXTURE_2D_ARRAY]: {
		controller: GlAssemblerController<ShaderAssemblerTexture2DArray>;
		assembler: typeof ShaderAssemblerTexture2DArray;
	};
	[AssemblerName.GL_VOLUME]: {
		controller: GlAssemblerController<ShaderAssemblerVolume>;
		assembler: typeof ShaderAssemblerVolume;
	};
	[AssemblerName.JS_ACTOR]: {
		controller: JsAssemblerController<JsAssemblerActor>;
		assembler: typeof JsAssemblerActor;
	};
	[AssemblerName.JS_SDF]: {
		controller: JsAssemblerController<JsAssemblerSDF>;
		assembler: typeof JsAssemblerSDF;
	};
}
declare class AssemblersRegister extends BaseAssemblersRegister {
	assembler<K extends keyof AssemblersMap>(node: BaseNodeType, name: K): AssemblersMap[K]['controller'] | undefined;
	unregister<K extends keyof AssemblersMap>(name: K): ControllerAssemblerPair | undefined;
}
declare class BaseNamedFunctionRegister {
	protected _functionByName: Map<string, typeof BaseNamedFunction>;
	register(namedFunction: typeof BaseNamedFunction): void;
}
declare class NamedFunctionRegister extends BaseNamedFunctionRegister {
	getFunction<K extends keyof NamedFunctionMap>(
		functionName: K,
		node: BaseNodeType,
		shadersCollectionController?: ShadersCollectionController
	): NamedFunctionMap[K];
}
declare class PolyEngine {
	readonly renderersController: RenderersController;
	readonly scenesRegister: ScenesRegister;
	readonly nodesRegister: NodesRegister;
	readonly operationsRegister: OperationsRegister;
	readonly expressionsRegister: ExpressionRegister;
	readonly assemblersRegister: AssemblersRegister;
	readonly pluginsRegister: PluginsRegister;
	readonly camerasRegister: PolyCamerasRegister;
	readonly modulesRegister: DynamicModulesRegister;
	readonly namedFunctionsRegister: NamedFunctionRegister;
	readonly blobs: BlobsController;
	readonly assetUrls: AssetUrlsController;
	readonly thirdParty: PolyThirdPartyController;
	readonly onObjectsAddedHooks: PolyOnObjectsAddedHooksController;
	readonly specializedChildren: PolySpecializedChildrenController;
	readonly performance: PolyPerformanceformanceController;
	scenesByUuid: PolyDictionary<PolyScene>;
	_env: string | undefined;
	private _playerMode;
	private _logger;
	static _instance_(): PolyEngine;
	private constructor();
	version(): string;
	setPlayerMode(mode: boolean): void;
	playerMode(): boolean;
	registerNode(node: BaseNodeConstructor, tab_menu_category?: string | string[], options?: NodeRegisterOptions): void;
	registerOperation(operation: typeof BaseOperation, options?: OperationRegisterOptions): void;
	registerNamedFunction(namedFunction: typeof BaseNamedFunction): void;
	registerCamera<C extends Camera>(cameraClass: any, viewerCreateCallback: ViewerCreateCallback<C>): void;
	registerCameraNodeType(nodeType: string): void;
	registerPlugin(plugin: PolyPluginInterface): void;
	wrapConfigurePolygonjs(callback: WrapConfigurePolygonjsCallback): void;
	registeredNodes(parentNode: BaseNodeType): PolyDictionary<typeof BaseNodeClass>;
	registeredOperation(parent_context: NodeContext, operation_type: string): typeof BaseOperation | undefined;
	registerModule(module: BaseModule<ModuleName>): void;
	inWorkerThread(): boolean;
	private _libs_controller;
	get libs(): PolyLibsController;
	setEnv(env: string): void;
	env(): string | undefined;
	setLogger(logger: BaseCoreLogger | null): void;
	log(message?: any, ...optionalParams: any[]): void;
	warn(message?: any, ...optionalParams: any[]): void;
	error(message?: any, ...optionalParams: any[]): void;
}
export declare const Poly: PolyEngine;
declare class ViewerRaycastersController {
	protected viewer: BaseViewerType;
	pointerEventsController: PointerEventsController;
	constructor(viewer: BaseViewerType);
	setCursor0(cursor: Vector2Like): void;
	raycaster0(): {
		ray: {
			origin: {
				x: number;
				y: number;
				z: number;
				readonly isVector3: true;
				set: (x: number, y: number, z: number) => Vector3;
				setScalar: (scalar: number) => Vector3;
				setX: (x: number) => Vector3;
				setY: (y: number) => Vector3;
				setZ: (z: number) => Vector3;
				setComponent: (index: number, value: number) => Vector3;
				getComponent: (index: number) => number;
				clone: () => Vector3;
				copy: (v: Vector3) => Vector3;
				add: (v: Vector3) => Vector3;
				addScalar: (s: number) => Vector3;
				addScaledVector: (v: Vector3, s: number) => Vector3;
				addVectors: (a: Vector3, b: Vector3) => Vector3;
				sub: (a: Vector3) => Vector3;
				subScalar: (s: number) => Vector3;
				subVectors: (a: Vector3, b: Vector3) => Vector3;
				multiply: (v: Vector3) => Vector3;
				multiplyScalar: (s: number) => Vector3;
				multiplyVectors: (a: Vector3, b: Vector3) => Vector3;
				applyEuler: (euler: Euler) => Vector3;
				applyAxisAngle: (axis: Vector3, angle: number) => Vector3;
				applyMatrix3: (m: Matrix3) => Vector3;
				applyNormalMatrix: (m: Matrix3) => Vector3;
				applyMatrix4: (m: Matrix4) => Vector3;
				applyQuaternion: (q: Quaternion) => Vector3;
				project: (camera: Camera) => Vector3;
				unproject: (camera: Camera) => Vector3;
				transformDirection: (m: Matrix4) => Vector3;
				divide: (v: Vector3) => Vector3;
				divideScalar: (s: number) => Vector3;
				min: (v: Vector3) => Vector3;
				max: (v: Vector3) => Vector3;
				clamp: (min: Vector3, max: Vector3) => Vector3;
				clampScalar: (min: number, max: number) => Vector3;
				clampLength: (min: number, max: number) => Vector3;
				floor: () => Vector3;
				ceil: () => Vector3;
				round: () => Vector3;
				roundToZero: () => Vector3;
				negate: () => Vector3;
				dot: (v: Vector3) => number;
				lengthSq: () => number;
				length: () => number;
				lengthManhattan: () => number;
				manhattanLength: () => number;
				manhattanDistanceTo: (v: Vector3) => number;
				normalize: () => Vector3;
				setLength: (l: number) => Vector3;
				lerp: (v: Vector3, alpha: number) => Vector3;
				lerpVectors: (v1: Vector3, v2: Vector3, alpha: number) => Vector3;
				cross: (a: Vector3) => Vector3;
				crossVectors: (a: Vector3, b: Vector3) => Vector3;
				projectOnVector: (v: Vector3) => Vector3;
				projectOnPlane: (planeNormal: Vector3) => Vector3;
				reflect: (vector: Vector3) => Vector3;
				angleTo: (v: Vector3) => number;
				distanceTo: (v: Vector3) => number;
				distanceToSquared: (v: Vector3) => number;
				distanceToManhattan: (v: Vector3) => number;
				setFromSpherical: (s: Spherical) => Vector3;
				setFromSphericalCoords: (r: number, phi: number, theta: number) => Vector3;
				setFromCylindrical: (s: Cylindrical) => Vector3;
				setFromCylindricalCoords: (radius: number, theta: number, y: number) => Vector3;
				setFromMatrixPosition: (m: Matrix4) => Vector3;
				setFromMatrixScale: (m: Matrix4) => Vector3;
				setFromMatrixColumn: (matrix: Matrix4, index: number) => Vector3;
				setFromMatrix3Column: (matrix: Matrix3, index: number) => Vector3;
				setFromEuler: (e: Euler) => Vector3;
				equals: (v: Vector3) => boolean;
				fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Vector3;
				toArray: {
					(array?: number[] | undefined, offset?: number | undefined): number[];
					(array?: Vector3Tuple | undefined, offset?: 0 | undefined): Vector3Tuple;
					(array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
				};
				fromBufferAttribute: (
					attribute: BufferAttribute | InterleavedBufferAttribute,
					index: number
				) => Vector3;
				random: () => Vector3;
				randomDirection: () => Vector3;
			};
			direction: {
				x: number;
				y: number;
				z: number;
				readonly isVector3: true;
				set: (x: number, y: number, z: number) => Vector3;
				setScalar: (scalar: number) => Vector3;
				setX: (x: number) => Vector3;
				setY: (y: number) => Vector3;
				setZ: (z: number) => Vector3;
				setComponent: (index: number, value: number) => Vector3;
				getComponent: (index: number) => number;
				clone: () => Vector3;
				copy: (v: Vector3) => Vector3;
				add: (v: Vector3) => Vector3;
				addScalar: (s: number) => Vector3;
				addScaledVector: (v: Vector3, s: number) => Vector3;
				addVectors: (a: Vector3, b: Vector3) => Vector3;
				sub: (a: Vector3) => Vector3;
				subScalar: (s: number) => Vector3;
				subVectors: (a: Vector3, b: Vector3) => Vector3;
				multiply: (v: Vector3) => Vector3;
				multiplyScalar: (s: number) => Vector3;
				multiplyVectors: (a: Vector3, b: Vector3) => Vector3;
				applyEuler: (euler: Euler) => Vector3;
				applyAxisAngle: (axis: Vector3, angle: number) => Vector3;
				applyMatrix3: (m: Matrix3) => Vector3;
				applyNormalMatrix: (m: Matrix3) => Vector3;
				applyMatrix4: (m: Matrix4) => Vector3;
				applyQuaternion: (q: Quaternion) => Vector3;
				project: (camera: Camera) => Vector3;
				unproject: (camera: Camera) => Vector3;
				transformDirection: (m: Matrix4) => Vector3;
				divide: (v: Vector3) => Vector3;
				divideScalar: (s: number) => Vector3;
				min: (v: Vector3) => Vector3;
				max: (v: Vector3) => Vector3;
				clamp: (min: Vector3, max: Vector3) => Vector3;
				clampScalar: (min: number, max: number) => Vector3;
				clampLength: (min: number, max: number) => Vector3;
				floor: () => Vector3;
				ceil: () => Vector3;
				round: () => Vector3;
				roundToZero: () => Vector3;
				negate: () => Vector3;
				dot: (v: Vector3) => number;
				lengthSq: () => number;
				length: () => number;
				lengthManhattan: () => number;
				manhattanLength: () => number;
				manhattanDistanceTo: (v: Vector3) => number;
				normalize: () => Vector3;
				setLength: (l: number) => Vector3;
				lerp: (v: Vector3, alpha: number) => Vector3;
				lerpVectors: (v1: Vector3, v2: Vector3, alpha: number) => Vector3;
				cross: (a: Vector3) => Vector3;
				crossVectors: (a: Vector3, b: Vector3) => Vector3;
				projectOnVector: (v: Vector3) => Vector3;
				projectOnPlane: (planeNormal: Vector3) => Vector3;
				reflect: (vector: Vector3) => Vector3;
				angleTo: (v: Vector3) => number;
				distanceTo: (v: Vector3) => number;
				distanceToSquared: (v: Vector3) => number;
				distanceToManhattan: (v: Vector3) => number;
				setFromSpherical: (s: Spherical) => Vector3;
				setFromSphericalCoords: (r: number, phi: number, theta: number) => Vector3;
				setFromCylindrical: (s: Cylindrical) => Vector3;
				setFromCylindricalCoords: (radius: number, theta: number, y: number) => Vector3;
				setFromMatrixPosition: (m: Matrix4) => Vector3;
				setFromMatrixScale: (m: Matrix4) => Vector3;
				setFromMatrixColumn: (matrix: Matrix4, index: number) => Vector3;
				setFromMatrix3Column: (matrix: Matrix3, index: number) => Vector3;
				setFromEuler: (e: Euler) => Vector3;
				equals: (v: Vector3) => boolean;
				fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Vector3;
				toArray: {
					(array?: number[] | undefined, offset?: number | undefined): number[];
					(array?: Vector3Tuple | undefined, offset?: 0 | undefined): Vector3Tuple;
					(array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
				};
				fromBufferAttribute: (
					attribute: BufferAttribute | InterleavedBufferAttribute,
					index: number
				) => Vector3;
				random: () => Vector3;
				randomDirection: () => Vector3;
			};
			set: (origin: Vector3, direction: Vector3) => Ray;
			clone: () => Ray;
			copy: (ray: Ray) => Ray;
			at: (t: number, target: Vector3) => Vector3;
			lookAt: (v: Vector3) => Ray;
			recast: (t: number) => Ray;
			closestPointToPoint: (point: Vector3, target: Vector3) => Vector3;
			distanceToPoint: (point: Vector3) => number;
			distanceSqToPoint: (point: Vector3) => number;
			distanceSqToSegment: (
				v0: Vector3,
				v1: Vector3,
				optionalPointOnRay?: Vector3 | undefined,
				optionalPointOnSegment?: Vector3 | undefined
			) => number;
			intersectSphere: (sphere: Sphere, target: Vector3) => Vector3 | null;
			intersectsSphere: (sphere: Sphere) => boolean;
			distanceToPlane: (plane: Plane) => number;
			intersectPlane: (plane: Plane, target: Vector3) => Vector3 | null;
			intersectsPlane: (plane: Plane) => boolean;
			intersectBox: (box: Box3, target: Vector3) => Vector3 | null;
			intersectsBox: (box: Box3) => boolean;
			intersectTriangle: (
				a: Vector3,
				b: Vector3,
				c: Vector3,
				backfaceCulling: boolean,
				target: Vector3
			) => Vector3 | null;
			applyMatrix4: (matrix4: Matrix4) => Ray;
			equals: (ray: Ray) => boolean;
			isIntersectionBox: (b: any) => any;
			isIntersectionPlane: (p: any) => any;
			isIntersectionSphere: (s: any) => any;
		};
		near: number;
		far: number;
		camera: {
			matrixWorldInverse: {
				elements: number[];
				set: (
					n11: number,
					n12: number,
					n13: number,
					n14: number,
					n21: number,
					n22: number,
					n23: number,
					n24: number,
					n31: number,
					n32: number,
					n33: number,
					n34: number,
					n41: number,
					n42: number,
					n43: number,
					n44: number
				) => Matrix4;
				identity: () => Matrix4;
				clone: () => Matrix4;
				copy: (m: Matrix4) => Matrix4;
				copyPosition: (m: Matrix4) => Matrix4;
				extractBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix4;
				makeBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix4;
				extractRotation: (m: Matrix4) => Matrix4;
				makeRotationFromEuler: (euler: Euler) => Matrix4;
				makeRotationFromQuaternion: (q: Quaternion) => Matrix4;
				lookAt: (eye: Vector3, target: Vector3, up: Vector3) => Matrix4;
				multiply: (m: Matrix4) => Matrix4;
				premultiply: (m: Matrix4) => Matrix4;
				multiplyMatrices: (a: Matrix4, b: Matrix4) => Matrix4;
				multiplyToArray: (a: Matrix4, b: Matrix4, r: number[]) => Matrix4;
				multiplyScalar: (s: number) => Matrix4;
				determinant: () => number;
				transpose: () => Matrix4;
				setPosition: (v: number | Vector3, y?: number | undefined, z?: number | undefined) => Matrix4;
				invert: () => Matrix4;
				scale: (v: Vector3) => Matrix4;
				getMaxScaleOnAxis: () => number;
				makeTranslation: (x: number, y: number, z: number) => Matrix4;
				makeRotationX: (theta: number) => Matrix4;
				makeRotationY: (theta: number) => Matrix4;
				makeRotationZ: (theta: number) => Matrix4;
				makeRotationAxis: (axis: Vector3, angle: number) => Matrix4;
				makeScale: (x: number, y: number, z: number) => Matrix4;
				makeShear: (xy: number, xz: number, yx: number, yz: number, zx: number, zy: number) => Matrix4;
				compose: (translation: Vector3, rotation: Quaternion, scale: Vector3) => Matrix4;
				decompose: (translation: Vector3, rotation: Quaternion, scale: Vector3) => Matrix4;
				makePerspective: {
					(left: number, right: number, bottom: number, top: number, near: number, far: number): Matrix4;
					(fov: number, aspect: number, near: number, far: number): Matrix4;
				};
				makeOrthographic: (
					left: number,
					right: number,
					top: number,
					bottom: number,
					near: number,
					far: number
				) => Matrix4;
				equals: (matrix: Matrix4) => boolean;
				fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Matrix4;
				toArray: {
					(array?: number[] | undefined, offset?: number | undefined): number[];
					(array?: Matrix4Tuple | undefined, offset?: 0 | undefined): Matrix4Tuple;
					(array?: ArrayLike<number> | undefined, offset?: number | undefined): ArrayLike<number>;
				};
				setFromMatrix3: (m: Matrix3) => Matrix4;
				extractPosition: (m: Matrix4) => Matrix4;
				setRotationFromQuaternion: (q: Quaternion) => Matrix4;
				multiplyVector3: (v: any) => any;
				multiplyVector4: (v: any) => any;
				multiplyVector3Array: (array: number[]) => number[];
				rotateAxis: (v: any) => void;
				crossVector: (v: any) => void;
				flattenToArrayOffset: (array: number[], offset: number) => number[];
				getInverse: (matrix: Matrix) => Matrix;
			};
			projectionMatrix: {
				elements: number[];
				set: (
					n11: number,
					n12: number,
					n13: number,
					n14: number,
					n21: number,
					n22: number,
					n23: number,
					n24: number,
					n31: number,
					n32: number,
					n33: number,
					n34: number,
					n41: number,
					n42: number,
					n43: number,
					n44: number
				) => Matrix4;
				identity: () => Matrix4;
				clone: () => Matrix4;
				copy: (m: Matrix4) => Matrix4;
				copyPosition: (m: Matrix4) => Matrix4;
				extractBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix4;
				makeBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix4;
				extractRotation: (m: Matrix4) => Matrix4;
				makeRotationFromEuler: (euler: Euler) => Matrix4;
				makeRotationFromQuaternion: (q: Quaternion) => Matrix4;
				lookAt: (eye: Vector3, target: Vector3, up: Vector3) => Matrix4;
				multiply: (m: Matrix4) => Matrix4;
				premultiply: (m: Matrix4) => Matrix4;
				multiplyMatrices: (a: Matrix4, b: Matrix4) => Matrix4;
				multiplyToArray: (a: Matrix4, b: Matrix4, r: number[]) => Matrix4;
				multiplyScalar: (s: number) => Matrix4;
				determinant: () => number;
				transpose: () => Matrix4;
				setPosition: (v: number | Vector3, y?: number | undefined, z?: number | undefined) => Matrix4;
				invert: () => Matrix4;
				scale: (v: Vector3) => Matrix4;
				getMaxScaleOnAxis: () => number;
				makeTranslation: (x: number, y: number, z: number) => Matrix4;
				makeRotationX: (theta: number) => Matrix4;
				makeRotationY: (theta: number) => Matrix4;
				makeRotationZ: (theta: number) => Matrix4;
				makeRotationAxis: (axis: Vector3, angle: number) => Matrix4;
				makeScale: (x: number, y: number, z: number) => Matrix4;
				makeShear: (xy: number, xz: number, yx: number, yz: number, zx: number, zy: number) => Matrix4;
				compose: (translation: Vector3, rotation: Quaternion, scale: Vector3) => Matrix4;
				decompose: (translation: Vector3, rotation: Quaternion, scale: Vector3) => Matrix4;
				makePerspective: {
					(left: number, right: number, bottom: number, top: number, near: number, far: number): Matrix4;
					(fov: number, aspect: number, near: number, far: number): Matrix4;
				};
				makeOrthographic: (
					left: number,
					right: number,
					top: number,
					bottom: number,
					near: number,
					far: number
				) => Matrix4;
				equals: (matrix: Matrix4) => boolean;
				fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Matrix4;
				toArray: {
					(array?: number[] | undefined, offset?: number | undefined): number[];
					(array?: Matrix4Tuple | undefined, offset?: 0 | undefined): Matrix4Tuple;
					(array?: ArrayLike<number> | undefined, offset?: number | undefined): ArrayLike<number>;
				};
				setFromMatrix3: (m: Matrix3) => Matrix4;
				extractPosition: (m: Matrix4) => Matrix4;
				setRotationFromQuaternion: (q: Quaternion) => Matrix4;
				multiplyVector3: (v: any) => any;
				multiplyVector4: (v: any) => any;
				multiplyVector3Array: (array: number[]) => number[];
				rotateAxis: (v: any) => void;
				crossVector: (v: any) => void;
				flattenToArrayOffset: (array: number[], offset: number) => number[];
				getInverse: (matrix: Matrix) => Matrix;
			};
			projectionMatrixInverse: {
				elements: number[];
				set: (
					n11: number,
					n12: number,
					n13: number,
					n14: number,
					n21: number,
					n22: number,
					n23: number,
					n24: number,
					n31: number,
					n32: number,
					n33: number,
					n34: number,
					n41: number,
					n42: number,
					n43: number,
					n44: number
				) => Matrix4;
				identity: () => Matrix4;
				clone: () => Matrix4;
				copy: (m: Matrix4) => Matrix4;
				copyPosition: (m: Matrix4) => Matrix4;
				extractBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix4;
				makeBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix4;
				extractRotation: (m: Matrix4) => Matrix4;
				makeRotationFromEuler: (euler: Euler) => Matrix4;
				makeRotationFromQuaternion: (q: Quaternion) => Matrix4;
				lookAt: (eye: Vector3, target: Vector3, up: Vector3) => Matrix4;
				multiply: (m: Matrix4) => Matrix4;
				premultiply: (m: Matrix4) => Matrix4;
				multiplyMatrices: (a: Matrix4, b: Matrix4) => Matrix4;
				multiplyToArray: (a: Matrix4, b: Matrix4, r: number[]) => Matrix4;
				multiplyScalar: (s: number) => Matrix4;
				determinant: () => number;
				transpose: () => Matrix4;
				setPosition: (v: number | Vector3, y?: number | undefined, z?: number | undefined) => Matrix4;
				invert: () => Matrix4;
				scale: (v: Vector3) => Matrix4;
				getMaxScaleOnAxis: () => number;
				makeTranslation: (x: number, y: number, z: number) => Matrix4;
				makeRotationX: (theta: number) => Matrix4;
				makeRotationY: (theta: number) => Matrix4;
				makeRotationZ: (theta: number) => Matrix4;
				makeRotationAxis: (axis: Vector3, angle: number) => Matrix4;
				makeScale: (x: number, y: number, z: number) => Matrix4;
				makeShear: (xy: number, xz: number, yx: number, yz: number, zx: number, zy: number) => Matrix4;
				compose: (translation: Vector3, rotation: Quaternion, scale: Vector3) => Matrix4;
				decompose: (translation: Vector3, rotation: Quaternion, scale: Vector3) => Matrix4;
				makePerspective: {
					(left: number, right: number, bottom: number, top: number, near: number, far: number): Matrix4;
					(fov: number, aspect: number, near: number, far: number): Matrix4;
				};
				makeOrthographic: (
					left: number,
					right: number,
					top: number,
					bottom: number,
					near: number,
					far: number
				) => Matrix4;
				equals: (matrix: Matrix4) => boolean;
				fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Matrix4;
				toArray: {
					(array?: number[] | undefined, offset?: number | undefined): number[];
					(array?: Matrix4Tuple | undefined, offset?: 0 | undefined): Matrix4Tuple;
					(array?: ArrayLike<number> | undefined, offset?: number | undefined): ArrayLike<number>;
				};
				setFromMatrix3: (m: Matrix3) => Matrix4;
				extractPosition: (m: Matrix4) => Matrix4;
				setRotationFromQuaternion: (q: Quaternion) => Matrix4;
				multiplyVector3: (v: any) => any;
				multiplyVector4: (v: any) => any;
				multiplyVector3Array: (array: number[]) => number[];
				rotateAxis: (v: any) => void;
				crossVector: (v: any) => void;
				flattenToArrayOffset: (array: number[], offset: number) => number[];
				getInverse: (matrix: Matrix) => Matrix;
			};
			readonly isCamera: true;
			getWorldDirection: (target: Vector3) => Vector3;
			updateMatrixWorld: (force?: boolean | undefined) => void;
			id: number;
			uuid: string;
			name: string;
			type: string;
			parent: {
				id: number;
				uuid: string;
				name: string;
				type: string;
				parent: any | null;
				children: any[];
				up: {
					x: number;
					y: number;
					z: number;
					readonly isVector3: true;
					set: (x: number, y: number, z: number) => Vector3;
					setScalar: (scalar: number) => Vector3;
					setX: (x: number) => Vector3;
					setY: (y: number) => Vector3;
					setZ: (z: number) => Vector3;
					setComponent: (index: number, value: number) => Vector3;
					getComponent: (index: number) => number;
					clone: () => Vector3;
					copy: (v: Vector3) => Vector3;
					add: (v: Vector3) => Vector3;
					addScalar: (s: number) => Vector3;
					addScaledVector: (v: Vector3, s: number) => Vector3;
					addVectors: (a: Vector3, b: Vector3) => Vector3;
					sub: (a: Vector3) => Vector3;
					subScalar: (s: number) => Vector3;
					subVectors: (a: Vector3, b: Vector3) => Vector3;
					multiply: (v: Vector3) => Vector3;
					multiplyScalar: (s: number) => Vector3;
					multiplyVectors: (a: Vector3, b: Vector3) => Vector3;
					applyEuler: (euler: Euler) => Vector3;
					applyAxisAngle: (axis: Vector3, angle: number) => Vector3;
					applyMatrix3: (m: Matrix3) => Vector3;
					applyNormalMatrix: (m: Matrix3) => Vector3;
					applyMatrix4: (m: Matrix4) => Vector3;
					applyQuaternion: (q: Quaternion) => Vector3;
					project: (camera: Camera) => Vector3;
					unproject: (camera: Camera) => Vector3;
					transformDirection: (m: Matrix4) => Vector3;
					divide: (v: Vector3) => Vector3;
					divideScalar: (s: number) => Vector3;
					min: (v: Vector3) => Vector3;
					max: (v: Vector3) => Vector3;
					clamp: (min: Vector3, max: Vector3) => Vector3;
					clampScalar: (min: number, max: number) => Vector3;
					clampLength: (min: number, max: number) => Vector3;
					floor: () => Vector3;
					ceil: () => Vector3;
					round: () => Vector3;
					roundToZero: () => Vector3;
					negate: () => Vector3;
					dot: (v: Vector3) => number;
					lengthSq: () => number;
					length: () => number;
					lengthManhattan: () => number;
					manhattanLength: () => number;
					manhattanDistanceTo: (v: Vector3) => number;
					normalize: () => Vector3;
					setLength: (l: number) => Vector3;
					lerp: (v: Vector3, alpha: number) => Vector3;
					lerpVectors: (v1: Vector3, v2: Vector3, alpha: number) => Vector3;
					cross: (a: Vector3) => Vector3;
					crossVectors: (a: Vector3, b: Vector3) => Vector3;
					projectOnVector: (v: Vector3) => Vector3;
					projectOnPlane: (planeNormal: Vector3) => Vector3;
					reflect: (vector: Vector3) => Vector3;
					angleTo: (v: Vector3) => number;
					distanceTo: (v: Vector3) => number;
					distanceToSquared: (v: Vector3) => number;
					distanceToManhattan: (v: Vector3) => number;
					setFromSpherical: (s: Spherical) => Vector3;
					setFromSphericalCoords: (r: number, phi: number, theta: number) => Vector3;
					setFromCylindrical: (s: Cylindrical) => Vector3;
					setFromCylindricalCoords: (radius: number, theta: number, y: number) => Vector3;
					setFromMatrixPosition: (m: Matrix4) => Vector3;
					setFromMatrixScale: (m: Matrix4) => Vector3;
					setFromMatrixColumn: (matrix: Matrix4, index: number) => Vector3;
					setFromMatrix3Column: (matrix: Matrix3, index: number) => Vector3;
					setFromEuler: (e: Euler) => Vector3;
					equals: (v: Vector3) => boolean;
					fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Vector3;
					toArray: {
						(array?: number[] | undefined, offset?: number | undefined): number[];
						(array?: Vector3Tuple | undefined, offset?: 0 | undefined): Vector3Tuple;
						(array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
					};
					fromBufferAttribute: (
						attribute: BufferAttribute | InterleavedBufferAttribute,
						index: number
					) => Vector3;
					random: () => Vector3;
					randomDirection: () => Vector3;
				};
				readonly position: {
					x: number;
					y: number;
					z: number;
					readonly isVector3: true;
					set: (x: number, y: number, z: number) => Vector3;
					setScalar: (scalar: number) => Vector3;
					setX: (x: number) => Vector3;
					setY: (y: number) => Vector3;
					setZ: (z: number) => Vector3;
					setComponent: (index: number, value: number) => Vector3;
					getComponent: (index: number) => number;
					clone: () => Vector3;
					copy: (v: Vector3) => Vector3;
					add: (v: Vector3) => Vector3;
					addScalar: (s: number) => Vector3;
					addScaledVector: (v: Vector3, s: number) => Vector3;
					addVectors: (a: Vector3, b: Vector3) => Vector3;
					sub: (a: Vector3) => Vector3;
					subScalar: (s: number) => Vector3;
					subVectors: (a: Vector3, b: Vector3) => Vector3;
					multiply: (v: Vector3) => Vector3;
					multiplyScalar: (s: number) => Vector3;
					multiplyVectors: (a: Vector3, b: Vector3) => Vector3;
					applyEuler: (euler: Euler) => Vector3;
					applyAxisAngle: (axis: Vector3, angle: number) => Vector3;
					applyMatrix3: (m: Matrix3) => Vector3;
					applyNormalMatrix: (m: Matrix3) => Vector3;
					applyMatrix4: (m: Matrix4) => Vector3;
					applyQuaternion: (q: Quaternion) => Vector3;
					project: (camera: Camera) => Vector3;
					unproject: (camera: Camera) => Vector3;
					transformDirection: (m: Matrix4) => Vector3;
					divide: (v: Vector3) => Vector3;
					divideScalar: (s: number) => Vector3;
					min: (v: Vector3) => Vector3;
					max: (v: Vector3) => Vector3;
					clamp: (min: Vector3, max: Vector3) => Vector3;
					clampScalar: (min: number, max: number) => Vector3;
					clampLength: (min: number, max: number) => Vector3;
					floor: () => Vector3;
					ceil: () => Vector3;
					round: () => Vector3;
					roundToZero: () => Vector3;
					negate: () => Vector3;
					dot: (v: Vector3) => number;
					lengthSq: () => number;
					length: () => number;
					lengthManhattan: () => number;
					manhattanLength: () => number;
					manhattanDistanceTo: (v: Vector3) => number;
					normalize: () => Vector3;
					setLength: (l: number) => Vector3;
					lerp: (v: Vector3, alpha: number) => Vector3;
					lerpVectors: (v1: Vector3, v2: Vector3, alpha: number) => Vector3;
					cross: (a: Vector3) => Vector3;
					crossVectors: (a: Vector3, b: Vector3) => Vector3;
					projectOnVector: (v: Vector3) => Vector3;
					projectOnPlane: (planeNormal: Vector3) => Vector3;
					reflect: (vector: Vector3) => Vector3;
					angleTo: (v: Vector3) => number;
					distanceTo: (v: Vector3) => number;
					distanceToSquared: (v: Vector3) => number;
					distanceToManhattan: (v: Vector3) => number;
					setFromSpherical: (s: Spherical) => Vector3;
					setFromSphericalCoords: (r: number, phi: number, theta: number) => Vector3;
					setFromCylindrical: (s: Cylindrical) => Vector3;
					setFromCylindricalCoords: (radius: number, theta: number, y: number) => Vector3;
					setFromMatrixPosition: (m: Matrix4) => Vector3;
					setFromMatrixScale: (m: Matrix4) => Vector3;
					setFromMatrixColumn: (matrix: Matrix4, index: number) => Vector3;
					setFromMatrix3Column: (matrix: Matrix3, index: number) => Vector3;
					setFromEuler: (e: Euler) => Vector3;
					equals: (v: Vector3) => boolean;
					fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Vector3;
					toArray: {
						(array?: number[] | undefined, offset?: number | undefined): number[];
						(array?: Vector3Tuple | undefined, offset?: 0 | undefined): Vector3Tuple;
						(array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
					};
					fromBufferAttribute: (
						attribute: BufferAttribute | InterleavedBufferAttribute,
						index: number
					) => Vector3;
					random: () => Vector3;
					randomDirection: () => Vector3;
				};
				readonly rotation: {
					x: number;
					y: number;
					z: number;
					order: EulerOrder;
					readonly isEuler: true;
					_onChangeCallback: () => void;
					set: (x: number, y: number, z: number, order?: EulerOrder | undefined) => Euler;
					clone: () => Euler;
					copy: (euler: Euler) => Euler;
					setFromRotationMatrix: (
						m: Matrix4,
						order?: EulerOrder | undefined,
						update?: boolean | undefined
					) => Euler;
					setFromQuaternion: (
						q: Quaternion,
						order?: EulerOrder | undefined,
						update?: boolean | undefined
					) => Euler;
					setFromVector3: (v: Vector3, order?: EulerOrder | undefined) => Euler;
					reorder: (newOrder: EulerOrder) => Euler;
					equals: (euler: Euler) => boolean;
					fromArray: (xyzo: [number, number, number, (EulerOrder | undefined)?, ...any[]]) => Euler;
					toArray: (
						array?: (string | number | undefined)[] | undefined,
						offset?: number | undefined
					) => (string | number | undefined)[];
					_onChange: (callback: () => void) => Euler;
					[Symbol.iterator]: () => Generator<string | number, void, unknown>;
				};
				readonly quaternion: {
					x: number;
					y: number;
					z: number;
					w: number;
					readonly isQuaternion: true;
					set: (x: number, y: number, z: number, w: number) => Quaternion;
					clone: () => Quaternion;
					copy: (q: Quaternion) => Quaternion;
					setFromEuler: (euler: Euler, update?: boolean | undefined) => Quaternion;
					setFromAxisAngle: (axis: Vector3, angle: number) => Quaternion;
					setFromRotationMatrix: (m: Matrix4) => Quaternion;
					setFromUnitVectors: (vFrom: Vector3, vTo: Vector3) => Quaternion;
					angleTo: (q: Quaternion) => number;
					rotateTowards: (q: Quaternion, step: number) => Quaternion;
					identity: () => Quaternion;
					invert: () => Quaternion;
					conjugate: () => Quaternion;
					dot: (v: Quaternion) => number;
					lengthSq: () => number;
					length: () => number;
					normalize: () => Quaternion;
					multiply: (q: Quaternion) => Quaternion;
					premultiply: (q: Quaternion) => Quaternion;
					multiplyQuaternions: (a: Quaternion, b: Quaternion) => Quaternion;
					slerp: (qb: Quaternion, t: number) => Quaternion;
					slerpQuaternions: (qa: Quaternion, qb: Quaternion, t: number) => Quaternion;
					equals: (v: Quaternion) => boolean;
					fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Quaternion;
					toArray: {
						(array?: number[] | undefined, offset?: number | undefined): number[];
						(array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
					};
					fromBufferAttribute: (
						attribute: BufferAttribute | InterleavedBufferAttribute,
						index: number
					) => Quaternion;
					_onChange: (callback: () => void) => Quaternion;
					_onChangeCallback: () => void;
					multiplyVector3: (v: any) => any;
					random: () => Quaternion;
					[Symbol.iterator]: () => Generator<number, void, unknown>;
				};
				readonly scale: {
					x: number;
					y: number;
					z: number;
					readonly isVector3: true;
					set: (x: number, y: number, z: number) => Vector3;
					setScalar: (scalar: number) => Vector3;
					setX: (x: number) => Vector3;
					setY: (y: number) => Vector3;
					setZ: (z: number) => Vector3;
					setComponent: (index: number, value: number) => Vector3;
					getComponent: (index: number) => number;
					clone: () => Vector3;
					copy: (v: Vector3) => Vector3;
					add: (v: Vector3) => Vector3;
					addScalar: (s: number) => Vector3;
					addScaledVector: (v: Vector3, s: number) => Vector3;
					addVectors: (a: Vector3, b: Vector3) => Vector3;
					sub: (a: Vector3) => Vector3;
					subScalar: (s: number) => Vector3;
					subVectors: (a: Vector3, b: Vector3) => Vector3;
					multiply: (v: Vector3) => Vector3;
					multiplyScalar: (s: number) => Vector3;
					multiplyVectors: (a: Vector3, b: Vector3) => Vector3;
					applyEuler: (euler: Euler) => Vector3;
					applyAxisAngle: (axis: Vector3, angle: number) => Vector3;
					applyMatrix3: (m: Matrix3) => Vector3;
					applyNormalMatrix: (m: Matrix3) => Vector3;
					applyMatrix4: (m: Matrix4) => Vector3;
					applyQuaternion: (q: Quaternion) => Vector3;
					project: (camera: Camera) => Vector3;
					unproject: (camera: Camera) => Vector3;
					transformDirection: (m: Matrix4) => Vector3;
					divide: (v: Vector3) => Vector3;
					divideScalar: (s: number) => Vector3;
					min: (v: Vector3) => Vector3;
					max: (v: Vector3) => Vector3;
					clamp: (min: Vector3, max: Vector3) => Vector3;
					clampScalar: (min: number, max: number) => Vector3;
					clampLength: (min: number, max: number) => Vector3;
					floor: () => Vector3;
					ceil: () => Vector3;
					round: () => Vector3;
					roundToZero: () => Vector3;
					negate: () => Vector3;
					dot: (v: Vector3) => number;
					lengthSq: () => number;
					length: () => number;
					lengthManhattan: () => number;
					manhattanLength: () => number;
					manhattanDistanceTo: (v: Vector3) => number;
					normalize: () => Vector3;
					setLength: (l: number) => Vector3;
					lerp: (v: Vector3, alpha: number) => Vector3;
					lerpVectors: (v1: Vector3, v2: Vector3, alpha: number) => Vector3;
					cross: (a: Vector3) => Vector3;
					crossVectors: (a: Vector3, b: Vector3) => Vector3;
					projectOnVector: (v: Vector3) => Vector3;
					projectOnPlane: (planeNormal: Vector3) => Vector3;
					reflect: (vector: Vector3) => Vector3;
					angleTo: (v: Vector3) => number;
					distanceTo: (v: Vector3) => number;
					distanceToSquared: (v: Vector3) => number;
					distanceToManhattan: (v: Vector3) => number;
					setFromSpherical: (s: Spherical) => Vector3;
					setFromSphericalCoords: (r: number, phi: number, theta: number) => Vector3;
					setFromCylindrical: (s: Cylindrical) => Vector3;
					setFromCylindricalCoords: (radius: number, theta: number, y: number) => Vector3;
					setFromMatrixPosition: (m: Matrix4) => Vector3;
					setFromMatrixScale: (m: Matrix4) => Vector3;
					setFromMatrixColumn: (matrix: Matrix4, index: number) => Vector3;
					setFromMatrix3Column: (matrix: Matrix3, index: number) => Vector3;
					setFromEuler: (e: Euler) => Vector3;
					equals: (v: Vector3) => boolean;
					fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Vector3;
					toArray: {
						(array?: number[] | undefined, offset?: number | undefined): number[];
						(array?: Vector3Tuple | undefined, offset?: 0 | undefined): Vector3Tuple;
						(array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
					};
					fromBufferAttribute: (
						attribute: BufferAttribute | InterleavedBufferAttribute,
						index: number
					) => Vector3;
					random: () => Vector3;
					randomDirection: () => Vector3;
				};
				readonly modelViewMatrix: {
					elements: number[];
					set: (
						n11: number,
						n12: number,
						n13: number,
						n14: number,
						n21: number,
						n22: number,
						n23: number,
						n24: number,
						n31: number,
						n32: number,
						n33: number,
						n34: number,
						n41: number,
						n42: number,
						n43: number,
						n44: number
					) => Matrix4;
					identity: () => Matrix4;
					clone: () => Matrix4;
					copy: (m: Matrix4) => Matrix4;
					copyPosition: (m: Matrix4) => Matrix4;
					extractBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix4;
					makeBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix4;
					extractRotation: (m: Matrix4) => Matrix4;
					makeRotationFromEuler: (euler: Euler) => Matrix4;
					makeRotationFromQuaternion: (q: Quaternion) => Matrix4;
					lookAt: (eye: Vector3, target: Vector3, up: Vector3) => Matrix4;
					multiply: (m: Matrix4) => Matrix4;
					premultiply: (m: Matrix4) => Matrix4;
					multiplyMatrices: (a: Matrix4, b: Matrix4) => Matrix4;
					multiplyToArray: (a: Matrix4, b: Matrix4, r: number[]) => Matrix4;
					multiplyScalar: (s: number) => Matrix4;
					determinant: () => number;
					transpose: () => Matrix4;
					setPosition: (v: number | Vector3, y?: number | undefined, z?: number | undefined) => Matrix4;
					invert: () => Matrix4;
					scale: (v: Vector3) => Matrix4;
					getMaxScaleOnAxis: () => number;
					makeTranslation: (x: number, y: number, z: number) => Matrix4;
					makeRotationX: (theta: number) => Matrix4;
					makeRotationY: (theta: number) => Matrix4;
					makeRotationZ: (theta: number) => Matrix4;
					makeRotationAxis: (axis: Vector3, angle: number) => Matrix4;
					makeScale: (x: number, y: number, z: number) => Matrix4;
					makeShear: (xy: number, xz: number, yx: number, yz: number, zx: number, zy: number) => Matrix4;
					compose: (translation: Vector3, rotation: Quaternion, scale: Vector3) => Matrix4;
					decompose: (translation: Vector3, rotation: Quaternion, scale: Vector3) => Matrix4;
					makePerspective: {
						(left: number, right: number, bottom: number, top: number, near: number, far: number): Matrix4;
						(fov: number, aspect: number, near: number, far: number): Matrix4;
					};
					makeOrthographic: (
						left: number,
						right: number,
						top: number,
						bottom: number,
						near: number,
						far: number
					) => Matrix4;
					equals: (matrix: Matrix4) => boolean;
					fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Matrix4;
					toArray: {
						(array?: number[] | undefined, offset?: number | undefined): number[];
						(array?: Matrix4Tuple | undefined, offset?: 0 | undefined): Matrix4Tuple;
						(array?: ArrayLike<number> | undefined, offset?: number | undefined): ArrayLike<number>;
					};
					setFromMatrix3: (m: Matrix3) => Matrix4;
					extractPosition: (m: Matrix4) => Matrix4;
					setRotationFromQuaternion: (q: Quaternion) => Matrix4;
					multiplyVector3: (v: any) => any;
					multiplyVector4: (v: any) => any;
					multiplyVector3Array: (array: number[]) => number[];
					rotateAxis: (v: any) => void;
					crossVector: (v: any) => void;
					flattenToArrayOffset: (array: number[], offset: number) => number[];
					getInverse: (matrix: Matrix) => Matrix;
				};
				readonly normalMatrix: {
					elements: number[];
					set: (
						n11: number,
						n12: number,
						n13: number,
						n21: number,
						n22: number,
						n23: number,
						n31: number,
						n32: number,
						n33: number
					) => Matrix3;
					identity: () => Matrix3;
					clone: () => Matrix3;
					copy: (m: Matrix3) => Matrix3;
					extractBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix3;
					setFromMatrix4: (m: Matrix4) => Matrix3;
					multiplyScalar: (s: number) => Matrix3;
					determinant: () => number;
					invert: () => Matrix3;
					transpose: () => Matrix3;
					getNormalMatrix: (matrix4: Matrix4) => Matrix3;
					transposeIntoArray: (r: number[]) => Matrix3;
					setUvTransform: (
						tx: number,
						ty: number,
						sx: number,
						sy: number,
						rotation: number,
						cx: number,
						cy: number
					) => Matrix3;
					scale: (sx: number, sy: number) => Matrix3;
					makeTranslation: {
						(x: number, y: number): Matrix3;
						(x: number, y: number): Matrix3;
					};
					makeRotation: {
						(theta: number): Matrix3;
						(theta: number): Matrix3;
					};
					makeScale: {
						(x: number, y: number): Matrix3;
						(x: number, y: number): Matrix3;
					};
					rotate: (theta: number) => Matrix3;
					translate: (tx: number, ty: number) => Matrix3;
					equals: (matrix: Matrix3) => boolean;
					fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Matrix3;
					toArray: {
						(array?: number[] | undefined, offset?: number | undefined): number[];
						(array?: Matrix3Tuple | undefined, offset?: 0 | undefined): Matrix3Tuple;
						(array?: ArrayLike<number> | undefined, offset?: number | undefined): ArrayLike<number>;
					};
					multiply: (m: Matrix3) => Matrix3;
					premultiply: (m: Matrix3) => Matrix3;
					multiplyMatrices: (a: Matrix3, b: Matrix3) => Matrix3;
					multiplyVector3: (vector: Vector3) => any;
					multiplyVector3Array: (a: any) => any;
					getInverse: {
						(matrix: Matrix4, throwOnDegenerate?: boolean | undefined): Matrix3;
						(matrix: Matrix): Matrix;
					};
					flattenToArrayOffset: (array: number[], offset: number) => number[];
				};
				matrix: {
					elements: number[];
					set: (
						n11: number,
						n12: number,
						n13: number,
						n14: number,
						n21: number,
						n22: number,
						n23: number,
						n24: number,
						n31: number,
						n32: number,
						n33: number,
						n34: number,
						n41: number,
						n42: number,
						n43: number,
						n44: number
					) => Matrix4;
					identity: () => Matrix4;
					clone: () => Matrix4;
					copy: (m: Matrix4) => Matrix4;
					copyPosition: (m: Matrix4) => Matrix4;
					extractBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix4;
					makeBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix4;
					extractRotation: (m: Matrix4) => Matrix4;
					makeRotationFromEuler: (euler: Euler) => Matrix4;
					makeRotationFromQuaternion: (q: Quaternion) => Matrix4;
					lookAt: (eye: Vector3, target: Vector3, up: Vector3) => Matrix4;
					multiply: (m: Matrix4) => Matrix4;
					premultiply: (m: Matrix4) => Matrix4;
					multiplyMatrices: (a: Matrix4, b: Matrix4) => Matrix4;
					multiplyToArray: (a: Matrix4, b: Matrix4, r: number[]) => Matrix4;
					multiplyScalar: (s: number) => Matrix4;
					determinant: () => number;
					transpose: () => Matrix4;
					setPosition: (v: number | Vector3, y?: number | undefined, z?: number | undefined) => Matrix4;
					invert: () => Matrix4;
					scale: (v: Vector3) => Matrix4;
					getMaxScaleOnAxis: () => number;
					makeTranslation: (x: number, y: number, z: number) => Matrix4;
					makeRotationX: (theta: number) => Matrix4;
					makeRotationY: (theta: number) => Matrix4;
					makeRotationZ: (theta: number) => Matrix4;
					makeRotationAxis: (axis: Vector3, angle: number) => Matrix4;
					makeScale: (x: number, y: number, z: number) => Matrix4;
					makeShear: (xy: number, xz: number, yx: number, yz: number, zx: number, zy: number) => Matrix4;
					compose: (translation: Vector3, rotation: Quaternion, scale: Vector3) => Matrix4;
					decompose: (translation: Vector3, rotation: Quaternion, scale: Vector3) => Matrix4;
					makePerspective: {
						(left: number, right: number, bottom: number, top: number, near: number, far: number): Matrix4;
						(fov: number, aspect: number, near: number, far: number): Matrix4;
					};
					makeOrthographic: (
						left: number,
						right: number,
						top: number,
						bottom: number,
						near: number,
						far: number
					) => Matrix4;
					equals: (matrix: Matrix4) => boolean;
					fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Matrix4;
					toArray: {
						(array?: number[] | undefined, offset?: number | undefined): number[];
						(array?: Matrix4Tuple | undefined, offset?: 0 | undefined): Matrix4Tuple;
						(array?: ArrayLike<number> | undefined, offset?: number | undefined): ArrayLike<number>;
					};
					setFromMatrix3: (m: Matrix3) => Matrix4;
					extractPosition: (m: Matrix4) => Matrix4;
					setRotationFromQuaternion: (q: Quaternion) => Matrix4;
					multiplyVector3: (v: any) => any;
					multiplyVector4: (v: any) => any;
					multiplyVector3Array: (array: number[]) => number[];
					rotateAxis: (v: any) => void;
					crossVector: (v: any) => void;
					flattenToArrayOffset: (array: number[], offset: number) => number[];
					getInverse: (matrix: Matrix) => Matrix;
				};
				matrixWorld: {
					elements: number[];
					set: (
						n11: number,
						n12: number,
						n13: number,
						n14: number,
						n21: number,
						n22: number,
						n23: number,
						n24: number,
						n31: number,
						n32: number,
						n33: number,
						n34: number,
						n41: number,
						n42: number,
						n43: number,
						n44: number
					) => Matrix4;
					identity: () => Matrix4;
					clone: () => Matrix4;
					copy: (m: Matrix4) => Matrix4;
					copyPosition: (m: Matrix4) => Matrix4;
					extractBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix4;
					makeBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix4;
					extractRotation: (m: Matrix4) => Matrix4;
					makeRotationFromEuler: (euler: Euler) => Matrix4;
					makeRotationFromQuaternion: (q: Quaternion) => Matrix4;
					lookAt: (eye: Vector3, target: Vector3, up: Vector3) => Matrix4;
					multiply: (m: Matrix4) => Matrix4;
					premultiply: (m: Matrix4) => Matrix4;
					multiplyMatrices: (a: Matrix4, b: Matrix4) => Matrix4;
					multiplyToArray: (a: Matrix4, b: Matrix4, r: number[]) => Matrix4;
					multiplyScalar: (s: number) => Matrix4;
					determinant: () => number;
					transpose: () => Matrix4;
					setPosition: (v: number | Vector3, y?: number | undefined, z?: number | undefined) => Matrix4;
					invert: () => Matrix4;
					scale: (v: Vector3) => Matrix4;
					getMaxScaleOnAxis: () => number;
					makeTranslation: (x: number, y: number, z: number) => Matrix4;
					makeRotationX: (theta: number) => Matrix4;
					makeRotationY: (theta: number) => Matrix4;
					makeRotationZ: (theta: number) => Matrix4;
					makeRotationAxis: (axis: Vector3, angle: number) => Matrix4;
					makeScale: (x: number, y: number, z: number) => Matrix4;
					makeShear: (xy: number, xz: number, yx: number, yz: number, zx: number, zy: number) => Matrix4;
					compose: (translation: Vector3, rotation: Quaternion, scale: Vector3) => Matrix4;
					decompose: (translation: Vector3, rotation: Quaternion, scale: Vector3) => Matrix4;
					makePerspective: {
						(left: number, right: number, bottom: number, top: number, near: number, far: number): Matrix4;
						(fov: number, aspect: number, near: number, far: number): Matrix4;
					};
					makeOrthographic: (
						left: number,
						right: number,
						top: number,
						bottom: number,
						near: number,
						far: number
					) => Matrix4;
					equals: (matrix: Matrix4) => boolean;
					fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Matrix4;
					toArray: {
						(array?: number[] | undefined, offset?: number | undefined): number[];
						(array?: Matrix4Tuple | undefined, offset?: 0 | undefined): Matrix4Tuple;
						(array?: ArrayLike<number> | undefined, offset?: number | undefined): ArrayLike<number>;
					};
					setFromMatrix3: (m: Matrix3) => Matrix4;
					extractPosition: (m: Matrix4) => Matrix4;
					setRotationFromQuaternion: (q: Quaternion) => Matrix4;
					multiplyVector3: (v: any) => any;
					multiplyVector4: (v: any) => any;
					multiplyVector3Array: (array: number[]) => number[];
					rotateAxis: (v: any) => void;
					crossVector: (v: any) => void;
					flattenToArrayOffset: (array: number[], offset: number) => number[];
					getInverse: (matrix: Matrix) => Matrix;
				};
				matrixAutoUpdate: boolean;
				matrixWorldAutoUpdate: boolean;
				matrixWorldNeedsUpdate: boolean;
				layers: {
					mask: number;
					set: (channel: number) => void;
					enable: (channel: number) => void;
					enableAll: () => void;
					toggle: (channel: number) => void;
					disable: (channel: number) => void;
					disableAll: () => void;
					test: (layers: Layers) => boolean;
					isEnabled: (channel: number) => boolean;
				};
				visible: boolean;
				castShadow: boolean;
				receiveShadow: boolean;
				frustumCulled: boolean;
				renderOrder: number;
				animations: {
					name: string;
					tracks: {
						name: string;
						times: {
							[x: number]: number;
							readonly BYTES_PER_ELEMENT: number;
							readonly buffer:
								| {
										readonly byteLength: number;
										slice: (begin: number, end?: number | undefined) => ArrayBuffer;
										readonly [Symbol.toStringTag]: string;
								  }
								| {
										readonly byteLength: number;
										slice: (begin: number, end?: number | undefined) => SharedArrayBuffer;
										readonly [Symbol.species]: SharedArrayBuffer;
										readonly [Symbol.toStringTag]: 'SharedArrayBuffer';
								  };
							readonly byteLength: number;
							readonly byteOffset: number;
							copyWithin: (target: number, start: number, end?: number | undefined) => Float32Array;
							every: (
								predicate: (value: number, index: number, array: Float32Array) => unknown,
								thisArg?: any
							) => boolean;
							fill: (value: number, start?: number | undefined, end?: number | undefined) => Float32Array;
							filter: (
								predicate: (value: number, index: number, array: Float32Array) => any,
								thisArg?: any
							) => Float32Array;
							find: (
								predicate: (value: number, index: number, obj: Float32Array) => boolean,
								thisArg?: any
							) => number | undefined;
							findIndex: (
								predicate: (value: number, index: number, obj: Float32Array) => boolean,
								thisArg?: any
							) => number;
							forEach: (
								callbackfn: (value: number, index: number, array: Float32Array) => void,
								thisArg?: any
							) => void;
							indexOf: (searchElement: number, fromIndex?: number | undefined) => number;
							join: (separator?: string | undefined) => string;
							lastIndexOf: (searchElement: number, fromIndex?: number | undefined) => number;
							readonly length: number;
							map: (
								callbackfn: (value: number, index: number, array: Float32Array) => number,
								thisArg?: any
							) => Float32Array;
							reduce: {
								(
									callbackfn: (
										previousValue: number,
										currentValue: number,
										currentIndex: number,
										array: Float32Array
									) => number
								): number;
								(
									callbackfn: (
										previousValue: number,
										currentValue: number,
										currentIndex: number,
										array: Float32Array
									) => number,
									initialValue: number
								): number;
								<U>(
									callbackfn: (
										previousValue: U,
										currentValue: number,
										currentIndex: number,
										array: Float32Array
									) => U,
									initialValue: U
								): U;
							};
							reduceRight: {
								(
									callbackfn: (
										previousValue: number,
										currentValue: number,
										currentIndex: number,
										array: Float32Array
									) => number
								): number;
								(
									callbackfn: (
										previousValue: number,
										currentValue: number,
										currentIndex: number,
										array: Float32Array
									) => number,
									initialValue: number
								): number;
								<U_1>(
									callbackfn: (
										previousValue: U_1,
										currentValue: number,
										currentIndex: number,
										array: Float32Array
									) => U_1,
									initialValue: U_1
								): U_1;
							};
							reverse: () => Float32Array;
							set: (array: ArrayLike<number>, offset?: number | undefined) => void;
							slice: (start?: number | undefined, end?: number | undefined) => Float32Array;
							some: (
								predicate: (value: number, index: number, array: Float32Array) => unknown,
								thisArg?: any
							) => boolean;
							sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
							subarray: (begin?: number | undefined, end?: number | undefined) => Float32Array;
							toLocaleString: () => string;
							toString: () => string;
							valueOf: () => Float32Array;
							entries: () => IterableIterator<[number, number]>;
							keys: () => IterableIterator<number>;
							values: () => IterableIterator<number>;
							includes: (searchElement: number, fromIndex?: number | undefined) => boolean;
							[Symbol.iterator]: () => IterableIterator<number>;
							readonly [Symbol.toStringTag]: 'Float32Array';
							at: (index: number) => number | undefined;
						};
						values: {
							[x: number]: number;
							readonly BYTES_PER_ELEMENT: number;
							readonly buffer:
								| {
										readonly byteLength: number;
										slice: (begin: number, end?: number | undefined) => ArrayBuffer;
										readonly [Symbol.toStringTag]: string;
								  }
								| {
										readonly byteLength: number;
										slice: (begin: number, end?: number | undefined) => SharedArrayBuffer;
										readonly [Symbol.species]: SharedArrayBuffer;
										readonly [Symbol.toStringTag]: 'SharedArrayBuffer';
								  };
							readonly byteLength: number;
							readonly byteOffset: number;
							copyWithin: (target: number, start: number, end?: number | undefined) => Float32Array;
							every: (
								predicate: (value: number, index: number, array: Float32Array) => unknown,
								thisArg?: any
							) => boolean;
							fill: (value: number, start?: number | undefined, end?: number | undefined) => Float32Array;
							filter: (
								predicate: (value: number, index: number, array: Float32Array) => any,
								thisArg?: any
							) => Float32Array;
							find: (
								predicate: (value: number, index: number, obj: Float32Array) => boolean,
								thisArg?: any
							) => number | undefined;
							findIndex: (
								predicate: (value: number, index: number, obj: Float32Array) => boolean,
								thisArg?: any
							) => number;
							forEach: (
								callbackfn: (value: number, index: number, array: Float32Array) => void,
								thisArg?: any
							) => void;
							indexOf: (searchElement: number, fromIndex?: number | undefined) => number;
							join: (separator?: string | undefined) => string;
							lastIndexOf: (searchElement: number, fromIndex?: number | undefined) => number;
							readonly length: number;
							map: (
								callbackfn: (value: number, index: number, array: Float32Array) => number,
								thisArg?: any
							) => Float32Array;
							reduce: {
								(
									callbackfn: (
										previousValue: number,
										currentValue: number,
										currentIndex: number,
										array: Float32Array
									) => number
								): number;
								(
									callbackfn: (
										previousValue: number,
										currentValue: number,
										currentIndex: number,
										array: Float32Array
									) => number,
									initialValue: number
								): number;
								<U>(
									callbackfn: (
										previousValue: U,
										currentValue: number,
										currentIndex: number,
										array: Float32Array
									) => U,
									initialValue: U
								): U;
							};
							reduceRight: {
								(
									callbackfn: (
										previousValue: number,
										currentValue: number,
										currentIndex: number,
										array: Float32Array
									) => number
								): number;
								(
									callbackfn: (
										previousValue: number,
										currentValue: number,
										currentIndex: number,
										array: Float32Array
									) => number,
									initialValue: number
								): number;
								<U_1>(
									callbackfn: (
										previousValue: U_1,
										currentValue: number,
										currentIndex: number,
										array: Float32Array
									) => U_1,
									initialValue: U_1
								): U_1;
							};
							reverse: () => Float32Array;
							set: (array: ArrayLike<number>, offset?: number | undefined) => void;
							slice: (start?: number | undefined, end?: number | undefined) => Float32Array;
							some: (
								predicate: (value: number, index: number, array: Float32Array) => unknown,
								thisArg?: any
							) => boolean;
							sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
							subarray: (begin?: number | undefined, end?: number | undefined) => Float32Array;
							toLocaleString: () => string;
							toString: () => string;
							valueOf: () => Float32Array;
							entries: () => IterableIterator<[number, number]>;
							keys: () => IterableIterator<number>;
							values: () => IterableIterator<number>;
							includes: (searchElement: number, fromIndex?: number | undefined) => boolean;
							[Symbol.iterator]: () => IterableIterator<number>;
							readonly [Symbol.toStringTag]: 'Float32Array';
							at: (index: number) => number | undefined;
						};
						ValueTypeName: string;
						TimeBufferType: {
							[x: number]: number;
							readonly BYTES_PER_ELEMENT: number;
							readonly buffer:
								| {
										readonly byteLength: number;
										slice: (begin: number, end?: number | undefined) => ArrayBuffer;
										readonly [Symbol.toStringTag]: string;
								  }
								| {
										readonly byteLength: number;
										slice: (begin: number, end?: number | undefined) => SharedArrayBuffer;
										readonly [Symbol.species]: SharedArrayBuffer;
										readonly [Symbol.toStringTag]: 'SharedArrayBuffer';
								  };
							readonly byteLength: number;
							readonly byteOffset: number;
							copyWithin: (target: number, start: number, end?: number | undefined) => Float32Array;
							every: (
								predicate: (value: number, index: number, array: Float32Array) => unknown,
								thisArg?: any
							) => boolean;
							fill: (value: number, start?: number | undefined, end?: number | undefined) => Float32Array;
							filter: (
								predicate: (value: number, index: number, array: Float32Array) => any,
								thisArg?: any
							) => Float32Array;
							find: (
								predicate: (value: number, index: number, obj: Float32Array) => boolean,
								thisArg?: any
							) => number | undefined;
							findIndex: (
								predicate: (value: number, index: number, obj: Float32Array) => boolean,
								thisArg?: any
							) => number;
							forEach: (
								callbackfn: (value: number, index: number, array: Float32Array) => void,
								thisArg?: any
							) => void;
							indexOf: (searchElement: number, fromIndex?: number | undefined) => number;
							join: (separator?: string | undefined) => string;
							lastIndexOf: (searchElement: number, fromIndex?: number | undefined) => number;
							readonly length: number;
							map: (
								callbackfn: (value: number, index: number, array: Float32Array) => number,
								thisArg?: any
							) => Float32Array;
							reduce: {
								(
									callbackfn: (
										previousValue: number,
										currentValue: number,
										currentIndex: number,
										array: Float32Array
									) => number
								): number;
								(
									callbackfn: (
										previousValue: number,
										currentValue: number,
										currentIndex: number,
										array: Float32Array
									) => number,
									initialValue: number
								): number;
								<U>(
									callbackfn: (
										previousValue: U,
										currentValue: number,
										currentIndex: number,
										array: Float32Array
									) => U,
									initialValue: U
								): U;
							};
							reduceRight: {
								(
									callbackfn: (
										previousValue: number,
										currentValue: number,
										currentIndex: number,
										array: Float32Array
									) => number
								): number;
								(
									callbackfn: (
										previousValue: number,
										currentValue: number,
										currentIndex: number,
										array: Float32Array
									) => number,
									initialValue: number
								): number;
								<U_1>(
									callbackfn: (
										previousValue: U_1,
										currentValue: number,
										currentIndex: number,
										array: Float32Array
									) => U_1,
									initialValue: U_1
								): U_1;
							};
							reverse: () => Float32Array;
							set: (array: ArrayLike<number>, offset?: number | undefined) => void;
							slice: (start?: number | undefined, end?: number | undefined) => Float32Array;
							some: (
								predicate: (value: number, index: number, array: Float32Array) => unknown,
								thisArg?: any
							) => boolean;
							sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
							subarray: (begin?: number | undefined, end?: number | undefined) => Float32Array;
							toLocaleString: () => string;
							toString: () => string;
							valueOf: () => Float32Array;
							entries: () => IterableIterator<[number, number]>;
							keys: () => IterableIterator<number>;
							values: () => IterableIterator<number>;
							includes: (searchElement: number, fromIndex?: number | undefined) => boolean;
							[Symbol.iterator]: () => IterableIterator<number>;
							readonly [Symbol.toStringTag]: 'Float32Array';
							at: (index: number) => number | undefined;
						};
						ValueBufferType: {
							[x: number]: number;
							readonly BYTES_PER_ELEMENT: number;
							readonly buffer:
								| {
										readonly byteLength: number;
										slice: (begin: number, end?: number | undefined) => ArrayBuffer;
										readonly [Symbol.toStringTag]: string;
								  }
								| {
										readonly byteLength: number;
										slice: (begin: number, end?: number | undefined) => SharedArrayBuffer;
										readonly [Symbol.species]: SharedArrayBuffer;
										readonly [Symbol.toStringTag]: 'SharedArrayBuffer';
								  };
							readonly byteLength: number;
							readonly byteOffset: number;
							copyWithin: (target: number, start: number, end?: number | undefined) => Float32Array;
							every: (
								predicate: (value: number, index: number, array: Float32Array) => unknown,
								thisArg?: any
							) => boolean;
							fill: (value: number, start?: number | undefined, end?: number | undefined) => Float32Array;
							filter: (
								predicate: (value: number, index: number, array: Float32Array) => any,
								thisArg?: any
							) => Float32Array;
							find: (
								predicate: (value: number, index: number, obj: Float32Array) => boolean,
								thisArg?: any
							) => number | undefined;
							findIndex: (
								predicate: (value: number, index: number, obj: Float32Array) => boolean,
								thisArg?: any
							) => number;
							forEach: (
								callbackfn: (value: number, index: number, array: Float32Array) => void,
								thisArg?: any
							) => void;
							indexOf: (searchElement: number, fromIndex?: number | undefined) => number;
							join: (separator?: string | undefined) => string;
							lastIndexOf: (searchElement: number, fromIndex?: number | undefined) => number;
							readonly length: number;
							map: (
								callbackfn: (value: number, index: number, array: Float32Array) => number,
								thisArg?: any
							) => Float32Array;
							reduce: {
								(
									callbackfn: (
										previousValue: number,
										currentValue: number,
										currentIndex: number,
										array: Float32Array
									) => number
								): number;
								(
									callbackfn: (
										previousValue: number,
										currentValue: number,
										currentIndex: number,
										array: Float32Array
									) => number,
									initialValue: number
								): number;
								<U>(
									callbackfn: (
										previousValue: U,
										currentValue: number,
										currentIndex: number,
										array: Float32Array
									) => U,
									initialValue: U
								): U;
							};
							reduceRight: {
								(
									callbackfn: (
										previousValue: number,
										currentValue: number,
										currentIndex: number,
										array: Float32Array
									) => number
								): number;
								(
									callbackfn: (
										previousValue: number,
										currentValue: number,
										currentIndex: number,
										array: Float32Array
									) => number,
									initialValue: number
								): number;
								<U_1>(
									callbackfn: (
										previousValue: U_1,
										currentValue: number,
										currentIndex: number,
										array: Float32Array
									) => U_1,
									initialValue: U_1
								): U_1;
							};
							reverse: () => Float32Array;
							set: (array: ArrayLike<number>, offset?: number | undefined) => void;
							slice: (start?: number | undefined, end?: number | undefined) => Float32Array;
							some: (
								predicate: (value: number, index: number, array: Float32Array) => unknown,
								thisArg?: any
							) => boolean;
							sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
							subarray: (begin?: number | undefined, end?: number | undefined) => Float32Array;
							toLocaleString: () => string;
							toString: () => string;
							valueOf: () => Float32Array;
							entries: () => IterableIterator<[number, number]>;
							keys: () => IterableIterator<number>;
							values: () => IterableIterator<number>;
							includes: (searchElement: number, fromIndex?: number | undefined) => boolean;
							[Symbol.iterator]: () => IterableIterator<number>;
							readonly [Symbol.toStringTag]: 'Float32Array';
							at: (index: number) => number | undefined;
						};
						DefaultInterpolation: InterpolationModes;
						InterpolantFactoryMethodDiscrete: (result: any) => DiscreteInterpolant;
						InterpolantFactoryMethodLinear: (result: any) => LinearInterpolant;
						InterpolantFactoryMethodSmooth: (result: any) => CubicInterpolant;
						setInterpolation: (interpolation: InterpolationModes) => KeyframeTrack;
						getInterpolation: () => InterpolationModes;
						createInterpolant: () => Interpolant;
						getValueSize: () => number;
						shift: (timeOffset: number) => KeyframeTrack;
						scale: (timeScale: number) => KeyframeTrack;
						trim: (startTime: number, endTime: number) => KeyframeTrack;
						validate: () => boolean;
						optimize: () => KeyframeTrack;
						clone: () => KeyframeTrack;
					}[];
					blendMode: AnimationBlendMode;
					duration: number;
					uuid: string;
					results: any[];
					resetDuration: () => AnimationClip;
					trim: () => AnimationClip;
					validate: () => boolean;
					optimize: () => AnimationClip;
					clone: () => AnimationClip;
					toJSON: (clip: AnimationClip) => any;
				}[];
				userData: {
					[key: string]: any;
				};
				customDepthMaterial: {
					alphaTest: number;
					alphaToCoverage: boolean;
					blendDst: BlendingDstFactor;
					blendDstAlpha: number | null;
					blendEquation: BlendingEquation;
					blendEquationAlpha: number | null;
					blending: Blending;
					blendSrc: BlendingDstFactor | BlendingSrcFactor;
					blendSrcAlpha: number | null;
					clipIntersection: boolean;
					clippingPlanes: any;
					clipShadows: boolean;
					colorWrite: boolean;
					defines:
						| {
								[key: string]: any;
						  }
						| undefined;
					depthFunc: DepthModes;
					depthTest: boolean;
					depthWrite: boolean;
					id: number;
					stencilWrite: boolean;
					stencilFunc: StencilFunc;
					stencilRef: number;
					stencilWriteMask: number;
					stencilFuncMask: number;
					stencilFail: StencilOp;
					stencilZFail: StencilOp;
					stencilZPass: StencilOp;
					readonly isMaterial: true;
					name: string;
					needsUpdate: boolean;
					opacity: number;
					polygonOffset: boolean;
					polygonOffsetFactor: number;
					polygonOffsetUnits: number;
					precision: 'highp' | 'mediump' | 'lowp' | null;
					premultipliedAlpha: boolean;
					forceSinglePass: boolean;
					dithering: boolean;
					side: Side;
					shadowSide: Side | null;
					toneMapped: boolean;
					transparent: boolean;
					type: string;
					uuid: string;
					vertexColors: boolean;
					visible: boolean;
					userData: any;
					version: number;
					clone: () => Material;
					copy: (material: Material) => Material;
					dispose: () => void;
					onBeforeCompile: (shader: Shader, renderer: WebGLRenderer) => void;
					customProgramCacheKey: () => string;
					setValues: (values: MaterialParameters) => void;
					toJSON: (meta?: any) => any;
					addEventListener: <T extends string>(type: T, listener: EventListener<Event, T, Material>) => void;
					hasEventListener: <T_1 extends string>(
						type: T_1,
						listener: EventListener<Event, T_1, Material>
					) => boolean;
					removeEventListener: <T_2 extends string>(
						type: T_2,
						listener: EventListener<Event, T_2, Material>
					) => void;
					dispatchEvent: (event: Event) => void;
				};
				customDistanceMaterial: {
					alphaTest: number;
					alphaToCoverage: boolean;
					blendDst: BlendingDstFactor;
					blendDstAlpha: number | null;
					blendEquation: BlendingEquation;
					blendEquationAlpha: number | null;
					blending: Blending;
					blendSrc: BlendingDstFactor | BlendingSrcFactor;
					blendSrcAlpha: number | null;
					clipIntersection: boolean;
					clippingPlanes: any;
					clipShadows: boolean;
					colorWrite: boolean;
					defines:
						| {
								[key: string]: any;
						  }
						| undefined;
					depthFunc: DepthModes;
					depthTest: boolean;
					depthWrite: boolean;
					id: number;
					stencilWrite: boolean;
					stencilFunc: StencilFunc;
					stencilRef: number;
					stencilWriteMask: number;
					stencilFuncMask: number;
					stencilFail: StencilOp;
					stencilZFail: StencilOp;
					stencilZPass: StencilOp;
					readonly isMaterial: true;
					name: string;
					needsUpdate: boolean;
					opacity: number;
					polygonOffset: boolean;
					polygonOffsetFactor: number;
					polygonOffsetUnits: number;
					precision: 'highp' | 'mediump' | 'lowp' | null;
					premultipliedAlpha: boolean;
					forceSinglePass: boolean;
					dithering: boolean;
					side: Side;
					shadowSide: Side | null;
					toneMapped: boolean;
					transparent: boolean;
					type: string;
					uuid: string;
					vertexColors: boolean;
					visible: boolean;
					userData: any;
					version: number;
					clone: () => Material;
					copy: (material: Material) => Material;
					dispose: () => void;
					onBeforeCompile: (shader: Shader, renderer: WebGLRenderer) => void;
					customProgramCacheKey: () => string;
					setValues: (values: MaterialParameters) => void;
					toJSON: (meta?: any) => any;
					addEventListener: <T extends string>(type: T, listener: EventListener<Event, T, Material>) => void;
					hasEventListener: <T_1 extends string>(
						type: T_1,
						listener: EventListener<Event, T_1, Material>
					) => boolean;
					removeEventListener: <T_2 extends string>(
						type: T_2,
						listener: EventListener<Event, T_2, Material>
					) => void;
					dispatchEvent: (event: Event) => void;
				};
				readonly isObject3D: true;
				onBeforeRender: (
					renderer: WebGLRenderer,
					scene: Scene,
					camera: Camera,
					geometry: BufferGeometry,
					material: Material,
					group: Group
				) => void;
				onAfterRender: (
					renderer: WebGLRenderer,
					scene: Scene,
					camera: Camera,
					geometry: BufferGeometry,
					material: Material,
					group: Group
				) => void;
				applyMatrix4: (matrix: Matrix4) => void;
				applyQuaternion: (quaternion: Quaternion) => Object3D<Event>;
				setRotationFromAxisAngle: (axis: Vector3, angle: number) => void;
				setRotationFromEuler: (euler: Euler) => void;
				setRotationFromMatrix: (m: Matrix4) => void;
				setRotationFromQuaternion: (q: Quaternion) => void;
				rotateOnAxis: (axis: Vector3, angle: number) => Object3D<Event>;
				rotateOnWorldAxis: (axis: Vector3, angle: number) => Object3D<Event>;
				rotateX: (angle: number) => Object3D<Event>;
				rotateY: (angle: number) => Object3D<Event>;
				rotateZ: (angle: number) => Object3D<Event>;
				translateOnAxis: (axis: Vector3, distance: number) => Object3D<Event>;
				translateX: (distance: number) => Object3D<Event>;
				translateY: (distance: number) => Object3D<Event>;
				translateZ: (distance: number) => Object3D<Event>;
				localToWorld: (vector: Vector3) => Vector3;
				worldToLocal: (vector: Vector3) => Vector3;
				lookAt: {
					(vector: Vector3): void;
					(x: number, y: number, z: number): void;
				};
				add: (...object: Object3D<Event>[]) => Object3D<Event>;
				remove: (...object: Object3D<Event>[]) => Object3D<Event>;
				removeFromParent: () => Object3D<Event>;
				clear: () => Object3D<Event>;
				attach: (object: Object3D<Event>) => Object3D<Event>;
				getObjectById: (id: number) => Object3D<Event> | undefined;
				getObjectByName: (name: string) => Object3D<Event> | undefined;
				getObjectByProperty: (name: string, value: any) => Object3D<Event> | undefined;
				getObjectsByProperty: (name: string, value: any) => Object3D<Event>[];
				getWorldPosition: (target: Vector3) => Vector3;
				getWorldQuaternion: (target: Quaternion) => Quaternion;
				getWorldScale: (target: Vector3) => Vector3;
				getWorldDirection: (target: Vector3) => Vector3;
				raycast: (raycaster: Raycaster, intersects: Intersection<Object3D<Event>>[]) => void;
				traverse: (callback: (object: Object3D<Event>) => any) => void;
				traverseVisible: (callback: (object: Object3D<Event>) => any) => void;
				traverseAncestors: (callback: (object: Object3D<Event>) => any) => void;
				updateMatrix: () => void;
				updateMatrixWorld: (force?: boolean | undefined) => void;
				updateWorldMatrix: (updateParents: boolean, updateChildren: boolean) => void;
				toJSON: (
					meta?:
						| {
								geometries: any;
								materials: any;
								textures: any;
								images: any;
						  }
						| undefined
				) => any;
				clone: (recursive?: boolean | undefined) => Object3D<Event>;
				copy: (source: Object3D<Event>, recursive?: boolean | undefined) => Object3D<Event>;
				addEventListener: <T_3 extends string>(
					type: T_3,
					listener: EventListener<Event, T_3, Object3D<Event>>
				) => void;
				hasEventListener: <T_4 extends string>(
					type: T_4,
					listener: EventListener<Event, T_4, Object3D<Event>>
				) => boolean;
				removeEventListener: <T_5 extends string>(
					type: T_5,
					listener: EventListener<Event, T_5, Object3D<Event>>
				) => void;
				dispatchEvent: (event: Event) => void;
			} | null;
			children: {
				id: number;
				uuid: string;
				name: string;
				type: string;
				parent: any | null;
				children: any[];
				up: {
					x: number;
					y: number;
					z: number;
					readonly isVector3: true;
					set: (x: number, y: number, z: number) => Vector3;
					setScalar: (scalar: number) => Vector3;
					setX: (x: number) => Vector3;
					setY: (y: number) => Vector3;
					setZ: (z: number) => Vector3;
					setComponent: (index: number, value: number) => Vector3;
					getComponent: (index: number) => number;
					clone: () => Vector3;
					copy: (v: Vector3) => Vector3;
					add: (v: Vector3) => Vector3;
					addScalar: (s: number) => Vector3;
					addScaledVector: (v: Vector3, s: number) => Vector3;
					addVectors: (a: Vector3, b: Vector3) => Vector3;
					sub: (a: Vector3) => Vector3;
					subScalar: (s: number) => Vector3;
					subVectors: (a: Vector3, b: Vector3) => Vector3;
					multiply: (v: Vector3) => Vector3;
					multiplyScalar: (s: number) => Vector3;
					multiplyVectors: (a: Vector3, b: Vector3) => Vector3;
					applyEuler: (euler: Euler) => Vector3;
					applyAxisAngle: (axis: Vector3, angle: number) => Vector3;
					applyMatrix3: (m: Matrix3) => Vector3;
					applyNormalMatrix: (m: Matrix3) => Vector3;
					applyMatrix4: (m: Matrix4) => Vector3;
					applyQuaternion: (q: Quaternion) => Vector3;
					project: (camera: Camera) => Vector3;
					unproject: (camera: Camera) => Vector3;
					transformDirection: (m: Matrix4) => Vector3;
					divide: (v: Vector3) => Vector3;
					divideScalar: (s: number) => Vector3;
					min: (v: Vector3) => Vector3;
					max: (v: Vector3) => Vector3;
					clamp: (min: Vector3, max: Vector3) => Vector3;
					clampScalar: (min: number, max: number) => Vector3;
					clampLength: (min: number, max: number) => Vector3;
					floor: () => Vector3;
					ceil: () => Vector3;
					round: () => Vector3;
					roundToZero: () => Vector3;
					negate: () => Vector3;
					dot: (v: Vector3) => number;
					lengthSq: () => number;
					length: () => number;
					lengthManhattan: () => number;
					manhattanLength: () => number;
					manhattanDistanceTo: (v: Vector3) => number;
					normalize: () => Vector3;
					setLength: (l: number) => Vector3;
					lerp: (v: Vector3, alpha: number) => Vector3;
					lerpVectors: (v1: Vector3, v2: Vector3, alpha: number) => Vector3;
					cross: (a: Vector3) => Vector3;
					crossVectors: (a: Vector3, b: Vector3) => Vector3;
					projectOnVector: (v: Vector3) => Vector3;
					projectOnPlane: (planeNormal: Vector3) => Vector3;
					reflect: (vector: Vector3) => Vector3;
					angleTo: (v: Vector3) => number;
					distanceTo: (v: Vector3) => number;
					distanceToSquared: (v: Vector3) => number;
					distanceToManhattan: (v: Vector3) => number;
					setFromSpherical: (s: Spherical) => Vector3;
					setFromSphericalCoords: (r: number, phi: number, theta: number) => Vector3;
					setFromCylindrical: (s: Cylindrical) => Vector3;
					setFromCylindricalCoords: (radius: number, theta: number, y: number) => Vector3;
					setFromMatrixPosition: (m: Matrix4) => Vector3;
					setFromMatrixScale: (m: Matrix4) => Vector3;
					setFromMatrixColumn: (matrix: Matrix4, index: number) => Vector3;
					setFromMatrix3Column: (matrix: Matrix3, index: number) => Vector3;
					setFromEuler: (e: Euler) => Vector3;
					equals: (v: Vector3) => boolean;
					fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Vector3;
					toArray: {
						(array?: number[] | undefined, offset?: number | undefined): number[];
						(array?: Vector3Tuple | undefined, offset?: 0 | undefined): Vector3Tuple;
						(array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
					};
					fromBufferAttribute: (
						attribute: BufferAttribute | InterleavedBufferAttribute,
						index: number
					) => Vector3;
					random: () => Vector3;
					randomDirection: () => Vector3;
				};
				readonly position: {
					x: number;
					y: number;
					z: number;
					readonly isVector3: true;
					set: (x: number, y: number, z: number) => Vector3;
					setScalar: (scalar: number) => Vector3;
					setX: (x: number) => Vector3;
					setY: (y: number) => Vector3;
					setZ: (z: number) => Vector3;
					setComponent: (index: number, value: number) => Vector3;
					getComponent: (index: number) => number;
					clone: () => Vector3;
					copy: (v: Vector3) => Vector3;
					add: (v: Vector3) => Vector3;
					addScalar: (s: number) => Vector3;
					addScaledVector: (v: Vector3, s: number) => Vector3;
					addVectors: (a: Vector3, b: Vector3) => Vector3;
					sub: (a: Vector3) => Vector3;
					subScalar: (s: number) => Vector3;
					subVectors: (a: Vector3, b: Vector3) => Vector3;
					multiply: (v: Vector3) => Vector3;
					multiplyScalar: (s: number) => Vector3;
					multiplyVectors: (a: Vector3, b: Vector3) => Vector3;
					applyEuler: (euler: Euler) => Vector3;
					applyAxisAngle: (axis: Vector3, angle: number) => Vector3;
					applyMatrix3: (m: Matrix3) => Vector3;
					applyNormalMatrix: (m: Matrix3) => Vector3;
					applyMatrix4: (m: Matrix4) => Vector3;
					applyQuaternion: (q: Quaternion) => Vector3;
					project: (camera: Camera) => Vector3;
					unproject: (camera: Camera) => Vector3;
					transformDirection: (m: Matrix4) => Vector3;
					divide: (v: Vector3) => Vector3;
					divideScalar: (s: number) => Vector3;
					min: (v: Vector3) => Vector3;
					max: (v: Vector3) => Vector3;
					clamp: (min: Vector3, max: Vector3) => Vector3;
					clampScalar: (min: number, max: number) => Vector3;
					clampLength: (min: number, max: number) => Vector3;
					floor: () => Vector3;
					ceil: () => Vector3;
					round: () => Vector3;
					roundToZero: () => Vector3;
					negate: () => Vector3;
					dot: (v: Vector3) => number;
					lengthSq: () => number;
					length: () => number;
					lengthManhattan: () => number;
					manhattanLength: () => number;
					manhattanDistanceTo: (v: Vector3) => number;
					normalize: () => Vector3;
					setLength: (l: number) => Vector3;
					lerp: (v: Vector3, alpha: number) => Vector3;
					lerpVectors: (v1: Vector3, v2: Vector3, alpha: number) => Vector3;
					cross: (a: Vector3) => Vector3;
					crossVectors: (a: Vector3, b: Vector3) => Vector3;
					projectOnVector: (v: Vector3) => Vector3;
					projectOnPlane: (planeNormal: Vector3) => Vector3;
					reflect: (vector: Vector3) => Vector3;
					angleTo: (v: Vector3) => number;
					distanceTo: (v: Vector3) => number;
					distanceToSquared: (v: Vector3) => number;
					distanceToManhattan: (v: Vector3) => number;
					setFromSpherical: (s: Spherical) => Vector3;
					setFromSphericalCoords: (r: number, phi: number, theta: number) => Vector3;
					setFromCylindrical: (s: Cylindrical) => Vector3;
					setFromCylindricalCoords: (radius: number, theta: number, y: number) => Vector3;
					setFromMatrixPosition: (m: Matrix4) => Vector3;
					setFromMatrixScale: (m: Matrix4) => Vector3;
					setFromMatrixColumn: (matrix: Matrix4, index: number) => Vector3;
					setFromMatrix3Column: (matrix: Matrix3, index: number) => Vector3;
					setFromEuler: (e: Euler) => Vector3;
					equals: (v: Vector3) => boolean;
					fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Vector3;
					toArray: {
						(array?: number[] | undefined, offset?: number | undefined): number[];
						(array?: Vector3Tuple | undefined, offset?: 0 | undefined): Vector3Tuple;
						(array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
					};
					fromBufferAttribute: (
						attribute: BufferAttribute | InterleavedBufferAttribute,
						index: number
					) => Vector3;
					random: () => Vector3;
					randomDirection: () => Vector3;
				};
				readonly rotation: {
					x: number;
					y: number;
					z: number;
					order: EulerOrder;
					readonly isEuler: true;
					_onChangeCallback: () => void;
					set: (x: number, y: number, z: number, order?: EulerOrder | undefined) => Euler;
					clone: () => Euler;
					copy: (euler: Euler) => Euler;
					setFromRotationMatrix: (
						m: Matrix4,
						order?: EulerOrder | undefined,
						update?: boolean | undefined
					) => Euler;
					setFromQuaternion: (
						q: Quaternion,
						order?: EulerOrder | undefined,
						update?: boolean | undefined
					) => Euler;
					setFromVector3: (v: Vector3, order?: EulerOrder | undefined) => Euler;
					reorder: (newOrder: EulerOrder) => Euler;
					equals: (euler: Euler) => boolean;
					fromArray: (xyzo: [number, number, number, (EulerOrder | undefined)?, ...any[]]) => Euler;
					toArray: (
						array?: (string | number | undefined)[] | undefined,
						offset?: number | undefined
					) => (string | number | undefined)[];
					_onChange: (callback: () => void) => Euler;
					[Symbol.iterator]: () => Generator<string | number, void, unknown>;
				};
				readonly quaternion: {
					x: number;
					y: number;
					z: number;
					w: number;
					readonly isQuaternion: true;
					set: (x: number, y: number, z: number, w: number) => Quaternion;
					clone: () => Quaternion;
					copy: (q: Quaternion) => Quaternion;
					setFromEuler: (euler: Euler, update?: boolean | undefined) => Quaternion;
					setFromAxisAngle: (axis: Vector3, angle: number) => Quaternion;
					setFromRotationMatrix: (m: Matrix4) => Quaternion;
					setFromUnitVectors: (vFrom: Vector3, vTo: Vector3) => Quaternion;
					angleTo: (q: Quaternion) => number;
					rotateTowards: (q: Quaternion, step: number) => Quaternion;
					identity: () => Quaternion;
					invert: () => Quaternion;
					conjugate: () => Quaternion;
					dot: (v: Quaternion) => number;
					lengthSq: () => number;
					length: () => number;
					normalize: () => Quaternion;
					multiply: (q: Quaternion) => Quaternion;
					premultiply: (q: Quaternion) => Quaternion;
					multiplyQuaternions: (a: Quaternion, b: Quaternion) => Quaternion;
					slerp: (qb: Quaternion, t: number) => Quaternion;
					slerpQuaternions: (qa: Quaternion, qb: Quaternion, t: number) => Quaternion;
					equals: (v: Quaternion) => boolean;
					fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Quaternion;
					toArray: {
						(array?: number[] | undefined, offset?: number | undefined): number[];
						(array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
					};
					fromBufferAttribute: (
						attribute: BufferAttribute | InterleavedBufferAttribute,
						index: number
					) => Quaternion;
					_onChange: (callback: () => void) => Quaternion;
					_onChangeCallback: () => void;
					multiplyVector3: (v: any) => any;
					random: () => Quaternion;
					[Symbol.iterator]: () => Generator<number, void, unknown>;
				};
				readonly scale: {
					x: number;
					y: number;
					z: number;
					readonly isVector3: true;
					set: (x: number, y: number, z: number) => Vector3;
					setScalar: (scalar: number) => Vector3;
					setX: (x: number) => Vector3;
					setY: (y: number) => Vector3;
					setZ: (z: number) => Vector3;
					setComponent: (index: number, value: number) => Vector3;
					getComponent: (index: number) => number;
					clone: () => Vector3;
					copy: (v: Vector3) => Vector3;
					add: (v: Vector3) => Vector3;
					addScalar: (s: number) => Vector3;
					addScaledVector: (v: Vector3, s: number) => Vector3;
					addVectors: (a: Vector3, b: Vector3) => Vector3;
					sub: (a: Vector3) => Vector3;
					subScalar: (s: number) => Vector3;
					subVectors: (a: Vector3, b: Vector3) => Vector3;
					multiply: (v: Vector3) => Vector3;
					multiplyScalar: (s: number) => Vector3;
					multiplyVectors: (a: Vector3, b: Vector3) => Vector3;
					applyEuler: (euler: Euler) => Vector3;
					applyAxisAngle: (axis: Vector3, angle: number) => Vector3;
					applyMatrix3: (m: Matrix3) => Vector3;
					applyNormalMatrix: (m: Matrix3) => Vector3;
					applyMatrix4: (m: Matrix4) => Vector3;
					applyQuaternion: (q: Quaternion) => Vector3;
					project: (camera: Camera) => Vector3;
					unproject: (camera: Camera) => Vector3;
					transformDirection: (m: Matrix4) => Vector3;
					divide: (v: Vector3) => Vector3;
					divideScalar: (s: number) => Vector3;
					min: (v: Vector3) => Vector3;
					max: (v: Vector3) => Vector3;
					clamp: (min: Vector3, max: Vector3) => Vector3;
					clampScalar: (min: number, max: number) => Vector3;
					clampLength: (min: number, max: number) => Vector3;
					floor: () => Vector3;
					ceil: () => Vector3;
					round: () => Vector3;
					roundToZero: () => Vector3;
					negate: () => Vector3;
					dot: (v: Vector3) => number;
					lengthSq: () => number;
					length: () => number;
					lengthManhattan: () => number;
					manhattanLength: () => number;
					manhattanDistanceTo: (v: Vector3) => number;
					normalize: () => Vector3;
					setLength: (l: number) => Vector3;
					lerp: (v: Vector3, alpha: number) => Vector3;
					lerpVectors: (v1: Vector3, v2: Vector3, alpha: number) => Vector3;
					cross: (a: Vector3) => Vector3;
					crossVectors: (a: Vector3, b: Vector3) => Vector3;
					projectOnVector: (v: Vector3) => Vector3;
					projectOnPlane: (planeNormal: Vector3) => Vector3;
					reflect: (vector: Vector3) => Vector3;
					angleTo: (v: Vector3) => number;
					distanceTo: (v: Vector3) => number;
					distanceToSquared: (v: Vector3) => number;
					distanceToManhattan: (v: Vector3) => number;
					setFromSpherical: (s: Spherical) => Vector3;
					setFromSphericalCoords: (r: number, phi: number, theta: number) => Vector3;
					setFromCylindrical: (s: Cylindrical) => Vector3;
					setFromCylindricalCoords: (radius: number, theta: number, y: number) => Vector3;
					setFromMatrixPosition: (m: Matrix4) => Vector3;
					setFromMatrixScale: (m: Matrix4) => Vector3;
					setFromMatrixColumn: (matrix: Matrix4, index: number) => Vector3;
					setFromMatrix3Column: (matrix: Matrix3, index: number) => Vector3;
					setFromEuler: (e: Euler) => Vector3;
					equals: (v: Vector3) => boolean;
					fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Vector3;
					toArray: {
						(array?: number[] | undefined, offset?: number | undefined): number[];
						(array?: Vector3Tuple | undefined, offset?: 0 | undefined): Vector3Tuple;
						(array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
					};
					fromBufferAttribute: (
						attribute: BufferAttribute | InterleavedBufferAttribute,
						index: number
					) => Vector3;
					random: () => Vector3;
					randomDirection: () => Vector3;
				};
				readonly modelViewMatrix: {
					elements: number[];
					set: (
						n11: number,
						n12: number,
						n13: number,
						n14: number,
						n21: number,
						n22: number,
						n23: number,
						n24: number,
						n31: number,
						n32: number,
						n33: number,
						n34: number,
						n41: number,
						n42: number,
						n43: number,
						n44: number
					) => Matrix4;
					identity: () => Matrix4;
					clone: () => Matrix4;
					copy: (m: Matrix4) => Matrix4;
					copyPosition: (m: Matrix4) => Matrix4;
					extractBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix4;
					makeBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix4;
					extractRotation: (m: Matrix4) => Matrix4;
					makeRotationFromEuler: (euler: Euler) => Matrix4;
					makeRotationFromQuaternion: (q: Quaternion) => Matrix4;
					lookAt: (eye: Vector3, target: Vector3, up: Vector3) => Matrix4;
					multiply: (m: Matrix4) => Matrix4;
					premultiply: (m: Matrix4) => Matrix4;
					multiplyMatrices: (a: Matrix4, b: Matrix4) => Matrix4;
					multiplyToArray: (a: Matrix4, b: Matrix4, r: number[]) => Matrix4;
					multiplyScalar: (s: number) => Matrix4;
					determinant: () => number;
					transpose: () => Matrix4;
					setPosition: (v: number | Vector3, y?: number | undefined, z?: number | undefined) => Matrix4;
					invert: () => Matrix4;
					scale: (v: Vector3) => Matrix4;
					getMaxScaleOnAxis: () => number;
					makeTranslation: (x: number, y: number, z: number) => Matrix4;
					makeRotationX: (theta: number) => Matrix4;
					makeRotationY: (theta: number) => Matrix4;
					makeRotationZ: (theta: number) => Matrix4;
					makeRotationAxis: (axis: Vector3, angle: number) => Matrix4;
					makeScale: (x: number, y: number, z: number) => Matrix4;
					makeShear: (xy: number, xz: number, yx: number, yz: number, zx: number, zy: number) => Matrix4;
					compose: (translation: Vector3, rotation: Quaternion, scale: Vector3) => Matrix4;
					decompose: (translation: Vector3, rotation: Quaternion, scale: Vector3) => Matrix4;
					makePerspective: {
						(left: number, right: number, bottom: number, top: number, near: number, far: number): Matrix4;
						(fov: number, aspect: number, near: number, far: number): Matrix4;
					};
					makeOrthographic: (
						left: number,
						right: number,
						top: number,
						bottom: number,
						near: number,
						far: number
					) => Matrix4;
					equals: (matrix: Matrix4) => boolean;
					fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Matrix4;
					toArray: {
						(array?: number[] | undefined, offset?: number | undefined): number[];
						(array?: Matrix4Tuple | undefined, offset?: 0 | undefined): Matrix4Tuple;
						(array?: ArrayLike<number> | undefined, offset?: number | undefined): ArrayLike<number>;
					};
					setFromMatrix3: (m: Matrix3) => Matrix4;
					extractPosition: (m: Matrix4) => Matrix4;
					setRotationFromQuaternion: (q: Quaternion) => Matrix4;
					multiplyVector3: (v: any) => any;
					multiplyVector4: (v: any) => any;
					multiplyVector3Array: (array: number[]) => number[];
					rotateAxis: (v: any) => void;
					crossVector: (v: any) => void;
					flattenToArrayOffset: (array: number[], offset: number) => number[];
					getInverse: (matrix: Matrix) => Matrix;
				};
				readonly normalMatrix: {
					elements: number[];
					set: (
						n11: number,
						n12: number,
						n13: number,
						n21: number,
						n22: number,
						n23: number,
						n31: number,
						n32: number,
						n33: number
					) => Matrix3;
					identity: () => Matrix3;
					clone: () => Matrix3;
					copy: (m: Matrix3) => Matrix3;
					extractBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix3;
					setFromMatrix4: (m: Matrix4) => Matrix3;
					multiplyScalar: (s: number) => Matrix3;
					determinant: () => number;
					invert: () => Matrix3;
					transpose: () => Matrix3;
					getNormalMatrix: (matrix4: Matrix4) => Matrix3;
					transposeIntoArray: (r: number[]) => Matrix3;
					setUvTransform: (
						tx: number,
						ty: number,
						sx: number,
						sy: number,
						rotation: number,
						cx: number,
						cy: number
					) => Matrix3;
					scale: (sx: number, sy: number) => Matrix3;
					makeTranslation: {
						(x: number, y: number): Matrix3;
						(x: number, y: number): Matrix3;
					};
					makeRotation: {
						(theta: number): Matrix3;
						(theta: number): Matrix3;
					};
					makeScale: {
						(x: number, y: number): Matrix3;
						(x: number, y: number): Matrix3;
					};
					rotate: (theta: number) => Matrix3;
					translate: (tx: number, ty: number) => Matrix3;
					equals: (matrix: Matrix3) => boolean;
					fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Matrix3;
					toArray: {
						(array?: number[] | undefined, offset?: number | undefined): number[];
						(array?: Matrix3Tuple | undefined, offset?: 0 | undefined): Matrix3Tuple;
						(array?: ArrayLike<number> | undefined, offset?: number | undefined): ArrayLike<number>;
					};
					multiply: (m: Matrix3) => Matrix3;
					premultiply: (m: Matrix3) => Matrix3;
					multiplyMatrices: (a: Matrix3, b: Matrix3) => Matrix3;
					multiplyVector3: (vector: Vector3) => any;
					multiplyVector3Array: (a: any) => any;
					getInverse: {
						(matrix: Matrix4, throwOnDegenerate?: boolean | undefined): Matrix3;
						(matrix: Matrix): Matrix;
					};
					flattenToArrayOffset: (array: number[], offset: number) => number[];
				};
				matrix: {
					elements: number[];
					set: (
						n11: number,
						n12: number,
						n13: number,
						n14: number,
						n21: number,
						n22: number,
						n23: number,
						n24: number,
						n31: number,
						n32: number,
						n33: number,
						n34: number,
						n41: number,
						n42: number,
						n43: number,
						n44: number
					) => Matrix4;
					identity: () => Matrix4;
					clone: () => Matrix4;
					copy: (m: Matrix4) => Matrix4;
					copyPosition: (m: Matrix4) => Matrix4;
					extractBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix4;
					makeBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix4;
					extractRotation: (m: Matrix4) => Matrix4;
					makeRotationFromEuler: (euler: Euler) => Matrix4;
					makeRotationFromQuaternion: (q: Quaternion) => Matrix4;
					lookAt: (eye: Vector3, target: Vector3, up: Vector3) => Matrix4;
					multiply: (m: Matrix4) => Matrix4;
					premultiply: (m: Matrix4) => Matrix4;
					multiplyMatrices: (a: Matrix4, b: Matrix4) => Matrix4;
					multiplyToArray: (a: Matrix4, b: Matrix4, r: number[]) => Matrix4;
					multiplyScalar: (s: number) => Matrix4;
					determinant: () => number;
					transpose: () => Matrix4;
					setPosition: (v: number | Vector3, y?: number | undefined, z?: number | undefined) => Matrix4;
					invert: () => Matrix4;
					scale: (v: Vector3) => Matrix4;
					getMaxScaleOnAxis: () => number;
					makeTranslation: (x: number, y: number, z: number) => Matrix4;
					makeRotationX: (theta: number) => Matrix4;
					makeRotationY: (theta: number) => Matrix4;
					makeRotationZ: (theta: number) => Matrix4;
					makeRotationAxis: (axis: Vector3, angle: number) => Matrix4;
					makeScale: (x: number, y: number, z: number) => Matrix4;
					makeShear: (xy: number, xz: number, yx: number, yz: number, zx: number, zy: number) => Matrix4;
					compose: (translation: Vector3, rotation: Quaternion, scale: Vector3) => Matrix4;
					decompose: (translation: Vector3, rotation: Quaternion, scale: Vector3) => Matrix4;
					makePerspective: {
						(left: number, right: number, bottom: number, top: number, near: number, far: number): Matrix4;
						(fov: number, aspect: number, near: number, far: number): Matrix4;
					};
					makeOrthographic: (
						left: number,
						right: number,
						top: number,
						bottom: number,
						near: number,
						far: number
					) => Matrix4;
					equals: (matrix: Matrix4) => boolean;
					fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Matrix4;
					toArray: {
						(array?: number[] | undefined, offset?: number | undefined): number[];
						(array?: Matrix4Tuple | undefined, offset?: 0 | undefined): Matrix4Tuple;
						(array?: ArrayLike<number> | undefined, offset?: number | undefined): ArrayLike<number>;
					};
					setFromMatrix3: (m: Matrix3) => Matrix4;
					extractPosition: (m: Matrix4) => Matrix4;
					setRotationFromQuaternion: (q: Quaternion) => Matrix4;
					multiplyVector3: (v: any) => any;
					multiplyVector4: (v: any) => any;
					multiplyVector3Array: (array: number[]) => number[];
					rotateAxis: (v: any) => void;
					crossVector: (v: any) => void;
					flattenToArrayOffset: (array: number[], offset: number) => number[];
					getInverse: (matrix: Matrix) => Matrix;
				};
				matrixWorld: {
					elements: number[];
					set: (
						n11: number,
						n12: number,
						n13: number,
						n14: number,
						n21: number,
						n22: number,
						n23: number,
						n24: number,
						n31: number,
						n32: number,
						n33: number,
						n34: number,
						n41: number,
						n42: number,
						n43: number,
						n44: number
					) => Matrix4;
					identity: () => Matrix4;
					clone: () => Matrix4;
					copy: (m: Matrix4) => Matrix4;
					copyPosition: (m: Matrix4) => Matrix4;
					extractBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix4;
					makeBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix4;
					extractRotation: (m: Matrix4) => Matrix4;
					makeRotationFromEuler: (euler: Euler) => Matrix4;
					makeRotationFromQuaternion: (q: Quaternion) => Matrix4;
					lookAt: (eye: Vector3, target: Vector3, up: Vector3) => Matrix4;
					multiply: (m: Matrix4) => Matrix4;
					premultiply: (m: Matrix4) => Matrix4;
					multiplyMatrices: (a: Matrix4, b: Matrix4) => Matrix4;
					multiplyToArray: (a: Matrix4, b: Matrix4, r: number[]) => Matrix4;
					multiplyScalar: (s: number) => Matrix4;
					determinant: () => number;
					transpose: () => Matrix4;
					setPosition: (v: number | Vector3, y?: number | undefined, z?: number | undefined) => Matrix4;
					invert: () => Matrix4;
					scale: (v: Vector3) => Matrix4;
					getMaxScaleOnAxis: () => number;
					makeTranslation: (x: number, y: number, z: number) => Matrix4;
					makeRotationX: (theta: number) => Matrix4;
					makeRotationY: (theta: number) => Matrix4;
					makeRotationZ: (theta: number) => Matrix4;
					makeRotationAxis: (axis: Vector3, angle: number) => Matrix4;
					makeScale: (x: number, y: number, z: number) => Matrix4;
					makeShear: (xy: number, xz: number, yx: number, yz: number, zx: number, zy: number) => Matrix4;
					compose: (translation: Vector3, rotation: Quaternion, scale: Vector3) => Matrix4;
					decompose: (translation: Vector3, rotation: Quaternion, scale: Vector3) => Matrix4;
					makePerspective: {
						(left: number, right: number, bottom: number, top: number, near: number, far: number): Matrix4;
						(fov: number, aspect: number, near: number, far: number): Matrix4;
					};
					makeOrthographic: (
						left: number,
						right: number,
						top: number,
						bottom: number,
						near: number,
						far: number
					) => Matrix4;
					equals: (matrix: Matrix4) => boolean;
					fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Matrix4;
					toArray: {
						(array?: number[] | undefined, offset?: number | undefined): number[];
						(array?: Matrix4Tuple | undefined, offset?: 0 | undefined): Matrix4Tuple;
						(array?: ArrayLike<number> | undefined, offset?: number | undefined): ArrayLike<number>;
					};
					setFromMatrix3: (m: Matrix3) => Matrix4;
					extractPosition: (m: Matrix4) => Matrix4;
					setRotationFromQuaternion: (q: Quaternion) => Matrix4;
					multiplyVector3: (v: any) => any;
					multiplyVector4: (v: any) => any;
					multiplyVector3Array: (array: number[]) => number[];
					rotateAxis: (v: any) => void;
					crossVector: (v: any) => void;
					flattenToArrayOffset: (array: number[], offset: number) => number[];
					getInverse: (matrix: Matrix) => Matrix;
				};
				matrixAutoUpdate: boolean;
				matrixWorldAutoUpdate: boolean;
				matrixWorldNeedsUpdate: boolean;
				layers: {
					mask: number;
					set: (channel: number) => void;
					enable: (channel: number) => void;
					enableAll: () => void;
					toggle: (channel: number) => void;
					disable: (channel: number) => void;
					disableAll: () => void;
					test: (layers: Layers) => boolean;
					isEnabled: (channel: number) => boolean;
				};
				visible: boolean;
				castShadow: boolean;
				receiveShadow: boolean;
				frustumCulled: boolean;
				renderOrder: number;
				animations: {
					name: string;
					tracks: {
						name: string;
						times: {
							[x: number]: number;
							readonly BYTES_PER_ELEMENT: number;
							readonly buffer:
								| {
										readonly byteLength: number;
										slice: (begin: number, end?: number | undefined) => ArrayBuffer;
										readonly [Symbol.toStringTag]: string;
								  }
								| {
										readonly byteLength: number;
										slice: (begin: number, end?: number | undefined) => SharedArrayBuffer;
										readonly [Symbol.species]: SharedArrayBuffer;
										readonly [Symbol.toStringTag]: 'SharedArrayBuffer';
								  };
							readonly byteLength: number;
							readonly byteOffset: number;
							copyWithin: (target: number, start: number, end?: number | undefined) => Float32Array;
							every: (
								predicate: (value: number, index: number, array: Float32Array) => unknown,
								thisArg?: any
							) => boolean;
							fill: (value: number, start?: number | undefined, end?: number | undefined) => Float32Array;
							filter: (
								predicate: (value: number, index: number, array: Float32Array) => any,
								thisArg?: any
							) => Float32Array;
							find: (
								predicate: (value: number, index: number, obj: Float32Array) => boolean,
								thisArg?: any
							) => number | undefined;
							findIndex: (
								predicate: (value: number, index: number, obj: Float32Array) => boolean,
								thisArg?: any
							) => number;
							forEach: (
								callbackfn: (value: number, index: number, array: Float32Array) => void,
								thisArg?: any
							) => void;
							indexOf: (searchElement: number, fromIndex?: number | undefined) => number;
							join: (separator?: string | undefined) => string;
							lastIndexOf: (searchElement: number, fromIndex?: number | undefined) => number;
							readonly length: number;
							map: (
								callbackfn: (value: number, index: number, array: Float32Array) => number,
								thisArg?: any
							) => Float32Array;
							reduce: {
								(
									callbackfn: (
										previousValue: number,
										currentValue: number,
										currentIndex: number,
										array: Float32Array
									) => number
								): number;
								(
									callbackfn: (
										previousValue: number,
										currentValue: number,
										currentIndex: number,
										array: Float32Array
									) => number,
									initialValue: number
								): number;
								<U>(
									callbackfn: (
										previousValue: U,
										currentValue: number,
										currentIndex: number,
										array: Float32Array
									) => U,
									initialValue: U
								): U;
							};
							reduceRight: {
								(
									callbackfn: (
										previousValue: number,
										currentValue: number,
										currentIndex: number,
										array: Float32Array
									) => number
								): number;
								(
									callbackfn: (
										previousValue: number,
										currentValue: number,
										currentIndex: number,
										array: Float32Array
									) => number,
									initialValue: number
								): number;
								<U_1>(
									callbackfn: (
										previousValue: U_1,
										currentValue: number,
										currentIndex: number,
										array: Float32Array
									) => U_1,
									initialValue: U_1
								): U_1;
							};
							reverse: () => Float32Array;
							set: (array: ArrayLike<number>, offset?: number | undefined) => void;
							slice: (start?: number | undefined, end?: number | undefined) => Float32Array;
							some: (
								predicate: (value: number, index: number, array: Float32Array) => unknown,
								thisArg?: any
							) => boolean;
							sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
							subarray: (begin?: number | undefined, end?: number | undefined) => Float32Array;
							toLocaleString: () => string;
							toString: () => string;
							valueOf: () => Float32Array;
							entries: () => IterableIterator<[number, number]>;
							keys: () => IterableIterator<number>;
							values: () => IterableIterator<number>;
							includes: (searchElement: number, fromIndex?: number | undefined) => boolean;
							[Symbol.iterator]: () => IterableIterator<number>;
							readonly [Symbol.toStringTag]: 'Float32Array';
							at: (index: number) => number | undefined;
						};
						values: {
							[x: number]: number;
							readonly BYTES_PER_ELEMENT: number;
							readonly buffer:
								| {
										readonly byteLength: number;
										slice: (begin: number, end?: number | undefined) => ArrayBuffer;
										readonly [Symbol.toStringTag]: string;
								  }
								| {
										readonly byteLength: number;
										slice: (begin: number, end?: number | undefined) => SharedArrayBuffer;
										readonly [Symbol.species]: SharedArrayBuffer;
										readonly [Symbol.toStringTag]: 'SharedArrayBuffer';
								  };
							readonly byteLength: number;
							readonly byteOffset: number;
							copyWithin: (target: number, start: number, end?: number | undefined) => Float32Array;
							every: (
								predicate: (value: number, index: number, array: Float32Array) => unknown,
								thisArg?: any
							) => boolean;
							fill: (value: number, start?: number | undefined, end?: number | undefined) => Float32Array;
							filter: (
								predicate: (value: number, index: number, array: Float32Array) => any,
								thisArg?: any
							) => Float32Array;
							find: (
								predicate: (value: number, index: number, obj: Float32Array) => boolean,
								thisArg?: any
							) => number | undefined;
							findIndex: (
								predicate: (value: number, index: number, obj: Float32Array) => boolean,
								thisArg?: any
							) => number;
							forEach: (
								callbackfn: (value: number, index: number, array: Float32Array) => void,
								thisArg?: any
							) => void;
							indexOf: (searchElement: number, fromIndex?: number | undefined) => number;
							join: (separator?: string | undefined) => string;
							lastIndexOf: (searchElement: number, fromIndex?: number | undefined) => number;
							readonly length: number;
							map: (
								callbackfn: (value: number, index: number, array: Float32Array) => number,
								thisArg?: any
							) => Float32Array;
							reduce: {
								(
									callbackfn: (
										previousValue: number,
										currentValue: number,
										currentIndex: number,
										array: Float32Array
									) => number
								): number;
								(
									callbackfn: (
										previousValue: number,
										currentValue: number,
										currentIndex: number,
										array: Float32Array
									) => number,
									initialValue: number
								): number;
								<U>(
									callbackfn: (
										previousValue: U,
										currentValue: number,
										currentIndex: number,
										array: Float32Array
									) => U,
									initialValue: U
								): U;
							};
							reduceRight: {
								(
									callbackfn: (
										previousValue: number,
										currentValue: number,
										currentIndex: number,
										array: Float32Array
									) => number
								): number;
								(
									callbackfn: (
										previousValue: number,
										currentValue: number,
										currentIndex: number,
										array: Float32Array
									) => number,
									initialValue: number
								): number;
								<U_1>(
									callbackfn: (
										previousValue: U_1,
										currentValue: number,
										currentIndex: number,
										array: Float32Array
									) => U_1,
									initialValue: U_1
								): U_1;
							};
							reverse: () => Float32Array;
							set: (array: ArrayLike<number>, offset?: number | undefined) => void;
							slice: (start?: number | undefined, end?: number | undefined) => Float32Array;
							some: (
								predicate: (value: number, index: number, array: Float32Array) => unknown,
								thisArg?: any
							) => boolean;
							sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
							subarray: (begin?: number | undefined, end?: number | undefined) => Float32Array;
							toLocaleString: () => string;
							toString: () => string;
							valueOf: () => Float32Array;
							entries: () => IterableIterator<[number, number]>;
							keys: () => IterableIterator<number>;
							values: () => IterableIterator<number>;
							includes: (searchElement: number, fromIndex?: number | undefined) => boolean;
							[Symbol.iterator]: () => IterableIterator<number>;
							readonly [Symbol.toStringTag]: 'Float32Array';
							at: (index: number) => number | undefined;
						};
						ValueTypeName: string;
						TimeBufferType: {
							[x: number]: number;
							readonly BYTES_PER_ELEMENT: number;
							readonly buffer:
								| {
										readonly byteLength: number;
										slice: (begin: number, end?: number | undefined) => ArrayBuffer;
										readonly [Symbol.toStringTag]: string;
								  }
								| {
										readonly byteLength: number;
										slice: (begin: number, end?: number | undefined) => SharedArrayBuffer;
										readonly [Symbol.species]: SharedArrayBuffer;
										readonly [Symbol.toStringTag]: 'SharedArrayBuffer';
								  };
							readonly byteLength: number;
							readonly byteOffset: number;
							copyWithin: (target: number, start: number, end?: number | undefined) => Float32Array;
							every: (
								predicate: (value: number, index: number, array: Float32Array) => unknown,
								thisArg?: any
							) => boolean;
							fill: (value: number, start?: number | undefined, end?: number | undefined) => Float32Array;
							filter: (
								predicate: (value: number, index: number, array: Float32Array) => any,
								thisArg?: any
							) => Float32Array;
							find: (
								predicate: (value: number, index: number, obj: Float32Array) => boolean,
								thisArg?: any
							) => number | undefined;
							findIndex: (
								predicate: (value: number, index: number, obj: Float32Array) => boolean,
								thisArg?: any
							) => number;
							forEach: (
								callbackfn: (value: number, index: number, array: Float32Array) => void,
								thisArg?: any
							) => void;
							indexOf: (searchElement: number, fromIndex?: number | undefined) => number;
							join: (separator?: string | undefined) => string;
							lastIndexOf: (searchElement: number, fromIndex?: number | undefined) => number;
							readonly length: number;
							map: (
								callbackfn: (value: number, index: number, array: Float32Array) => number,
								thisArg?: any
							) => Float32Array;
							reduce: {
								(
									callbackfn: (
										previousValue: number,
										currentValue: number,
										currentIndex: number,
										array: Float32Array
									) => number
								): number;
								(
									callbackfn: (
										previousValue: number,
										currentValue: number,
										currentIndex: number,
										array: Float32Array
									) => number,
									initialValue: number
								): number;
								<U>(
									callbackfn: (
										previousValue: U,
										currentValue: number,
										currentIndex: number,
										array: Float32Array
									) => U,
									initialValue: U
								): U;
							};
							reduceRight: {
								(
									callbackfn: (
										previousValue: number,
										currentValue: number,
										currentIndex: number,
										array: Float32Array
									) => number
								): number;
								(
									callbackfn: (
										previousValue: number,
										currentValue: number,
										currentIndex: number,
										array: Float32Array
									) => number,
									initialValue: number
								): number;
								<U_1>(
									callbackfn: (
										previousValue: U_1,
										currentValue: number,
										currentIndex: number,
										array: Float32Array
									) => U_1,
									initialValue: U_1
								): U_1;
							};
							reverse: () => Float32Array;
							set: (array: ArrayLike<number>, offset?: number | undefined) => void;
							slice: (start?: number | undefined, end?: number | undefined) => Float32Array;
							some: (
								predicate: (value: number, index: number, array: Float32Array) => unknown,
								thisArg?: any
							) => boolean;
							sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
							subarray: (begin?: number | undefined, end?: number | undefined) => Float32Array;
							toLocaleString: () => string;
							toString: () => string;
							valueOf: () => Float32Array;
							entries: () => IterableIterator<[number, number]>;
							keys: () => IterableIterator<number>;
							values: () => IterableIterator<number>;
							includes: (searchElement: number, fromIndex?: number | undefined) => boolean;
							[Symbol.iterator]: () => IterableIterator<number>;
							readonly [Symbol.toStringTag]: 'Float32Array';
							at: (index: number) => number | undefined;
						};
						ValueBufferType: {
							[x: number]: number;
							readonly BYTES_PER_ELEMENT: number;
							readonly buffer:
								| {
										readonly byteLength: number;
										slice: (begin: number, end?: number | undefined) => ArrayBuffer;
										readonly [Symbol.toStringTag]: string;
								  }
								| {
										readonly byteLength: number;
										slice: (begin: number, end?: number | undefined) => SharedArrayBuffer;
										readonly [Symbol.species]: SharedArrayBuffer;
										readonly [Symbol.toStringTag]: 'SharedArrayBuffer';
								  };
							readonly byteLength: number;
							readonly byteOffset: number;
							copyWithin: (target: number, start: number, end?: number | undefined) => Float32Array;
							every: (
								predicate: (value: number, index: number, array: Float32Array) => unknown,
								thisArg?: any
							) => boolean;
							fill: (value: number, start?: number | undefined, end?: number | undefined) => Float32Array;
							filter: (
								predicate: (value: number, index: number, array: Float32Array) => any,
								thisArg?: any
							) => Float32Array;
							find: (
								predicate: (value: number, index: number, obj: Float32Array) => boolean,
								thisArg?: any
							) => number | undefined;
							findIndex: (
								predicate: (value: number, index: number, obj: Float32Array) => boolean,
								thisArg?: any
							) => number;
							forEach: (
								callbackfn: (value: number, index: number, array: Float32Array) => void,
								thisArg?: any
							) => void;
							indexOf: (searchElement: number, fromIndex?: number | undefined) => number;
							join: (separator?: string | undefined) => string;
							lastIndexOf: (searchElement: number, fromIndex?: number | undefined) => number;
							readonly length: number;
							map: (
								callbackfn: (value: number, index: number, array: Float32Array) => number,
								thisArg?: any
							) => Float32Array;
							reduce: {
								(
									callbackfn: (
										previousValue: number,
										currentValue: number,
										currentIndex: number,
										array: Float32Array
									) => number
								): number;
								(
									callbackfn: (
										previousValue: number,
										currentValue: number,
										currentIndex: number,
										array: Float32Array
									) => number,
									initialValue: number
								): number;
								<U>(
									callbackfn: (
										previousValue: U,
										currentValue: number,
										currentIndex: number,
										array: Float32Array
									) => U,
									initialValue: U
								): U;
							};
							reduceRight: {
								(
									callbackfn: (
										previousValue: number,
										currentValue: number,
										currentIndex: number,
										array: Float32Array
									) => number
								): number;
								(
									callbackfn: (
										previousValue: number,
										currentValue: number,
										currentIndex: number,
										array: Float32Array
									) => number,
									initialValue: number
								): number;
								<U_1>(
									callbackfn: (
										previousValue: U_1,
										currentValue: number,
										currentIndex: number,
										array: Float32Array
									) => U_1,
									initialValue: U_1
								): U_1;
							};
							reverse: () => Float32Array;
							set: (array: ArrayLike<number>, offset?: number | undefined) => void;
							slice: (start?: number | undefined, end?: number | undefined) => Float32Array;
							some: (
								predicate: (value: number, index: number, array: Float32Array) => unknown,
								thisArg?: any
							) => boolean;
							sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
							subarray: (begin?: number | undefined, end?: number | undefined) => Float32Array;
							toLocaleString: () => string;
							toString: () => string;
							valueOf: () => Float32Array;
							entries: () => IterableIterator<[number, number]>;
							keys: () => IterableIterator<number>;
							values: () => IterableIterator<number>;
							includes: (searchElement: number, fromIndex?: number | undefined) => boolean;
							[Symbol.iterator]: () => IterableIterator<number>;
							readonly [Symbol.toStringTag]: 'Float32Array';
							at: (index: number) => number | undefined;
						};
						DefaultInterpolation: InterpolationModes;
						InterpolantFactoryMethodDiscrete: (result: any) => DiscreteInterpolant;
						InterpolantFactoryMethodLinear: (result: any) => LinearInterpolant;
						InterpolantFactoryMethodSmooth: (result: any) => CubicInterpolant;
						setInterpolation: (interpolation: InterpolationModes) => KeyframeTrack;
						getInterpolation: () => InterpolationModes;
						createInterpolant: () => Interpolant;
						getValueSize: () => number;
						shift: (timeOffset: number) => KeyframeTrack;
						scale: (timeScale: number) => KeyframeTrack;
						trim: (startTime: number, endTime: number) => KeyframeTrack;
						validate: () => boolean;
						optimize: () => KeyframeTrack;
						clone: () => KeyframeTrack;
					}[];
					blendMode: AnimationBlendMode;
					duration: number;
					uuid: string;
					results: any[];
					resetDuration: () => AnimationClip;
					trim: () => AnimationClip;
					validate: () => boolean;
					optimize: () => AnimationClip;
					clone: () => AnimationClip;
					toJSON: (clip: AnimationClip) => any;
				}[];
				userData: {
					[key: string]: any;
				};
				customDepthMaterial: {
					alphaTest: number;
					alphaToCoverage: boolean;
					blendDst: BlendingDstFactor;
					blendDstAlpha: number | null;
					blendEquation: BlendingEquation;
					blendEquationAlpha: number | null;
					blending: Blending;
					blendSrc: BlendingDstFactor | BlendingSrcFactor;
					blendSrcAlpha: number | null;
					clipIntersection: boolean;
					clippingPlanes: any;
					clipShadows: boolean;
					colorWrite: boolean;
					defines:
						| {
								[key: string]: any;
						  }
						| undefined;
					depthFunc: DepthModes;
					depthTest: boolean;
					depthWrite: boolean;
					id: number;
					stencilWrite: boolean;
					stencilFunc: StencilFunc;
					stencilRef: number;
					stencilWriteMask: number;
					stencilFuncMask: number;
					stencilFail: StencilOp;
					stencilZFail: StencilOp;
					stencilZPass: StencilOp;
					readonly isMaterial: true;
					name: string;
					needsUpdate: boolean;
					opacity: number;
					polygonOffset: boolean;
					polygonOffsetFactor: number;
					polygonOffsetUnits: number;
					precision: 'highp' | 'mediump' | 'lowp' | null;
					premultipliedAlpha: boolean;
					forceSinglePass: boolean;
					dithering: boolean;
					side: Side;
					shadowSide: Side | null;
					toneMapped: boolean;
					transparent: boolean;
					type: string;
					uuid: string;
					vertexColors: boolean;
					visible: boolean;
					userData: any;
					version: number;
					clone: () => Material;
					copy: (material: Material) => Material;
					dispose: () => void;
					onBeforeCompile: (shader: Shader, renderer: WebGLRenderer) => void;
					customProgramCacheKey: () => string;
					setValues: (values: MaterialParameters) => void;
					toJSON: (meta?: any) => any;
					addEventListener: <T extends string>(type: T, listener: EventListener<Event, T, Material>) => void;
					hasEventListener: <T_1 extends string>(
						type: T_1,
						listener: EventListener<Event, T_1, Material>
					) => boolean;
					removeEventListener: <T_2 extends string>(
						type: T_2,
						listener: EventListener<Event, T_2, Material>
					) => void;
					dispatchEvent: (event: Event) => void;
				};
				customDistanceMaterial: {
					alphaTest: number;
					alphaToCoverage: boolean;
					blendDst: BlendingDstFactor;
					blendDstAlpha: number | null;
					blendEquation: BlendingEquation;
					blendEquationAlpha: number | null;
					blending: Blending;
					blendSrc: BlendingDstFactor | BlendingSrcFactor;
					blendSrcAlpha: number | null;
					clipIntersection: boolean;
					clippingPlanes: any;
					clipShadows: boolean;
					colorWrite: boolean;
					defines:
						| {
								[key: string]: any;
						  }
						| undefined;
					depthFunc: DepthModes;
					depthTest: boolean;
					depthWrite: boolean;
					id: number;
					stencilWrite: boolean;
					stencilFunc: StencilFunc;
					stencilRef: number;
					stencilWriteMask: number;
					stencilFuncMask: number;
					stencilFail: StencilOp;
					stencilZFail: StencilOp;
					stencilZPass: StencilOp;
					readonly isMaterial: true;
					name: string;
					needsUpdate: boolean;
					opacity: number;
					polygonOffset: boolean;
					polygonOffsetFactor: number;
					polygonOffsetUnits: number;
					precision: 'highp' | 'mediump' | 'lowp' | null;
					premultipliedAlpha: boolean;
					forceSinglePass: boolean;
					dithering: boolean;
					side: Side;
					shadowSide: Side | null;
					toneMapped: boolean;
					transparent: boolean;
					type: string;
					uuid: string;
					vertexColors: boolean;
					visible: boolean;
					userData: any;
					version: number;
					clone: () => Material;
					copy: (material: Material) => Material;
					dispose: () => void;
					onBeforeCompile: (shader: Shader, renderer: WebGLRenderer) => void;
					customProgramCacheKey: () => string;
					setValues: (values: MaterialParameters) => void;
					toJSON: (meta?: any) => any;
					addEventListener: <T extends string>(type: T, listener: EventListener<Event, T, Material>) => void;
					hasEventListener: <T_1 extends string>(
						type: T_1,
						listener: EventListener<Event, T_1, Material>
					) => boolean;
					removeEventListener: <T_2 extends string>(
						type: T_2,
						listener: EventListener<Event, T_2, Material>
					) => void;
					dispatchEvent: (event: Event) => void;
				};
				readonly isObject3D: true;
				onBeforeRender: (
					renderer: WebGLRenderer,
					scene: Scene,
					camera: Camera,
					geometry: BufferGeometry,
					material: Material,
					group: Group
				) => void;
				onAfterRender: (
					renderer: WebGLRenderer,
					scene: Scene,
					camera: Camera,
					geometry: BufferGeometry,
					material: Material,
					group: Group
				) => void;
				applyMatrix4: (matrix: Matrix4) => void;
				applyQuaternion: (quaternion: Quaternion) => Object3D<Event>;
				setRotationFromAxisAngle: (axis: Vector3, angle: number) => void;
				setRotationFromEuler: (euler: Euler) => void;
				setRotationFromMatrix: (m: Matrix4) => void;
				setRotationFromQuaternion: (q: Quaternion) => void;
				rotateOnAxis: (axis: Vector3, angle: number) => Object3D<Event>;
				rotateOnWorldAxis: (axis: Vector3, angle: number) => Object3D<Event>;
				rotateX: (angle: number) => Object3D<Event>;
				rotateY: (angle: number) => Object3D<Event>;
				rotateZ: (angle: number) => Object3D<Event>;
				translateOnAxis: (axis: Vector3, distance: number) => Object3D<Event>;
				translateX: (distance: number) => Object3D<Event>;
				translateY: (distance: number) => Object3D<Event>;
				translateZ: (distance: number) => Object3D<Event>;
				localToWorld: (vector: Vector3) => Vector3;
				worldToLocal: (vector: Vector3) => Vector3;
				lookAt: {
					(vector: Vector3): void;
					(x: number, y: number, z: number): void;
				};
				add: (...object: Object3D<Event>[]) => Object3D<Event>;
				remove: (...object: Object3D<Event>[]) => Object3D<Event>;
				removeFromParent: () => Object3D<Event>;
				clear: () => Object3D<Event>;
				attach: (object: Object3D<Event>) => Object3D<Event>;
				getObjectById: (id: number) => Object3D<Event> | undefined;
				getObjectByName: (name: string) => Object3D<Event> | undefined;
				getObjectByProperty: (name: string, value: any) => Object3D<Event> | undefined;
				getObjectsByProperty: (name: string, value: any) => Object3D<Event>[];
				getWorldPosition: (target: Vector3) => Vector3;
				getWorldQuaternion: (target: Quaternion) => Quaternion;
				getWorldScale: (target: Vector3) => Vector3;
				getWorldDirection: (target: Vector3) => Vector3;
				raycast: (raycaster: Raycaster, intersects: Intersection<Object3D<Event>>[]) => void;
				traverse: (callback: (object: Object3D<Event>) => any) => void;
				traverseVisible: (callback: (object: Object3D<Event>) => any) => void;
				traverseAncestors: (callback: (object: Object3D<Event>) => any) => void;
				updateMatrix: () => void;
				updateMatrixWorld: (force?: boolean | undefined) => void;
				updateWorldMatrix: (updateParents: boolean, updateChildren: boolean) => void;
				toJSON: (
					meta?:
						| {
								geometries: any;
								materials: any;
								textures: any;
								images: any;
						  }
						| undefined
				) => any;
				clone: (recursive?: boolean | undefined) => Object3D<Event>;
				copy: (source: Object3D<Event>, recursive?: boolean | undefined) => Object3D<Event>;
				addEventListener: <T_3 extends string>(
					type: T_3,
					listener: EventListener<Event, T_3, Object3D<Event>>
				) => void;
				hasEventListener: <T_4 extends string>(
					type: T_4,
					listener: EventListener<Event, T_4, Object3D<Event>>
				) => boolean;
				removeEventListener: <T_5 extends string>(
					type: T_5,
					listener: EventListener<Event, T_5, Object3D<Event>>
				) => void;
				dispatchEvent: (event: Event) => void;
			}[];
			up: {
				x: number;
				y: number;
				z: number;
				readonly isVector3: true;
				set: (x: number, y: number, z: number) => Vector3;
				setScalar: (scalar: number) => Vector3;
				setX: (x: number) => Vector3;
				setY: (y: number) => Vector3;
				setZ: (z: number) => Vector3;
				setComponent: (index: number, value: number) => Vector3;
				getComponent: (index: number) => number;
				clone: () => Vector3;
				copy: (v: Vector3) => Vector3;
				add: (v: Vector3) => Vector3;
				addScalar: (s: number) => Vector3;
				addScaledVector: (v: Vector3, s: number) => Vector3;
				addVectors: (a: Vector3, b: Vector3) => Vector3;
				sub: (a: Vector3) => Vector3;
				subScalar: (s: number) => Vector3;
				subVectors: (a: Vector3, b: Vector3) => Vector3;
				multiply: (v: Vector3) => Vector3;
				multiplyScalar: (s: number) => Vector3;
				multiplyVectors: (a: Vector3, b: Vector3) => Vector3;
				applyEuler: (euler: Euler) => Vector3;
				applyAxisAngle: (axis: Vector3, angle: number) => Vector3;
				applyMatrix3: (m: Matrix3) => Vector3;
				applyNormalMatrix: (m: Matrix3) => Vector3;
				applyMatrix4: (m: Matrix4) => Vector3;
				applyQuaternion: (q: Quaternion) => Vector3;
				project: (camera: Camera) => Vector3;
				unproject: (camera: Camera) => Vector3;
				transformDirection: (m: Matrix4) => Vector3;
				divide: (v: Vector3) => Vector3;
				divideScalar: (s: number) => Vector3;
				min: (v: Vector3) => Vector3;
				max: (v: Vector3) => Vector3;
				clamp: (min: Vector3, max: Vector3) => Vector3;
				clampScalar: (min: number, max: number) => Vector3;
				clampLength: (min: number, max: number) => Vector3;
				floor: () => Vector3;
				ceil: () => Vector3;
				round: () => Vector3;
				roundToZero: () => Vector3;
				negate: () => Vector3;
				dot: (v: Vector3) => number;
				lengthSq: () => number;
				length: () => number;
				lengthManhattan: () => number;
				manhattanLength: () => number;
				manhattanDistanceTo: (v: Vector3) => number;
				normalize: () => Vector3;
				setLength: (l: number) => Vector3;
				lerp: (v: Vector3, alpha: number) => Vector3;
				lerpVectors: (v1: Vector3, v2: Vector3, alpha: number) => Vector3;
				cross: (a: Vector3) => Vector3;
				crossVectors: (a: Vector3, b: Vector3) => Vector3;
				projectOnVector: (v: Vector3) => Vector3;
				projectOnPlane: (planeNormal: Vector3) => Vector3;
				reflect: (vector: Vector3) => Vector3;
				angleTo: (v: Vector3) => number;
				distanceTo: (v: Vector3) => number;
				distanceToSquared: (v: Vector3) => number;
				distanceToManhattan: (v: Vector3) => number;
				setFromSpherical: (s: Spherical) => Vector3;
				setFromSphericalCoords: (r: number, phi: number, theta: number) => Vector3;
				setFromCylindrical: (s: Cylindrical) => Vector3;
				setFromCylindricalCoords: (radius: number, theta: number, y: number) => Vector3;
				setFromMatrixPosition: (m: Matrix4) => Vector3;
				setFromMatrixScale: (m: Matrix4) => Vector3;
				setFromMatrixColumn: (matrix: Matrix4, index: number) => Vector3;
				setFromMatrix3Column: (matrix: Matrix3, index: number) => Vector3;
				setFromEuler: (e: Euler) => Vector3;
				equals: (v: Vector3) => boolean;
				fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Vector3;
				toArray: {
					(array?: number[] | undefined, offset?: number | undefined): number[];
					(array?: Vector3Tuple | undefined, offset?: 0 | undefined): Vector3Tuple;
					(array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
				};
				fromBufferAttribute: (
					attribute: BufferAttribute | InterleavedBufferAttribute,
					index: number
				) => Vector3;
				random: () => Vector3;
				randomDirection: () => Vector3;
			};
			readonly position: {
				x: number;
				y: number;
				z: number;
				readonly isVector3: true;
				set: (x: number, y: number, z: number) => Vector3;
				setScalar: (scalar: number) => Vector3;
				setX: (x: number) => Vector3;
				setY: (y: number) => Vector3;
				setZ: (z: number) => Vector3;
				setComponent: (index: number, value: number) => Vector3;
				getComponent: (index: number) => number;
				clone: () => Vector3;
				copy: (v: Vector3) => Vector3;
				add: (v: Vector3) => Vector3;
				addScalar: (s: number) => Vector3;
				addScaledVector: (v: Vector3, s: number) => Vector3;
				addVectors: (a: Vector3, b: Vector3) => Vector3;
				sub: (a: Vector3) => Vector3;
				subScalar: (s: number) => Vector3;
				subVectors: (a: Vector3, b: Vector3) => Vector3;
				multiply: (v: Vector3) => Vector3;
				multiplyScalar: (s: number) => Vector3;
				multiplyVectors: (a: Vector3, b: Vector3) => Vector3;
				applyEuler: (euler: Euler) => Vector3;
				applyAxisAngle: (axis: Vector3, angle: number) => Vector3;
				applyMatrix3: (m: Matrix3) => Vector3;
				applyNormalMatrix: (m: Matrix3) => Vector3;
				applyMatrix4: (m: Matrix4) => Vector3;
				applyQuaternion: (q: Quaternion) => Vector3;
				project: (camera: Camera) => Vector3;
				unproject: (camera: Camera) => Vector3;
				transformDirection: (m: Matrix4) => Vector3;
				divide: (v: Vector3) => Vector3;
				divideScalar: (s: number) => Vector3;
				min: (v: Vector3) => Vector3;
				max: (v: Vector3) => Vector3;
				clamp: (min: Vector3, max: Vector3) => Vector3;
				clampScalar: (min: number, max: number) => Vector3;
				clampLength: (min: number, max: number) => Vector3;
				floor: () => Vector3;
				ceil: () => Vector3;
				round: () => Vector3;
				roundToZero: () => Vector3;
				negate: () => Vector3;
				dot: (v: Vector3) => number;
				lengthSq: () => number;
				length: () => number;
				lengthManhattan: () => number;
				manhattanLength: () => number;
				manhattanDistanceTo: (v: Vector3) => number;
				normalize: () => Vector3;
				setLength: (l: number) => Vector3;
				lerp: (v: Vector3, alpha: number) => Vector3;
				lerpVectors: (v1: Vector3, v2: Vector3, alpha: number) => Vector3;
				cross: (a: Vector3) => Vector3;
				crossVectors: (a: Vector3, b: Vector3) => Vector3;
				projectOnVector: (v: Vector3) => Vector3;
				projectOnPlane: (planeNormal: Vector3) => Vector3;
				reflect: (vector: Vector3) => Vector3;
				angleTo: (v: Vector3) => number;
				distanceTo: (v: Vector3) => number;
				distanceToSquared: (v: Vector3) => number;
				distanceToManhattan: (v: Vector3) => number;
				setFromSpherical: (s: Spherical) => Vector3;
				setFromSphericalCoords: (r: number, phi: number, theta: number) => Vector3;
				setFromCylindrical: (s: Cylindrical) => Vector3;
				setFromCylindricalCoords: (radius: number, theta: number, y: number) => Vector3;
				setFromMatrixPosition: (m: Matrix4) => Vector3;
				setFromMatrixScale: (m: Matrix4) => Vector3;
				setFromMatrixColumn: (matrix: Matrix4, index: number) => Vector3;
				setFromMatrix3Column: (matrix: Matrix3, index: number) => Vector3;
				setFromEuler: (e: Euler) => Vector3;
				equals: (v: Vector3) => boolean;
				fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Vector3;
				toArray: {
					(array?: number[] | undefined, offset?: number | undefined): number[];
					(array?: Vector3Tuple | undefined, offset?: 0 | undefined): Vector3Tuple;
					(array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
				};
				fromBufferAttribute: (
					attribute: BufferAttribute | InterleavedBufferAttribute,
					index: number
				) => Vector3;
				random: () => Vector3;
				randomDirection: () => Vector3;
			};
			readonly rotation: {
				x: number;
				y: number;
				z: number;
				order: EulerOrder;
				readonly isEuler: true;
				_onChangeCallback: () => void;
				set: (x: number, y: number, z: number, order?: EulerOrder | undefined) => Euler;
				clone: () => Euler;
				copy: (euler: Euler) => Euler;
				setFromRotationMatrix: (
					m: Matrix4,
					order?: EulerOrder | undefined,
					update?: boolean | undefined
				) => Euler;
				setFromQuaternion: (
					q: Quaternion,
					order?: EulerOrder | undefined,
					update?: boolean | undefined
				) => Euler;
				setFromVector3: (v: Vector3, order?: EulerOrder | undefined) => Euler;
				reorder: (newOrder: EulerOrder) => Euler;
				equals: (euler: Euler) => boolean;
				fromArray: (xyzo: [number, number, number, (EulerOrder | undefined)?, ...any[]]) => Euler;
				toArray: (
					array?: (string | number | undefined)[] | undefined,
					offset?: number | undefined
				) => (string | number | undefined)[];
				_onChange: (callback: () => void) => Euler;
				[Symbol.iterator]: () => Generator<string | number, void, unknown>;
			};
			readonly quaternion: {
				x: number;
				y: number;
				z: number;
				w: number;
				readonly isQuaternion: true;
				set: (x: number, y: number, z: number, w: number) => Quaternion;
				clone: () => Quaternion;
				copy: (q: Quaternion) => Quaternion;
				setFromEuler: (euler: Euler, update?: boolean | undefined) => Quaternion;
				setFromAxisAngle: (axis: Vector3, angle: number) => Quaternion;
				setFromRotationMatrix: (m: Matrix4) => Quaternion;
				setFromUnitVectors: (vFrom: Vector3, vTo: Vector3) => Quaternion;
				angleTo: (q: Quaternion) => number;
				rotateTowards: (q: Quaternion, step: number) => Quaternion;
				identity: () => Quaternion;
				invert: () => Quaternion;
				conjugate: () => Quaternion;
				dot: (v: Quaternion) => number;
				lengthSq: () => number;
				length: () => number;
				normalize: () => Quaternion;
				multiply: (q: Quaternion) => Quaternion;
				premultiply: (q: Quaternion) => Quaternion;
				multiplyQuaternions: (a: Quaternion, b: Quaternion) => Quaternion;
				slerp: (qb: Quaternion, t: number) => Quaternion;
				slerpQuaternions: (qa: Quaternion, qb: Quaternion, t: number) => Quaternion;
				equals: (v: Quaternion) => boolean;
				fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Quaternion;
				toArray: {
					(array?: number[] | undefined, offset?: number | undefined): number[];
					(array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
				};
				fromBufferAttribute: (
					attribute: BufferAttribute | InterleavedBufferAttribute,
					index: number
				) => Quaternion;
				_onChange: (callback: () => void) => Quaternion;
				_onChangeCallback: () => void;
				multiplyVector3: (v: any) => any;
				random: () => Quaternion;
				[Symbol.iterator]: () => Generator<number, void, unknown>;
			};
			readonly scale: {
				x: number;
				y: number;
				z: number;
				readonly isVector3: true;
				set: (x: number, y: number, z: number) => Vector3;
				setScalar: (scalar: number) => Vector3;
				setX: (x: number) => Vector3;
				setY: (y: number) => Vector3;
				setZ: (z: number) => Vector3;
				setComponent: (index: number, value: number) => Vector3;
				getComponent: (index: number) => number;
				clone: () => Vector3;
				copy: (v: Vector3) => Vector3;
				add: (v: Vector3) => Vector3;
				addScalar: (s: number) => Vector3;
				addScaledVector: (v: Vector3, s: number) => Vector3;
				addVectors: (a: Vector3, b: Vector3) => Vector3;
				sub: (a: Vector3) => Vector3;
				subScalar: (s: number) => Vector3;
				subVectors: (a: Vector3, b: Vector3) => Vector3;
				multiply: (v: Vector3) => Vector3;
				multiplyScalar: (s: number) => Vector3;
				multiplyVectors: (a: Vector3, b: Vector3) => Vector3;
				applyEuler: (euler: Euler) => Vector3;
				applyAxisAngle: (axis: Vector3, angle: number) => Vector3;
				applyMatrix3: (m: Matrix3) => Vector3;
				applyNormalMatrix: (m: Matrix3) => Vector3;
				applyMatrix4: (m: Matrix4) => Vector3;
				applyQuaternion: (q: Quaternion) => Vector3;
				project: (camera: Camera) => Vector3;
				unproject: (camera: Camera) => Vector3;
				transformDirection: (m: Matrix4) => Vector3;
				divide: (v: Vector3) => Vector3;
				divideScalar: (s: number) => Vector3;
				min: (v: Vector3) => Vector3;
				max: (v: Vector3) => Vector3;
				clamp: (min: Vector3, max: Vector3) => Vector3;
				clampScalar: (min: number, max: number) => Vector3;
				clampLength: (min: number, max: number) => Vector3;
				floor: () => Vector3;
				ceil: () => Vector3;
				round: () => Vector3;
				roundToZero: () => Vector3;
				negate: () => Vector3;
				dot: (v: Vector3) => number;
				lengthSq: () => number;
				length: () => number;
				lengthManhattan: () => number;
				manhattanLength: () => number;
				manhattanDistanceTo: (v: Vector3) => number;
				normalize: () => Vector3;
				setLength: (l: number) => Vector3;
				lerp: (v: Vector3, alpha: number) => Vector3;
				lerpVectors: (v1: Vector3, v2: Vector3, alpha: number) => Vector3;
				cross: (a: Vector3) => Vector3;
				crossVectors: (a: Vector3, b: Vector3) => Vector3;
				projectOnVector: (v: Vector3) => Vector3;
				projectOnPlane: (planeNormal: Vector3) => Vector3;
				reflect: (vector: Vector3) => Vector3;
				angleTo: (v: Vector3) => number;
				distanceTo: (v: Vector3) => number;
				distanceToSquared: (v: Vector3) => number;
				distanceToManhattan: (v: Vector3) => number;
				setFromSpherical: (s: Spherical) => Vector3;
				setFromSphericalCoords: (r: number, phi: number, theta: number) => Vector3;
				setFromCylindrical: (s: Cylindrical) => Vector3;
				setFromCylindricalCoords: (radius: number, theta: number, y: number) => Vector3;
				setFromMatrixPosition: (m: Matrix4) => Vector3;
				setFromMatrixScale: (m: Matrix4) => Vector3;
				setFromMatrixColumn: (matrix: Matrix4, index: number) => Vector3;
				setFromMatrix3Column: (matrix: Matrix3, index: number) => Vector3;
				setFromEuler: (e: Euler) => Vector3;
				equals: (v: Vector3) => boolean;
				fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Vector3;
				toArray: {
					(array?: number[] | undefined, offset?: number | undefined): number[];
					(array?: Vector3Tuple | undefined, offset?: 0 | undefined): Vector3Tuple;
					(array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
				};
				fromBufferAttribute: (
					attribute: BufferAttribute | InterleavedBufferAttribute,
					index: number
				) => Vector3;
				random: () => Vector3;
				randomDirection: () => Vector3;
			};
			readonly modelViewMatrix: {
				elements: number[];
				set: (
					n11: number,
					n12: number,
					n13: number,
					n14: number,
					n21: number,
					n22: number,
					n23: number,
					n24: number,
					n31: number,
					n32: number,
					n33: number,
					n34: number,
					n41: number,
					n42: number,
					n43: number,
					n44: number
				) => Matrix4;
				identity: () => Matrix4;
				clone: () => Matrix4;
				copy: (m: Matrix4) => Matrix4;
				copyPosition: (m: Matrix4) => Matrix4;
				extractBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix4;
				makeBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix4;
				extractRotation: (m: Matrix4) => Matrix4;
				makeRotationFromEuler: (euler: Euler) => Matrix4;
				makeRotationFromQuaternion: (q: Quaternion) => Matrix4;
				lookAt: (eye: Vector3, target: Vector3, up: Vector3) => Matrix4;
				multiply: (m: Matrix4) => Matrix4;
				premultiply: (m: Matrix4) => Matrix4;
				multiplyMatrices: (a: Matrix4, b: Matrix4) => Matrix4;
				multiplyToArray: (a: Matrix4, b: Matrix4, r: number[]) => Matrix4;
				multiplyScalar: (s: number) => Matrix4;
				determinant: () => number;
				transpose: () => Matrix4;
				setPosition: (v: number | Vector3, y?: number | undefined, z?: number | undefined) => Matrix4;
				invert: () => Matrix4;
				scale: (v: Vector3) => Matrix4;
				getMaxScaleOnAxis: () => number;
				makeTranslation: (x: number, y: number, z: number) => Matrix4;
				makeRotationX: (theta: number) => Matrix4;
				makeRotationY: (theta: number) => Matrix4;
				makeRotationZ: (theta: number) => Matrix4;
				makeRotationAxis: (axis: Vector3, angle: number) => Matrix4;
				makeScale: (x: number, y: number, z: number) => Matrix4;
				makeShear: (xy: number, xz: number, yx: number, yz: number, zx: number, zy: number) => Matrix4;
				compose: (translation: Vector3, rotation: Quaternion, scale: Vector3) => Matrix4;
				decompose: (translation: Vector3, rotation: Quaternion, scale: Vector3) => Matrix4;
				makePerspective: {
					(left: number, right: number, bottom: number, top: number, near: number, far: number): Matrix4;
					(fov: number, aspect: number, near: number, far: number): Matrix4;
				};
				makeOrthographic: (
					left: number,
					right: number,
					top: number,
					bottom: number,
					near: number,
					far: number
				) => Matrix4;
				equals: (matrix: Matrix4) => boolean;
				fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Matrix4;
				toArray: {
					(array?: number[] | undefined, offset?: number | undefined): number[];
					(array?: Matrix4Tuple | undefined, offset?: 0 | undefined): Matrix4Tuple;
					(array?: ArrayLike<number> | undefined, offset?: number | undefined): ArrayLike<number>;
				};
				setFromMatrix3: (m: Matrix3) => Matrix4;
				extractPosition: (m: Matrix4) => Matrix4;
				setRotationFromQuaternion: (q: Quaternion) => Matrix4;
				multiplyVector3: (v: any) => any;
				multiplyVector4: (v: any) => any;
				multiplyVector3Array: (array: number[]) => number[];
				rotateAxis: (v: any) => void;
				crossVector: (v: any) => void;
				flattenToArrayOffset: (array: number[], offset: number) => number[];
				getInverse: (matrix: Matrix) => Matrix;
			};
			readonly normalMatrix: {
				elements: number[];
				set: (
					n11: number,
					n12: number,
					n13: number,
					n21: number,
					n22: number,
					n23: number,
					n31: number,
					n32: number,
					n33: number
				) => Matrix3;
				identity: () => Matrix3;
				clone: () => Matrix3;
				copy: (m: Matrix3) => Matrix3;
				extractBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix3;
				setFromMatrix4: (m: Matrix4) => Matrix3;
				multiplyScalar: (s: number) => Matrix3;
				determinant: () => number;
				invert: () => Matrix3;
				transpose: () => Matrix3;
				getNormalMatrix: (matrix4: Matrix4) => Matrix3;
				transposeIntoArray: (r: number[]) => Matrix3;
				setUvTransform: (
					tx: number,
					ty: number,
					sx: number,
					sy: number,
					rotation: number,
					cx: number,
					cy: number
				) => Matrix3;
				scale: (sx: number, sy: number) => Matrix3;
				makeTranslation: {
					(x: number, y: number): Matrix3;
					(x: number, y: number): Matrix3;
				};
				makeRotation: {
					(theta: number): Matrix3;
					(theta: number): Matrix3;
				};
				makeScale: {
					(x: number, y: number): Matrix3;
					(x: number, y: number): Matrix3;
				};
				rotate: (theta: number) => Matrix3;
				translate: (tx: number, ty: number) => Matrix3;
				equals: (matrix: Matrix3) => boolean;
				fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Matrix3;
				toArray: {
					(array?: number[] | undefined, offset?: number | undefined): number[];
					(array?: Matrix3Tuple | undefined, offset?: 0 | undefined): Matrix3Tuple;
					(array?: ArrayLike<number> | undefined, offset?: number | undefined): ArrayLike<number>;
				};
				multiply: (m: Matrix3) => Matrix3;
				premultiply: (m: Matrix3) => Matrix3;
				multiplyMatrices: (a: Matrix3, b: Matrix3) => Matrix3;
				multiplyVector3: (vector: Vector3) => any;
				multiplyVector3Array: (a: any) => any;
				getInverse: {
					(matrix: Matrix4, throwOnDegenerate?: boolean | undefined): Matrix3;
					(matrix: Matrix): Matrix;
				};
				flattenToArrayOffset: (array: number[], offset: number) => number[];
			};
			matrix: {
				elements: number[];
				set: (
					n11: number,
					n12: number,
					n13: number,
					n14: number,
					n21: number,
					n22: number,
					n23: number,
					n24: number,
					n31: number,
					n32: number,
					n33: number,
					n34: number,
					n41: number,
					n42: number,
					n43: number,
					n44: number
				) => Matrix4;
				identity: () => Matrix4;
				clone: () => Matrix4;
				copy: (m: Matrix4) => Matrix4;
				copyPosition: (m: Matrix4) => Matrix4;
				extractBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix4;
				makeBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix4;
				extractRotation: (m: Matrix4) => Matrix4;
				makeRotationFromEuler: (euler: Euler) => Matrix4;
				makeRotationFromQuaternion: (q: Quaternion) => Matrix4;
				lookAt: (eye: Vector3, target: Vector3, up: Vector3) => Matrix4;
				multiply: (m: Matrix4) => Matrix4;
				premultiply: (m: Matrix4) => Matrix4;
				multiplyMatrices: (a: Matrix4, b: Matrix4) => Matrix4;
				multiplyToArray: (a: Matrix4, b: Matrix4, r: number[]) => Matrix4;
				multiplyScalar: (s: number) => Matrix4;
				determinant: () => number;
				transpose: () => Matrix4;
				setPosition: (v: number | Vector3, y?: number | undefined, z?: number | undefined) => Matrix4;
				invert: () => Matrix4;
				scale: (v: Vector3) => Matrix4;
				getMaxScaleOnAxis: () => number;
				makeTranslation: (x: number, y: number, z: number) => Matrix4;
				makeRotationX: (theta: number) => Matrix4;
				makeRotationY: (theta: number) => Matrix4;
				makeRotationZ: (theta: number) => Matrix4;
				makeRotationAxis: (axis: Vector3, angle: number) => Matrix4;
				makeScale: (x: number, y: number, z: number) => Matrix4;
				makeShear: (xy: number, xz: number, yx: number, yz: number, zx: number, zy: number) => Matrix4;
				compose: (translation: Vector3, rotation: Quaternion, scale: Vector3) => Matrix4;
				decompose: (translation: Vector3, rotation: Quaternion, scale: Vector3) => Matrix4;
				makePerspective: {
					(left: number, right: number, bottom: number, top: number, near: number, far: number): Matrix4;
					(fov: number, aspect: number, near: number, far: number): Matrix4;
				};
				makeOrthographic: (
					left: number,
					right: number,
					top: number,
					bottom: number,
					near: number,
					far: number
				) => Matrix4;
				equals: (matrix: Matrix4) => boolean;
				fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Matrix4;
				toArray: {
					(array?: number[] | undefined, offset?: number | undefined): number[];
					(array?: Matrix4Tuple | undefined, offset?: 0 | undefined): Matrix4Tuple;
					(array?: ArrayLike<number> | undefined, offset?: number | undefined): ArrayLike<number>;
				};
				setFromMatrix3: (m: Matrix3) => Matrix4;
				extractPosition: (m: Matrix4) => Matrix4;
				setRotationFromQuaternion: (q: Quaternion) => Matrix4;
				multiplyVector3: (v: any) => any;
				multiplyVector4: (v: any) => any;
				multiplyVector3Array: (array: number[]) => number[];
				rotateAxis: (v: any) => void;
				crossVector: (v: any) => void;
				flattenToArrayOffset: (array: number[], offset: number) => number[];
				getInverse: (matrix: Matrix) => Matrix;
			};
			matrixWorld: {
				elements: number[];
				set: (
					n11: number,
					n12: number,
					n13: number,
					n14: number,
					n21: number,
					n22: number,
					n23: number,
					n24: number,
					n31: number,
					n32: number,
					n33: number,
					n34: number,
					n41: number,
					n42: number,
					n43: number,
					n44: number
				) => Matrix4;
				identity: () => Matrix4;
				clone: () => Matrix4;
				copy: (m: Matrix4) => Matrix4;
				copyPosition: (m: Matrix4) => Matrix4;
				extractBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix4;
				makeBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix4;
				extractRotation: (m: Matrix4) => Matrix4;
				makeRotationFromEuler: (euler: Euler) => Matrix4;
				makeRotationFromQuaternion: (q: Quaternion) => Matrix4;
				lookAt: (eye: Vector3, target: Vector3, up: Vector3) => Matrix4;
				multiply: (m: Matrix4) => Matrix4;
				premultiply: (m: Matrix4) => Matrix4;
				multiplyMatrices: (a: Matrix4, b: Matrix4) => Matrix4;
				multiplyToArray: (a: Matrix4, b: Matrix4, r: number[]) => Matrix4;
				multiplyScalar: (s: number) => Matrix4;
				determinant: () => number;
				transpose: () => Matrix4;
				setPosition: (v: number | Vector3, y?: number | undefined, z?: number | undefined) => Matrix4;
				invert: () => Matrix4;
				scale: (v: Vector3) => Matrix4;
				getMaxScaleOnAxis: () => number;
				makeTranslation: (x: number, y: number, z: number) => Matrix4;
				makeRotationX: (theta: number) => Matrix4;
				makeRotationY: (theta: number) => Matrix4;
				makeRotationZ: (theta: number) => Matrix4;
				makeRotationAxis: (axis: Vector3, angle: number) => Matrix4;
				makeScale: (x: number, y: number, z: number) => Matrix4;
				makeShear: (xy: number, xz: number, yx: number, yz: number, zx: number, zy: number) => Matrix4;
				compose: (translation: Vector3, rotation: Quaternion, scale: Vector3) => Matrix4;
				decompose: (translation: Vector3, rotation: Quaternion, scale: Vector3) => Matrix4;
				makePerspective: {
					(left: number, right: number, bottom: number, top: number, near: number, far: number): Matrix4;
					(fov: number, aspect: number, near: number, far: number): Matrix4;
				};
				makeOrthographic: (
					left: number,
					right: number,
					top: number,
					bottom: number,
					near: number,
					far: number
				) => Matrix4;
				equals: (matrix: Matrix4) => boolean;
				fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Matrix4;
				toArray: {
					(array?: number[] | undefined, offset?: number | undefined): number[];
					(array?: Matrix4Tuple | undefined, offset?: 0 | undefined): Matrix4Tuple;
					(array?: ArrayLike<number> | undefined, offset?: number | undefined): ArrayLike<number>;
				};
				setFromMatrix3: (m: Matrix3) => Matrix4;
				extractPosition: (m: Matrix4) => Matrix4;
				setRotationFromQuaternion: (q: Quaternion) => Matrix4;
				multiplyVector3: (v: any) => any;
				multiplyVector4: (v: any) => any;
				multiplyVector3Array: (array: number[]) => number[];
				rotateAxis: (v: any) => void;
				crossVector: (v: any) => void;
				flattenToArrayOffset: (array: number[], offset: number) => number[];
				getInverse: (matrix: Matrix) => Matrix;
			};
			matrixAutoUpdate: boolean;
			matrixWorldAutoUpdate: boolean;
			matrixWorldNeedsUpdate: boolean;
			layers: {
				mask: number;
				set: (channel: number) => void;
				enable: (channel: number) => void;
				enableAll: () => void;
				toggle: (channel: number) => void;
				disable: (channel: number) => void;
				disableAll: () => void;
				test: (layers: Layers) => boolean;
				isEnabled: (channel: number) => boolean;
			};
			visible: boolean;
			castShadow: boolean;
			receiveShadow: boolean;
			frustumCulled: boolean;
			renderOrder: number;
			animations: {
				name: string;
				tracks: {
					name: string;
					times: {
						[x: number]: number;
						readonly BYTES_PER_ELEMENT: number;
						readonly buffer:
							| {
									readonly byteLength: number;
									slice: (begin: number, end?: number | undefined) => ArrayBuffer;
									readonly [Symbol.toStringTag]: string;
							  }
							| {
									readonly byteLength: number;
									slice: (begin: number, end?: number | undefined) => SharedArrayBuffer;
									readonly [Symbol.species]: SharedArrayBuffer;
									readonly [Symbol.toStringTag]: 'SharedArrayBuffer';
							  };
						readonly byteLength: number;
						readonly byteOffset: number;
						copyWithin: (target: number, start: number, end?: number | undefined) => Float32Array;
						every: (
							predicate: (value: number, index: number, array: Float32Array) => unknown,
							thisArg?: any
						) => boolean;
						fill: (value: number, start?: number | undefined, end?: number | undefined) => Float32Array;
						filter: (
							predicate: (value: number, index: number, array: Float32Array) => any,
							thisArg?: any
						) => Float32Array;
						find: (
							predicate: (value: number, index: number, obj: Float32Array) => boolean,
							thisArg?: any
						) => number | undefined;
						findIndex: (
							predicate: (value: number, index: number, obj: Float32Array) => boolean,
							thisArg?: any
						) => number;
						forEach: (
							callbackfn: (value: number, index: number, array: Float32Array) => void,
							thisArg?: any
						) => void;
						indexOf: (searchElement: number, fromIndex?: number | undefined) => number;
						join: (separator?: string | undefined) => string;
						lastIndexOf: (searchElement: number, fromIndex?: number | undefined) => number;
						readonly length: number;
						map: (
							callbackfn: (value: number, index: number, array: Float32Array) => number,
							thisArg?: any
						) => Float32Array;
						reduce: {
							(
								callbackfn: (
									previousValue: number,
									currentValue: number,
									currentIndex: number,
									array: Float32Array
								) => number
							): number;
							(
								callbackfn: (
									previousValue: number,
									currentValue: number,
									currentIndex: number,
									array: Float32Array
								) => number,
								initialValue: number
							): number;
							<U>(
								callbackfn: (
									previousValue: U,
									currentValue: number,
									currentIndex: number,
									array: Float32Array
								) => U,
								initialValue: U
							): U;
						};
						reduceRight: {
							(
								callbackfn: (
									previousValue: number,
									currentValue: number,
									currentIndex: number,
									array: Float32Array
								) => number
							): number;
							(
								callbackfn: (
									previousValue: number,
									currentValue: number,
									currentIndex: number,
									array: Float32Array
								) => number,
								initialValue: number
							): number;
							<U_1>(
								callbackfn: (
									previousValue: U_1,
									currentValue: number,
									currentIndex: number,
									array: Float32Array
								) => U_1,
								initialValue: U_1
							): U_1;
						};
						reverse: () => Float32Array;
						set: (array: ArrayLike<number>, offset?: number | undefined) => void;
						slice: (start?: number | undefined, end?: number | undefined) => Float32Array;
						some: (
							predicate: (value: number, index: number, array: Float32Array) => unknown,
							thisArg?: any
						) => boolean;
						sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
						subarray: (begin?: number | undefined, end?: number | undefined) => Float32Array;
						toLocaleString: () => string;
						toString: () => string;
						valueOf: () => Float32Array;
						entries: () => IterableIterator<[number, number]>;
						keys: () => IterableIterator<number>;
						values: () => IterableIterator<number>;
						includes: (searchElement: number, fromIndex?: number | undefined) => boolean;
						[Symbol.iterator]: () => IterableIterator<number>;
						readonly [Symbol.toStringTag]: 'Float32Array';
						at: (index: number) => number | undefined;
					};
					values: {
						[x: number]: number;
						readonly BYTES_PER_ELEMENT: number;
						readonly buffer:
							| {
									readonly byteLength: number;
									slice: (begin: number, end?: number | undefined) => ArrayBuffer;
									readonly [Symbol.toStringTag]: string;
							  }
							| {
									readonly byteLength: number;
									slice: (begin: number, end?: number | undefined) => SharedArrayBuffer;
									readonly [Symbol.species]: SharedArrayBuffer;
									readonly [Symbol.toStringTag]: 'SharedArrayBuffer';
							  };
						readonly byteLength: number;
						readonly byteOffset: number;
						copyWithin: (target: number, start: number, end?: number | undefined) => Float32Array;
						every: (
							predicate: (value: number, index: number, array: Float32Array) => unknown,
							thisArg?: any
						) => boolean;
						fill: (value: number, start?: number | undefined, end?: number | undefined) => Float32Array;
						filter: (
							predicate: (value: number, index: number, array: Float32Array) => any,
							thisArg?: any
						) => Float32Array;
						find: (
							predicate: (value: number, index: number, obj: Float32Array) => boolean,
							thisArg?: any
						) => number | undefined;
						findIndex: (
							predicate: (value: number, index: number, obj: Float32Array) => boolean,
							thisArg?: any
						) => number;
						forEach: (
							callbackfn: (value: number, index: number, array: Float32Array) => void,
							thisArg?: any
						) => void;
						indexOf: (searchElement: number, fromIndex?: number | undefined) => number;
						join: (separator?: string | undefined) => string;
						lastIndexOf: (searchElement: number, fromIndex?: number | undefined) => number;
						readonly length: number;
						map: (
							callbackfn: (value: number, index: number, array: Float32Array) => number,
							thisArg?: any
						) => Float32Array;
						reduce: {
							(
								callbackfn: (
									previousValue: number,
									currentValue: number,
									currentIndex: number,
									array: Float32Array
								) => number
							): number;
							(
								callbackfn: (
									previousValue: number,
									currentValue: number,
									currentIndex: number,
									array: Float32Array
								) => number,
								initialValue: number
							): number;
							<U>(
								callbackfn: (
									previousValue: U,
									currentValue: number,
									currentIndex: number,
									array: Float32Array
								) => U,
								initialValue: U
							): U;
						};
						reduceRight: {
							(
								callbackfn: (
									previousValue: number,
									currentValue: number,
									currentIndex: number,
									array: Float32Array
								) => number
							): number;
							(
								callbackfn: (
									previousValue: number,
									currentValue: number,
									currentIndex: number,
									array: Float32Array
								) => number,
								initialValue: number
							): number;
							<U_1>(
								callbackfn: (
									previousValue: U_1,
									currentValue: number,
									currentIndex: number,
									array: Float32Array
								) => U_1,
								initialValue: U_1
							): U_1;
						};
						reverse: () => Float32Array;
						set: (array: ArrayLike<number>, offset?: number | undefined) => void;
						slice: (start?: number | undefined, end?: number | undefined) => Float32Array;
						some: (
							predicate: (value: number, index: number, array: Float32Array) => unknown,
							thisArg?: any
						) => boolean;
						sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
						subarray: (begin?: number | undefined, end?: number | undefined) => Float32Array;
						toLocaleString: () => string;
						toString: () => string;
						valueOf: () => Float32Array;
						entries: () => IterableIterator<[number, number]>;
						keys: () => IterableIterator<number>;
						values: () => IterableIterator<number>;
						includes: (searchElement: number, fromIndex?: number | undefined) => boolean;
						[Symbol.iterator]: () => IterableIterator<number>;
						readonly [Symbol.toStringTag]: 'Float32Array';
						at: (index: number) => number | undefined;
					};
					ValueTypeName: string;
					TimeBufferType: {
						[x: number]: number;
						readonly BYTES_PER_ELEMENT: number;
						readonly buffer:
							| {
									readonly byteLength: number;
									slice: (begin: number, end?: number | undefined) => ArrayBuffer;
									readonly [Symbol.toStringTag]: string;
							  }
							| {
									readonly byteLength: number;
									slice: (begin: number, end?: number | undefined) => SharedArrayBuffer;
									readonly [Symbol.species]: SharedArrayBuffer;
									readonly [Symbol.toStringTag]: 'SharedArrayBuffer';
							  };
						readonly byteLength: number;
						readonly byteOffset: number;
						copyWithin: (target: number, start: number, end?: number | undefined) => Float32Array;
						every: (
							predicate: (value: number, index: number, array: Float32Array) => unknown,
							thisArg?: any
						) => boolean;
						fill: (value: number, start?: number | undefined, end?: number | undefined) => Float32Array;
						filter: (
							predicate: (value: number, index: number, array: Float32Array) => any,
							thisArg?: any
						) => Float32Array;
						find: (
							predicate: (value: number, index: number, obj: Float32Array) => boolean,
							thisArg?: any
						) => number | undefined;
						findIndex: (
							predicate: (value: number, index: number, obj: Float32Array) => boolean,
							thisArg?: any
						) => number;
						forEach: (
							callbackfn: (value: number, index: number, array: Float32Array) => void,
							thisArg?: any
						) => void;
						indexOf: (searchElement: number, fromIndex?: number | undefined) => number;
						join: (separator?: string | undefined) => string;
						lastIndexOf: (searchElement: number, fromIndex?: number | undefined) => number;
						readonly length: number;
						map: (
							callbackfn: (value: number, index: number, array: Float32Array) => number,
							thisArg?: any
						) => Float32Array;
						reduce: {
							(
								callbackfn: (
									previousValue: number,
									currentValue: number,
									currentIndex: number,
									array: Float32Array
								) => number
							): number;
							(
								callbackfn: (
									previousValue: number,
									currentValue: number,
									currentIndex: number,
									array: Float32Array
								) => number,
								initialValue: number
							): number;
							<U>(
								callbackfn: (
									previousValue: U,
									currentValue: number,
									currentIndex: number,
									array: Float32Array
								) => U,
								initialValue: U
							): U;
						};
						reduceRight: {
							(
								callbackfn: (
									previousValue: number,
									currentValue: number,
									currentIndex: number,
									array: Float32Array
								) => number
							): number;
							(
								callbackfn: (
									previousValue: number,
									currentValue: number,
									currentIndex: number,
									array: Float32Array
								) => number,
								initialValue: number
							): number;
							<U_1>(
								callbackfn: (
									previousValue: U_1,
									currentValue: number,
									currentIndex: number,
									array: Float32Array
								) => U_1,
								initialValue: U_1
							): U_1;
						};
						reverse: () => Float32Array;
						set: (array: ArrayLike<number>, offset?: number | undefined) => void;
						slice: (start?: number | undefined, end?: number | undefined) => Float32Array;
						some: (
							predicate: (value: number, index: number, array: Float32Array) => unknown,
							thisArg?: any
						) => boolean;
						sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
						subarray: (begin?: number | undefined, end?: number | undefined) => Float32Array;
						toLocaleString: () => string;
						toString: () => string;
						valueOf: () => Float32Array;
						entries: () => IterableIterator<[number, number]>;
						keys: () => IterableIterator<number>;
						values: () => IterableIterator<number>;
						includes: (searchElement: number, fromIndex?: number | undefined) => boolean;
						[Symbol.iterator]: () => IterableIterator<number>;
						readonly [Symbol.toStringTag]: 'Float32Array';
						at: (index: number) => number | undefined;
					};
					ValueBufferType: {
						[x: number]: number;
						readonly BYTES_PER_ELEMENT: number;
						readonly buffer:
							| {
									readonly byteLength: number;
									slice: (begin: number, end?: number | undefined) => ArrayBuffer;
									readonly [Symbol.toStringTag]: string;
							  }
							| {
									readonly byteLength: number;
									slice: (begin: number, end?: number | undefined) => SharedArrayBuffer;
									readonly [Symbol.species]: SharedArrayBuffer;
									readonly [Symbol.toStringTag]: 'SharedArrayBuffer';
							  };
						readonly byteLength: number;
						readonly byteOffset: number;
						copyWithin: (target: number, start: number, end?: number | undefined) => Float32Array;
						every: (
							predicate: (value: number, index: number, array: Float32Array) => unknown,
							thisArg?: any
						) => boolean;
						fill: (value: number, start?: number | undefined, end?: number | undefined) => Float32Array;
						filter: (
							predicate: (value: number, index: number, array: Float32Array) => any,
							thisArg?: any
						) => Float32Array;
						find: (
							predicate: (value: number, index: number, obj: Float32Array) => boolean,
							thisArg?: any
						) => number | undefined;
						findIndex: (
							predicate: (value: number, index: number, obj: Float32Array) => boolean,
							thisArg?: any
						) => number;
						forEach: (
							callbackfn: (value: number, index: number, array: Float32Array) => void,
							thisArg?: any
						) => void;
						indexOf: (searchElement: number, fromIndex?: number | undefined) => number;
						join: (separator?: string | undefined) => string;
						lastIndexOf: (searchElement: number, fromIndex?: number | undefined) => number;
						readonly length: number;
						map: (
							callbackfn: (value: number, index: number, array: Float32Array) => number,
							thisArg?: any
						) => Float32Array;
						reduce: {
							(
								callbackfn: (
									previousValue: number,
									currentValue: number,
									currentIndex: number,
									array: Float32Array
								) => number
							): number;
							(
								callbackfn: (
									previousValue: number,
									currentValue: number,
									currentIndex: number,
									array: Float32Array
								) => number,
								initialValue: number
							): number;
							<U>(
								callbackfn: (
									previousValue: U,
									currentValue: number,
									currentIndex: number,
									array: Float32Array
								) => U,
								initialValue: U
							): U;
						};
						reduceRight: {
							(
								callbackfn: (
									previousValue: number,
									currentValue: number,
									currentIndex: number,
									array: Float32Array
								) => number
							): number;
							(
								callbackfn: (
									previousValue: number,
									currentValue: number,
									currentIndex: number,
									array: Float32Array
								) => number,
								initialValue: number
							): number;
							<U_1>(
								callbackfn: (
									previousValue: U_1,
									currentValue: number,
									currentIndex: number,
									array: Float32Array
								) => U_1,
								initialValue: U_1
							): U_1;
						};
						reverse: () => Float32Array;
						set: (array: ArrayLike<number>, offset?: number | undefined) => void;
						slice: (start?: number | undefined, end?: number | undefined) => Float32Array;
						some: (
							predicate: (value: number, index: number, array: Float32Array) => unknown,
							thisArg?: any
						) => boolean;
						sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
						subarray: (begin?: number | undefined, end?: number | undefined) => Float32Array;
						toLocaleString: () => string;
						toString: () => string;
						valueOf: () => Float32Array;
						entries: () => IterableIterator<[number, number]>;
						keys: () => IterableIterator<number>;
						values: () => IterableIterator<number>;
						includes: (searchElement: number, fromIndex?: number | undefined) => boolean;
						[Symbol.iterator]: () => IterableIterator<number>;
						readonly [Symbol.toStringTag]: 'Float32Array';
						at: (index: number) => number | undefined;
					};
					DefaultInterpolation: InterpolationModes;
					InterpolantFactoryMethodDiscrete: (result: any) => DiscreteInterpolant;
					InterpolantFactoryMethodLinear: (result: any) => LinearInterpolant;
					InterpolantFactoryMethodSmooth: (result: any) => CubicInterpolant;
					setInterpolation: (interpolation: InterpolationModes) => KeyframeTrack;
					getInterpolation: () => InterpolationModes;
					createInterpolant: () => Interpolant;
					getValueSize: () => number;
					shift: (timeOffset: number) => KeyframeTrack;
					scale: (timeScale: number) => KeyframeTrack;
					trim: (startTime: number, endTime: number) => KeyframeTrack;
					validate: () => boolean;
					optimize: () => KeyframeTrack;
					clone: () => KeyframeTrack;
				}[];
				blendMode: AnimationBlendMode;
				duration: number;
				uuid: string;
				results: any[];
				resetDuration: () => AnimationClip;
				trim: () => AnimationClip;
				validate: () => boolean;
				optimize: () => AnimationClip;
				clone: () => AnimationClip;
				toJSON: (clip: AnimationClip) => any;
			}[];
			userData: {
				[key: string]: any;
			};
			customDepthMaterial: {
				alphaTest: number;
				alphaToCoverage: boolean;
				blendDst: BlendingDstFactor;
				blendDstAlpha: number | null;
				blendEquation: BlendingEquation;
				blendEquationAlpha: number | null;
				blending: Blending;
				blendSrc: BlendingDstFactor | BlendingSrcFactor;
				blendSrcAlpha: number | null;
				clipIntersection: boolean;
				clippingPlanes: any;
				clipShadows: boolean;
				colorWrite: boolean;
				defines:
					| {
							[key: string]: any;
					  }
					| undefined;
				depthFunc: DepthModes;
				depthTest: boolean;
				depthWrite: boolean;
				id: number;
				stencilWrite: boolean;
				stencilFunc: StencilFunc;
				stencilRef: number;
				stencilWriteMask: number;
				stencilFuncMask: number;
				stencilFail: StencilOp;
				stencilZFail: StencilOp;
				stencilZPass: StencilOp;
				readonly isMaterial: true;
				name: string;
				needsUpdate: boolean;
				opacity: number;
				polygonOffset: boolean;
				polygonOffsetFactor: number;
				polygonOffsetUnits: number;
				precision: 'highp' | 'mediump' | 'lowp' | null;
				premultipliedAlpha: boolean;
				forceSinglePass: boolean;
				dithering: boolean;
				side: Side;
				shadowSide: Side | null;
				toneMapped: boolean;
				transparent: boolean;
				type: string;
				uuid: string;
				vertexColors: boolean;
				visible: boolean;
				userData: any;
				version: number;
				clone: () => Material;
				copy: (material: Material) => Material;
				dispose: () => void;
				onBeforeCompile: (shader: Shader, renderer: WebGLRenderer) => void;
				customProgramCacheKey: () => string;
				setValues: (values: MaterialParameters) => void;
				toJSON: (meta?: any) => any;
				addEventListener: <T extends string>(type: T, listener: EventListener<Event, T, Material>) => void;
				hasEventListener: <T_1 extends string>(
					type: T_1,
					listener: EventListener<Event, T_1, Material>
				) => boolean;
				removeEventListener: <T_2 extends string>(
					type: T_2,
					listener: EventListener<Event, T_2, Material>
				) => void;
				dispatchEvent: (event: Event) => void;
			};
			customDistanceMaterial: {
				alphaTest: number;
				alphaToCoverage: boolean;
				blendDst: BlendingDstFactor;
				blendDstAlpha: number | null;
				blendEquation: BlendingEquation;
				blendEquationAlpha: number | null;
				blending: Blending;
				blendSrc: BlendingDstFactor | BlendingSrcFactor;
				blendSrcAlpha: number | null;
				clipIntersection: boolean;
				clippingPlanes: any;
				clipShadows: boolean;
				colorWrite: boolean;
				defines:
					| {
							[key: string]: any;
					  }
					| undefined;
				depthFunc: DepthModes;
				depthTest: boolean;
				depthWrite: boolean;
				id: number;
				stencilWrite: boolean;
				stencilFunc: StencilFunc;
				stencilRef: number;
				stencilWriteMask: number;
				stencilFuncMask: number;
				stencilFail: StencilOp;
				stencilZFail: StencilOp;
				stencilZPass: StencilOp;
				readonly isMaterial: true;
				name: string;
				needsUpdate: boolean;
				opacity: number;
				polygonOffset: boolean;
				polygonOffsetFactor: number;
				polygonOffsetUnits: number;
				precision: 'highp' | 'mediump' | 'lowp' | null;
				premultipliedAlpha: boolean;
				forceSinglePass: boolean;
				dithering: boolean;
				side: Side;
				shadowSide: Side | null;
				toneMapped: boolean;
				transparent: boolean;
				type: string;
				uuid: string;
				vertexColors: boolean;
				visible: boolean;
				userData: any;
				version: number;
				clone: () => Material;
				copy: (material: Material) => Material;
				dispose: () => void;
				onBeforeCompile: (shader: Shader, renderer: WebGLRenderer) => void;
				customProgramCacheKey: () => string;
				setValues: (values: MaterialParameters) => void;
				toJSON: (meta?: any) => any;
				addEventListener: <T extends string>(type: T, listener: EventListener<Event, T, Material>) => void;
				hasEventListener: <T_1 extends string>(
					type: T_1,
					listener: EventListener<Event, T_1, Material>
				) => boolean;
				removeEventListener: <T_2 extends string>(
					type: T_2,
					listener: EventListener<Event, T_2, Material>
				) => void;
				dispatchEvent: (event: Event) => void;
			};
			readonly isObject3D: true;
			onBeforeRender: (
				renderer: WebGLRenderer,
				scene: Scene,
				camera: Camera,
				geometry: BufferGeometry,
				material: Material,
				group: Group
			) => void;
			onAfterRender: (
				renderer: WebGLRenderer,
				scene: Scene,
				camera: Camera,
				geometry: BufferGeometry,
				material: Material,
				group: Group
			) => void;
			applyMatrix4: (matrix: Matrix4) => void;
			applyQuaternion: (quaternion: Quaternion) => Camera;
			setRotationFromAxisAngle: (axis: Vector3, angle: number) => void;
			setRotationFromEuler: (euler: Euler) => void;
			setRotationFromMatrix: (m: Matrix4) => void;
			setRotationFromQuaternion: (q: Quaternion) => void;
			rotateOnAxis: (axis: Vector3, angle: number) => Camera;
			rotateOnWorldAxis: (axis: Vector3, angle: number) => Camera;
			rotateX: (angle: number) => Camera;
			rotateY: (angle: number) => Camera;
			rotateZ: (angle: number) => Camera;
			translateOnAxis: (axis: Vector3, distance: number) => Camera;
			translateX: (distance: number) => Camera;
			translateY: (distance: number) => Camera;
			translateZ: (distance: number) => Camera;
			localToWorld: (vector: Vector3) => Vector3;
			worldToLocal: (vector: Vector3) => Vector3;
			lookAt: {
				(vector: Vector3): void;
				(x: number, y: number, z: number): void;
			};
			add: (...object: Object3D<Event>[]) => Camera;
			remove: (...object: Object3D<Event>[]) => Camera;
			removeFromParent: () => Camera;
			clear: () => Camera;
			attach: (object: Object3D<Event>) => Camera;
			getObjectById: (id: number) => Object3D<Event> | undefined;
			getObjectByName: (name: string) => Object3D<Event> | undefined;
			getObjectByProperty: (name: string, value: any) => Object3D<Event> | undefined;
			getObjectsByProperty: (name: string, value: any) => Object3D<Event>[];
			getWorldPosition: (target: Vector3) => Vector3;
			getWorldQuaternion: (target: Quaternion) => Quaternion;
			getWorldScale: (target: Vector3) => Vector3;
			raycast: (raycaster: Raycaster, intersects: Intersection<Object3D<Event>>[]) => void;
			traverse: (callback: (object: Object3D<Event>) => any) => void;
			traverseVisible: (callback: (object: Object3D<Event>) => any) => void;
			traverseAncestors: (callback: (object: Object3D<Event>) => any) => void;
			updateMatrix: () => void;
			updateWorldMatrix: (updateParents: boolean, updateChildren: boolean) => void;
			toJSON: (
				meta?:
					| {
							geometries: any;
							materials: any;
							textures: any;
							images: any;
					  }
					| undefined
			) => any;
			clone: (recursive?: boolean | undefined) => Camera;
			copy: (source: Camera, recursive?: boolean | undefined) => Camera;
			addEventListener: <T_6 extends string>(type: T_6, listener: EventListener<Event, T_6, Camera>) => void;
			hasEventListener: <T_7 extends string>(type: T_7, listener: EventListener<Event, T_7, Camera>) => boolean;
			removeEventListener: <T_8 extends string>(type: T_8, listener: EventListener<Event, T_8, Camera>) => void;
			dispatchEvent: (event: Event) => void;
		};
		layers: {
			mask: number;
			set: (channel: number) => void;
			enable: (channel: number) => void;
			enableAll: () => void;
			toggle: (channel: number) => void;
			disable: (channel: number) => void;
			disableAll: () => void;
			test: (layers: Layers) => boolean;
			isEnabled: (channel: number) => boolean;
		};
		params: {
			Mesh?: any;
			Line?:
				| {
						threshold: number;
				  }
				| undefined;
			LOD?: any;
			Points?:
				| {
						threshold: number;
				  }
				| undefined;
			Sprite?: any;
		};
		set: (origin: Vector3, direction: Vector3) => void;
		setFromCamera: (
			coords: {
				x: number;
				y: number;
			},
			camera: Camera
		) => void;
		intersectObject: <TIntersected extends Object3D<Event>>(
			object: Object3D<Event>,
			recursive?: boolean | undefined,
			optionalTarget?: Intersection<TIntersected>[] | undefined
		) => Intersection<TIntersected>[];
		intersectObjects: <TIntersected_1 extends Object3D<Event>>(
			objects: Object3D<Event>[],
			recursive?: boolean | undefined,
			optionalTarget?: Intersection<TIntersected_1>[] | undefined
		) => Intersection<TIntersected_1>[];
		firstHitOnly?: boolean | undefined;
	};
	updateRaycasters(): void;
}
declare class ViewerPerformanceMonitor {
	protected viewer: BaseViewerType;
	constructor(viewer: BaseViewerType);
	protected _accumulatedDelta: number;
	protected _framesCount: number;
	protected _lastRoundedPerf: number;
	measurePerformance(delta: number): void;
}
export declare type ViewerTickCallback = (delta: number) => void;
export declare type ViewerRenderCallback = (delta: number, renderer: AbstractRenderer) => void;
export interface BaseViewerCallbackOptions {
	persistent?: boolean;
}
export interface HTMLElementWithViewer<C extends Camera> extends HTMLElement {
	scene: PolyScene;
	viewer: TypedViewer<C>;
	Poly: PolyEngine;
}
export declare type UpdateCameraAspectCallback = (aspect: number) => void;
export interface CreateViewerOptions {
	canvas?: HTMLCanvasElement;
	autoRender?: boolean;
	renderer?: AbstractRenderer;
	cameraMaskOverride?: string;
}
export interface TypedViewerOptions<C extends Camera> extends CreateViewerOptions {
	camera: C;
	scene: PolyScene;
	updateCameraAspect: UpdateCameraAspectCallback;
}
export interface TypedViewerInterectionObserverChangeOptions {
	root?: HTMLElement;
	rootMargin?: string;
	threshold?: number;
	playPauseScene?: boolean;
	onChange?: (isIntersecting: boolean) => void;
}
declare abstract class TypedViewer<C extends Camera> {
	protected _domElement: HTMLElementWithViewer<C> | undefined;
	protected _active: boolean;
	private static _nextViewerId;
	private _id;
	protected _renderObjectOverride: Object3D | undefined;
	protected _canvas: HTMLCanvasElement | undefined;
	protected _camera: C;
	protected _scene: PolyScene;
	readonly updateCameraAspect: UpdateCameraAspectCallback;
	protected _doRender: boolean;
	protected _controlsNode: ApplicableControlsNode | undefined;
	constructor(options: TypedViewerOptions<C>);
	private static _nextId;
	createRaycaster(): Raycaster;
	abstract renderer(): AbstractRenderer | undefined;
	protected _mounted: boolean;
	/**
	 * mounts the viewer onto an element
	 *
	 *
	 */
	mount(element: HTMLElement): void;
	/**
	 * unmounts the viewer
	 *
	 *
	 */
	unmount(): void;
	static _canvasIdPrefix(): string;
	static createCanvas(id?: string): HTMLCanvasElement;
	controlsNode(): ApplicableControlsNode | undefined;
	/**
	 * return the canvas and create one if none yet
	 *
	 *
	 */
	canvas(): HTMLCanvasElement;
	render(delta: number): void;
	setRenderObjectOverride(object?: Object3D | null): void;
	active(): boolean;
	activate(): void;
	deactivate(): void;
	protected _camerasController: ViewerCamerasController | undefined;
	camerasController(): ViewerCamerasController;
	protected _controlsController: ViewerControlsController<C>;
	controlsController(): ViewerControlsController<C>;
	protected _eventsController: ViewerEventsController | undefined;
	eventsController(): ViewerEventsController;
	protected _webGLController: ViewerWebGLController | undefined;
	webglController(): ViewerWebGLController;
	private _audioController;
	audioController(): ViewerAudioController;
	readonly raycastersController: ViewerRaycastersController;
	readonly performanceMonitor: ViewerPerformanceMonitor;
	domElement(): HTMLElementWithViewer<C> | undefined;
	scene(): PolyScene;
	/**
	 * return the camera the viewer was created with
	 *
	 *
	 */
	camera(): C;
	id(): string;
	/**
	 * disposes the viewer
	 *
	 *
	 */
	dispose(): void;
	resetContainerClass(): void;
	setContainerClassHovered(): void;
	markAsReady(): void;
	/**
	 * sets auto render state. If falls, the viewer will not render.
	 *
	 *
	 */
	setAutoRender(state?: boolean): void;
	autoRenderState(): boolean;
	/**
	 * This sets the viewer to detect if it is visible, and to pause/unpause itself when its visibility changes.
	 * This can be very useful to improve performance.
	 *
	 */
	updateAutoRenderOnIntersectionChange(_options: TypedViewerInterectionObserverChangeOptions): void;
	private _onBeforeTickCallbacksMap;
	private _onAfterTickCallbacksMap;
	protected _onBeforeTickCallbacks: Array<ViewerTickCallback>;
	protected _onAfterTickCallbacks: Array<ViewerTickCallback>;
	private _onBeforeRenderCallbacksMap;
	private _onAfterRenderCallbacksMap;
	protected _onBeforeRenderCallbacks: Array<ViewerRenderCallback>;
	protected _onAfterRenderCallbacks: Array<ViewerRenderCallback>;
	/**
	 * registers a BeforeTick callback. BeforeTick callbacks are run before updating the frame (and therefore before any time dependent node has changed)
	 *
	 */
	registerOnBeforeTick(callbackName: string, callback: ViewerTickCallback, options?: BaseViewerCallbackOptions): void;
	/**
	 * unregisters BeforeTick callback
	 *
	 */
	unRegisterOnBeforeTick(callbackName: string): void;
	/**
	 * Returns the list registered BeforeTick callback names
	 *
	 */
	registeredBeforeTickCallbacks(): Map<any, any>;
	/**
	 * registers AfterTick callback. AfterTick callbacks are run after updating the frame (and therefore after any time dependent node has changed)
	 *
	 */
	registerOnAfterTick(callbackName: string, callback: ViewerTickCallback, options?: BaseViewerCallbackOptions): void;
	/**
	 * unregisters AfterTick callback
	 *
	 */
	unRegisterOnAfterTick(callbackName: string): void;
	/**
	 * Returns the list registered AfterTick callback names
	 *
	 */
	registeredAfterTickCallbacks(): Map<any, any>;
	/**
	 * registers a BeforeRender callback. BeforeRender callbacks are run before the frame is rendered
	 *
	 */
	registerOnBeforeRender(
		callbackName: string,
		callback: ViewerRenderCallback,
		options?: BaseViewerCallbackOptions
	): void;
	/**
	 * unregisters BeforeRender callback
	 *
	 */
	unRegisterOnBeforeRender(callbackName: string): void;
	/**
	 * Returns the list registered BeforeRender callback names
	 *
	 */
	registeredBeforeRenderCallbacks(): Map<any, any>;
	/**
	 * registers a AfterRender callback. AfterRender callbacks are run after the frame is rendered
	 *
	 */ registerOnAfterRender(
		callbackName: string,
		callback: ViewerRenderCallback,
		options?: BaseViewerCallbackOptions
	): void;
	/**
	 * unregisters AfterRender callback
	 *
	 */
	unRegisterOnAfterRender(callbackName: string): void;
	/**
	 * Returns the list AfterRender BeforeRender callback names
	 *
	 */
	registeredAfterRenderCallbacks(): Map<any, any>;
	private _registerCallback;
	private _unregisterCallback;
	private _updateCallbacks;
	private _runTickCallbacks;
	private _runRenderCallbacks;
	protected _runOnBeforeTickCallbacks(delta: number): void;
	protected _runOnAfterTickCallbacks(delta: number): void;
	protected _runOnBeforeRenderCallbacks(delta: number, renderer: AbstractRenderer): void;
	protected _runOnAfterRenderCallbacks(delta: number, renderer: AbstractRenderer): void;
}
export declare type BaseViewerType = TypedViewer<Camera>;
export interface EventContextValue {
	node?: BaseNodeType;
	intersect?: Intersection;
}
export interface EventContext<E extends Event> {
	viewer?: Readonly<BaseViewerType>;
	event?: Readonly<E>;
	emitter?: CoreEventEmitter;
	value?: EventContextValue;
}
declare abstract class BaseSceneEventsController<E extends Event, T extends BaseInputEventNodeType> {
	protected dispatcher: SceneEventsDispatcher;
	private _activeEventDatas;
	private _activeEventDataTypes;
	protected _eventNodes: Set<T>;
	protected _requireCanvasEventListeners: boolean;
	protected _actorEvaluators: Set<ActorEvaluatorGenerator>;
	protected _actorEvaluatorsByEventNames: Map<string, Map<CoreEventEmitter, Set<ActorEvaluatorGenerator>>>;
	constructor(dispatcher: SceneEventsDispatcher);
	registerEventNode(node: T): void;
	unregisterEventNode(node: T): void;
	registerEvaluatorGenerator(evaluator: ActorEvaluatorGenerator): void;
	unregisterEvaluatorGenerator(evaluator: ActorEvaluatorGenerator): void;
	private _updateActorEvaluatorCache;
	abstract type(): string;
	abstract acceptedEventTypes(): Set<string>;
	processEvent(eventContext: EventContext<E>): void;
	updateViewerEventListeners(): void;
	activeEventDatas(): EventData[];
	private _updateActiveEventTypes;
}
export declare type BaseSceneEventsControllerType = BaseSceneEventsController<Event, BaseInputEventNodeType>;
export declare type DispatchHook = (event_context: EventContext<Event>) => void;
declare class TypedEventNode<K extends NodeParamsConfig> extends TypedNode<NodeContext.EVENT, K> {
	static context(): NodeContext;
	initializeBaseNode(): void;
	private _cookWithoutInputsBound;
	_cookWithoutInputs(): void;
	cook(): void;
	processEventViaConnectionPoint(eventContext: EventContext<Event>, connectionPoint: BaseEventConnectionPoint): void;
	processEvent(event_context: EventContext<Event>): void;
	protected dispatchEventToOutput(output_name: string, event_context: EventContext<Event>): Promise<void>;
	private _on_dispatch_hooks_by_output_name;
	/**
	 * onDispatch is called when an output triggers an event.
	 *
	 * Here is an example usage to listen to events:
	 *
	 * ``` ts
	 *let _currentState = false;
	 *function setHit( newState ){
	 *  if( _currentState != newState ){
	 *    if( newState ){
	 *      playSound();
	 *    }
	 *    _currentState = newState;
	 *  }
	 *}
	 *
	 *const raycastNode = scene.node('<path to the node>');
	 *raycastNode.onDispatch('hit', ()=>setHit(true) );
	 *raycastNode.onDispatch('miss', ()=>setHit(false) );
	 * ```
	 *
	 * Alternatively, you can also have the following arguments from the callback
	 *
	 * - viewer: the [viewer](https://polygonjs.com/docs/api/TypedViewer) displaying the scene.
	 * - event: the mouse/pointer/keyboard event that originally triggered the event
	 * - emitter: the domElement the event was triggered from (either the canvas or the document)
	 * - value: an optional value linked to the event.
	 *
	 * ``` ts
	 *raycastNode.onDispatch('hit',(eventContext)=>{
	 *  const {viewer, event, emitter, value} = eventContext;
	 *});
	 * ```
	 *
	 */
	onDispatch(outputName: string, callback: DispatchHook): void;
	private run_on_dispatch_hook;
}
export declare type BaseEventNodeType = TypedEventNode<any>;
declare enum NodeContext {
	ACTOR = 'actor',
	ANIM = 'anim',
	AUDIO = 'audio',
	COP = 'cop',
	EVENT = 'event',
	GL = 'gl',
	JS = 'js',
	MANAGER = 'manager',
	MAT = 'mat',
	OBJ = 'obj',
	POST = 'post',
	ROP = 'rop',
	SOP = 'sop',
}
declare enum NetworkNodeType {
	ACTOR = 'actorsNetwork',
	ANIM = 'animationsNetwork',
	AUDIO = 'audioNetwork',
	COP = 'copNetwork',
	CSG = 'csgNetwork',
	EVENT = 'eventsNetwork',
	MAT = 'materialsNetwork',
	POST = 'postProcessNetwork',
	ROP = 'renderersNetwork',
	SOLVER = 'solver',
	SUBNET = 'subnet',
	DECOMPOSE = 'decompose',
}
declare enum NetworkChildNodeType {
	INPUT = 'subnetInput',
	OUTPUT = 'subnetOutput',
}
declare enum CameraNodeType {
	MAPBOX = 'mapboxCamera',
	ORTHOGRAPHIC = 'orthographicCamera',
	PERSPECTIVE = 'perspectiveCamera',
}
declare enum CameraSopNodeType {
	CONTROLS = 'cameraControls',
	CSS_RENDERER = 'cameraCSSRenderer',
	FRAME_MODE = 'cameraFrameMode',
	POST_PROCESS = 'cameraPostProcess',
	RENDER_SCENE = 'cameraRenderScene',
	RENDERER = 'cameraRenderer',
	WEBXR_AR = 'cameraWebXRAR',
	WEBXR_VR = 'cameraWebXRVR',
	WEBXR_AR_MARKER_TRACKING = 'cameraWebXRARMarkerTracking',
}
declare enum CameraControlsNodeType {
	MAP = 'cameraMapControls',
	ORBIT = 'cameraOrbitControls',
	FIRST_PERSON = 'firstPersonControls',
	PLAYER = 'playerControls',
	MOBILE_JOYSTICK = 'mobileJoystickControls',
}
declare enum AudioNodeAnalyserType {
	FFT = 'FFT',
	METER = 'meter',
	WAVEFORM = 'waveform',
}
export declare type NodeTypeMapGeneric = {
	[key in NodeContext]: TypedNode<key, any>;
};
export interface BaseNodeByContextMap extends NodeTypeMapGeneric {
	[NodeContext.ANIM]: BaseAnimNodeType;
	[NodeContext.AUDIO]: BaseAudioNodeType;
	[NodeContext.COP]: BaseCopNodeType;
	[NodeContext.EVENT]: BaseEventNodeType;
	[NodeContext.GL]: BaseGlNodeType;
	[NodeContext.JS]: BaseJsNodeType;
	[NodeContext.MANAGER]: BaseManagerNodeType;
	[NodeContext.MAT]: BaseMatNodeType;
	[NodeContext.OBJ]: BaseObjNodeType;
	[NodeContext.POST]: BasePostProcessNodeType;
	[NodeContext.SOP]: BaseSopNodeType;
	[NodeContext.ROP]: BaseRopNodeType;
}
declare class NodeTimeDependentState<NC extends NodeContext> extends NodeBaseState<NC> {
	active(): boolean;
	paramsTimeDependent(): boolean;
	inputsTimeDependent(): boolean;
	forceTimeDependent(): void;
	unforceTimeDependent(): void;
}
declare class NodeStatesController<NC extends NodeContext> {
	protected node: BaseNodeType;
	timeDependent: NodeTimeDependentState<any>;
	error: NodeErrorState<any>;
	constructor(node: BaseNodeType);
}
declare class HierarchyParentController {
	protected node: BaseNodeType;
	private _parent;
	private _on_set_parent_hooks;
	constructor(node: BaseNodeType);
	parent(): BaseNodeType | null;
	setParent(parent: BaseNodeType | null): void;
	firstAncestorWithContext<N extends NodeContext>(context: N): BaseNodeByContextMap[N] | null;
	findParent(callback: (parent: BaseNodeType) => boolean): BaseNodeType | null;
	path(relativeToParent?: BaseNodeType): string;
	onSetParent(): void;
	findNode(path: string | null): BaseNodeType | null;
}
export declare type NodeLifeCycleControllerCallback = () => void;
export declare type NodeLifeCycleControllerCallbackWithChildNode = (childNode: BaseNodeType) => void;
declare class NodeLifeCycleController {
	protected node: BaseNodeType;
	protected _creationCompleted: boolean;
	protected _onChildAddCallbacks: NodeLifeCycleControllerCallbackWithChildNode[] | undefined;
	private _onChildRemoveCallbacks;
	private _onAfterCreatedCallbacks;
	private _onAfterAddedCallbacks;
	private _onBeforeDeletedCallbacks;
	private _onAfterDeletedCallbacks;
	constructor(node: BaseNodeType);
	dispose(): void;
	setCreationCompleted(): void;
	creationCompleted(): boolean;
	onChildAdd(callback: NodeLifeCycleControllerCallbackWithChildNode): void;
	runOnChildAddCallbacks(node: BaseNodeType): void;
	onChildRemove(callback: NodeLifeCycleControllerCallbackWithChildNode): void;
	runOnChildRemoveCallbacks(node: BaseNodeType): void;
	onAfterCreated(callback: NodeLifeCycleControllerCallback): void;
	runOnAfterCreatedCallbacks(): void;
	onAfterAdded(callback: NodeLifeCycleControllerCallback): void;
	runOnAfterAddedCallbacks(): void;
	onBeforeDeleted(callback: NodeLifeCycleControllerCallback): void;
	runOnBeforeDeleteCallbacks(): void;
	onAfterDeleted(callback: NodeLifeCycleControllerCallback): void;
	runOnDeleteCallbacks(): void;
	protected _runCallbacks(hooks: NodeLifeCycleControllerCallback[] | undefined): void;
	protected _runCallbacksWithChildNode(
		hooks: NodeLifeCycleControllerCallbackWithChildNode[] | undefined,
		childNode: BaseNodeType
	): void;
}
declare class TypedContainerController<NC extends NodeContext> {
	protected node: TypedNode<NC, any>;
	private _callbacks;
	private _callbacksTmp;
	protected _container: ContainerMap[NC];
	constructor(node: TypedNode<NC, any>);
	container(): ContainerMap[NC];
	private _createContainer;
	private _createContainerWithContent;
	containerUnlessBypassed(): ContainerMap[NC] | undefined;
	compute(): Promise<ContainerMap[NC]>;
	requestInputContainer(inputIndex: number): Promise<ContainerMap[NC] | null>;
	notifyRequesters(container?: ContainerMap[NC]): void;
}
export declare type OnCookCompleteHook = () => void;
declare class NodeCookController<NC extends NodeContext> {
	private node;
	private _corePerformance;
	private _cooking;
	private _cookingDirtyTimestamp;
	private _performanceController;
	constructor(node: BaseNodeType);
	performanceRecordStarted(): boolean;
	dispose(): void;
	private _inputsEvaluationRequired;
	disallowInputsEvaluation(): void;
	isCooking(): boolean;
	private _startCookIfNoErrors;
	cookMain(): Promise<void>;
	private _onError;
	cookMainWithoutInputs(): Promise<void>;
	endCook(): void;
	private _initCookingState;
	private _terminateCookProcess;
	private _evaluateInputs;
	private _evaluateParams;
	cooksCount(): number;
	cookTime(): number;
	private _finalizeCookPerformance;
	private _onCookCompleteHookNames;
	private _onCookCompleteHooks;
	registerOnCookEnd(callbackName: string, callback: OnCookCompleteHook): void;
	private _clearHooks;
	deregisterOnCookEnd(callbackName: string): void;
	private _runOnCookCompleteHooks;
	onCookEndCallbackNames(): string[] | undefined;
}
export declare type NameControllerCallback = () => void;
declare class NameController {
	protected node: BaseNodeType;
	private _graphNode;
	private _onSetNameHooks;
	private _onSetFullPathHooks;
	constructor(node: BaseNodeType);
	dispose(): void;
	graphNode(): CoreGraphNode;
	static baseName(node: BaseNodeType | typeof BaseNodeClass): string;
	requestNameToParent(newName: string): void;
	setName(newName: string): void;
	updateNameFromParent(new_name: string): void;
	add_post_set_name_hook(hook: NameControllerCallback): void;
	add_post_set_fullPath_hook(hook: NameControllerCallback): void;
	private _postSetName;
	runPostSetFullPathHooks(): void;
}
export interface NodeSerializerData {
	name: string;
	type: string;
	graph_node_id: CoreGraphNodeId;
	is_dirty: boolean;
	ui_data_json: NodeUIDataJson;
	error_message: string | undefined;
	children: CoreGraphNodeId[];
	maxInputsCount: number;
	inputs: Array<CoreGraphNodeId | undefined>;
	input_connection_output_indices: Array<number | undefined> | undefined;
	named_input_connection_points: BaseConnectionPointData[];
	named_output_connection_points: BaseConnectionPointData[];
	param_ids: CoreGraphNodeId[];
	override_cloned_state_allowed: boolean;
	inputs_clone_required_states: boolean | boolean[];
	flags?: {
		display?: boolean;
		bypass?: boolean;
		optimize?: boolean;
	};
	selection?: CoreGraphNodeId[];
	polyNode?: {
		locked: boolean;
	};
}
declare class NodeSerializer {
	private node;
	constructor(node: BaseNodeType);
	dispose(): void;
	toJSON(include_param_components?: boolean): NodeSerializerData;
	childrenIds(): number[];
	maxInputsCount(): number;
	inputIds(): (CoreGraphNodeId | undefined)[];
	inputConnectionOutputIndices(): (number | undefined)[] | undefined;
	namedInputConnectionPoints(): any[];
	namedOutputConnectionPoints(): any[];
	to_json_params_from_names(param_names: string[], include_components?: boolean): number[];
	to_json_params(include_components?: boolean): number[];
}
export declare type OnSceneLoadHook = () => void;
export declare type PostCreateParamsHook = () => void;
export interface ParamOptionToAdd<T extends ParamType> {
	name: string;
	type: T;
	initValue: ParamInitValueSerializedTypeMap[T];
	rawInput: ParamInitValueSerializedTypeMap[T];
	options?: ParamOptions;
}
export interface ParamsUpdateOptions {
	namesToDelete?: string[];
	toAdd?: ParamOptionToAdd<ParamType>[];
}
declare class ParamsController {
	readonly node: BaseNodeType;
	private _param_create_mode;
	private _params_created;
	private _paramsByName;
	private _paramsList;
	private _paramNames;
	private _non_spare_params;
	private _spare_params;
	private _non_spare_param_names;
	private _spare_param_names;
	private _params_node;
	private _params_added_since_last_params_eval;
	private _post_create_params_hook_names;
	private _post_create_params_hooks;
	private _on_scene_load_hooks;
	private _on_scene_load_hook_names;
	constructor(node: BaseNodeType);
	dispose(): void;
	private initDependencyNode;
	init(): void;
	private _postCreateParams;
	postCreateSpareParams(): void;
	updateParams(options: ParamsUpdateOptions): void;
	private _initFromParamsConfig;
	private _initParamAccessors;
	private _removeUnneededAccessors;
	get params_node(): CoreGraphNode | undefined;
	get all(): BaseParamType[];
	get non_spare(): BaseParamType[];
	get spare(): BaseParamType[];
	get names(): string[];
	get non_spare_names(): string[];
	get spare_names(): string[];
	private set_with_type;
	set_float(paramName: string, value: ParamInitValuesTypeMap[ParamType.FLOAT]): void;
	set_vector3(paramName: string, value: ParamInitValuesTypeMap[ParamType.VECTOR3]): void;
	has_param(paramName: string): boolean;
	has(paramName: string): boolean;
	get(paramName: string): BaseParamType | null;
	paramWithType<T extends ParamType>(param_name: string, type: T): ParamConstructorMap[T] | undefined;
	getFloat(param_name: string): FloatParam;
	value(
		paramName: string
	):
		| string
		| number
		| boolean
		| Color
		| TypedParamPathParamValue
		| TypedNodePathParamValue
		| RampValue
		| Vector2
		| Vector3
		| Vector4
		| null
		| undefined;
	valueWithType<T extends ParamType>(paramName: string, type: T): ParamValuesTypeMap[T];
	boolean(paramName: string): boolean;
	float(paramName: string): number;
	integer(paramName: string): number;
	string(paramName: string): string;
	vector2(paramName: string): Vector2;
	vector3(paramName: string): Vector3;
	color(paramName: string): Color;
	param(paramName: string): BaseParamType | null;
	private _deleteParam;
	addParam<T extends ParamType>(
		type: T,
		paramName: string,
		defaultValue: ParamInitValuesTypeMap[T],
		options?: ParamOptions,
		initData?: ParamInitData<T>
	): ParamConstructorMap[T] | undefined;
	private _updateCaches;
	_evalParam(param: BaseParamType): Promise<void>;
	private _promises;
	evalParams(params: BaseParamType[]): Promise<void>;
	paramsEvalRequired(): boolean;
	evalAll(): Promise<void>;
	onParamsCreated(hook_name: string, hook: PostCreateParamsHook): void;
	addOnSceneLoadHook(param_name: string, method: OnSceneLoadHook): void;
	private _runPostCreateParamsHooks;
	runOnSceneLoadHooks(): void;
}
export interface NamedInputData {
	index?: number;
	inputName?: string;
	node: string;
	output: string;
}
export declare type IndexedInputData = string | null;
export declare type InputData = NamedInputData | IndexedInputData;
export interface FlagsData {
	bypass?: boolean;
	display?: boolean;
	optimize?: boolean;
}
export interface IoConnectionPointsData {
	in?: BaseConnectionPointData[];
	out?: BaseConnectionPointData[];
}
export interface NodeJsonExporterData {
	type: string;
	nodes?: PolyDictionary<NodeJsonExporterData>;
	children_context?: NodeContext;
	params?: PolyDictionary<ParamJsonExporterData<ParamType>>;
	maxInputsCount?: number;
	inputs?: InputData[];
	connection_points?: IoConnectionPointsData;
	flags?: FlagsData;
	cloned_state_overriden?: boolean;
	persisted_config?: PersistedConfigWithShaders;
	polyNode?: {
		locked: boolean;
	};
}
export interface NodeJsonExporterUIData {
	pos?: Number2;
	comment?: string;
	selection?: string[];
	nodes?: PolyDictionary<NodeJsonExporterUIData>;
}
export declare type NodeJSONShadersData = PolyDictionary<PolyDictionary<string>>;
export declare type NodeJSONFunctionBodiesData = PolyDictionary<string>;
export interface PolyNodeSimpleInputsData {
	min: number;
	max: number;
	names?: string[];
}
export interface PolyNodeTypedInputData {
	type: string;
	name: string;
}
export interface PolyNodeTypedInputsData {
	types: PolyNodeTypedInputData[];
}
export interface PolyNodesInputsData {
	simple?: PolyNodeSimpleInputsData;
	typed?: PolyNodeTypedInputsData;
}
export interface PolyNodeMetadata {
	version: {
		marketplace?: number;
		editor?: string;
		polygonjs: string;
	};
	createdAt: number;
}
export interface PolyNodeDefinition {
	metadata: PolyNodeMetadata;
	nodeContext: NodeContext;
	inputs?: PolyNodesInputsData;
	params?: ParamOptionToAdd<ParamType>[];
	nodes?: PolyDictionary<NodeJsonExporterData>;
	ui?: PolyDictionary<NodeJsonExporterUIData>;
}
declare const BasePolySopNode: typeof SubnetSopNodeLike;
declare const BasePolyObjNode: typeof TypedObjNode;
export declare type PolyNodeClassByContextMapGeneric = {
	[key in NodeContext]: any;
};
export interface PolyNodeClassByContext extends PolyNodeClassByContextMapGeneric {
	[NodeContext.ACTOR]: undefined;
	[NodeContext.ANIM]: undefined;
	[NodeContext.AUDIO]: undefined;
	[NodeContext.COP]: undefined;
	[NodeContext.EVENT]: undefined;
	[NodeContext.GL]: undefined;
	[NodeContext.JS]: undefined;
	[NodeContext.MANAGER]: undefined;
	[NodeContext.MAT]: undefined;
	[NodeContext.OBJ]: typeof BasePolyObjNode;
	[NodeContext.ROP]: undefined;
	[NodeContext.SOP]: typeof BasePolySopNode;
}
export interface PolyNodeDataRegister<NC extends NodeContext> {
	node_context: NC;
	node_type: string;
	data: PolyNodeDefinition;
}
export declare class PolyNodeController {
	private node;
	private _definition;
	private static _definitionRegister;
	private _locked;
	constructor(node: BaseNodeType, _definition: PolyNodeDefinition);
	initializeNode(): void;
	locked(): boolean;
	setLockedState(state: boolean): void;
	private _initInputs;
	static setupParamsConfig(paramsConfig: NodeParamsConfig, data: PolyNodeDefinition): void;
	createChildNodesFromDefinition(): void;
	static inputsData(node: BaseNodeType): PolyNodesInputsData;
	static polyNodeData(node: BaseNodeType, inputsData?: PolyNodesInputsData): Promise<PolyNodeDefinition>;
	static _createNodeClass<NC extends NodeContext>(
		nodeContext: NC,
		nodeType: string,
		data: PolyNodeDefinition
	): PolyNodeClassByContext[NC] | undefined;
	static createNodeClassAndRegister<NC extends NodeContext>(dataRegister: PolyNodeDataRegister<NC>): void;
	static definition<NC extends NodeContext>(context: NC, type: string): PolyNodeDefinition | undefined;
	static register(): Map<NodeContext, Map<string, PolyNodeDefinition>>;
}
export interface NodeDeletedEmitData {
	parent_id: CoreGraphNodeId;
}
export interface NodeCreatedEmitData {
	child_node_json: NodeSerializerData;
}
export declare type EmitDataByNodeEventMapGeneric = {
	[key in NodeEvent]: any;
};
export interface EmitDataByNodeEventMap extends EmitDataByNodeEventMapGeneric {
	[NodeEvent.CREATED]: NodeCreatedEmitData;
	[NodeEvent.DELETED]: NodeDeletedEmitData;
	[NodeEvent.ERROR_UPDATED]: undefined;
}
export interface IntegrationData {
	name: string;
	data: PolyDictionary<string>;
}
export interface BaseNodeEvent extends BaseEvent {
	target?: BaseNodeType;
}
export declare type NodeEventListener = EventListener<BaseNodeEvent, string, EventDispatcher<BaseNodeEvent>>;
declare class TypedNode<NC extends NodeContext, K extends NodeParamsConfig> extends CoreGraphNode {
	createOptions?: NodeCreateOptions | undefined;
	containerController: TypedContainerController<NC>;
	private _parent_controller;
	private _uiData;
	private _states;
	private _lifecycle;
	private _serializer;
	private _cookController;
	readonly flags: FlagsController | undefined;
	readonly displayNodeController: DisplayNodeController | undefined;
	readonly persisted_config: BasePersistedConfig | undefined;
	private _paramsController;
	readonly paramsConfig: K | undefined;
	readonly pv: ParamsValueAccessorType<K>;
	readonly p: ParamsAccessorType<K>;
	copy_param_values(node: TypedNode<NC, K>): void;
	dataType(): string;
	private _nameController;
	get parentController(): HierarchyParentController;
	static displayedInputNames(): string[];
	displayedInputNames(): string[];
	private _childrenController;
	protected _childrenControllerContext: NodeContext | undefined;
	childrenControllerContext(): NodeContext | undefined;
	private _create_childrenController;
	get childrenController(): HierarchyChildrenController | undefined;
	childrenAllowed(): boolean;
	sceneReadonly(): boolean;
	get uiData(): UIData;
	get states(): NodeStatesController<NC>;
	get lifecycle(): NodeLifeCycleController;
	get serializer(): NodeSerializer;
	get cookController(): NodeCookController<NC>;
	protected _io: IOController<NC> | undefined;
	get io(): IOController<NC>;
	get nameController(): NameController;
	/**
	 * sets the name of a node. Note that if a sibling node already has that name, it will be updated to be unique.
	 *
	 */
	setName(name: string): void;
	_setCoreName(name: string): void;
	get params(): ParamsController;
	constructor(scene: PolyScene, nodeName?: string, createOptions?: NodeCreateOptions | undefined);
	private _initialized;
	initializeBaseAndNode(): void;
	protected initializeBaseNode(): void;
	protected initializeNode(): void;
	static type(): string;
	static onRegister: OnNodeRegisterCallback | undefined;
	/**
	 * returns the type of the node.
	 *
	 */
	type(): string;
	static context(): NodeContext;
	/**
	 * returns the context.
	 *
	 */
	context(): NodeContext;
	static require_webgl2(): boolean;
	require_webgl2(): boolean;
	setParent(parent: BaseNodeType | null): void;
	/**
	 * returns the parent.
	 *
	 */
	parent(): BaseNodeType | null;
	insideALockedParent(): boolean;
	lockedOrInsideALockedParent(): boolean;
	selfOrLockedParent(): BaseNodeType | null;
	lockedParent(): BaseNodeType | null;
	firstAncestorWithContext<N extends NodeContext>(context: N): BaseNodeByContextMap[N] | null;
	root(): RootManagerNode;
	/**
	 * returns the path.
	 *
	 */
	path(relative_to_parent?: BaseNodeType): string;
	createParams(): void;
	addParam<T extends ParamType>(
		type: T,
		name: string,
		default_value: ParamInitValuesTypeMap[T],
		options?: ParamOptions
	): ParamConstructorMap[T] | undefined;
	paramDefaultValue(name: string): ParamInitValueSerialized;
	cook(input_contents: any[]): any;
	/**
	 * registers a callback that will be run every time the node finishes cooking.
	 *
	 */
	onCookEnd(callbackName: string, callback: OnCookCompleteHook): void;
	/**
	 * returns a promise that will be resolved when the node finishes cooking.
	 *
	 */
	compute(): Promise<ContainerMap[NC]>;
	_setContainer(content: ContainableMap[NC]): void;
	/**
	 * create a node.
	 *
	 */
	createNode(nodeClass: any, options?: NodeCreateOptions): BaseNodeType | undefined;
	createOperationContainer(
		type: string,
		operation_container_name: string,
		options?: NodeCreateOptions
	): BaseOperationContainer<any> | undefined;
	/**
	 * removes a child node
	 *
	 */
	removeNode(node: BaseNodeType): void;
	dispose(): void;
	/**
	 * returns the list of children
	 *
	 */
	children(): BaseNodeType[];
	/**
	 * returns a child node
	 *
	 */
	node(path: string): BaseNodeType | null;
	/**
	 * returns a sibling node
	 *
	 */
	nodeSibling(name: string): BaseNodeByContextMap[NC] | null;
	/**
	 * returns the children matching the type
	 *
	 */
	nodesByType(type: string): BaseNodeType[];
	/**
	 * sets a node as input
	 *
	 */
	setInput(
		inputIndexOrName: number | string,
		node: BaseNodeByContextMap[NC] | null,
		outputIndexOrName?: number | string,
		options?: SetInputsOptions
	): void;
	emit(event_name: NodeEvent.CREATED, data: EmitDataByNodeEventMap[NodeEvent.CREATED]): void;
	emit(event_name: NodeEvent.DELETED, data: EmitDataByNodeEventMap[NodeEvent.DELETED]): void;
	emit(event_name: NodeEvent.NAME_UPDATED): void;
	emit(event_name: NodeEvent.OVERRIDE_CLONABLE_STATE_UPDATE): void;
	emit(event_name: NodeEvent.NAMED_INPUTS_UPDATED): void;
	emit(event_name: NodeEvent.NAMED_OUTPUTS_UPDATED): void;
	emit(event_name: NodeEvent.INPUTS_UPDATED): void;
	emit(event_name: NodeEvent.PARAMS_UPDATED): void;
	emit(event_name: NodeEvent.UI_DATA_POSITION_UPDATED): void;
	emit(event_name: NodeEvent.UI_DATA_COMMENT_UPDATED): void;
	emit(event_name: NodeEvent.ERROR_UPDATED): void;
	emit(event_name: NodeEvent.FLAG_BYPASS_UPDATED): void;
	emit(event_name: NodeEvent.FLAG_DISPLAY_UPDATED): void;
	emit(event_name: NodeEvent.FLAG_OPTIMIZE_UPDATED): void;
	emit(event_name: NodeEvent.SELECTION_UPDATED): void;
	emit(event_name: NodeEvent.POLY_NODE_LOCK_STATE_UPDATED): void;
	private __eventsDispatcher;
	private _eventsDispatcher;
	dispatchEvent(event: {type: string}): void;
	addEventListener(type: string, listener: NodeEventListener): void;
	removeEventListener(type: string, listener: NodeEventListener): void;
	toJSON(include_param_components?: boolean): NodeSerializerData;
	requiredModules(): ModuleName[] | void;
	usedAssembler(): AssemblerName | void;
	integrationData(): IntegrationData | void;
	readonly polyNodeController: PolyNodeController | undefined;
	processError(e: unknown): unknown;
}
export declare type BaseNodeType = TypedNode<any, any>;
declare class BaseNodeClass extends TypedNode<any, any> {}
declare class BaseNodeClassWithDisplayFlag extends TypedNode<any, any> {
	readonly flags: FlagsControllerD;
}
declare class BaseJsParentNode extends TypedNode<any, any> {
	createNode<S extends keyof JsNodeChildrenMap>(node_class: S, options?: NodeCreateOptions): JsNodeChildrenMap[S];
	createNode<K extends valueof<JsNodeChildrenMap>>(node_class: Constructor<K>, options?: NodeCreateOptions): K;
	children(): BaseJsNodeType[];
	nodesByType<K extends keyof JsNodeChildrenMap>(type: K): JsNodeChildrenMap[K][];
}
declare abstract class AssemblerControllerNode<A extends BaseJsShaderAssembler> extends BaseJsParentNode {
	abstract assemblerController(): JsAssemblerController<A> | undefined;
	abstract compile(): void;
}
export declare type BaseJsShaderAssemblerConstructor<A extends BaseJsShaderAssembler> = new (...args: any[]) => A;
declare class JsAssemblerController<A extends BaseJsShaderAssembler> {
	private node;
	protected _assembler: A;
	private _spareParamsController;
	private _globalsHandler;
	private _compileRequired;
	constructor(node: AssemblerControllerNode<A>, assembler_class: BaseJsShaderAssemblerConstructor<A>);
	setAssemblerGlobalsHandler(globalsHandler: GlobalsBaseController): void;
	get assembler(): A;
	globalsHandler(): GlobalsBaseController | undefined;
	add_output_inputs(output_child: OutputJsNode): void;
	add_globals_outputs(globals_node: GlobalsJsNode): void;
	allow_attribute_exports(): boolean;
	setCompilationRequired(newState?: boolean): void;
	setCompilationRequiredAndDirty(triggerNode?: BaseJsNodeType): void;
	compileRequired(): boolean;
	post_compile(): void;
	createSpareParameters(): void;
}
declare abstract class ActorBuilderNode extends AssemblerControllerNode<JsAssemblerActor> {
	abstract readonly compilationController: ActorCompilationController;
}
declare class ActorsManager {
	readonly scene: PolyScene;
	private _actorNodes;
	private _keyboardEventsController;
	private _manualTriggerController;
	private _pointerEventsController;
	constructor(scene: PolyScene);
	registerEvaluatorGenerator(evaluatorGenerator: ActorEvaluatorGenerator): void;
	unregisterEvaluatorGenerator(evaluatorGenerator: ActorEvaluatorGenerator): void;
	assignActorBuilder(object: Object3D, node: ActorBuilderNode): void;
	objectActorNodeIds(object: Object3D): number[] | undefined;
	get keyboardEventsController(): ActorKeyboardEventsController;
	get manualTriggerController(): ActorManualTriggersController;
	get pointerEventsController(): ActorPointerEventsController;
	tick(): void;
	runOnEventSceneReset(): void;
	runOnEventScenePlay(): void;
	runOnEventScenePause(): void;
	runOnEventPerformanceChange(): void;
	private _runOnEventTick;
	private _onEventTickBound;
	private _onEventTick;
	private _onEventTickTraverse;
	private _onEventSceneResetBound;
	private _onEventSceneReset;
	private _onEventSceneResetTraverse;
	private _onEventScenePlayBound;
	private _onEventScenePlay;
	private _onEventScenePlayTraverse;
	private _onEventScenePauseBound;
	private _onEventScenePause;
	private _onEventScenePauseTraverse;
	private _onEventPerformanceChangeBound;
	private _onEventPerformanceChange;
	private _onEventPerformanceChangeTraverse;
	triggerEventNodes(object: Object3D, methodName: EvaluatorMethodName): void;
	triggerEventNode(node: ActorBuilderNode, object: Object3D, methodName: EvaluatorMethodName): void;
	triggerEvaluatorGenerator(
		evaluatorGenerator: ActorEvaluatorGenerator,
		object: Object3D,
		methodName: EvaluatorMethodName
	): void;
}
export declare type OnCameraObjectsUpdated = () => void;
export interface MainCameraOptions {
	cameraMaskOverride?: string;
	findAnyCamera?: boolean;
	printCameraNotFoundError?: boolean;
}
declare class SceneCamerasController {
	private scene;
	private _coreGraphNode;
	constructor(scene: PolyScene);
	coreGraphNode(): CoreGraphNode;
	private _cameraObjectsRecentlyUpdated;
	updateFromChangeInObject(object: Object3D): void;
	cameraObjects(): Camera[];
	private _cameraObjects;
	cameraObjectsRecentlyUpdated(): Camera[];
	setMainCamera(camera: Camera): void;
	setMainCameraPath(path: string): void;
	mainCameraPath(): string;
	mainCamera(options?: MainCameraOptions): Promise<Camera | null>;
	private _findAnyCameraObject;
	createMainViewer(options?: CreateViewerOptions): Promise<TypedViewer<Camera> | undefined>;
	private _onCameraObjectsUpdated;
	onCameraObjectsUpdated(callback: OnCameraObjectsUpdated | undefined): void;
}
declare class Cooker {
	private _scene;
	constructor(_scene: PolyScene);
	block(): void;
	unblock(): void;
}
declare class SceneCookController {
	private _cooking_nodes_by_id;
	private _resolves;
	constructor();
	addNode(node: BaseNodeType): void;
	removeNode(node: BaseNodeType): void;
	cookingNodes(): BaseNodeType[];
	private flush;
	waitForCooksCompleted(): Promise<void>;
}
export interface NodePerformanceData {
	inputsTime: number;
	paramsTime: number;
	cookTime: number;
}
export interface PerformancePrintObject {
	fullPath: string;
	cooks_count: number;
	total_time: number;
	total_cook_time: number;
	cook_time_per_iteration: number;
	inputs_time_per_iteration: number;
	params_time_per_iteration: number;
}
declare class PerformanceNode {
	private _node;
	_cooks_count: number;
	_total_cook_time: number;
	_total_inputs_time: number;
	_total_params_time: number;
	constructor(_node: BaseNodeType);
	update_cook_data(performance_data: NodePerformanceData): void;
	total_time(): number;
	total_cook_time(): number;
	cook_time_per_iteration(): number;
	total_inputs_time(): number;
	inputs_time_per_iteration(): number;
	total_params_time2(): number;
	params_time_per_iteration2(): number;
	cooks_count(): number;
	print_object(): PerformancePrintObject;
}
declare class CorePerformance {
	private _started;
	_start_time: number | null;
	_previous_timestamp: number;
	_nodes_cook_data: PolyDictionary<PerformanceNode>;
	_durations_by_name: PolyDictionary<number>;
	_durations_count_by_name: PolyDictionary<number>;
	profile(name: string, method: (args?: any) => any): void;
	start(): void;
	stop(): void;
	reset(): void;
	started(): boolean;
	recordNodeCookData(node: BaseNodeType, performance_data: NodePerformanceData): void;
	record(name: string): number;
	print(): void;
	print_node_cook_data(): PerformancePrintObject[];
	print_recordings(): {
		duration: number;
		name: string;
		count: number;
		duration_per_iteration: number;
	}[];
}
declare class ExpressionsController {
	private _params_by_id;
	constructor();
	registerParam(param: BaseParamType): void;
	deregisterParam(param: BaseParamType): void;
	regenerateReferringExpressions(node: BaseNodeType): void;
}
declare class SceneLifeCycleController {
	private scene;
	constructor(scene: PolyScene);
	private _lifecycleOnAfterCreatedAllowed;
	onAfterCreatedCallbackAllowed(): boolean;
	onAfterCreatedPrevent(callback: () => void): void;
}
declare class LoadingController {
	private scene;
	constructor(scene: PolyScene);
	private _loadingState;
	private _autoUpdating;
	markAsLoading(): void;
	markAsLoaded(): void;
	dispatchReadyEvent(): void;
	private _triggerLoadedEvent;
	private _setLoadingState;
	isLoading(): boolean;
	loaded(): boolean;
	autoUpdating(): boolean;
	setAutoUpdate(newState: boolean): void;
}
declare class MissingReference {
	private param;
	readonly path: string;
	constructor(param: BaseParamType, path: string);
	absolutePath(): string | null;
	matchesPath(path: string): boolean;
	resolveMissingDependencies(): void;
}
declare class MissingReferencesController {
	private scene;
	private references;
	constructor(scene: PolyScene);
	register(param: BaseParamType, path: string): MissingReference;
	deregisterParam(param: BaseParamType): void;
	resolveMissingReferences(): void;
	private _isReferenceResolvable;
	checkForMissingNodeReferences(node: BaseNodeType): void;
	checkForMissingParamReferences(param: BaseParamType): void;
	private _checkForMissingReferencesForNode;
	private _checkForMissingReferencesForParam;
}
export declare type ActorNodeParamConstructorMapType = {
	[key in ParamType]: TypedParam<ParamType>;
};
export interface ActorNodeParamConstructorMap extends ActorNodeParamConstructorMapType {
	[ParamType.BOOLEAN]: BooleanParam;
	[ParamType.BUTTON]: ButtonParam;
	[ParamType.COLOR]: ColorParam;
	[ParamType.FLOAT]: FloatParam;
	[ParamType.FOLDER]: FolderParam;
	[ParamType.INTEGER]: IntegerParam;
	[ParamType.STRING]: StringParam;
	[ParamType.VECTOR2]: Vector2Param;
	[ParamType.VECTOR3]: Vector3Param;
	[ParamType.VECTOR4]: Vector4Param;
}
export interface ActorNodeTriggerContext {
	Object3D: Object3D;
}
declare class TypedActorNode<K extends NodeParamsConfig> extends TypedNode<NodeContext.ACTOR, K> {
	static context(): NodeContext;
	static displayedInputNames(): string[];
	private _paramsEditableStatesController;
	initializeBaseNode(): void;
	private _cookWithoutInputsBound;
	_cookWithoutInputs(): void;
	cook(): void;
	receiveTrigger(context: ActorNodeTriggerContext): void;
	runTrigger: (context: ActorNodeTriggerContext, outputIndex?: number) => void;
	private _triggerConnectionForEditor;
	private _triggerConnectionForPlayer;
	outputValue(
		context: ActorNodeTriggerContext,
		outputName?: string
	): ReturnValueTypeByActorConnectionPointType[ActorConnectionPointType] | undefined;
	protected _inputValueFromParam<T extends ParamType>(
		param: ActorNodeParamConstructorMap[T],
		context: ActorNodeTriggerContext
	): ParamValuesTypeMap[T];
	protected _inputValue<T extends ActorConnectionPointType>(
		inputNameOrIndex: string | number,
		context: ActorNodeTriggerContext
	): ReturnValueTypeByActorConnectionPointType[T] | undefined;
	static PARAM_CALLBACK_selfTrigger(node: BaseActorNodeType): void;
}
export declare type BaseActorNodeType = TypedActorNode<NodeParamsConfig>;
declare class ParamlessActorParamsConfig extends NodeParamsConfig {}
declare class ParamlessTypedActorNode extends TypedActorNode<ParamlessActorParamsConfig> {
	paramsConfig: ParamlessActorParamsConfig;
}
declare class BaseActorMathFunctionParamsConfig extends NodeParamsConfig {}
declare abstract class BaseMathFunctionActorNode extends TypedActorNode<BaseActorMathFunctionParamsConfig> {
	paramsConfig: BaseActorMathFunctionParamsConfig;
	initializeNode(): void;
	protected _expectedInputTypes(): ActorConnectionPointType[];
	protected _expectedOutputTypes(): ActorConnectionPointType[];
	protected _expectedInputName(index: number): string;
}
declare abstract class BaseMathFunctionArg1ActorNode extends BaseMathFunctionActorNode {
	protected _expectedInputName(index: number): string;
	protected _expectedInputTypes(): ActorConnectionPointType[];
}
declare abstract class BaseMathFunctionArg2ActorNode extends BaseMathFunctionActorNode {
	protected _expectedInputTypes(): ActorConnectionPointType[];
}
declare const AbsActorNode_base: typeof BaseMathFunctionActorNode;
declare class AbsActorNode extends AbsActorNode_base {
	protected _applyOperation<T extends number>(arg1: T): any;
}
declare const AcosActorNode_base: typeof BaseMathFunctionActorNode;
declare class AcosActorNode extends AcosActorNode_base {
	protected _applyOperation<T extends number>(arg1: T): any;
}
declare const AddActorNode_base: typeof BaseMathFunctionActorNode;
declare class AddActorNode extends AddActorNode_base {
	protected _applyOperation<T extends number>(arg1: T, arg2: T): any;
}
declare class BaseLogicOperationActorNode extends ParamlessTypedActorNode {
	initializeNode(): void;
	protected _expectedInputName(index: number): string;
	protected _expectedOutputName(): string;
	protected _expectedInputTypes(): ActorConnectionPointType[];
	protected _expectedOutputTypes(): ActorConnectionPointType[];
}
declare class AndActorNode extends BaseLogicOperationActorNode {
	static type(): string;
	outputValue(context: ActorNodeTriggerContext): boolean;
}
declare class AnyTriggerActorParamsConfig extends NodeParamsConfig {
	/** @param audio node */
	condition: ParamTemplate<ParamType.BOOLEAN>;
}
declare class AnyTriggerActorNode extends TypedActorNode<AnyTriggerActorParamsConfig> {
	readonly paramsConfig: AnyTriggerActorParamsConfig;
	static type(): string;
	initializeNode(): void;
	protected _expectedInputTypes(): any[];
	protected _expectedOutputTypes(): ActorConnectionPointType[];
	protected _expectedInputName(index: number): string;
	protected _expectedOutputName(index: number): string;
	receiveTrigger(context: ActorNodeTriggerContext): void;
}
declare const AsinActorNode_base: typeof BaseMathFunctionActorNode;
declare class AsinActorNode extends AsinActorNode_base {
	protected _applyOperation<T extends number>(arg1: T): any;
}
declare const AtanActorNode_base: typeof BaseMathFunctionActorNode;
declare class AtanActorNode extends AtanActorNode_base {
	protected _applyOperation<T extends number>(arg1: T): any;
}
declare class AnimationActionActorParamsConfig extends NodeParamsConfig {
	clipName: ParamTemplate<ParamType.STRING>;
	autoPlay: ParamTemplate<ParamType.BOOLEAN>;
}
declare class AnimationActionActorNode extends TypedActorNode<AnimationActionActorParamsConfig> {
	readonly paramsConfig: AnimationActionActorParamsConfig;
	static type(): string;
	static readonly OUTPUT_NAME = 'val';
	initializeNode(): void;
	private _actionByNameByMixer;
	outputValue(context: ActorNodeTriggerContext): AnimationAction | undefined;
}
declare abstract class AnimationActionBaseActorNode<K extends NodeParamsConfig> extends TypedActorNode<K> {
	protected _setAnimationActionWeight(action: AnimationAction, weight: number): void;
	protected _crossFade(from: AnimationAction, to: AnimationAction, duration: number, warp: boolean): void;
}
declare class AnimationActionCrossFadeActorParamsConfig extends NodeParamsConfig {
	/** @param manual trigger */
	trigger: ParamTemplate<ParamType.BUTTON>;
	/** @param fadeIn duration */
	duration: ParamTemplate<ParamType.FLOAT>;
	/** @param additional warping (gradually changes of the time scales) will be applied */
	warp: ParamTemplate<ParamType.BOOLEAN>;
	/** @param starts cross fade when the from action ends */
	startOnFromActionEnd: ParamTemplate<ParamType.BOOLEAN>;
}
declare class AnimationActionCrossFadeActorNode extends AnimationActionBaseActorNode<AnimationActionCrossFadeActorParamsConfig> {
	readonly paramsConfig: AnimationActionCrossFadeActorParamsConfig;
	static type(): string;
	initializeNode(): void;
	receiveTrigger(context: ActorNodeTriggerContext): void;
}
declare class AnimationActionFadeOutActorParamsConfig extends NodeParamsConfig {
	/** @param manual trigger */
	trigger: ParamTemplate<ParamType.BUTTON>;
	/** @param fadeIn duration */
	duration: ParamTemplate<ParamType.FLOAT>;
}
declare class AnimationActionFadeOutActorNode extends AnimationActionBaseActorNode<AnimationActionFadeOutActorParamsConfig> {
	readonly paramsConfig: AnimationActionFadeOutActorParamsConfig;
	static type(): string;
	initializeNode(): void;
	receiveTrigger(context: ActorNodeTriggerContext): void;
}
declare class AnimationActionFadeInActorParamsConfig extends NodeParamsConfig {
	/** @param manual trigger */
	trigger: ParamTemplate<ParamType.BUTTON>;
	/** @param fadeIn duration */
	duration: ParamTemplate<ParamType.FLOAT>;
	/** @param fade out other actions */
	fadeOutOtherActions: ParamTemplate<ParamType.BOOLEAN>;
	/** @param additional warping (gradually changes of the time scales) will be applied */
	warp: ParamTemplate<ParamType.BOOLEAN>;
	/** @param starts cross fade when the from action ends */
	startOnFromActionEnd: ParamTemplate<ParamType.BOOLEAN>;
}
declare class AnimationActionFadeInActorNode extends AnimationActionBaseActorNode<AnimationActionFadeInActorParamsConfig> {
	readonly paramsConfig: AnimationActionFadeInActorParamsConfig;
	static type(): string;
	initializeNode(): void;
}
declare class AnimationActionPlayActorParamsConfig extends NodeParamsConfig {
	/** @param manual trigger */
	trigger: ParamTemplate<ParamType.BUTTON>;
}
declare class AnimationActionPlayActorNode extends AnimationActionBaseActorNode<AnimationActionPlayActorParamsConfig> {
	readonly paramsConfig: AnimationActionPlayActorParamsConfig;
	static type(): string;
	initializeNode(): void;
	receiveTrigger(context: ActorNodeTriggerContext): void;
}
declare class AnimationActionStopActorParamsConfig extends NodeParamsConfig {
	/** @param manual trigger */
	trigger: ParamTemplate<ParamType.BUTTON>;
}
declare class AnimationActionStopActorNode extends AnimationActionBaseActorNode<AnimationActionStopActorParamsConfig> {
	readonly paramsConfig: AnimationActionStopActorParamsConfig;
	static type(): string;
	initializeNode(): void;
	receiveTrigger(context: ActorNodeTriggerContext): void;
}
declare class AnimationMixerActorParamsConfig extends NodeParamsConfig {}
declare class AnimationMixerActorNode extends TypedActorNode<AnimationMixerActorParamsConfig> {
	readonly paramsConfig: AnimationMixerActorParamsConfig;
	static type(): string;
	dispose(): void;
	static readonly OUTPUT_NAME = 'val';
	initializeNode(): void;
	private _mixerByObject;
	outputValue(context: ActorNodeTriggerContext): AnimationMixer;
	getAnimationMixer(object: Object3D): AnimationMixer | undefined;
}
declare class AnimationMixerUpdateActorParamsConfig extends NodeParamsConfig {}
declare class AnimationMixerUpdateActorNode extends TypedActorNode<AnimationMixerUpdateActorParamsConfig> {
	readonly paramsConfig: AnimationMixerUpdateActorParamsConfig;
	static type(): string;
	static readonly OUTPUT_NAME = 'val';
	static readonly INPUT_NAMES: {
		TRIGGER: string;
		ANIMATION_MIXER: ActorConnectionPointType;
	};
	initializeNode(): void;
	receiveTrigger(context: ActorNodeTriggerContext): void;
}
declare class BoolToIntActorParamsConfig extends NodeParamsConfig {
	bool: ParamTemplate<ParamType.BOOLEAN>;
}
declare class BoolToIntActorNode extends TypedActorNode<BoolToIntActorParamsConfig> {
	paramsConfig: BoolToIntActorParamsConfig;
	static type(): string;
	initializeNode(): void;
	outputValue(
		context: ActorNodeTriggerContext,
		outputName?: string
	): ReturnValueTypeByActorConnectionPointType[ActorConnectionPointType];
}
declare class Box3ActorParamsConfig extends NodeParamsConfig {
	/** @param position representing the lower bound of the box */
	min: ParamTemplate<ParamType.VECTOR3>;
	/** @param position representing the upper bound of the box */
	max: ParamTemplate<ParamType.VECTOR3>;
}
declare class Box3ActorNode extends TypedActorNode<Box3ActorParamsConfig> {
	paramsConfig: Box3ActorParamsConfig;
	static type(): string;
	initializeNode(): void;
	private _box3;
	private _box3Updated;
	outputValue(context: ActorNodeTriggerContext): Box3;
	static PARAM_CALLBACK_updateBox3(node: Box3ActorNode): void;
	private _updateBox3;
}
declare enum CacheActorNodeInputName {
	RESET = 'reset',
	IN = 'input',
}
declare class CacheActorParamsConfig extends NodeParamsConfig {}
declare class CacheActorNode extends TypedActorNode<CacheActorParamsConfig> {
	readonly paramsConfig: CacheActorParamsConfig;
	static type(): string;
	initializeNode(): void;
	protected _expectedInputTypes(): ActorConnectionPointType[];
	protected _expectedInputName(index: number): CacheActorNodeInputName;
	protected _expectedOutputTypes(): ActorConnectionPointType[];
	paramDefaultValue(name: string): number;
	receiveTrigger(context: ActorNodeTriggerContext): void;
	private _cache;
	outputValue(
		context: ActorNodeTriggerContext
	): ReturnValueTypeByActorConnectionPointType[ActorConnectionPointType] | undefined;
}
declare class CatmullRomCurve3GetPointActorParamsConfig extends NodeParamsConfig {
	t: ParamTemplate<ParamType.FLOAT>;
}
declare class CatmullRomCurve3GetPointActorNode extends TypedActorNode<CatmullRomCurve3GetPointActorParamsConfig> {
	paramsConfig: CatmullRomCurve3GetPointActorParamsConfig;
	static type(): string;
	initializeNode(): void;
	private _curvePos;
	outputValue(context: ActorNodeTriggerContext): Vector3;
}
declare const CeilActorNode_base: typeof BaseMathFunctionActorNode;
declare class CeilActorNode extends CeilActorNode_base {
	protected _applyOperation<T extends number>(arg1: T): any;
}
declare enum ClampActorNodeInputName {
	VALUE = 'value',
	MIN = 'min',
	MAX = 'max',
}
declare class ClampActorParamsConfig extends NodeParamsConfig {}
declare class ClampActorNode extends TypedActorNode<ClampActorParamsConfig> {
	readonly paramsConfig: ClampActorParamsConfig;
	static type(): string;
	initializeNode(): void;
	protected _expectedInputTypes(): ActorConnectionPointType[];
	protected _expectedInputName(index: number): ClampActorNodeInputName;
	protected _expectedOutputTypes(): ActorConnectionPointType[];
	paramDefaultValue(name: string): number;
	private _valTmp;
	outputValue(context: ActorNodeTriggerContext): number | Vector2 | Vector3 | Vector4;
}
declare class BaseCodeActorProcessor extends BaseCodeProcessor {
	protected node: CodeActorNode;
	constructor(node: CodeActorNode);
	get pv(): ParamsValueAccessorType<CodeActorParamsConfig>;
	get p(): ParamsAccessorType<CodeActorParamsConfig>;
	get io(): IOController<NodeContext.ACTOR>;
	protected _inputValueFromParam<T extends ParamType>(
		param: ActorNodeParamConstructorMap[T],
		context: ActorNodeTriggerContext
	): ParamValuesTypeMap[T];
	protected _inputValue<T extends ActorConnectionPointType>(
		inputNameOrIndex: string | number,
		context: ActorNodeTriggerContext
	): ReturnValueTypeByActorConnectionPointType[T] | undefined;
	runTrigger(context: ActorNodeTriggerContext, outputIndex?: number): void;
	initializeProcessor(): void;
	receiveTrigger(context: ActorNodeTriggerContext): void;
}
declare class CodeActorParamsConfig extends NodeParamsConfig {
	compile: ParamTemplate<ParamType.BUTTON>;
	codeTypescript: ParamTemplate<ParamType.STRING>;
	codeJavascript: ParamTemplate<ParamType.STRING>;
}
declare class CodeActorNode extends TypedActorNode<CodeActorParamsConfig> {
	paramsConfig: CodeActorParamsConfig;
	static BaseCodeActorProcessor: typeof BaseCodeActorProcessor;
	static type(): string;
	private _processor;
	initializeNode(): void;
	receiveTrigger(context: ActorNodeTriggerContext): void;
	private _compile;
	static PARAM_CALLBACK_compile(node: CodeActorNode): void;
	_processorHookInputValueFromParam<T extends ParamType>(
		param: ActorNodeParamConstructorMap[T],
		context: ActorNodeTriggerContext
	): ParamValuesTypeMap[T];
	_processorHookInputValue<T extends ActorConnectionPointType>(
		inputNameOrIndex: string | number,
		context: ActorNodeTriggerContext
	): ReturnValueTypeByActorConnectionPointType[T] | undefined;
}
declare class VecToParamsActorConfig extends NodeParamsConfig {}
declare class BaseVecToActorNode extends TypedActorNode<VecToParamsActorConfig> {
	paramsConfig: VecToParamsActorConfig;
}
declare enum ColorToVec3ActorNodeOutputName {
	VEC3 = 'Vector3',
}
declare class ColorToVec3ActorNode extends BaseVecToActorNode {
	static type(): string;
	static readonly INPUT_NAME_COLOR = 'color';
	initializeNode(): void;
	createParams(): void;
	private _defaultColor;
	outputValue(
		context: ActorNodeTriggerContext,
		outputName?: ColorToVec3ActorNodeOutputName
	): ReturnValueTypeByActorConnectionPointType[ActorConnectionPointType];
}
declare enum ActorCompareTestName {
	EQUAL = 'Equal',
	LESS_THAN = 'Less Than',
	GREATER_THAN = 'Greater Than',
	LESS_THAN_OR_EQUAL = 'Less Than Or Equal',
	GREATER_THAN_OR_EQUAL = 'Greater Than Or Equal',
	NOT_EQUAL = 'Not Equal',
}
declare enum ActorCompareTestOperation {
	EQUAL = '==',
	LESS_THAN = '<',
	GREATER_THAN = '>',
	LESS_THAN_OR_EQUAL = '<=',
	GREATER_THAN_OR_EQUAL = '>=',
	NOT_EQUAL = '!=',
}
declare class CompareActorParamsConfig extends NodeParamsConfig {
	test: ParamTemplate<ParamType.INTEGER>;
}
declare class CompareActorNode extends TypedActorNode<CompareActorParamsConfig> {
	paramsConfig: CompareActorParamsConfig;
	static type(): string;
	initializeNode(): void;
	setTestName(test: ActorCompareTestName): void;
	testName(): ActorCompareTestName;
	operator(): ActorCompareTestOperation;
	protected _expectedInputName(index: number): string;
	protected _expectedInputType(): ActorConnectionPointType[];
	outputValue(context: ActorNodeTriggerContext): boolean;
	private _testOperatorNumber;
	private _testOperatorString;
}
declare const ComplementActorNode_base: typeof BaseMathFunctionActorNode;
declare class ComplementActorNode extends ComplementActorNode_base {
	protected _applyOperation<T extends boolean | number | Vector2 | Vector3 | Vector4>(arg1: T): T;
}
declare class ConstantActorParamsConfig extends NodeParamsConfig {
	type: ParamTemplate<ParamType.INTEGER>;
	boolean: ParamTemplate<ParamType.BOOLEAN>;
	color: ParamTemplate<ParamType.COLOR>;
	float: ParamTemplate<ParamType.FLOAT>;
	integer: ParamTemplate<ParamType.INTEGER>;
	string: ParamTemplate<ParamType.STRING>;
	vector2: ParamTemplate<ParamType.VECTOR2>;
	vector3: ParamTemplate<ParamType.VECTOR3>;
	vector4: ParamTemplate<ParamType.VECTOR4>;
}
declare class ConstantActorNode extends TypedActorNode<ConstantActorParamsConfig> {
	readonly paramsConfig: ConstantActorParamsConfig;
	static type(): string;
	static readonly OUTPUT_NAME = 'val';
	initializeNode(): void;
	private _currentConnectionType;
	currentParam(): BaseParamType;
	setConstantType(type: ActorConnectionPointType): void;
	outputValue(
		context: ActorNodeTriggerContext
	): ReturnValueTypeByActorConnectionPointType[ActorConnectionPointType] | undefined;
}
declare class CookNodeActorParamsConfig extends NodeParamsConfig {
	/** @param  node to cook */
	node: ParamTemplate<ParamType.NODE_PATH>;
}
declare class CookNodeActorNode extends TypedActorNode<CookNodeActorParamsConfig> {
	readonly paramsConfig: CookNodeActorParamsConfig;
	static type(): string;
	initializeNode(): void;
	receiveTrigger(context: ActorNodeTriggerContext): Promise<void>;
}
declare const CosActorNode_base: typeof BaseMathFunctionActorNode;
declare class CosActorNode extends CosActorNode_base {
	protected _applyOperation<T extends number>(arg1: T): any;
}
declare enum CrossActorNodeInputName {
	V0 = 'v0',
	V1 = 'v1',
}
declare class CrossActorParamsConfig extends NodeParamsConfig {}
declare class CrossActorNode extends TypedActorNode<CrossActorParamsConfig> {
	readonly paramsConfig: CrossActorParamsConfig;
	static type(): string;
	initializeNode(): void;
	protected _expectedInputTypes(): ActorConnectionPointType[];
	protected _expectedInputName(index: number): CrossActorNodeInputName;
	protected _expectedOutputTypes(): ActorConnectionPointType[];
	paramDefaultValue(name: string): Number3;
	outputValue(context: ActorNodeTriggerContext): number | Vector3;
}
declare enum ActorType {
	CURSOR = 'cursor',
	ON_CHILD_ATTRIBUTE_UPDATE = 'onChildAttributeUpdate',
	ON_KEYDOWN = 'onKeydown',
	ON_KEYPRESS = 'onKeypress',
	ON_KEYUP = 'onKeyup',
	ON_MAPBOX_CAMERA_MOVE = 'onMapboxCameraMove',
	ON_MAPBOX_CAMERA_MOVE_START = 'onMapboxCameraMoveStart',
	ON_MAPBOX_CAMERA_MOVE_END = 'onMapboxCameraMoveEnd',
	ON_PLAYER_EVENT = 'onPlayerEvent',
	ON_SCENE_RESET = 'onSceneReset',
	ON_SCENE_PLAY_STATE = 'onScenePlayState',
	ON_TICK = 'onTick',
	ON_OBJECT_ATTRIBUTE_UPDATE = 'onObjectAttributeUpdate',
	ON_OBJECT_CLICK = 'onObjectClick',
	ON_OBJECT_DISPATCH_EVENT = 'onObjectDispatchEvent',
	ON_OBJECT_HOVER = 'onObjectHover',
	ON_OBJECT_POINTERDOWN = 'onObjectPointerdown',
	ON_OBJECT_POINTERUP = 'onObjectPointerup',
	ON_PERFORMANCE_CHANGE = 'onPerformanceChange',
	ON_POINTERDOWN = 'onPointerdown',
	ON_POINTERUP = 'onPointerup',
	ON_VIDEO_EVENT = 'onVideoEvent',
	ON_WEBXR_CONTROLLER_EVENT = 'onWebXRControllerEvent',
	RAY_FROM_CURSOR = 'rayFromCursor',
	RAY_FROM_CAMERA = 'rayFromCamera',
	SET_OBJECT_LOOK_AT = 'setObjectLookAt',
	SET_PHYSICS_RBD_POSITION = 'setPhysicsRBDPosition',
}
declare abstract class BaseUserInputActorNode<K extends NodeParamsConfig> extends TypedActorNode<K> {
	initializeNode(): void;
	abstract userInputEventNames(): string[];
	eventEmitter(): CoreEventEmitter;
}
declare class CursorActorParamsConfig extends NodeParamsConfig {
	/** @param set which element triggers the event */
	element: ParamTemplate<ParamType.INTEGER>;
	/** @param cursor */
	cursor: ParamTemplate<ParamType.VECTOR2>;
}
declare class CursorActorNode extends BaseUserInputActorNode<CursorActorParamsConfig> {
	paramsConfig: CursorActorParamsConfig;
	static type(): ActorType;
	userInputEventNames(): string[];
	eventEmitter(): CoreEventEmitter;
	initializeNode(): void;
	outputValue(
		context: ActorNodeTriggerContext
	): ReturnValueTypeByActorConnectionPointType[ActorConnectionPointType.VECTOR2] | undefined;
}
declare class DebugActorParamsConfig extends NodeParamsConfig {
	printInConsole: ParamTemplate<ParamType.BOOLEAN>;
	boolean: ParamTemplate<ParamType.BOOLEAN>;
	color: ParamTemplate<ParamType.COLOR>;
	float: ParamTemplate<ParamType.FLOAT>;
	integer: ParamTemplate<ParamType.INTEGER>;
	string: ParamTemplate<ParamType.STRING>;
	vector2: ParamTemplate<ParamType.VECTOR2>;
	vector3: ParamTemplate<ParamType.VECTOR3>;
	vector4: ParamTemplate<ParamType.VECTOR4>;
}
declare class DebugActorNode extends TypedActorNode<DebugActorParamsConfig> {
	readonly paramsConfig: DebugActorParamsConfig;
	static type(): string;
	static INPUT_NAME: string;
	initializeNode(): void;
	expectedInputTypes(): ActorConnectionPointType[];
	protected _expectedOutputTypes(): ActorConnectionPointType[];
	protected _expectedInputName(index: number): string;
	receiveTrigger(context: ActorNodeTriggerContext): void;
	outputValue(
		context: ActorNodeTriggerContext
	): ReturnValueTypeByActorConnectionPointType[ActorConnectionPointType] | undefined;
	private _setDisplayParam;
}
declare enum DistanceActorNodeInputName {
	V0 = 'v0',
	V1 = 'v1',
}
declare class DistanceActorParamsConfig extends NodeParamsConfig {}
declare class DistanceActorNode extends TypedActorNode<DistanceActorParamsConfig> {
	readonly paramsConfig: DistanceActorParamsConfig;
	static type(): string;
	initializeNode(): void;
	protected _expectedInputTypes(): ActorConnectionPointType[];
	protected _expectedInputName(index: number): DistanceActorNodeInputName;
	protected _expectedOutputTypes(): ActorConnectionPointType[];
	paramDefaultValue(name: string): Number3;
	outputValue(context: ActorNodeTriggerContext): number;
}
declare const DivideActorNode_base: typeof BaseMathFunctionActorNode;
declare class DivideActorNode extends DivideActorNode_base {
	paramDefaultValue(name: string): number;
	protected _applyOperation<T extends number>(arg1: T, arg2: T): any;
}
declare enum DotActorNodeInputName {
	V0 = 'v0',
	V1 = 'v1',
}
declare class DotActorParamsConfig extends NodeParamsConfig {}
declare class DotActorNode extends TypedActorNode<DotActorParamsConfig> {
	readonly paramsConfig: DotActorParamsConfig;
	static type(): string;
	initializeNode(): void;
	protected _expectedInputTypes(): ActorConnectionPointType[];
	protected _expectedInputName(index: number): DotActorNodeInputName;
	protected _expectedOutputTypes(): ActorConnectionPointType[];
	paramDefaultValue(name: string): Number3;
	outputValue(context: ActorNodeTriggerContext): number;
}
declare class EasingActorParamsConfig extends NodeParamsConfig {
	type: ParamTemplate<ParamType.INTEGER>;
}
declare class EasingActorNode extends TypedActorNode<EasingActorParamsConfig> {
	readonly paramsConfig: EasingActorParamsConfig;
	static type(): string;
	initializeNode(): void;
	private _expectedInputTypes;
	private _expectedOutputTypes;
	private _actorInputName;
	private _actorOutputName;
	outputValue(
		context: ActorNodeTriggerContext
	): ReturnValueTypeByActorConnectionPointType[ActorConnectionPointType] | undefined;
}
declare class ElementsToArrayActorParamsConfig extends NodeParamsConfig {}
declare class ElementsToArrayActorNode extends TypedActorNode<ElementsToArrayActorParamsConfig> {
	readonly paramsConfig: ElementsToArrayActorParamsConfig;
	static type(): string;
	initializeNode(): void;
	protected _expectedInputTypes(): ActorConnectionPointType[];
	protected _expectedInputName(index: number): string;
	protected _expectedOutputTypes(): (
		| ActorConnectionPointType.ANIMATION_MIXER
		| ActorConnectionPointType.ANIMATION_ACTION
		| ActorConnectionPointType.BOOLEAN_ARRAY
		| ActorConnectionPointType.BOX3
		| ActorConnectionPointType.CAMERA
		| ActorConnectionPointType.CATMULL_ROM_CURVE3
		| ActorConnectionPointType.COLOR_ARRAY
		| ActorConnectionPointType.FLOAT_ARRAY
		| ActorConnectionPointType.INTEGER_ARRAY
		| ActorConnectionPointType.INTERSECTION_ARRAY
		| ActorConnectionPointType.MATERIAL
		| ActorConnectionPointType.MATRIX4_ARRAY
		| ActorConnectionPointType.OBJECT_3D
		| ActorConnectionPointType.PLANE
		| ActorConnectionPointType.QUATERNION_ARRAY
		| ActorConnectionPointType.RAY
		| ActorConnectionPointType.SPHERE
		| ActorConnectionPointType.STRING_ARRAY
		| ActorConnectionPointType.TEXTURE_ARRAY
		| ActorConnectionPointType.TRIGGER
		| ActorConnectionPointType.VECTOR2_ARRAY
		| ActorConnectionPointType.VECTOR3_ARRAY
		| ActorConnectionPointType.VECTOR4_ARRAY
	)[];
	outputValue(context: ActorNodeTriggerContext): any[];
}
declare enum FitActorNodeInputName {
	VALUE = 'val',
	SRC_MIN = 'srcMin',
	SRC_MAX = 'srcMax',
	DEST_MIN = 'destMin',
	DEST_MAX = 'destMax',
	CLAMP_TO_DEST_RANGE = 'clampToDestRange',
}
declare class FitActorParamsConfig extends NodeParamsConfig {}
declare class FitActorNode extends TypedActorNode<FitActorParamsConfig> {
	readonly paramsConfig: FitActorParamsConfig;
	static type(): string;
	initializeNode(): void;
	protected _expectedInputTypes(): ActorConnectionPointType[];
	protected _expectedInputName(index: number): FitActorNodeInputName;
	protected _expectedOutputTypes(): ActorConnectionPointType[];
	paramDefaultValue(name: string): number;
	private _valTmp;
	outputValue(context: ActorNodeTriggerContext): number | Vector2 | Vector3 | Vector4;
}
declare class FloatToIntActorParamsConfig extends NodeParamsConfig {
	float: ParamTemplate<ParamType.FLOAT>;
}
declare class FloatToIntActorNode extends TypedActorNode<FloatToIntActorParamsConfig> {
	paramsConfig: FloatToIntActorParamsConfig;
	static type(): string;
	initializeNode(): void;
	outputValue(context: ActorNodeTriggerContext): ReturnValueTypeByActorConnectionPointType[ActorConnectionPointType];
}
declare class FloatToVec2ActorParamsConfig extends NodeParamsConfig {
	x: ParamTemplate<ParamType.FLOAT>;
	y: ParamTemplate<ParamType.FLOAT>;
}
declare class FloatToVec2ActorNode extends TypedActorNode<FloatToVec2ActorParamsConfig> {
	paramsConfig: FloatToVec2ActorParamsConfig;
	static type(): string;
	static readonly OUTPUT_NAME = 'vec2';
	initializeNode(): void;
	outputValue(
		context: ActorNodeTriggerContext,
		outputName?: string
	): ReturnValueTypeByActorConnectionPointType[ActorConnectionPointType];
}
declare class FloatToVec3ActorParamsConfig extends NodeParamsConfig {
	x: ParamTemplate<ParamType.FLOAT>;
	y: ParamTemplate<ParamType.FLOAT>;
	z: ParamTemplate<ParamType.FLOAT>;
}
declare class FloatToVec3ActorNode extends TypedActorNode<FloatToVec3ActorParamsConfig> {
	paramsConfig: FloatToVec3ActorParamsConfig;
	static type(): string;
	static readonly OUTPUT_NAME = 'vec3';
	initializeNode(): void;
	outputValue(
		context: ActorNodeTriggerContext,
		outputName?: string
	): ReturnValueTypeByActorConnectionPointType[ActorConnectionPointType];
}
declare class FloatToVec4ActorParamsConfig extends NodeParamsConfig {
	x: ParamTemplate<ParamType.FLOAT>;
	y: ParamTemplate<ParamType.FLOAT>;
	z: ParamTemplate<ParamType.FLOAT>;
	w: ParamTemplate<ParamType.FLOAT>;
}
declare class FloatToVec4ActorNode extends TypedActorNode<FloatToVec4ActorParamsConfig> {
	paramsConfig: FloatToVec4ActorParamsConfig;
	static type(): string;
	static readonly OUTPUT_NAME = 'vec4';
	initializeNode(): void;
	outputValue(
		context: ActorNodeTriggerContext,
		outputName?: string
	): ReturnValueTypeByActorConnectionPointType[ActorConnectionPointType];
}
declare const FloorActorNode_base: typeof BaseMathFunctionActorNode;
declare class FloorActorNode extends FloorActorNode_base {
	protected _applyOperation<T extends number>(arg1: T): any;
}
declare enum GetARSessionPropertyActorNodeOutputName {
	hitDetected = 'hitDetected',
	hitMatrix = 'hitMatrix',
	hitPosition = 'hitPosition',
	hitQuaternion = 'hitQuaternion',
}
declare class GetWebXRARSessionPropertyActorParamsConfig extends NodeParamsConfig {}
declare class GetWebXRARSessionPropertyActorNode extends TypedActorNode<GetWebXRARSessionPropertyActorParamsConfig> {
	paramsConfig: GetWebXRARSessionPropertyActorParamsConfig;
	static type(): string;
	initializeNode(): void;
	outputValue(
		context: ActorNodeTriggerContext,
		outputName: GetARSessionPropertyActorNodeOutputName
	): ReturnValueTypeByActorConnectionPointType[ActorConnectionPointType] | undefined;
}
declare enum GetBox3PropertyActorNodeInputName {
	min = 'min',
	max = 'max',
}
declare class GetBox3PropertyActorNode extends ParamlessTypedActorNode {
	static type(): string;
	initializeNode(): void;
	private _target;
	outputValue(
		context: ActorNodeTriggerContext,
		outputName: GetBox3PropertyActorNodeInputName | string
	): ReturnValueTypeByActorConnectionPointType[ActorConnectionPointType] | undefined;
}
declare class GetChildrenAttributesActorParamsConfig extends NodeParamsConfig {
	attribName: ParamTemplate<ParamType.STRING>;
	type: ParamTemplate<ParamType.INTEGER>;
}
declare class GetChildrenAttributesActorNode extends TypedActorNode<GetChildrenAttributesActorParamsConfig> {
	readonly paramsConfig: GetChildrenAttributesActorParamsConfig;
	static type(): string;
	static readonly OUTPUT_NAME = 'val';
	initializeNode(): void;
	private _currentConnectionType;
	setAttribType(type: ActorConnectionPointType): void;
	outputValue(
		context: ActorNodeTriggerContext
	): ReturnValueTypeByActorConnectionPointType[ActorConnectionPointType] | undefined;
}
declare enum GetChildrenPropertiesActorNodeInputName {
	position = 'position',
	quaternion = 'quaternion',
	scale = 'scale',
	visible = 'visible',
	castShadow = 'castShadow',
	receiveShadow = 'receiveShadow',
	frustumCulled = 'frustumCulled',
	up = 'up',
	matrixAutoUpdate = 'matrixAutoUpdate',
}
declare class GetChildrenPropertiesActorNode extends ParamlessTypedActorNode {
	static type(): string;
	initializeNode(): void;
	outputValue(
		context: ActorNodeTriggerContext,
		outputName: GetChildrenPropertiesActorNodeInputName
	): ReturnValueTypeByActorConnectionPointType[ActorConnectionPointType] | undefined;
}
declare enum GetChildrenPhysicsRBDPropertiesActorNodeInputName {
	linVel = 'linVel',
	angVel = 'angVel',
	linearDamping = 'linearDamping',
	angularDamping = 'angularDamping',
	isSleeping = 'isSleeping',
	isMoving = 'isMoving',
}
declare class GetChildrenPhysicsRBDPropertiesActorNode extends ParamlessTypedActorNode {
	static type(): string;
	initializeNode(): void;
	outputValue(
		context: ActorNodeTriggerContext,
		outputName: GetChildrenPhysicsRBDPropertiesActorNodeInputName
	): ReturnValueTypeByActorConnectionPointType[ActorConnectionPointType] | undefined;
}
declare enum GetIntersectionPropertyActorNodeOutputName {
	distance = 'distance',
	object = 'object',
	point = 'point',
	uv = 'uv',
}
declare class GetIntersectionPropertyActorNode extends ParamlessTypedActorNode {
	static type(): string;
	initializeNode(): void;
	outputValue(
		context: ActorNodeTriggerContext,
		outputName: GetIntersectionPropertyActorNodeOutputName | string
	): ReturnValueTypeByActorConnectionPointType[ActorConnectionPointType] | undefined;
}
declare class GetObjectChildActorParamsConfig extends NodeParamsConfig {
	/** @param child index */
	index: ParamTemplate<ParamType.INTEGER>;
}
declare class GetObjectChildActorNode extends TypedActorNode<GetObjectChildActorParamsConfig> {
	readonly paramsConfig: GetObjectChildActorParamsConfig;
	static type(): string;
	initializeNode(): void;
	outputValue(
		context: ActorNodeTriggerContext
	): ReturnValueTypeByActorConnectionPointType[ActorConnectionPointType.OBJECT_3D];
}
declare class GetDefaultCameraActorParamsConfig extends NodeParamsConfig {}
declare class GetDefaultCameraActorNode extends TypedActorNode<GetDefaultCameraActorParamsConfig> {
	readonly paramsConfig: GetDefaultCameraActorParamsConfig;
	static type(): string;
	initializeNode(): void;
	outputValue(
		context: ActorNodeTriggerContext
	): ReturnValueTypeByActorConnectionPointType[ActorConnectionPointType.CAMERA];
}
declare class GetMaterialActorParamsConfig extends NodeParamsConfig {
	/** @param the material node */
	node: ParamTemplate<ParamType.NODE_PATH>;
}
declare class GetMaterialActorNode extends TypedActorNode<GetMaterialActorParamsConfig> {
	readonly paramsConfig: GetMaterialActorParamsConfig;
	static type(): string;
	initializeNode(): void;
	outputValue(
		context: ActorNodeTriggerContext
	): ReturnValueTypeByActorConnectionPointType[ActorConnectionPointType] | undefined;
}
declare class GetObjectActorParamsConfig extends NodeParamsConfig {
	/** @param use current object */
	getCurrentObject: ParamTemplate<ParamType.BOOLEAN>;
	/** @param object mask */
	mask: ParamTemplate<ParamType.STRING>;
}
declare class GetObjectActorNode extends TypedActorNode<GetObjectActorParamsConfig> {
	readonly paramsConfig: GetObjectActorParamsConfig;
	static type(): string;
	initializeNode(): void;
	outputValue(
		context: ActorNodeTriggerContext
	): ReturnValueTypeByActorConnectionPointType[ActorConnectionPointType.OBJECT_3D];
	static objectFromMask(mask: string, scene: PolyScene): Object3D<Event> | null | undefined;
	private static _cacheClearedOnFrame;
	private static _cachedObjectByMask;
	private static _clearOutputValueCache;
	static PARAM_CALLBACK_clearCache(): void;
}
declare class GetObjectAttributeActorParamsConfig extends NodeParamsConfig {
	attribName: ParamTemplate<ParamType.STRING>;
	type: ParamTemplate<ParamType.INTEGER>;
}
declare class GetObjectAttributeActorNode extends TypedActorNode<GetObjectAttributeActorParamsConfig> {
	readonly paramsConfig: GetObjectAttributeActorParamsConfig;
	static type(): string;
	static readonly OUTPUT_NAME = 'val';
	initializeNode(): void;
	private _currentConnectionType;
	setAttribType(type: ActorConnectionPointType): void;
	outputValue(
		context: ActorNodeTriggerContext
	): ReturnValueTypeByActorConnectionPointType[ActorConnectionPointType] | undefined;
}
declare enum GetObjectPropertyActorNodeInputName {
	position = 'position',
	quaternion = 'quaternion',
	scale = 'scale',
	matrix = 'matrix',
	visible = 'visible',
	castShadow = 'castShadow',
	receiveShadow = 'receiveShadow',
	frustumCulled = 'frustumCulled',
	uuid = 'uuid',
	name = 'name',
	up = 'up',
	matrixAutoUpdate = 'matrixAutoUpdate',
}
declare class GetObjectPropertyActorNode extends ParamlessTypedActorNode {
	static type(): string;
	initializeNode(): void;
	outputValue(
		context: ActorNodeTriggerContext,
		outputName: GetObjectPropertyActorNodeInputName | string
	): ReturnValueTypeByActorConnectionPointType[ActorConnectionPointType] | undefined;
}
declare class GetObjectUserDataActorParamsConfig extends NodeParamsConfig {
	type: ParamTemplate<ParamType.INTEGER>;
	name: ParamTemplate<ParamType.STRING>;
}
declare class GetObjectUserDataActorNode extends TypedActorNode<GetObjectUserDataActorParamsConfig> {
	readonly paramsConfig: GetObjectUserDataActorParamsConfig;
	static type(): string;
	static readonly OUTPUT_NAME = 'val';
	initializeNode(): void;
	private _currentConnectionType;
	setUserDataType(type: ActorConnectionPointType): void;
	outputValue(
		context: ActorNodeTriggerContext,
		outputName: string
	): ReturnValueTypeByActorConnectionPointType[ActorConnectionPointType] | undefined;
}
declare enum GetObjectWorldPositionActorNodeInputName {
	worldPosition = 'worldPosition',
}
declare class GetObjectWorldPositionActorNode extends ParamlessTypedActorNode {
	static type(): string;
	initializeNode(): void;
	outputValue(
		context: ActorNodeTriggerContext,
		outputName: GetObjectWorldPositionActorNodeInputName | string
	): ReturnValueTypeByActorConnectionPointType[ActorConnectionPointType] | undefined;
}
declare class GetParentActorParamsConfig extends NodeParamsConfig {
	/** @param use current object */
	getCurrentObject: ParamTemplate<ParamType.BOOLEAN>;
	/** @param object mask */
	mask: ParamTemplate<ParamType.STRING>;
}
declare class GetParentActorNode extends TypedActorNode<GetParentActorParamsConfig> {
	readonly paramsConfig: GetParentActorParamsConfig;
	static type(): string;
	initializeNode(): void;
	outputValue(
		context: ActorNodeTriggerContext
	): ReturnValueTypeByActorConnectionPointType[ActorConnectionPointType.OBJECT_3D];
	static PARAM_CALLBACK_clearCache(): void;
}
declare enum GetPhysicsRBDConePropertyActorNodeInputName {
	height = 'height',
	radius = 'radius',
}
declare class GetPhysicsRBDConePropertyActorNode extends ParamlessTypedActorNode {
	static type(): string;
	initializeNode(): void;
	outputValue(
		context: ActorNodeTriggerContext,
		outputName: GetPhysicsRBDConePropertyActorNodeInputName
	): ReturnValueTypeByActorConnectionPointType[ActorConnectionPointType] | undefined;
}
declare enum GetPhysicsRBDCapsulePropertyActorNodeInputName {
	radius = 'radius',
	height = 'height',
}
declare class GetPhysicsRBDCapsulePropertyActorNode extends ParamlessTypedActorNode {
	static type(): string;
	initializeNode(): void;
	outputValue(
		context: ActorNodeTriggerContext,
		outputName: GetPhysicsRBDCapsulePropertyActorNodeInputName
	): ReturnValueTypeByActorConnectionPointType[ActorConnectionPointType] | undefined;
}
declare enum GetPhysicsRBDCylinderPropertyActorNodeInputName {
	height = 'height',
	radius = 'radius',
}
declare class GetPhysicsRBDCylinderPropertyActorNode extends ParamlessTypedActorNode {
	static type(): string;
	initializeNode(): void;
	outputValue(
		context: ActorNodeTriggerContext,
		outputName: GetPhysicsRBDCylinderPropertyActorNodeInputName
	): ReturnValueTypeByActorConnectionPointType[ActorConnectionPointType] | undefined;
}
declare enum GetPhysicsRBDCuboidPropertyActorNodeInputName {
	sizes = 'sizes',
}
declare class GetPhysicsRBDCuboidPropertyActorNode extends ParamlessTypedActorNode {
	static type(): string;
	initializeNode(): void;
	outputValue(
		context: ActorNodeTriggerContext,
		outputName: GetPhysicsRBDCuboidPropertyActorNodeInputName
	): ReturnValueTypeByActorConnectionPointType[ActorConnectionPointType] | undefined;
}
declare enum GetPhysicsRBDSpherePropertyActorNodeInputName {
	radius = 'radius',
}
declare class GetPhysicsRBDSpherePropertyActorNode extends ParamlessTypedActorNode {
	static type(): string;
	initializeNode(): void;
	outputValue(
		context: ActorNodeTriggerContext,
		outputName: GetPhysicsRBDSpherePropertyActorNodeInputName
	): ReturnValueTypeByActorConnectionPointType[ActorConnectionPointType] | undefined;
}
declare enum GetPhysicsRBDPropertyActorNodeInputName {
	linVel = 'linVel',
	angVel = 'angVel',
	linearDamping = 'linearDamping',
	angularDamping = 'angularDamping',
	isSleeping = 'isSleeping',
	isMoving = 'isMoving',
}
declare class GetPhysicsRBDPropertyActorNode extends ParamlessTypedActorNode {
	static type(): string;
	initializeNode(): void;
	outputValue(
		context: ActorNodeTriggerContext,
		outputName: GetPhysicsRBDPropertyActorNodeInputName
	): ReturnValueTypeByActorConnectionPointType[ActorConnectionPointType] | undefined;
}
declare enum GetPlanePropertyActorNodeInputName {
	normal = 'normal',
	constant = 'constant',
}
declare class GetPlanePropertyActorNode extends ParamlessTypedActorNode {
	static type(): string;
	initializeNode(): void;
	private _target;
	outputValue(
		context: ActorNodeTriggerContext,
		outputName: GetPlanePropertyActorNodeInputName | string
	): ReturnValueTypeByActorConnectionPointType[ActorConnectionPointType] | undefined;
}
declare enum GetRayPropertyActorNodeInputName {
	origin = 'origin',
	direction = 'direction',
}
declare class GetRayPropertyActorNode extends ParamlessTypedActorNode {
	static type(): string;
	initializeNode(): void;
	private _target;
	outputValue(
		context: ActorNodeTriggerContext,
		outputName: GetRayPropertyActorNodeInputName | string
	): ReturnValueTypeByActorConnectionPointType[ActorConnectionPointType] | undefined;
}
declare enum GetSpherePropertyActorNodeInputName {
	center = 'center',
	radius = 'radius',
}
declare class GetSpherePropertyActorNode extends ParamlessTypedActorNode {
	static type(): string;
	initializeNode(): void;
	private _target;
	outputValue(
		context: ActorNodeTriggerContext,
		outputName: GetSpherePropertyActorNodeInputName | string
	): ReturnValueTypeByActorConnectionPointType[ActorConnectionPointType] | undefined;
}
declare class GetTextureActorParamsConfig extends NodeParamsConfig {
	/** @param the material node */
	node: ParamTemplate<ParamType.NODE_PATH>;
}
declare class GetTextureActorNode extends TypedActorNode<GetTextureActorParamsConfig> {
	readonly paramsConfig: GetTextureActorParamsConfig;
	static type(): string;
	initializeNode(): void;
	outputValue(
		context: ActorNodeTriggerContext
	): ReturnValueTypeByActorConnectionPointType[ActorConnectionPointType] | undefined;
}
declare enum GetTrackedHandPropertyActorNodeInputName {
	thumbDirection = 'thumbDirection',
	indexDirection = 'indexDirection',
	middleDirection = 'middleDirection',
	ringDirection = 'ringDirection',
	pinkyDirection = 'pinkyDirection',
}
declare class GetTrackedHandPropertyActorNode extends ParamlessTypedActorNode {
	static type(): string;
	initializeNode(): void;
	outputValue(
		context: ActorNodeTriggerContext,
		outputName: GetTrackedHandPropertyActorNodeInputName
	): ReturnValueTypeByActorConnectionPointType[ActorConnectionPointType] | undefined;
}
declare enum GetVideoPropertyActorNodeOutputName {
	currentTime = 'currentTime',
	duration = 'duration',
	playing = 'playing',
	muted = 'muted',
}
declare class GetVideoPropertyActorParamsConfig extends NodeParamsConfig {
	node: ParamTemplate<ParamType.NODE_PATH>;
}
declare class GetVideoPropertyActorNode extends TypedActorNode<GetVideoPropertyActorParamsConfig> {
	paramsConfig: GetVideoPropertyActorParamsConfig;
	static type(): string;
	initializeNode(): void;
	outputValue(
		context: ActorNodeTriggerContext,
		outputName: GetVideoPropertyActorNodeOutputName
	): ReturnValueTypeByActorConnectionPointType[ActorConnectionPointType] | undefined;
}
declare enum GetWebXRControllerPropertyActorNodeInputName {
	Object3D = 'Object3D',
	Ray = 'Ray',
	hasLinearVelocity = 'hasLinearVelocity',
	linearVelocity = 'linearVelocity',
	hasAngularVelocity = 'hasAngularVelocity',
	angularVelocity = 'angularVelocity',
}
declare class GetWebXRControllerPropertyActorParamsConfig extends NodeParamsConfig {
	/** @param  controller index */
	controllerIndex: ParamTemplate<ParamType.INTEGER>;
}
declare class GetWebXRControllerPropertyActorNode extends TypedActorNode<GetWebXRControllerPropertyActorParamsConfig> {
	paramsConfig: GetWebXRControllerPropertyActorParamsConfig;
	static type(): string;
	initializeNode(): void;
	outputValue(
		context: ActorNodeTriggerContext,
		outputName: GetWebXRControllerPropertyActorNodeInputName
	): ReturnValueTypeByActorConnectionPointType[ActorConnectionPointType] | undefined;
}
declare enum GetWebXRTrackedMarkerActorNodeInputName {
	matrix = 'matrix',
}
declare class GetWebXRTrackedMarkerActorParamsConfig extends NodeParamsConfig {}
declare class GetWebXRTrackedMarkerPropertyActorNode extends TypedActorNode<GetWebXRTrackedMarkerActorParamsConfig> {
	paramsConfig: GetWebXRTrackedMarkerActorParamsConfig;
	static type(): string;
	initializeNode(): void;
	outputValue(
		context: ActorNodeTriggerContext,
		outputName: GetWebXRTrackedMarkerActorNodeInputName
	): ReturnValueTypeByActorConnectionPointType[ActorConnectionPointType] | undefined;
}
declare class IntToFloatActorParamsConfig extends NodeParamsConfig {
	int: ParamTemplate<ParamType.INTEGER>;
}
declare class IntToFloatActorNode extends TypedActorNode<IntToFloatActorParamsConfig> {
	paramsConfig: IntToFloatActorParamsConfig;
	static type(): string;
	initializeNode(): void;
	outputValue(context: ActorNodeTriggerContext): ReturnValueTypeByActorConnectionPointType[ActorConnectionPointType];
}
declare class IntToBoolActorParamsConfig extends NodeParamsConfig {
	int: ParamTemplate<ParamType.INTEGER>;
}
declare class IntToBoolActorNode extends TypedActorNode<IntToBoolActorParamsConfig> {
	paramsConfig: IntToBoolActorParamsConfig;
	static type(): string;
	initializeNode(): void;
	outputValue(
		context: ActorNodeTriggerContext,
		outputName?: string
	): ReturnValueTypeByActorConnectionPointType[ActorConnectionPointType];
}
declare enum LengthActorNodeInputName {
	V = 'v',
}
declare class LengthActorParamsConfig extends NodeParamsConfig {}
declare class LengthActorNode extends TypedActorNode<LengthActorParamsConfig> {
	readonly paramsConfig: LengthActorParamsConfig;
	static type(): string;
	initializeNode(): void;
	protected _expectedInputTypes(): ActorConnectionPointType[];
	protected _expectedInputName(index: number): LengthActorNodeInputName;
	protected _expectedOutputTypes(): ActorConnectionPointType[];
	paramDefaultValue(name: string): Number3;
	outputValue(context: ActorNodeTriggerContext): number;
}
declare enum LerpActorNodeInputName {
	V0 = 'v0',
	V1 = 'v1',
	ALPHA = 'alpha',
}
declare class LerpActorParamsConfig extends NodeParamsConfig {}
declare class LerpActorNode extends TypedActorNode<LerpActorParamsConfig> {
	readonly paramsConfig: LerpActorParamsConfig;
	static type(): string;
	initializeNode(): void;
	protected _expectedInputTypes(): ActorConnectionPointType[];
	protected _expectedInputName(index: number): LerpActorNodeInputName;
	protected _expectedOutputTypes(): ActorConnectionPointType[];
	paramDefaultValue(name: string): number | Number3;
	private _valTmp;
	outputValue(context: ActorNodeTriggerContext): 0 | Vector2 | Vector3 | Vector4;
}
declare enum ManhattanDistanceActorNodeInputName {
	V0 = 'v0',
	V1 = 'v1',
}
declare class ManhattanDistanceActorParamsConfig extends NodeParamsConfig {}
declare class ManhattanDistanceActorNode extends TypedActorNode<ManhattanDistanceActorParamsConfig> {
	readonly paramsConfig: ManhattanDistanceActorParamsConfig;
	static type(): string;
	initializeNode(): void;
	protected _expectedInputTypes(): ActorConnectionPointType[];
	protected _expectedInputName(index: number): ManhattanDistanceActorNodeInputName;
	protected _expectedOutputTypes(): ActorConnectionPointType[];
	paramDefaultValue(name: string): Number3;
	outputValue(context: ActorNodeTriggerContext): number;
}
declare const MaxActorNode_base: typeof BaseMathFunctionActorNode;
declare class MaxActorNode extends MaxActorNode_base {
	protected _applyOperation<T extends number>(arg1: T, arg2: T): any;
}
declare enum MaxLengthActorNodeInputName {
	VALUE = 'value',
	MAX = 'max',
}
declare class MaxLengthActorParamsConfig extends NodeParamsConfig {}
declare class MaxLengthActorNode extends TypedActorNode<MaxLengthActorParamsConfig> {
	readonly paramsConfig: MaxLengthActorParamsConfig;
	static type(): string;
	initializeNode(): void;
	protected _expectedInputTypes(): ActorConnectionPointType[];
	protected _expectedInputName(index: number): MaxLengthActorNodeInputName;
	protected _expectedOutputTypes(): ActorConnectionPointType[];
	paramDefaultValue(name: string): number;
	private _valTmp;
	outputValue(context: ActorNodeTriggerContext): 0 | Vector2 | Vector3;
}
declare const MinActorNode_base: typeof BaseMathFunctionActorNode;
declare class MinActorNode extends MinActorNode_base {
	protected _applyOperation<T extends number>(arg1: T, arg2: T): any;
}
declare enum MixActorNodeInputName {
	VALUE0 = 'value0',
	VALUE1 = 'value1',
	BLEND = 'blend',
}
declare class MixActorParamsConfig extends NodeParamsConfig {}
declare class MixActorNode extends TypedActorNode<MixActorParamsConfig> {
	readonly paramsConfig: MixActorParamsConfig;
	static type(): string;
	initializeNode(): void;
	protected _expectedInputTypes(): ActorConnectionPointType[];
	protected _expectedInputName(index: number): MixActorNodeInputName;
	protected _expectedOutputTypes(): ActorConnectionPointType[];
	paramDefaultValue(name: string): number;
	private _val0Tmp;
	private _val1Tmp;
	outputValue(context: ActorNodeTriggerContext): number | Color | Vector3;
	private _vectorTmp;
}
declare const MultActorNode_base: typeof BaseMathFunctionActorNode;
declare class MultActorNode extends MultActorNode_base {
	static type(): string;
	paramDefaultValue(name: string): number;
	protected _applyOperation<T extends number>(arg1: T, arg2: T): any;
	initializeNode(): void;
	protected _expectedOutputType(): ActorConnectionPointType[];
	protected _expectedInputTypes(): ActorConnectionPointType[];
}
declare enum MultAddActorNodeInputName {
	VALUE = 'value',
	PRE_ADD = 'preAdd',
	MULT = 'mult',
	POST_ADD = 'postAdd',
}
declare class MultAddActorParamsConfig extends NodeParamsConfig {}
declare class MultAddActorNode extends TypedActorNode<MultAddActorParamsConfig> {
	readonly paramsConfig: MultAddActorParamsConfig;
	static type(): string;
	initializeNode(): void;
	protected _expectedInputTypes(): ActorConnectionPointType[];
	protected _expectedInputName(index: number): MultAddActorNodeInputName;
	protected _expectedOutputTypes(): ActorConnectionPointType[];
	paramDefaultValue(name: string): number;
	private _valTmp;
	outputValue(context: ActorNodeTriggerContext): number | Vector2 | Vector3 | Vector4;
}
declare enum MultScalarActorNodeInputName {
	VALUE = 'value',
	MULT = 'mult',
}
declare class MultScalarActorNode extends BaseMathFunctionArg2ActorNode {
	static type(): string;
	protected _expectedInputTypes(): ActorConnectionPointType[];
	protected _expectedInputName(index: number): MultScalarActorNodeInputName;
	paramDefaultValue(name: string): number;
	private _tmpColor;
	private _tmpVec2;
	private _tmpVec3;
	private _tmpVec4;
	outputValue(context: ActorNodeTriggerContext): Color | Vector2 | Vector3 | Vector4;
	private _defaultInput;
	private _inputColorOrVector;
}
declare class NearestPositionActorParamsConfig extends NodeParamsConfig {
	/** @param vector3 */
	Vector3: ParamTemplate<ParamType.VECTOR3>;
}
declare class NearestPositionActorNode extends TypedActorNode<NearestPositionActorParamsConfig> {
	paramsConfig: NearestPositionActorParamsConfig;
	static type(): string;
	initializeNode(): void;
	outputValue(context: ActorNodeTriggerContext): Vector3;
}
declare const NegateActorNode_base: typeof BaseMathFunctionActorNode;
declare class NegateActorNode extends NegateActorNode_base {
	protected _applyOperation<T extends boolean | number | Vector2 | Vector3 | Vector4>(arg1: T): T;
}
declare enum NormalizeActorNodeInputName {
	V = 'v',
}
declare class NormalizeActorParamsConfig extends NodeParamsConfig {}
declare class NormalizeActorNode extends TypedActorNode<NormalizeActorParamsConfig> {
	readonly paramsConfig: NormalizeActorParamsConfig;
	static type(): string;
	initializeNode(): void;
	protected _expectedInputTypes(): ActorConnectionPointType[];
	protected _expectedInputName(index: number): NormalizeActorNodeInputName;
	protected _expectedOutputTypes(): ActorConnectionPointType[];
	paramDefaultValue(name: string): Number3;
	private _valTmp;
	outputValue(context: ActorNodeTriggerContext): Vector2 | Vector3 | Vector4;
}
declare class NullActorParamsConfig extends NodeParamsConfig {}
declare class NullActorNode extends BaseMathFunctionArg1ActorNode {
	readonly paramsConfig: NullActorParamsConfig;
	static type(): string;
	protected _expectedInputTypes(): ActorConnectionPointType[];
	receiveTrigger(context: ActorNodeTriggerContext): void;
	outputValue(
		context: ActorNodeTriggerContext
	): ReturnValueTypeByActorConnectionPointType[ActorConnectionPointType] | undefined;
}
declare class Object3DLocalToWorldActorParamsConfig extends NodeParamsConfig {
	/** @param vector3 */
	Vector3: ParamTemplate<ParamType.VECTOR3>;
}
declare class Object3DLocalToWorldActorNode extends TypedActorNode<Object3DLocalToWorldActorParamsConfig> {
	paramsConfig: Object3DLocalToWorldActorParamsConfig;
	static type(): string;
	initializeNode(): void;
	outputValue(context: ActorNodeTriggerContext): Vector3;
}
declare class Object3DUpdateMatrixActorParamsConfig extends NodeParamsConfig {}
declare class Object3DUpdateMatrixActorNode extends TypedActorNode<Object3DUpdateMatrixActorParamsConfig> {
	readonly paramsConfig: Object3DUpdateMatrixActorParamsConfig;
	static type(): string;
	initializeNode(): void;
	receiveTrigger(context: ActorNodeTriggerContext): void;
}
declare class Object3DUpdateWorldMatrixActorParamsConfig extends NodeParamsConfig {
	/** @param updates the matrix of the parents */
	updateParents: ParamTemplate<ParamType.BOOLEAN>;
	/** @param updates the matrix of the children */
	updateChildren: ParamTemplate<ParamType.BOOLEAN>;
}
declare class Object3DUpdateWorldMatrixActorNode extends TypedActorNode<Object3DUpdateWorldMatrixActorParamsConfig> {
	readonly paramsConfig: Object3DUpdateWorldMatrixActorParamsConfig;
	static type(): string;
	initializeNode(): void;
	receiveTrigger(context: ActorNodeTriggerContext): void;
}
declare class Object3DWorldToLocalActorParamsConfig extends NodeParamsConfig {
	/** @param vector3 */
	Vector3: ParamTemplate<ParamType.VECTOR3>;
}
declare class Object3DWorldToLocalActorNode extends TypedActorNode<Object3DWorldToLocalActorParamsConfig> {
	paramsConfig: Object3DWorldToLocalActorParamsConfig;
	static type(): string;
	initializeNode(): void;
	outputValue(context: ActorNodeTriggerContext): Vector3;
}
declare class ObjectDispatchEventActorParamsConfig extends NodeParamsConfig {
	/** @param event name */
	eventName: ParamTemplate<ParamType.STRING>;
}
declare class ObjectDispatchEventActorNode extends TypedActorNode<ObjectDispatchEventActorParamsConfig> {
	readonly paramsConfig: ObjectDispatchEventActorParamsConfig;
	static type(): string;
	initializeNode(): void;
	receiveTrigger(context: ActorNodeTriggerContext): void;
}
declare class OnChildAttributeUpdateActorParamsConfig extends NodeParamsConfig {
	attribName: ParamTemplate<ParamType.STRING>;
	type: ParamTemplate<ParamType.INTEGER>;
}
declare class OnChildAttributeUpdateActorNode extends TypedActorNode<OnChildAttributeUpdateActorParamsConfig> {
	readonly paramsConfig: OnChildAttributeUpdateActorParamsConfig;
	static type(): ActorType;
	static readonly OUTPUT_PREV_VALUES = 'previousValues';
	static readonly OUTPUT_NEW_VALUES = 'newValues';
	initializeNode(): void;
	private _currentConnectionType;
	setAttribType(type: ActorConnectionPointType): void;
	attributeName(): string;
	outputValue(
		context: ActorNodeTriggerContext,
		outputName: string
	): ReturnValueTypeByActorConnectionPointType[ActorConnectionPointType] | undefined;
}
declare class BaseOnKeyEventActorParamsConfig extends NodeParamsConfig {
	/** @param set which element triggers the event */
	element: ParamTemplate<ParamType.INTEGER>;
	/** @param space separated list of accepted key codes. If this is empty then any key is accepted. */
	keyCodes: ParamTemplate<ParamType.STRING>;
	/** @param requires ctrlKey */
	ctrlKey: ParamTemplate<ParamType.BOOLEAN>;
	/** @param requires altKey */
	altKey: ParamTemplate<ParamType.BOOLEAN>;
	/** @param requires shiftKey */
	shiftKey: ParamTemplate<ParamType.BOOLEAN>;
	/** @param requires metaKey */
	metaKey: ParamTemplate<ParamType.BOOLEAN>;
}
declare abstract class BaseOnKeyEventActorNode extends BaseUserInputActorNode<BaseOnKeyEventActorParamsConfig> {
	readonly paramsConfig: BaseOnKeyEventActorParamsConfig;
	initializeNode(): void;
	eventEmitter(): CoreEventEmitter;
	receiveTrigger(context: ActorNodeTriggerContext): void;
}
declare class OnKeydownActorActorNode extends BaseOnKeyEventActorNode {
	static type(): ActorType;
	userInputEventNames(): KeyboardEventType[];
}
declare class OnKeypressActorActorNode extends BaseOnKeyEventActorNode {
	static type(): ActorType;
	userInputEventNames(): KeyboardEventType[];
}
declare class OnKeyupActorActorNode extends BaseOnKeyEventActorNode {
	static type(): ActorType;
	userInputEventNames(): KeyboardEventType[];
}
declare class OnManualTriggerActorParamsConfig extends NodeParamsConfig {
	trigger: ParamTemplate<ParamType.BUTTON>;
}
declare class OnManualTriggerActorNode extends TypedActorNode<OnManualTriggerActorParamsConfig> {
	readonly paramsConfig: OnManualTriggerActorParamsConfig;
	static type(): string;
	initializeNode(): void;
	static PARAM_CALLBACK_sendTrigger(node: OnManualTriggerActorNode): void;
	private _triggerWithNode;
}
declare class OnMapboxCameraMoveActorParamsConfig extends NodeParamsConfig {}
declare class OnMapboxCameraMoveActorNode extends TypedActorNode<OnMapboxCameraMoveActorParamsConfig> {
	readonly paramsConfig: OnMapboxCameraMoveActorParamsConfig;
	static type(): ActorType;
	initializeNode(): void;
}
declare class OnMapboxCameraMoveStartActorParamsConfig extends NodeParamsConfig {}
declare class OnMapboxCameraMoveStartActorNode extends TypedActorNode<OnMapboxCameraMoveStartActorParamsConfig> {
	readonly paramsConfig: OnMapboxCameraMoveStartActorParamsConfig;
	static type(): ActorType;
	initializeNode(): void;
}
declare class OnMapboxCameraMoveEndActorParamsConfig extends NodeParamsConfig {}
declare class OnMapboxCameraMoveEndActorNode extends TypedActorNode<OnMapboxCameraMoveEndActorParamsConfig> {
	readonly paramsConfig: OnMapboxCameraMoveEndActorParamsConfig;
	static type(): ActorType;
	initializeNode(): void;
}
declare class OnObjectAttributeUpdateActorParamsConfig extends NodeParamsConfig {
	attribName: ParamTemplate<ParamType.STRING>;
	type: ParamTemplate<ParamType.INTEGER>;
}
declare class OnObjectAttributeUpdateActorNode extends TypedActorNode<OnObjectAttributeUpdateActorParamsConfig> {
	readonly paramsConfig: OnObjectAttributeUpdateActorParamsConfig;
	static type(): ActorType;
	static readonly OUTPUT_NEW_VAL = 'newValue';
	static readonly OUTPUT_PREV_VAL = 'previousValue';
	initializeNode(): void;
	private _currentConnectionType;
	setAttribType(type: ActorConnectionPointType): void;
	attributeName(): string;
}
declare class OnObjectClickActorParamsConfig extends NodeParamsConfig {
	/** @param set which element triggers the event */
	element: ParamTemplate<ParamType.INTEGER>;
	/** @param include children */
	traverseChildren: ParamTemplate<ParamType.BOOLEAN>;
	/** @param pointsThreshold */
	pointsThreshold: ParamTemplate<ParamType.FLOAT>;
	/** @param lineThreshold */
	lineThreshold: ParamTemplate<ParamType.FLOAT>;
}
declare class OnObjectClickActorNode extends BaseUserInputActorNode<OnObjectClickActorParamsConfig> {
	readonly paramsConfig: OnObjectClickActorParamsConfig;
	static type(): ActorType;
	userInputEventNames(): string[];
	eventEmitter(): CoreEventEmitter;
	initializeNode(): void;
	private _intersectionByObject;
	receiveTrigger(context: ActorNodeTriggerContext): void;
	outputValue(
		context: ActorNodeTriggerContext,
		outputName: string
	): ReturnValueTypeByActorConnectionPointType[ActorConnectionPointType] | undefined;
}
declare enum OnObjectDispatchEventActorNodeInputName {
	eventName = 'eventName',
}
declare class OnObjectDispatchEventActorParamsConfig extends NodeParamsConfig {
	/** @param event names (space separated) */
	eventNames: ParamTemplate<ParamType.STRING>;
}
declare class OnObjectDispatchEventActorNode extends TypedActorNode<OnObjectDispatchEventActorParamsConfig> {
	readonly paramsConfig: OnObjectDispatchEventActorParamsConfig;
	static type(): ActorType.ON_OBJECT_DISPATCH_EVENT;
	initializeNode(): void;
	private _lastReceivedEventName;
	outputValue(
		context: ActorNodeTriggerContext,
		outputName: OnObjectDispatchEventActorNodeInputName | string
	): ReturnValueTypeByActorConnectionPointType[ActorConnectionPointType] | undefined;
	initOnPlay(): void;
	disposeOnPause(): void;
	private _addEventListenersToObjects;
	private _listenerByObject;
	dispose(): void;
}
declare class OnObjectHoverActorParamsConfig extends NodeParamsConfig {
	/** @param set which element triggers the event */
	element: ParamTemplate<ParamType.INTEGER>;
	/** @param include children */
	traverseChildren: ParamTemplate<ParamType.BOOLEAN>;
	/** @param pointsThreshold */
	pointsThreshold: ParamTemplate<ParamType.FLOAT>;
	/** @param lineThreshold */
	lineThreshold: ParamTemplate<ParamType.FLOAT>;
}
declare class OnObjectHoverActorNode extends BaseUserInputActorNode<OnObjectHoverActorParamsConfig> {
	readonly paramsConfig: OnObjectHoverActorParamsConfig;
	static type(): ActorType;
	userInputEventNames(): string[];
	eventEmitter(): CoreEventEmitter;
	initializeNode(): void;
	private _intersectionByObject;
	private _lastIntersectionStateByObject;
	receiveTrigger(context: ActorNodeTriggerContext): void;
	outputValue(
		context: ActorNodeTriggerContext,
		outputName: string
	): ReturnValueTypeByActorConnectionPointType[ActorConnectionPointType] | undefined;
}
declare class OnObjectPointerdownActorParamsConfig extends NodeParamsConfig {
	/** @param set which element triggers the event */
	element: ParamTemplate<ParamType.INTEGER>;
	/** @param include children */
	traverseChildren: ParamTemplate<ParamType.BOOLEAN>;
	/** @param pointsThreshold */
	pointsThreshold: ParamTemplate<ParamType.FLOAT>;
	/** @param lineThreshold */
	lineThreshold: ParamTemplate<ParamType.FLOAT>;
}
declare class OnObjectPointerdownActorNode extends BaseUserInputActorNode<OnObjectPointerdownActorParamsConfig> {
	readonly paramsConfig: OnObjectPointerdownActorParamsConfig;
	static type(): ActorType;
	userInputEventNames(): string[];
	eventEmitter(): CoreEventEmitter;
	initializeNode(): void;
	private _intersectionByObject;
	receiveTrigger(context: ActorNodeTriggerContext): void;
	outputValue(
		context: ActorNodeTriggerContext,
		outputName: string
	): ReturnValueTypeByActorConnectionPointType[ActorConnectionPointType] | undefined;
}
declare class OnObjectPointerupActorParamsConfig extends NodeParamsConfig {
	/** @param set which element triggers the event */
	element: ParamTemplate<ParamType.INTEGER>;
	/** @param include children */
	traverseChildren: ParamTemplate<ParamType.BOOLEAN>;
	/** @param pointsThreshold */
	pointsThreshold: ParamTemplate<ParamType.FLOAT>;
	/** @param lineThreshold */
	lineThreshold: ParamTemplate<ParamType.FLOAT>;
}
declare class OnObjectPointerupActorNode extends BaseUserInputActorNode<OnObjectPointerupActorParamsConfig> {
	readonly paramsConfig: OnObjectPointerupActorParamsConfig;
	static type(): ActorType;
	userInputEventNames(): string[];
	eventEmitter(): CoreEventEmitter;
	initializeNode(): void;
	private _intersectionByObject;
	receiveTrigger(context: ActorNodeTriggerContext): void;
	outputValue(
		context: ActorNodeTriggerContext,
		outputName: string
	): ReturnValueTypeByActorConnectionPointType[ActorConnectionPointType] | undefined;
}
declare class OnPerformanceChangeActorParamsConfig extends NodeParamsConfig {
	threshold: ParamTemplate<ParamType.FLOAT>;
}
declare class OnPerformanceChangeActorNode extends TypedActorNode<OnPerformanceChangeActorParamsConfig> {
	readonly paramsConfig: OnPerformanceChangeActorParamsConfig;
	static type(): ActorType;
	static OUTPUT_NAME_ABOVE: string;
	static OUTPUT_NAME_BELOW: string;
	static OUTPUT_TRIGGER_NAMES: string[];
	initializeNode(): void;
}
declare enum CorePlayerInput {
	LEFT = 'left',
	RIGHT = 'right',
	BACKWARD = 'backward',
	FORWARD = 'forward',
	RUN = 'run',
	JUMP = 'jump',
}
declare class BaseOnKeyEventActorParamsConfig extends NodeParamsConfig {
	/** @param set which element triggers the event */
	element: ParamTemplate<ParamType.INTEGER>;
	/** @param define if WASD keys are used or not */
	useWASDkeys: ParamTemplate<ParamType.BOOLEAN>;
	/** @param define if Arrow keys are used or not */
	useArrowkeys: ParamTemplate<ParamType.BOOLEAN>;
	/** @param prevent event propagation */
	stopPropagation: ParamTemplate<ParamType.BOOLEAN>;
}
declare class OnPlayerEventActorNode extends BaseUserInputActorNode<BaseOnKeyEventActorParamsConfig> {
	readonly paramsConfig: BaseOnKeyEventActorParamsConfig;
	static type(): ActorType;
	private _playerInputData;
	userInputEventNames(): KeyboardEventType[];
	eventEmitter(): CoreEventEmitter;
	initializeNode(): void;
	receiveTrigger(context: ActorNodeTriggerContext): void;
	outputValue(context: ActorNodeTriggerContext, outputName: CorePlayerInput): boolean;
	private _callbackByEventType;
	private _onKeydownCallback;
	private _onKeyupCallback;
	private _onEvent;
	private _eventByArrowKeyOnKeydown;
	private _eventByWASNKeyOnKeydown;
	private _eventByArrowKeyOnKeyup;
	private _eventByWASNKeyOnKeyup;
	private _runJumpEventByKeyOnkeydown;
	private _runJumpEventByKeyOnkeyup;
	private _onForwardStart;
	private _onBackwardStart;
	private _onLeftStart;
	private _onRightStart;
	private _onJumpStart;
	private _onRunStart;
	private _onForwardEnd;
	private _onBackwardEnd;
	private _onLeftEnd;
	private _onRightEnd;
	private _onJumpEnd;
	private _onRunEnd;
}
declare class OnPointerdownActorParamsConfig extends NodeParamsConfig {
	/** @param set which element triggers the event */
	element: ParamTemplate<ParamType.INTEGER>;
}
declare class OnPointerdownActorNode extends BaseUserInputActorNode<OnPointerdownActorParamsConfig> {
	readonly paramsConfig: OnPointerdownActorParamsConfig;
	static type(): ActorType;
	userInputEventNames(): string[];
	eventEmitter(): CoreEventEmitter;
	initializeNode(): void;
	receiveTrigger(context: ActorNodeTriggerContext): void;
}
declare class OnPointerupActorParamsConfig extends NodeParamsConfig {
	/** @param set which element triggers the event */
	element: ParamTemplate<ParamType.INTEGER>;
}
declare class OnPointerupActorNode extends BaseUserInputActorNode<OnPointerupActorParamsConfig> {
	readonly paramsConfig: OnPointerupActorParamsConfig;
	static type(): ActorType;
	userInputEventNames(): string[];
	eventEmitter(): CoreEventEmitter;
	initializeNode(): void;
	receiveTrigger(context: ActorNodeTriggerContext): void;
}
declare class OnScenePlayStateActorParamsConfig extends NodeParamsConfig {}
declare class OnScenePlayStateActorNode extends TypedActorNode<OnScenePlayStateActorParamsConfig> {
	readonly paramsConfig: OnScenePlayStateActorParamsConfig;
	static type(): ActorType;
	static OUTPUT_NAME_PLAY: string;
	static OUTPUT_NAME_PAUSE: string;
	static OUTPUT_TRIGGER_NAMES: string[];
	initializeNode(): void;
}
declare class OnSceneResetActorParamsConfig extends NodeParamsConfig {}
declare class OnSceneResetActorNode extends TypedActorNode<OnSceneResetActorParamsConfig> {
	readonly paramsConfig: OnSceneResetActorParamsConfig;
	static type(): ActorType;
	initializeNode(): void;
}
declare class OnTickActorParamsConfig extends NodeParamsConfig {}
declare class OnTickActorNode extends TypedActorNode<OnTickActorParamsConfig> {
	readonly paramsConfig: OnTickActorParamsConfig;
	static type(): ActorType;
	initializeNode(): void;
	outputValue(context: ActorNodeTriggerContext, outputName: string): number;
}
declare class OnVideoEventActorParamsConfig extends NodeParamsConfig {
	/** @param video node */
	node: ParamTemplate<ParamType.NODE_PATH>;
}
declare class OnVideoEventActorNode extends TypedActorNode<OnVideoEventActorParamsConfig> {
	readonly paramsConfig: OnVideoEventActorParamsConfig;
	static type(): ActorType.ON_VIDEO_EVENT;
	initializeNode(): void;
	initOnPlay(): void;
	disposeOnPause(): void;
	private _addEventListenersToObjects;
	private _listenerByObjectByVideoNode;
	dispose(): void;
	private _removeVideoNodeEventListener;
}
declare class OnWebXRControllerEventActorParamsConfig extends NodeParamsConfig {
	/** @param  controller index */
	controllerIndex: ParamTemplate<ParamType.INTEGER>;
}
declare class OnWebXRControllerEventActorNode extends TypedActorNode<OnWebXRControllerEventActorParamsConfig> {
	readonly paramsConfig: OnWebXRControllerEventActorParamsConfig;
	static type(): ActorType.ON_WEBXR_CONTROLLER_EVENT;
	initializeNode(): void;
	initOnPlay(): void;
	disposeOnPause(): void;
	private _addEventListenersToObjects;
	private _listenerByObjectByControllerIndex;
	dispose(): void;
	private _removeWebXREventListener;
}
declare class OrActorNode extends BaseLogicOperationActorNode {
	static type(): string;
	outputValue(context: ActorNodeTriggerContext): boolean;
}
declare class ParamButtonPressActorParamsConfig extends NodeParamsConfig {
	/** @param  parameter to update */
	param: ParamTemplate<ParamType.PARAM_PATH>;
}
declare class ParamButtonPressActorNode extends TypedActorNode<ParamButtonPressActorParamsConfig> {
	readonly paramsConfig: ParamButtonPressActorParamsConfig;
	static type(): string;
	initializeNode(): void;
	receiveTrigger(context: ActorNodeTriggerContext): Promise<void>;
}
declare class PauseAudioSourceActorParamsConfig extends NodeParamsConfig {
	/** @param audio node */
	node: ParamTemplate<ParamType.NODE_PATH>;
}
declare abstract class BaseAudioSourceActorNode extends TypedActorNode<PauseAudioSourceActorParamsConfig> {
	readonly paramsConfig: PauseAudioSourceActorParamsConfig;
	initializeNode(): void;
	protected _sourcePlayerContext: ActorNodeTriggerContext | undefined;
	receiveTrigger(context: ActorNodeTriggerContext): void;
	abstract onSourceFound(source: Player, context: ActorNodeTriggerContext): void;
}
declare class PauseAudioSourceActorNode extends BaseAudioSourceActorNode {
	static type(): string;
	onSourceFound(source: Player, context: ActorNodeTriggerContext): void;
}
declare class BaseTriggerAndObjectActorParamsConfig extends NodeParamsConfig {}
declare abstract class BaseTriggerAndObjectActorNode extends TypedActorNode<BaseTriggerAndObjectActorParamsConfig> {
	readonly paramsConfig: BaseTriggerAndObjectActorParamsConfig;
	initializeNode(): void;
	receiveTrigger(context: ActorNodeTriggerContext): void;
	abstract processObject(Object3D: Object3D): void;
}
declare class ParticlesSystemResetActorNode extends BaseTriggerAndObjectActorNode {
	static type(): string;
	processObject(Object3D: Object3D): void;
}
declare class ParticlesSystemStepSimulationActorNode extends BaseTriggerAndObjectActorNode {
	static type(): string;
	processObject(Object3D: Object3D): void;
}
declare class PhysicsPlayerUpdateActorParamsConfig extends NodeParamsConfig {
	/** @param travel speed */
	speed: ParamTemplate<ParamType.FLOAT>;
	/** @param run Allowed */
	runAllowed: ParamTemplate<ParamType.BOOLEAN>;
	/** @param jump Force */
	runSpeedMult: ParamTemplate<ParamType.FLOAT>;
	/** @param jump Allowed */
	jumpAllowed: ParamTemplate<ParamType.BOOLEAN>;
	/** @param jump Force */
	jumpStrength: ParamTemplate<ParamType.FLOAT>;
	/** @param reset if position is below a threshold */
	resetIfBelowThreshold: ParamTemplate<ParamType.BOOLEAN>;
	/** @param height under which the player gets reset */
	resetThreshold: ParamTemplate<ParamType.FLOAT>;
}
declare class PhysicsPlayerUpdateActorNode extends TypedActorNode<PhysicsPlayerUpdateActorParamsConfig> {
	readonly paramsConfig: PhysicsPlayerUpdateActorParamsConfig;
	static type(): string;
	private _playerInputData;
	private _playerComputeInputData;
	initializeNode(): void;
	receiveTrigger(context: ActorNodeTriggerContext): void;
}
declare class PhysicsRBDAddForceActorParamsConfig extends NodeParamsConfig {
	/** @param force */
	force: ParamTemplate<ParamType.VECTOR3>;
}
declare class PhysicsRBDAddForceActorNode extends TypedActorNode<PhysicsRBDAddForceActorParamsConfig> {
	readonly paramsConfig: PhysicsRBDAddForceActorParamsConfig;
	static type(): string;
	initializeNode(): void;
	receiveTrigger(context: ActorNodeTriggerContext): void;
}
declare class PhysicsRBDAddForceAtPointActorParamsConfig extends NodeParamsConfig {
	/** @param force */
	force: ParamTemplate<ParamType.VECTOR3>;
	/** @param point */
	point: ParamTemplate<ParamType.VECTOR3>;
}
declare class PhysicsRBDAddForceAtPointActorNode extends TypedActorNode<PhysicsRBDAddForceAtPointActorParamsConfig> {
	readonly paramsConfig: PhysicsRBDAddForceAtPointActorParamsConfig;
	static type(): string;
	initializeNode(): void;
	receiveTrigger(context: ActorNodeTriggerContext): void;
}
declare class PhysicsRBDAddTorqueActorParamsConfig extends NodeParamsConfig {
	/** @param torque */
	torque: ParamTemplate<ParamType.VECTOR3>;
}
declare class PhysicsRBDAddTorqueActorNode extends TypedActorNode<PhysicsRBDAddTorqueActorParamsConfig> {
	readonly paramsConfig: PhysicsRBDAddTorqueActorParamsConfig;
	static type(): string;
	initializeNode(): void;
	receiveTrigger(context: ActorNodeTriggerContext): void;
}
declare class PhysicsRBDApplyImpulseActorParamsConfig extends NodeParamsConfig {
	/** @param impulse */
	impulse: ParamTemplate<ParamType.VECTOR3>;
}
declare class PhysicsRBDApplyImpulseActorNode extends TypedActorNode<PhysicsRBDApplyImpulseActorParamsConfig> {
	readonly paramsConfig: PhysicsRBDApplyImpulseActorParamsConfig;
	static type(): string;
	initializeNode(): void;
	receiveTrigger(context: ActorNodeTriggerContext): void;
}
declare class PhysicsRBDApplyTorqueImpulseActorParamsConfig extends NodeParamsConfig {
	/** @param impulse */
	impulse: ParamTemplate<ParamType.VECTOR3>;
}
declare class PhysicsRBDApplyTorqueImpulseActorNode extends TypedActorNode<PhysicsRBDApplyTorqueImpulseActorParamsConfig> {
	readonly paramsConfig: PhysicsRBDApplyTorqueImpulseActorParamsConfig;
	static type(): string;
	initializeNode(): void;
	receiveTrigger(context: ActorNodeTriggerContext): void;
}
declare class PhysicsRBDApplyImpulseAtPointActorParamsConfig extends NodeParamsConfig {
	/** @param impulse */
	impulse: ParamTemplate<ParamType.VECTOR3>;
	/** @param point */
	point: ParamTemplate<ParamType.VECTOR3>;
}
declare class PhysicsRBDApplyImpulseAtPointActorNode extends TypedActorNode<PhysicsRBDApplyImpulseAtPointActorParamsConfig> {
	readonly paramsConfig: PhysicsRBDApplyImpulseAtPointActorParamsConfig;
	static type(): string;
	initializeNode(): void;
	receiveTrigger(context: ActorNodeTriggerContext): void;
}
declare class PhysicsRBDRemoveActorParamsConfig extends NodeParamsConfig {}
declare class PhysicsRBDRemoveActorNode extends TypedActorNode<PhysicsRBDRemoveActorParamsConfig> {
	readonly paramsConfig: PhysicsRBDRemoveActorParamsConfig;
	static type(): string;
	initializeNode(): void;
	receiveTrigger(context: ActorNodeTriggerContext): void;
}
declare class PhysicsRBDResetAllActorParamsConfig extends NodeParamsConfig {
	/** @param wakeup */
	wakeup: ParamTemplate<ParamType.BOOLEAN>;
}
declare class PhysicsRBDResetAllActorNode extends TypedActorNode<PhysicsRBDResetAllActorParamsConfig> {
	readonly paramsConfig: PhysicsRBDResetAllActorParamsConfig;
	static type(): string;
	initializeNode(): void;
	receiveTrigger(context: ActorNodeTriggerContext): void;
}
declare class PhysicsRBDResetForcesActorParamsConfig extends NodeParamsConfig {
	/** @param wakeup */
	wakeup: ParamTemplate<ParamType.BOOLEAN>;
}
declare class PhysicsRBDResetForcesActorNode extends TypedActorNode<PhysicsRBDResetForcesActorParamsConfig> {
	readonly paramsConfig: PhysicsRBDResetForcesActorParamsConfig;
	static type(): string;
	initializeNode(): void;
	receiveTrigger(context: ActorNodeTriggerContext): void;
}
declare class PhysicsRBDResetTorquesActorParamsConfig extends NodeParamsConfig {
	/** @param wakeup */
	wakeup: ParamTemplate<ParamType.BOOLEAN>;
}
declare class PhysicsRBDResetTorquesActorNode extends TypedActorNode<PhysicsRBDResetTorquesActorParamsConfig> {
	readonly paramsConfig: PhysicsRBDResetTorquesActorParamsConfig;
	static type(): string;
	initializeNode(): void;
	receiveTrigger(context: ActorNodeTriggerContext): void;
}
declare class PhysicsWorldResetActorNode extends BaseTriggerAndObjectActorNode {
	static type(): string;
	processObject(Object3D: Object3D): void;
}
declare class PhysicsWorldStepSimulationActorNode extends BaseTriggerAndObjectActorNode {
	static type(): string;
	processObject(Object3D: Object3D): void;
}
declare class PlaneActorParamsConfig extends NodeParamsConfig {
	/** @param a unit length vector defining the normal of the plane */
	normal: ParamTemplate<ParamType.VECTOR3>;
	/** @param the signed distance from the origin to the plane */
	constant: ParamTemplate<ParamType.FLOAT>;
}
declare class PlaneActorNode extends TypedActorNode<PlaneActorParamsConfig> {
	paramsConfig: PlaneActorParamsConfig;
	static type(): string;
	initializeNode(): void;
	private _plane;
	outputValue(context: ActorNodeTriggerContext): Plane;
}
declare enum PlayerUpdateOutput {
	VELOCITY = 'velocity',
	ON_GROUND = 'onGround',
}
declare class PlayerUpdateActorParamsConfig extends NodeParamsConfig {
	/** @param travel speed */
	speed: ParamTemplate<ParamType.FLOAT>;
	/** @param run Allowed */
	runAllowed: ParamTemplate<ParamType.BOOLEAN>;
	/** @param jump Force */
	runSpeedMult: ParamTemplate<ParamType.FLOAT>;
	/** @param jump Allowed */
	jumpAllowed: ParamTemplate<ParamType.BOOLEAN>;
	/** @param jump Force */
	jumpStrength: ParamTemplate<ParamType.FLOAT>;
	/** @param physics Steps */
	physicsSteps: ParamTemplate<ParamType.INTEGER>;
	/** @param gravity */
	gravity: ParamTemplate<ParamType.VECTOR3>;
	/** @param collision Capsule Radius */
	capsuleRadius: ParamTemplate<ParamType.FLOAT>;
	/** @param collision Capsule Height */
	capsuleHeight: ParamTemplate<ParamType.FLOAT>;
}
declare class PlayerUpdateActorNode extends TypedActorNode<PlayerUpdateActorParamsConfig> {
	readonly paramsConfig: PlayerUpdateActorParamsConfig;
	static type(): string;
	private _playerInputData;
	private _playerComputeInputData;
	private _playerByObject3D;
	initializeNode(): void;
	receiveTrigger(context: ActorNodeTriggerContext): void;
	outputValue(context: ActorNodeTriggerContext, outputName: PlayerUpdateOutput): boolean | 0 | Vector3;
}
declare class PlayAnimationActorParamsConfig extends NodeParamsConfig {
	/** @param manual trigger */
	trigger: ParamTemplate<ParamType.BUTTON>;
	/** @param include children */
	node: ParamTemplate<ParamType.NODE_PATH>;
}
declare class PlayAnimationActorNode extends TypedActorNode<PlayAnimationActorParamsConfig> {
	readonly paramsConfig: PlayAnimationActorParamsConfig;
	static type(): string;
	initializeNode(): void;
	receiveTrigger(context: ActorNodeTriggerContext): Promise<void>;
	private _triggerAnimationStarted;
	private _triggerAnimationCompleted;
}
declare class PlayAudioSourceActorNode extends BaseAudioSourceActorNode {
	static type(): string;
	private _sourcePlayer;
	onSourceFound(source: Player): void;
	dispose(): void;
	private _addPlayerEvent;
	private _removePlayerEvent;
	private _onSourcePlayerStopBound;
	private _onSourcePlayerStop;
}
declare class PlayInstrumentNoteActorParamsConfig extends NodeParamsConfig {
	/** @param audio node */
	node: ParamTemplate<ParamType.NODE_PATH>;
	/** @param note */
	note: ParamTemplate<ParamType.STRING>;
	/** @param duration */
	duration: ParamTemplate<ParamType.FLOAT>;
}
declare class PlayInstrumentNoteActorNode extends TypedActorNode<PlayInstrumentNoteActorParamsConfig> {
	readonly paramsConfig: PlayInstrumentNoteActorParamsConfig;
	static type(): string;
	initializeNode(): void;
	private _lastInstrumentType;
	private _lastNote;
	receiveTrigger(context: ActorNodeTriggerContext): void;
	__lastInstrumentType(): InstrumentType | undefined;
	__lastNote(): string | undefined;
}
declare class PressButtonParamActorParamsConfig extends NodeParamsConfig {
	/** @param the parameter to update */
	param: ParamTemplate<ParamType.PARAM_PATH>;
}
declare class PressButtonParamActorNode extends TypedActorNode<PressButtonParamActorParamsConfig> {
	readonly paramsConfig: PressButtonParamActorParamsConfig;
	static type(): string;
	initializeNode(): void;
	receiveTrigger(context: ActorNodeTriggerContext): Promise<void>;
}
declare const PowActorNode_base: typeof BaseMathFunctionActorNode;
declare class PowActorNode extends PowActorNode_base {
	paramDefaultValue(name: string): number;
	protected _applyOperation<T extends number>(arg1: T, arg2: T): any;
}
declare const RandActorNode_base: typeof BaseMathFunctionActorNode;
declare class RandActorNode extends RandActorNode_base {
	paramDefaultValue(name: string): number;
	protected _applyOperation<T extends number>(arg1: T, arg2: T): any;
}
declare class RandomActorParamsConfig extends NodeParamsConfig {}
declare class RandomActorNode extends TypedActorNode<RandomActorParamsConfig> {
	readonly paramsConfig: RandomActorParamsConfig;
	static type(): string;
	initializeNode(): void;
	outputValue(context: ActorNodeTriggerContext): number;
}
declare class RayActorParamsConfig extends NodeParamsConfig {
	/** @param ray origin */
	origin: ParamTemplate<ParamType.VECTOR3>;
	/** @param ray direction */
	direction: ParamTemplate<ParamType.VECTOR3>;
}
declare class RayActorNode extends TypedActorNode<RayActorParamsConfig> {
	paramsConfig: RayActorParamsConfig;
	static type(): string;
	initializeNode(): void;
	private _ray;
	outputValue(
		context: ActorNodeTriggerContext
	): ReturnValueTypeByActorConnectionPointType[ActorConnectionPointType.RAY];
}
export interface RayProcessData {
	ray?: Ray;
	plane?: Plane;
}
declare class BaseRayPlaneActorParamsConfig extends NodeParamsConfig {}
declare abstract class BaseRayPlaneActorNode<
	T extends ActorConnectionPointType
> extends TypedActorNode<BaseRayPlaneActorParamsConfig> {
	paramsConfig: BaseRayPlaneActorParamsConfig;
	initializeNode(): void;
	protected abstract _expectedOutputName(index: number): string;
	protected abstract _expectedOutputType(): T;
	protected _processData: RayProcessData;
	protected abstract _processRayData(): ReturnValueTypeByActorConnectionPointType[T];
	protected _expectedInputName(index: number): ActorConnectionPointType;
	protected _expectedInputType(): ActorConnectionPointType[];
	outputValue(context: ActorNodeTriggerContext): ReturnValueTypeByActorConnectionPointType[T];
}
declare class RayDistanceToPlaneActorNode extends BaseRayPlaneActorNode<ActorConnectionPointType.FLOAT> {
	static type(): string;
	protected _expectedOutputName(index: number): string;
	protected _expectedOutputType(): ActorConnectionPointType.FLOAT;
	protected _processRayData(): number;
}
declare class RayFromCameraActorParamsConfig extends NodeParamsConfig {
	/** @param x position in screen space  */
	x: ParamTemplate<ParamType.FLOAT>;
	/** @param y position in screen space */
	y: ParamTemplate<ParamType.FLOAT>;
}
declare class RayFromCameraActorNode extends TypedActorNode<RayFromCameraActorParamsConfig> {
	paramsConfig: RayFromCameraActorParamsConfig;
	static type(): ActorType;
	initializeNode(): void;
	outputValue(
		context: ActorNodeTriggerContext
	): ReturnValueTypeByActorConnectionPointType[ActorConnectionPointType.RAY] | undefined;
}
declare class RayFromCursorActorParamsConfig extends NodeParamsConfig {
	/** @param set which element triggers the event */
	element: ParamTemplate<ParamType.INTEGER>;
}
declare class RayFromCursorActorNode extends BaseUserInputActorNode<RayFromCursorActorParamsConfig> {
	paramsConfig: RayFromCursorActorParamsConfig;
	static type(): ActorType;
	userInputEventNames(): string[];
	eventEmitter(): CoreEventEmitter;
	initializeNode(): void;
	outputValue(
		context: ActorNodeTriggerContext
	): ReturnValueTypeByActorConnectionPointType[ActorConnectionPointType.RAY] | undefined;
}
export interface RayProcessData {
	ray?: Ray;
	box3?: Box3;
}
declare class BaseRayBox3ActorParamsConfig extends NodeParamsConfig {}
declare abstract class BaseRayBox3ActorNode<
	T extends ActorConnectionPointType
> extends TypedActorNode<BaseRayBox3ActorParamsConfig> {
	paramsConfig: BaseRayBox3ActorParamsConfig;
	initializeNode(): void;
	protected abstract _expectedOutputName(index: number): string;
	protected abstract _expectedOutputType(): T;
	protected _processData: RayProcessData;
	protected abstract _processRayData(): ReturnValueTypeByActorConnectionPointType[T];
	protected _expectedInputName(index: number): ActorConnectionPointType;
	protected _expectedInputType(): ActorConnectionPointType[];
	outputValue(context: ActorNodeTriggerContext): ReturnValueTypeByActorConnectionPointType[T];
}
declare class RayIntersectBoxActorNode extends BaseRayBox3ActorNode<ActorConnectionPointType.VECTOR3> {
	static type(): string;
	protected _expectedOutputName(index: number): string;
	protected _expectedOutputType(): ActorConnectionPointType.VECTOR3;
	private _target;
	protected _processRayData(): Vector3;
}
export interface RayProcessData {
	ray?: Ray;
	Object3D?: Object3D;
}
declare class BaseRayObjectActorParamsConfig extends NodeParamsConfig {}
declare abstract class BaseRayObjectActorNode<
	T extends ActorConnectionPointType
> extends TypedActorNode<BaseRayObjectActorParamsConfig> {
	paramsConfig: BaseRayObjectActorParamsConfig;
	initializeNode(): void;
	protected abstract _expectedOutputName(index: number): string;
	protected abstract _expectedOutputType(): T;
	protected _processData: RayProcessData;
	protected abstract _processRayData(context: ActorNodeTriggerContext): ReturnValueTypeByActorConnectionPointType[T];
	protected _expectedInputName(index: number): ActorConnectionPointType;
	protected _expectedInputType(): ActorConnectionPointType[];
	outputValue(context: ActorNodeTriggerContext): ReturnValueTypeByActorConnectionPointType[T];
}
declare class RayIntersectObjectActorNode extends BaseRayObjectActorNode<ActorConnectionPointType.INTERSECTION> {
	static type(): string;
	protected _expectedOutputName(index: number): ActorConnectionPointType;
	protected _expectedOutputType(): ActorConnectionPointType.INTERSECTION;
	private _raycaster;
	protected _processRayData(context: ActorNodeTriggerContext): Intersection<Object3D<Event>>;
}
declare class RayIntersectPlaneActorNode extends BaseRayPlaneActorNode<ActorConnectionPointType.VECTOR3> {
	static type(): string;
	protected _expectedOutputName(index: number): string;
	protected _expectedOutputType(): ActorConnectionPointType.VECTOR3;
	private _target;
	protected _processRayData(): Vector3;
}
export interface RayProcessData {
	ray?: Ray;
	sphere?: Sphere;
}
declare class BaseRaySphereActorParamsConfig extends NodeParamsConfig {}
declare abstract class BaseRaySphereActorNode<
	T extends ActorConnectionPointType
> extends TypedActorNode<BaseRaySphereActorParamsConfig> {
	paramsConfig: BaseRaySphereActorParamsConfig;
	initializeNode(): void;
	protected abstract _expectedOutputName(index: number): string;
	protected abstract _expectedOutputType(): T;
	protected _processData: RayProcessData;
	protected abstract _processRayData(): ReturnValueTypeByActorConnectionPointType[T];
	protected _expectedInputName(index: number): ActorConnectionPointType;
	protected _expectedInputType(): ActorConnectionPointType[];
	outputValue(context: ActorNodeTriggerContext): ReturnValueTypeByActorConnectionPointType[T];
}
declare class RayIntersectSphereActorNode extends BaseRaySphereActorNode<ActorConnectionPointType.VECTOR3> {
	static type(): string;
	protected _expectedOutputName(index: number): string;
	protected _expectedOutputType(): ActorConnectionPointType.VECTOR3;
	private _target;
	protected _processRayData(): Vector3;
}
declare class RayIntersectsBoxActorNode extends BaseRayBox3ActorNode<ActorConnectionPointType.BOOLEAN> {
	static type(): string;
	protected _expectedOutputName(index: number): string;
	protected _expectedOutputType(): ActorConnectionPointType.BOOLEAN;
	protected _processRayData(): boolean;
}
declare class RayIntersectsObjectActorNode extends BaseRayObjectActorNode<ActorConnectionPointType.BOOLEAN> {
	static type(): string;
	protected _expectedOutputName(index: number): string;
	protected _expectedOutputType(): ActorConnectionPointType.BOOLEAN;
	private _raycaster;
	protected _processRayData(): boolean;
}
declare class RayIntersectsPlaneActorNode extends BaseRayPlaneActorNode<ActorConnectionPointType.BOOLEAN> {
	static type(): string;
	protected _expectedOutputName(index: number): string;
	protected _expectedOutputType(): ActorConnectionPointType.BOOLEAN;
	protected _processRayData(): boolean;
}
declare class RayIntersectsSphereActorNode extends BaseRaySphereActorNode<ActorConnectionPointType.BOOLEAN> {
	static type(): string;
	protected _expectedOutputName(index: number): string;
	protected _expectedOutputType(): ActorConnectionPointType.BOOLEAN;
	protected _processRayData(): boolean;
}
declare const RoundActorNode_base: typeof BaseMathFunctionActorNode;
declare class RoundActorNode extends RoundActorNode_base {
	protected _applyOperation<T extends number>(arg1: T): any;
}
declare class SetGeometryPositionsActorParamsConfig extends NodeParamsConfig {}
declare class SetGeometryPositionsActorNode extends TypedActorNode<SetGeometryPositionsActorParamsConfig> {
	readonly paramsConfig: SetGeometryPositionsActorParamsConfig;
	static type(): string;
	initializeNode(): void;
	paramDefaultValue(name: string): number | boolean;
	expectedInputTypes(): ActorConnectionPointType[];
	protected _expectedInputName(index: number): string;
	protected _expectedOutputTypes(): ActorConnectionPointType[];
	protected _expectedOutputNames(i: number): ActorConnectionPointType;
	receiveTrigger(context: ActorNodeTriggerContext): void;
}
declare class SetGeometryInstanceAttributeActorParamsConfig extends NodeParamsConfig {
	/** @param manual trigger */
	trigger: ParamTemplate<ParamType.BUTTON>;
	/** @param attribute name */
	attribName: ParamTemplate<ParamType.STRING>;
	/** @param attribute size */
	size: ParamTemplate<ParamType.INTEGER>;
}
declare class SetGeometryInstanceAttributeActorNode extends TypedActorNode<SetGeometryInstanceAttributeActorParamsConfig> {
	readonly paramsConfig: SetGeometryInstanceAttributeActorParamsConfig;
	static type(): string;
	initializeNode(): void;
	private _currentConnectionType;
	paramDefaultValue(name: string): number | boolean;
	protected _expectedInputName(index: number): string;
	receiveTrigger(context: ActorNodeTriggerContext): void;
}
declare class SetGeometryInstancePositionsActorParamsConfig extends NodeParamsConfig {}
declare class SetGeometryInstancePositionsActorNode extends TypedActorNode<SetGeometryInstancePositionsActorParamsConfig> {
	readonly paramsConfig: SetGeometryInstancePositionsActorParamsConfig;
	static type(): string;
	initializeNode(): void;
	paramDefaultValue(name: string): number | boolean;
	expectedInputTypes(): ActorConnectionPointType[];
	protected _expectedOutputTypes(): ActorConnectionPointType[];
	protected _expectedInputName(index: number): string;
	receiveTrigger(context: ActorNodeTriggerContext): void;
}
declare class SetGeometryInstanceQuaternionsActorParamsConfig extends NodeParamsConfig {}
declare class SetGeometryInstanceQuaternionsActorNode extends TypedActorNode<SetGeometryInstanceQuaternionsActorParamsConfig> {
	readonly paramsConfig: SetGeometryInstanceQuaternionsActorParamsConfig;
	static type(): string;
	initializeNode(): void;
	paramDefaultValue(name: string): number | boolean;
	expectedInputTypes(): ActorConnectionPointType[];
	protected _expectedOutputTypes(): ActorConnectionPointType[];
	protected _expectedInputName(index: number): string;
	receiveTrigger(context: ActorNodeTriggerContext): void;
}
declare class SetGeometryInstanceScalesActorParamsConfig extends NodeParamsConfig {}
declare class SetGeometryInstanceScalesActorNode extends TypedActorNode<SetGeometryInstanceScalesActorParamsConfig> {
	readonly paramsConfig: SetGeometryInstanceScalesActorParamsConfig;
	static type(): string;
	initializeNode(): void;
	paramDefaultValue(name: string): number | boolean;
	expectedInputTypes(): ActorConnectionPointType[];
	protected _expectedOutputTypes(): ActorConnectionPointType[];
	protected _expectedInputName(index: number): string;
	receiveTrigger(context: ActorNodeTriggerContext): void;
}
declare class SetGeometryInstanceTransformsActorParamsConfig extends NodeParamsConfig {}
declare class SetGeometryInstanceTransformsActorNode extends TypedActorNode<SetGeometryInstanceTransformsActorParamsConfig> {
	readonly paramsConfig: SetGeometryInstanceTransformsActorParamsConfig;
	static type(): string;
	initializeNode(): void;
	paramDefaultValue(name: string): number | boolean;
	expectedInputTypes(): ActorConnectionPointType[];
	protected _expectedOutputTypes(): ActorConnectionPointType[];
	protected _expectedInputName(index: number): string;
	receiveTrigger(context: ActorNodeTriggerContext): void;
}
declare class BaseSetMaterialColorActorParamsConfig extends NodeParamsConfig {
	/** @param color */
	color: ParamTemplate<ParamType.COLOR>;
	/** @param lerp factor */
	lerp: ParamTemplate<ParamType.FLOAT>;
}
declare abstract class BaseSetMaterialColorActorNode extends TypedActorNode<BaseSetMaterialColorActorParamsConfig> {
	readonly paramsConfig: BaseSetMaterialColorActorParamsConfig;
	initializeNode(): void;
	receiveTrigger(context: ActorNodeTriggerContext): void;
	protected abstract _getMaterialColorProperty(material: Material): Color;
	private _updateMaterial;
}
declare class SetMaterialColorActorNode extends BaseSetMaterialColorActorNode {
	static type(): string;
	protected _getMaterialColorProperty(material: Material): Color;
}
declare class SetMaterialEmissiveColorActorNode extends BaseSetMaterialColorActorNode {
	static type(): string;
	protected _getMaterialColorProperty(material: Material): Color;
}
export declare type KeysOfType<T, U, B = false> = {
	[P in keyof T]: B extends true
		? T[P] extends U
			? U extends T[P]
				? P
				: never
			: never
		: T[P] extends U
		? P
		: never;
}[keyof T];
export declare type PickByType<T, U, B = false> = Pick<T, KeysOfType<T, U, B>>;
declare class BaseSetMaterialFloatActorParamsConfig extends NodeParamsConfig {
	/** @param float */
	float: ParamTemplate<ParamType.FLOAT>;
	/** @param lerp factor */
	lerp: ParamTemplate<ParamType.FLOAT>;
}
declare abstract class BaseSetMaterialFloatActorNode extends TypedActorNode<BaseSetMaterialFloatActorParamsConfig> {
	readonly paramsConfig: BaseSetMaterialFloatActorParamsConfig;
	initializeNode(): void;
	receiveTrigger(context: ActorNodeTriggerContext): void;
	protected abstract _getMaterialColorPropertyName(): keyof PickByType<Material, number>;
	private _updateMaterial;
}
declare class SetMaterialOpacityActorNode extends BaseSetMaterialFloatActorNode {
	static type(): string;
	protected _getMaterialColorPropertyName(): 'opacity';
}
export declare type AvailableActorType =
	| ActorConnectionPointType.COLOR
	| ActorConnectionPointType.FLOAT
	| ActorConnectionPointType.INTEGER
	| ActorConnectionPointType.VECTOR2
	| ActorConnectionPointType.VECTOR3
	| ActorConnectionPointType.VECTOR4;
declare class SetMaterialUniformActorParamsConfig extends NodeParamsConfig {
	/** @param add prefix */
	addPrefix: ParamTemplate<ParamType.BOOLEAN>;
	/** @param uniform name */
	/** @param uniform type */
	type: ParamTemplate<ParamType.INTEGER>;
}
declare class SetMaterialUniformActorNode extends TypedActorNode<SetMaterialUniformActorParamsConfig> {
	readonly paramsConfig: SetMaterialUniformActorParamsConfig;
	static type(): string;
	initializeNode(): void;
	private _expectedInputType;
	paramDefaultValue(name: 'lerp'): number;
	uniformType(): AvailableActorType;
	setUniformType(type: AvailableActorType): void;
	receiveTrigger(context: ActorNodeTriggerContext): void;
	private _updateMaterial;
}
declare class SetObjectAttributeActorParamsConfig extends NodeParamsConfig {
	/** @param manual trigger */
	trigger: ParamTemplate<ParamType.BUTTON>;
	/** @param attribute name */
	attribName: ParamTemplate<ParamType.STRING>;
	/** @param attribute type */
	type: ParamTemplate<ParamType.INTEGER>;
}
declare class SetObjectAttributeActorNode extends TypedActorNode<SetObjectAttributeActorParamsConfig> {
	readonly paramsConfig: SetObjectAttributeActorParamsConfig;
	static type(): string;
	static INPUT_NAME_VAL: string;
	initializeNode(): void;
	private _currentConnectionType;
	setAttribType(type: ActorConnectionPointType): void;
	receiveTrigger(context: ActorNodeTriggerContext): void;
}
declare class SetObjectCastShadowActorParamsConfig extends NodeParamsConfig {
	/** @param target castShadow state */
	castShadow: ParamTemplate<ParamType.BOOLEAN>;
}
declare class SetObjectCastShadowActorNode extends TypedActorNode<SetObjectCastShadowActorParamsConfig> {
	readonly paramsConfig: SetObjectCastShadowActorParamsConfig;
	static type(): string;
	initializeNode(): void;
	receiveTrigger(context: ActorNodeTriggerContext): void;
}
declare class SetObjectFrustumCulledActorParamsConfig extends NodeParamsConfig {
	/** @param target FrustumCulled state */
	frustumCulled: ParamTemplate<ParamType.BOOLEAN>;
}
declare class SetObjectFrustumCulledActorNode extends TypedActorNode<SetObjectFrustumCulledActorParamsConfig> {
	readonly paramsConfig: SetObjectFrustumCulledActorParamsConfig;
	static type(): string;
	initializeNode(): void;
	receiveTrigger(context: ActorNodeTriggerContext): void;
}
declare class SetObjectLookAtActorParamsConfig extends NodeParamsConfig {
	/** @param targetPosition */
	targetPosition: ParamTemplate<ParamType.VECTOR3>;
	/** @param up */
	up: ParamTemplate<ParamType.VECTOR3>;
	/** @param lerp factor */
	lerp: ParamTemplate<ParamType.FLOAT>;
	/** @param invertDirection */
	invertDirection: ParamTemplate<ParamType.BOOLEAN>;
	/** @param sets if the matrix should be updated as the animation progresses */
	updateMatrix: ParamTemplate<ParamType.BOOLEAN>;
}
declare class SetObjectLookAtActorNode extends TypedActorNode<SetObjectLookAtActorParamsConfig> {
	readonly paramsConfig: SetObjectLookAtActorParamsConfig;
	static type(): ActorType;
	initializeNode(): void;
	receiveTrigger(context: ActorNodeTriggerContext): void;
}
declare class SetObjectMaterialColorActorParamsConfig extends NodeParamsConfig {
	/** @param color */
	color: ParamTemplate<ParamType.COLOR>;
	/** @param lerp factor */
	lerp: ParamTemplate<ParamType.FLOAT>;
}
declare class SetObjectMaterialColorActorNode extends TypedActorNode<SetObjectMaterialColorActorParamsConfig> {
	readonly paramsConfig: SetObjectMaterialColorActorParamsConfig;
	static type(): string;
	initializeNode(): void;
	receiveTrigger(context: ActorNodeTriggerContext): void;
	private _updateMaterial;
}
declare class SetObjectMaterialActorNode extends ParamlessTypedActorNode {
	static type(): string;
	initializeNode(): void;
	receiveTrigger(context: ActorNodeTriggerContext): void;
}
declare class SetObjectMatrixActorParamsConfig extends NodeParamsConfig {}
declare class SetObjectMatrixActorNode extends TypedActorNode<SetObjectMatrixActorParamsConfig> {
	readonly paramsConfig: SetObjectMatrixActorParamsConfig;
	static type(): string;
	initializeNode(): void;
	receiveTrigger(context: ActorNodeTriggerContext): void;
}
declare class SetObjectMatrixAutoUpdateActorParamsConfig extends NodeParamsConfig {
	/** @param target MatrixAutoUpdate state */
	matrixAutoUpdate: ParamTemplate<ParamType.BOOLEAN>;
}
declare class SetObjectMatrixAutoUpdateActorNode extends TypedActorNode<SetObjectMatrixAutoUpdateActorParamsConfig> {
	readonly paramsConfig: SetObjectMatrixAutoUpdateActorParamsConfig;
	static type(): string;
	initializeNode(): void;
	receiveTrigger(context: ActorNodeTriggerContext): void;
}
declare class SetObjectPolarTransformActorParamsConfig extends NodeParamsConfig {
	/** @param center of the transform */
	center: ParamTemplate<ParamType.VECTOR3>;
	/** @param moves the objects along the longitude, which is equivalent to a rotation on the y axis */
	longitude: ParamTemplate<ParamType.FLOAT>;
	/** @param moves the objects along the latitude, which is equivalent to a rotation on the z or x axis */
	latitude: ParamTemplate<ParamType.FLOAT>;
	/** @param moves the point aways from the center */
	depth: ParamTemplate<ParamType.FLOAT>;
}
declare class SetObjectPolarTransformActorNode extends TypedActorNode<SetObjectPolarTransformActorParamsConfig> {
	readonly paramsConfig: SetObjectPolarTransformActorParamsConfig;
	static type(): string;
	initializeNode(): void;
	receiveTrigger(context: ActorNodeTriggerContext): void;
}
declare class SetObjectPositionActorParamsConfig extends NodeParamsConfig {
	/** @param target position */
	position: ParamTemplate<ParamType.VECTOR3>;
	/** @param lerp factor */
	lerp: ParamTemplate<ParamType.FLOAT>;
	/** @param sets if the matrix should be updated as the animation progresses */
	updateMatrix: ParamTemplate<ParamType.BOOLEAN>;
}
declare class SetObjectPositionActorNode extends TypedActorNode<SetObjectPositionActorParamsConfig> {
	readonly paramsConfig: SetObjectPositionActorParamsConfig;
	static type(): string;
	initializeNode(): void;
	receiveTrigger(context: ActorNodeTriggerContext): void;
}
declare class SetObjectReceiveShadowActorParamsConfig extends NodeParamsConfig {
	/** @param target ReceiveShadow state */
	receiveShadow: ParamTemplate<ParamType.BOOLEAN>;
}
declare class SetObjectReceiveShadowActorNode extends TypedActorNode<SetObjectReceiveShadowActorParamsConfig> {
	readonly paramsConfig: SetObjectReceiveShadowActorParamsConfig;
	static type(): string;
	initializeNode(): void;
	receiveTrigger(context: ActorNodeTriggerContext): void;
}
declare class SetObjectRotationActorParamsConfig extends NodeParamsConfig {
	/** @param rotation order */
	rotationOrder: ParamTemplate<ParamType.INTEGER>;
	/** @param rotation */
	rotation: ParamTemplate<ParamType.VECTOR3>;
	/** @param lerp factor */
	lerp: ParamTemplate<ParamType.FLOAT>;
	/** @param sets if the matrix should be updated as the animation progresses */
	updateMatrix: ParamTemplate<ParamType.BOOLEAN>;
}
declare class SetObjectRotationActorNode extends TypedActorNode<SetObjectRotationActorParamsConfig> {
	readonly paramsConfig: SetObjectRotationActorParamsConfig;
	static type(): string;
	initializeNode(): void;
	receiveTrigger(context: ActorNodeTriggerContext): void;
}
declare class SetObjectScaleActorParamsConfig extends NodeParamsConfig {
	/** @param target scale */
	scale: ParamTemplate<ParamType.VECTOR3>;
	/** @param target scale */
	mult: ParamTemplate<ParamType.FLOAT>;
	/** @param lerp factor */
	lerp: ParamTemplate<ParamType.FLOAT>;
	/** @param sets if the matrix should be updated as the animation progresses */
	updateMatrix: ParamTemplate<ParamType.BOOLEAN>;
}
declare class SetObjectScaleActorNode extends TypedActorNode<SetObjectScaleActorParamsConfig> {
	readonly paramsConfig: SetObjectScaleActorParamsConfig;
	static type(): string;
	initializeNode(): void;
	receiveTrigger(context: ActorNodeTriggerContext): void;
}
declare class SetObjectVisibleActorParamsConfig extends NodeParamsConfig {
	/** @param target visible state */
	visible: ParamTemplate<ParamType.BOOLEAN>;
}
declare class SetObjectVisibleActorNode extends TypedActorNode<SetObjectVisibleActorParamsConfig> {
	readonly paramsConfig: SetObjectVisibleActorParamsConfig;
	static type(): string;
	initializeNode(): void;
	receiveTrigger(context: ActorNodeTriggerContext): void;
}
declare class SetPhysicsRBDAngularVelocityActorParamsConfig extends NodeParamsConfig {
	/** @param target velocity */
	velocity: ParamTemplate<ParamType.VECTOR3>;
	/** @param lerp factor */
	lerp: ParamTemplate<ParamType.FLOAT>;
}
declare class SetPhysicsRBDAngularVelocityActorNode extends TypedActorNode<SetPhysicsRBDAngularVelocityActorParamsConfig> {
	readonly paramsConfig: SetPhysicsRBDAngularVelocityActorParamsConfig;
	static type(): string;
	initializeNode(): void;
	receiveTrigger(context: ActorNodeTriggerContext): void;
}
declare class SetPhysicsRBDLinearVelocityActorParamsConfig extends NodeParamsConfig {
	/** @param target position */
	velocity: ParamTemplate<ParamType.VECTOR3>;
	/** @param lerp factor */
	lerp: ParamTemplate<ParamType.FLOAT>;
}
declare class SetPhysicsRBDLinearVelocityActorNode extends TypedActorNode<SetPhysicsRBDLinearVelocityActorParamsConfig> {
	readonly paramsConfig: SetPhysicsRBDLinearVelocityActorParamsConfig;
	static type(): string;
	initializeNode(): void;
	receiveTrigger(context: ActorNodeTriggerContext): void;
}
declare class SetPhysicsRBDPositionActorParamsConfig extends NodeParamsConfig {
	/** @param target position */
	position: ParamTemplate<ParamType.VECTOR3>;
	/** @param lerp factor */
	lerp: ParamTemplate<ParamType.FLOAT>;
}
declare class SetPhysicsRBDPositionActorNode extends TypedActorNode<SetPhysicsRBDPositionActorParamsConfig> {
	readonly paramsConfig: SetPhysicsRBDPositionActorParamsConfig;
	static type(): ActorType;
	initializeNode(): void;
	receiveTrigger(context: ActorNodeTriggerContext): void;
}
declare class SetPhysicsRBDRotationActorParamsConfig extends NodeParamsConfig {
	/** @param target rotation */
	quaternion: ParamTemplate<ParamType.VECTOR4>;
	/** @param lerp factor */
	lerp: ParamTemplate<ParamType.FLOAT>;
}
declare class SetPhysicsRBDRotationActorNode extends TypedActorNode<SetPhysicsRBDRotationActorParamsConfig> {
	readonly paramsConfig: SetPhysicsRBDRotationActorParamsConfig;
	static type(): string;
	initializeNode(): void;
	receiveTrigger(context: ActorNodeTriggerContext): void;
}
declare class SetPhysicsRBDCapsulePropertyActorParamsConfig extends NodeParamsConfig {
	/** @param target scale */
	scale: ParamTemplate<ParamType.FLOAT>;
	/** @param lerp factor */
	lerp: ParamTemplate<ParamType.FLOAT>;
	/** @param sets if the matrix should be updated as the animation progresses */
	updateMatrix: ParamTemplate<ParamType.BOOLEAN>;
}
declare class SetPhysicsRBDCapsulePropertyActorNode extends TypedActorNode<SetPhysicsRBDCapsulePropertyActorParamsConfig> {
	readonly paramsConfig: SetPhysicsRBDCapsulePropertyActorParamsConfig;
	static type(): string;
	initializeNode(): void;
	receiveTrigger(context: ActorNodeTriggerContext): void;
}
declare class SetPhysicsRBDConePropertyActorParamsConfig extends NodeParamsConfig {
	/** @param target radius */
	radius: ParamTemplate<ParamType.FLOAT>;
	/** @param target height */
	height: ParamTemplate<ParamType.FLOAT>;
	/** @param lerp factor */
	lerp: ParamTemplate<ParamType.FLOAT>;
	/** @param sets if the matrix should be updated as the animation progresses */
	updateMatrix: ParamTemplate<ParamType.BOOLEAN>;
}
declare class SetPhysicsRBDConePropertyActorNode extends TypedActorNode<SetPhysicsRBDConePropertyActorParamsConfig> {
	readonly paramsConfig: SetPhysicsRBDConePropertyActorParamsConfig;
	static type(): string;
	initializeNode(): void;
	receiveTrigger(context: ActorNodeTriggerContext): void;
}
declare class SetPhysicsRBDCylinderPropertyActorParamsConfig extends NodeParamsConfig {
	/** @param target radius */
	radius: ParamTemplate<ParamType.FLOAT>;
	/** @param target height */
	height: ParamTemplate<ParamType.FLOAT>;
	/** @param lerp factor */
	lerp: ParamTemplate<ParamType.FLOAT>;
	/** @param sets if the matrix should be updated as the animation progresses */
	updateMatrix: ParamTemplate<ParamType.BOOLEAN>;
}
declare class SetPhysicsRBDCylinderPropertyActorNode extends TypedActorNode<SetPhysicsRBDCylinderPropertyActorParamsConfig> {
	readonly paramsConfig: SetPhysicsRBDCylinderPropertyActorParamsConfig;
	static type(): string;
	initializeNode(): void;
	receiveTrigger(context: ActorNodeTriggerContext): void;
}
declare class SetPhysicsRBDCuboidPropertyActorParamsConfig extends NodeParamsConfig {
	/** @param target sizes */
	sizes: ParamTemplate<ParamType.VECTOR3>;
	/** @param target size */
	size: ParamTemplate<ParamType.FLOAT>;
	/** @param lerp factor */
	lerp: ParamTemplate<ParamType.FLOAT>;
	/** @param sets if the matrix should be updated as the animation progresses */
	updateMatrix: ParamTemplate<ParamType.BOOLEAN>;
}
declare class SetPhysicsRBDCuboidPropertyActorNode extends TypedActorNode<SetPhysicsRBDCuboidPropertyActorParamsConfig> {
	readonly paramsConfig: SetPhysicsRBDCuboidPropertyActorParamsConfig;
	static type(): string;
	initializeNode(): void;
	receiveTrigger(context: ActorNodeTriggerContext): void;
}
declare class SetPhysicsRBDSpherePropertyActorParamsConfig extends NodeParamsConfig {
	/** @param target radois */
	radius: ParamTemplate<ParamType.FLOAT>;
	/** @param lerp factor */
	lerp: ParamTemplate<ParamType.FLOAT>;
	/** @param sets if the matrix should be updated as the animation progresses */
	updateMatrix: ParamTemplate<ParamType.BOOLEAN>;
}
declare class SetPhysicsRBDSpherePropertyActorNode extends TypedActorNode<SetPhysicsRBDSpherePropertyActorParamsConfig> {
	readonly paramsConfig: SetPhysicsRBDSpherePropertyActorParamsConfig;
	static type(): string;
	initializeNode(): void;
	receiveTrigger(context: ActorNodeTriggerContext): void;
}
declare class SetPhysicsWorldGravityActorParamsConfig extends NodeParamsConfig {
	gravity: ParamTemplate<ParamType.VECTOR3>;
	lerp: ParamTemplate<ParamType.FLOAT>;
}
declare class SetPhysicsWorldGravityActorNode extends TypedActorNode<SetPhysicsWorldGravityActorParamsConfig> {
	readonly paramsConfig: SetPhysicsWorldGravityActorParamsConfig;
	static type(): string;
	initializeNode(): void;
	receiveTrigger(context: ActorNodeTriggerContext): void;
}
declare class SetParamActorParamsConfig extends NodeParamsConfig {
	/** @param  parameter to update */
	param: ParamTemplate<ParamType.PARAM_PATH>;
	/** @param type of the parameter to update */
	type: ParamTemplate<ParamType.INTEGER>;
}
declare class SetParamActorNode extends TypedActorNode<SetParamActorParamsConfig> {
	readonly paramsConfig: SetParamActorParamsConfig;
	static type(): string;
	static INPUT_NAME_VAL: string;
	initializeNode(): void;
	private _currentConnectionType;
	setParamType(paramType: ActorConnectionPointType): void;
	receiveTrigger(context: ActorNodeTriggerContext): Promise<void>;
	private _setParam;
}
declare class SetPerspectiveCameraFovActorParamsConfig extends NodeParamsConfig {
	/** @param focal length */
	fov: ParamTemplate<ParamType.FLOAT>;
	/** @param lerp factor */
	lerp: ParamTemplate<ParamType.FLOAT>;
	/** @param sets if the projection matrix should be updated as the animation progresses */
	updateProjectionMatrix: ParamTemplate<ParamType.BOOLEAN>;
}
declare class SetPerspectiveCameraFovActorNode extends TypedActorNode<SetPerspectiveCameraFovActorParamsConfig> {
	readonly paramsConfig: SetPerspectiveCameraFovActorParamsConfig;
	static type(): string;
	initializeNode(): void;
	receiveTrigger(context: ActorNodeTriggerContext): void;
}
declare class SetPerspectiveCameraNearFarActorParamsConfig extends NodeParamsConfig {
	/** @param near */
	near: ParamTemplate<ParamType.FLOAT>;
	/** @param far */
	far: ParamTemplate<ParamType.FLOAT>;
	/** @param lerp factor */
	lerp: ParamTemplate<ParamType.FLOAT>;
	/** @param sets if the projection matrix should be updated as the animation progresses */
	updateProjectionMatrix: ParamTemplate<ParamType.BOOLEAN>;
}
declare class SetPerspectiveCameraNearFarActorNode extends TypedActorNode<SetPerspectiveCameraNearFarActorParamsConfig> {
	readonly paramsConfig: SetPerspectiveCameraNearFarActorParamsConfig;
	static type(): string;
	initializeNode(): void;
	receiveTrigger(context: ActorNodeTriggerContext): void;
}
declare class SetSpotLightIntensityActorParamsConfig extends NodeParamsConfig {
	/** @param intensity */
	intensity: ParamTemplate<ParamType.FLOAT>;
	/** @param lerp factor */
	lerp: ParamTemplate<ParamType.FLOAT>;
}
declare class SetSpotLightIntensityActorNode extends TypedActorNode<SetSpotLightIntensityActorParamsConfig> {
	readonly paramsConfig: SetSpotLightIntensityActorParamsConfig;
	static type(): string;
	initializeNode(): void;
	receiveTrigger(context: ActorNodeTriggerContext): void;
}
declare class SetViewerActorParamsConfig extends NodeParamsConfig {
	/** @param sets the class of the viewer */
	className: ParamTemplate<ParamType.STRING>;
	/** @param set or unset */
	set: ParamTemplate<ParamType.BOOLEAN>;
}
declare class SetViewerActorNode extends TypedActorNode<SetViewerActorParamsConfig> {
	readonly paramsConfig: SetViewerActorParamsConfig;
	static type(): string;
	initializeNode(): void;
	receiveTrigger(context: ActorNodeTriggerContext): void;
}
declare const SignActorNode_base: typeof BaseMathFunctionActorNode;
declare class SignActorNode extends SignActorNode_base {
	protected _applyOperation<T extends number>(arg1: T): any;
}
declare const SinActorNode_base: typeof BaseMathFunctionActorNode;
declare class SinActorNode extends SinActorNode_base {
	protected _applyOperation<T extends number>(arg1: T): any;
}
declare enum SmoothstepActorNodeInputName {
	EDGE0 = 'edge0',
	EDGE1 = 'edge1',
	X = 'x',
}
declare class SmoothstepActorParamsConfig extends NodeParamsConfig {}
declare class SmoothstepActorNode extends TypedActorNode<SmoothstepActorParamsConfig> {
	readonly paramsConfig: SmoothstepActorParamsConfig;
	static type(): string;
	initializeNode(): void;
	protected _expectedInputTypes(): ActorConnectionPointType[];
	protected _expectedInputName(index: number): SmoothstepActorNodeInputName;
	protected _expectedOutputTypes(): ActorConnectionPointType[];
	paramDefaultValue(name: string): number;
	private _valTmp;
	outputValue(context: ActorNodeTriggerContext): number | Vector2 | Vector3 | Vector4;
}
declare class SphereActorParamsConfig extends NodeParamsConfig {
	/** @param sphere center */
	center: ParamTemplate<ParamType.VECTOR3>;
	/** @param sphere radius */
	radius: ParamTemplate<ParamType.FLOAT>;
}
declare class SphereActorNode extends TypedActorNode<SphereActorParamsConfig> {
	paramsConfig: SphereActorParamsConfig;
	static type(): string;
	initializeNode(): void;
	private _sphere;
	outputValue(context: ActorNodeTriggerContext): Sphere;
}
declare const SqrtActorNode_base: typeof BaseMathFunctionActorNode;
declare class SqrtActorNode extends SqrtActorNode_base {
	protected _applyOperation<T extends number>(arg1: T): any;
}
declare const TypedSubnetActorParamsConfig_base: {
	new (...args: any[]): {
		inputs: ParamTemplate<ParamType.FOLDER>;
		inputsCount: ParamTemplate<ParamType.INTEGER>;
		inputType0: ParamTemplate<ParamType.INTEGER>;
		inputName0: ParamTemplate<ParamType.STRING>;
		inputType1: ParamTemplate<ParamType.INTEGER>;
		inputName1: ParamTemplate<ParamType.STRING>;
		inputType2: ParamTemplate<ParamType.INTEGER>;
		inputName2: ParamTemplate<ParamType.STRING>;
		inputType3: ParamTemplate<ParamType.INTEGER>;
		inputName3: ParamTemplate<ParamType.STRING>;
		inputType4: ParamTemplate<ParamType.INTEGER>;
		inputName4: ParamTemplate<ParamType.STRING>;
		inputType5: ParamTemplate<ParamType.INTEGER>;
		inputName5: ParamTemplate<ParamType.STRING>;
		inputType6: ParamTemplate<ParamType.INTEGER>;
		inputName6: ParamTemplate<ParamType.STRING>;
		inputType7: ParamTemplate<ParamType.INTEGER>;
		inputName7: ParamTemplate<ParamType.STRING>;
		inputType8: ParamTemplate<ParamType.INTEGER>;
		inputName8: ParamTemplate<ParamType.STRING>;
		inputType9: ParamTemplate<ParamType.INTEGER>;
		inputName9: ParamTemplate<ParamType.STRING>;
		spare: ParamTemplate<ParamType.FOLDER>;
	};
} & typeof NodeParamsConfig;
declare class TypedSubnetActorParamsConfig extends TypedSubnetActorParamsConfig_base {}
declare class AbstractTypedSubnetActorNode<K extends NodeParamsConfig> extends TypedActorNode<K> {
	protected _childrenControllerContext: NodeContext;
	initializeNode(): void;
	protected _expectedInputTypes(): ActorConnectionPointType[];
	protected _expectedInputName(index: number): string;
	protected _expectedOutputTypes(): ActorConnectionPointType[];
	protected _expectedOutputName(index: number): string;
	childExpectedInputConnectionPointTypes(): ActorConnectionPointType[];
	childExpectedOutputConnectionPointTypes(): ActorConnectionPointType[];
	childExpectedInputConnectionPointName(index: number): string;
	childExpectedOutputConnectionPointName(index: number): string;
	createNode<S extends keyof ActorNodeChildrenMap>(
		node_class: S,
		options?: NodeCreateOptions
	): ActorNodeChildrenMap[S];
	createNode<K extends valueof<ActorNodeChildrenMap>>(node_class: Constructor<K>, options?: NodeCreateOptions): K;
	children(): BaseActorNodeType[];
	nodesByType<K extends keyof ActorNodeChildrenMap>(type: K): ActorNodeChildrenMap[K][];
}
declare class TypedSubnetActorNode<K extends TypedSubnetActorParamsConfig> extends AbstractTypedSubnetActorNode<K> {
	initializeNode(): void;
	protected _inputTypeParams(): IntegerParam[];
	protected _inputNameParams(): StringParam[];
	setInputType(index: number, type: ActorConnectionPointType): void;
	setInputName(index: number, inputName: string): void;
	protected _expectedInputsCount(): number;
	protected _expectedInputTypes(): ActorConnectionPointType[];
	protected _expectedInputName(index: number): string;
	protected _expectedOutputTypes(): ActorConnectionPointType[];
	protected _expectedOutputName(index: number): string;
}
declare const SubnetActorParamsConfig_base: {
	new (...args: any[]): {
		inputs: ParamTemplate<ParamType.FOLDER>;
		inputsCount: ParamTemplate<ParamType.INTEGER>;
		inputType0: ParamTemplate<ParamType.INTEGER>;
		inputName0: ParamTemplate<ParamType.STRING>;
		inputType1: ParamTemplate<ParamType.INTEGER>;
		inputName1: ParamTemplate<ParamType.STRING>;
		inputType2: ParamTemplate<ParamType.INTEGER>;
		inputName2: ParamTemplate<ParamType.STRING>;
		inputType3: ParamTemplate<ParamType.INTEGER>;
		inputName3: ParamTemplate<ParamType.STRING>;
		inputType4: ParamTemplate<ParamType.INTEGER>;
		inputName4: ParamTemplate<ParamType.STRING>;
		inputType5: ParamTemplate<ParamType.INTEGER>;
		inputName5: ParamTemplate<ParamType.STRING>;
		inputType6: ParamTemplate<ParamType.INTEGER>;
		inputName6: ParamTemplate<ParamType.STRING>;
		inputType7: ParamTemplate<ParamType.INTEGER>;
		inputName7: ParamTemplate<ParamType.STRING>;
		inputType8: ParamTemplate<ParamType.INTEGER>;
		inputName8: ParamTemplate<ParamType.STRING>;
		inputType9: ParamTemplate<ParamType.INTEGER>;
		inputName9: ParamTemplate<ParamType.STRING>;
		spare: ParamTemplate<ParamType.FOLDER>;
	};
} & typeof NodeParamsConfig;
declare class SubnetActorParamsConfig extends SubnetActorParamsConfig_base {}
declare class SubnetActorNode extends TypedSubnetActorNode<SubnetActorParamsConfig> {
	paramsConfig: SubnetActorParamsConfig;
	static type(): NetworkNodeType;
	outputValue(
		context: ActorNodeTriggerContext,
		outputName: string
	):
		| string
		| number
		| true
		| string[]
		| Camera
		| Object3D<Event>
		| Material
		| Texture
		| Color
		| Vector2
		| Vector3
		| Vector4
		| Matrix4
		| Quaternion
		| number[]
		| Box3
		| Sphere
		| Plane
		| Ray
		| AnimationMixer
		| AnimationAction
		| CatmullRomCurve3
		| Texture[]
		| boolean[]
		| Vector3[]
		| Quaternion[]
		| Intersection<Object3D<Event>>
		| Vector4[]
		| Color[]
		| Vector2[]
		| Matrix4[]
		| Intersection<Object3D<Event>>[];
	inputValueForSubnetInput(
		context: ActorNodeTriggerContext,
		outputName: string
	):
		| string
		| number
		| true
		| string[]
		| Camera
		| Object3D<Event>
		| Material
		| Texture
		| Color
		| Vector2
		| Vector3
		| Vector4
		| Matrix4
		| Quaternion
		| number[]
		| Box3
		| Sphere
		| Plane
		| Ray
		| AnimationMixer
		| AnimationAction
		| CatmullRomCurve3
		| Texture[]
		| boolean[]
		| Vector3[]
		| Quaternion[]
		| Intersection<Object3D<Event>>
		| Vector4[]
		| Color[]
		| Vector2[]
		| Matrix4[]
		| Intersection<Object3D<Event>>[];
}
declare class SubnetInputActorParamsConfig extends NodeParamsConfig {}
declare class SubnetInputActorNode extends TypedActorNode<SubnetInputActorParamsConfig> {
	paramsConfig: SubnetInputActorParamsConfig;
	static type(): NetworkChildNodeType;
	initializeNode(): void;
	parent(): SubnetActorNode | null;
	private _expected_output_names;
	protected _expected_output_types(): ActorConnectionPointType[];
	outputValue(
		context: ActorNodeTriggerContext,
		outputName: string
	):
		| string
		| number
		| true
		| string[]
		| Camera
		| Object3D<Event>
		| Material
		| Texture
		| Color
		| Vector2
		| Vector3
		| Vector4
		| Matrix4
		| Quaternion
		| number[]
		| Box3
		| Sphere
		| Plane
		| Ray
		| AnimationMixer
		| AnimationAction
		| CatmullRomCurve3
		| Texture[]
		| boolean[]
		| Vector3[]
		| Quaternion[]
		| Intersection<Object3D<Event>>
		| Vector4[]
		| Color[]
		| Vector2[]
		| Matrix4[]
		| Intersection<Object3D<Event>>[]
		| undefined;
}
declare class SubnetOutputActorParamsConfig extends NodeParamsConfig {}
declare class SubnetOutputActorNode extends TypedActorNode<SubnetOutputActorParamsConfig> {
	paramsConfig: SubnetOutputActorParamsConfig;
	static type(): Readonly<NetworkChildNodeType.OUTPUT>;
	initializeNode(): void;
	parent(): SubnetActorNode | null;
	protected _expected_input_name(index: number): string;
	protected _expected_input_types(): ActorConnectionPointType[];
	outputValue(
		context: ActorNodeTriggerContext,
		outputName: string
	):
		| string
		| number
		| true
		| string[]
		| Camera
		| Object3D<Event>
		| Material
		| Texture
		| Color
		| Vector2
		| Vector3
		| Vector4
		| Matrix4
		| Quaternion
		| number[]
		| Box3
		| Sphere
		| Plane
		| Ray
		| AnimationMixer
		| AnimationAction
		| CatmullRomCurve3
		| Texture[]
		| boolean[]
		| Vector3[]
		| Quaternion[]
		| Intersection<Object3D<Event>>
		| Vector4[]
		| Color[]
		| Vector2[]
		| Matrix4[]
		| Intersection<Object3D<Event>>[];
}
declare const SubtractActorNode_base: typeof BaseMathFunctionActorNode;
declare class SubtractActorNode extends SubtractActorNode_base {
	protected _applyOperation<T extends number>(arg1: T, arg2: T): any;
}
declare class SwitchActorNode extends ParamlessTypedActorNode {
	static type(): string;
	static INPUT_INDEX_NAME: string;
	static OUTPUT_NAME: string;
	initializeNode(): void;
	protected _expectedInputName(index: number): string;
	protected _expectedOutputName(): string;
	protected _expectedInputTypes(): ActorConnectionPointType[];
	protected _expectedOutputTypes(): ActorConnectionPointType[];
	outputValue(
		context: ActorNodeTriggerContext
	): ReturnValueTypeByActorConnectionPointType[ActorConnectionPointType] | undefined;
}
declare const TanActorNode_base: typeof BaseMathFunctionActorNode;
declare class TanActorNode extends TanActorNode_base {
	protected _applyOperation<T extends number>(arg1: T): any;
}
declare enum TrackFaceActorNodeOutput {
	LANDMARKS = 'landmarks',
}
declare class TrackFaceActorParamsConfig extends NodeParamsConfig {
	faceIndex: ParamTemplate<ParamType.INTEGER>;
}
declare class TrackFaceActorNode extends TypedActorNode<TrackFaceActorParamsConfig> {
	readonly paramsConfig: TrackFaceActorParamsConfig;
	static type(): string;
	initializeNode(): void;
	receiveTrigger(context: ActorNodeTriggerContext): void;
	outputValue(
		context: ActorNodeTriggerContext,
		outputName: TrackFaceActorNodeOutput
	): ReturnValueTypeByActorConnectionPointType[ActorConnectionPointType] | undefined;
}
declare enum TrackHandActorNodeOutput {
	NORMALIZED_LANDMARKS = 'normalizedLandmarks',
	WORLD_LANDMARKS = 'worldLandmarks',
}
declare class TrackHandActorParamsConfig extends NodeParamsConfig {
	handIndex: ParamTemplate<ParamType.INTEGER>;
}
declare class TrackHandActorNode extends TypedActorNode<TrackHandActorParamsConfig> {
	readonly paramsConfig: TrackHandActorParamsConfig;
	static type(): string;
	initializeNode(): void;
	receiveTrigger(context: ActorNodeTriggerContext): void;
	outputValue(
		context: ActorNodeTriggerContext,
		outputName: TrackHandActorNodeOutput
	): ReturnValueTypeByActorConnectionPointType[ActorConnectionPointType] | undefined;
}
declare class TriggerDelayActorParamsConfig extends NodeParamsConfig {
	/** @param delay (in milliseconds) */
	delay: ParamTemplate<ParamType.FLOAT>;
}
declare class TriggerDelayActorNode extends TypedActorNode<TriggerDelayActorParamsConfig> {
	readonly paramsConfig: TriggerDelayActorParamsConfig;
	static type(): string;
	initializeNode(): void;
	receiveTrigger(context: ActorNodeTriggerContext): void;
}
declare class TriggerFilterActorParamsConfig extends NodeParamsConfig {
	/** @param If true, the trigger will be forwarded. If false, it will not be. */
	condition: ParamTemplate<ParamType.BOOLEAN>;
}
declare class TriggerFilterActorNode extends TypedActorNode<TriggerFilterActorParamsConfig> {
	readonly paramsConfig: TriggerFilterActorParamsConfig;
	static type(): string;
	initializeNode(): void;
	receiveTrigger(context: ActorNodeTriggerContext): void;
}
declare class TriggerTwoWaySwitchActorParamsConfig extends NodeParamsConfig {
	/** @param if true, trigger will be forward through the 1st output. If false, it will be forwarded through the 2nd output. */
	condition: ParamTemplate<ParamType.BOOLEAN>;
}
declare class TriggerTwoWaySwitchActorNode extends TypedActorNode<TriggerTwoWaySwitchActorParamsConfig> {
	readonly paramsConfig: TriggerTwoWaySwitchActorParamsConfig;
	static type(): string;
	static OUTPUT_NAME_IF_TRUE: string;
	static OUTPUT_NAME_IF_FALSE: string;
	initializeNode(): void;
	receiveTrigger(context: ActorNodeTriggerContext): void;
}
declare enum TwoWaySwitchActorNodeInputName {
	CONDITION = 'condition',
	IF_TRUE = 'ifTrue',
	IF_FALSE = 'ifFalse',
}
declare class TwoWaySwitchActorNode extends ParamlessTypedActorNode {
	static type(): string;
	initializeNode(): void;
	protected _expectedInputName(index: number): TwoWaySwitchActorNodeInputName;
	protected _expectedOutputName(): string;
	protected _expectedInputTypes(): ActorConnectionPointType[];
	protected _expectedOutputTypes(): ActorConnectionPointType[];
	outputValue(
		context: ActorNodeTriggerContext
	): ReturnValueTypeByActorConnectionPointType[ActorConnectionPointType] | undefined;
}
declare const Vec2ToFloatActorNode_base: typeof BaseVecToActorNode;
declare class Vec2ToFloatActorNode extends Vec2ToFloatActorNode_base {}
declare class Vec2ToVec3ActorNode extends BaseVecToActorNode {
	static type(): string;
	static readonly INPUT_NAME_VEC2 = 'vec2';
	static readonly INPUT_NAME_Z = 'z';
	initializeNode(): void;
	createParams(): void;
	private _defaultVector2;
	outputValue(
		context: ActorNodeTriggerContext,
		outputName?: string
	): ReturnValueTypeByActorConnectionPointType[ActorConnectionPointType];
}
declare enum Vec3ToColorActorNodeOutputName {
	COLOR = 'Color',
}
declare class Vec3ToColorActorNode extends BaseVecToActorNode {
	static type(): string;
	static readonly INPUT_NAME_VEC3 = 'vec3';
	initializeNode(): void;
	createParams(): void;
	private _defaultVector3;
	outputValue(
		context: ActorNodeTriggerContext,
		outputName?: Vec3ToColorActorNodeOutputName
	): ReturnValueTypeByActorConnectionPointType[ActorConnectionPointType] | undefined;
}
declare const Vec3ToFloatActorNode_base: typeof BaseVecToActorNode;
declare class Vec3ToFloatActorNode extends Vec3ToFloatActorNode_base {}
declare class Vec3ToVec4ActorNode extends BaseVecToActorNode {
	static type(): string;
	static readonly INPUT_NAME_VEC3 = 'vec3';
	static readonly INPUT_NAME_W = 'w';
	static readonly OUTPUT_NAME_VEC4 = 'vec4';
	initializeNode(): void;
	createParams(): void;
	private _defaultVector3;
	outputValue(
		context: ActorNodeTriggerContext,
		outputName?: string
	): ReturnValueTypeByActorConnectionPointType[ActorConnectionPointType];
}
declare enum Vec3ToVec2ActorNodeOutputName {
	VEC2 = 'Vector2',
	Z = 'z',
}
declare class Vec3ToVec2ActorNode extends BaseVecToActorNode {
	static type(): string;
	static readonly INPUT_NAME_VEC3 = 'vec3';
	initializeNode(): void;
	createParams(): void;
	private _defaultVector3;
	outputValue(
		context: ActorNodeTriggerContext,
		outputName?: Vec3ToVec2ActorNodeOutputName
	): ReturnValueTypeByActorConnectionPointType[ActorConnectionPointType] | undefined;
}
declare const Vec4ToFloatActorNode_base: typeof BaseVecToActorNode;
declare class Vec4ToFloatActorNode extends Vec4ToFloatActorNode_base {}
declare enum Vec4ToVec3ActorNodeOutputName {
	VEC3 = 'Vector3',
	W = 'w',
}
declare class Vec4ToVec3ActorNode extends BaseVecToActorNode {
	static type(): string;
	static readonly INPUT_NAME_VEC4 = 'vec4';
	initializeNode(): void;
	createParams(): void;
	private _defaultVector4;
	outputValue(
		context: ActorNodeTriggerContext,
		outputName?: Vec4ToVec3ActorNodeOutputName
	): ReturnValueTypeByActorConnectionPointType[ActorConnectionPointType];
}
declare class Vector2ActorParamsConfig extends NodeParamsConfig {
	/** @param vector value */
	Vector2: ParamTemplate<ParamType.VECTOR2>;
}
declare class Vector2ActorNode extends TypedActorNode<Vector2ActorParamsConfig> {
	paramsConfig: Vector2ActorParamsConfig;
	static type(): string;
	initializeNode(): void;
	private _tmpV2;
	outputValue(context: ActorNodeTriggerContext): Vector2;
}
declare class Vector3ActorParamsConfig extends NodeParamsConfig {
	/** @param vector value */
	Vector3: ParamTemplate<ParamType.VECTOR3>;
}
declare class Vector3ActorNode extends TypedActorNode<Vector3ActorParamsConfig> {
	paramsConfig: Vector3ActorParamsConfig;
	static type(): string;
	initializeNode(): void;
	private _tmpV3;
	outputValue(context: ActorNodeTriggerContext): Vector3;
}
declare class Vector3AngleToActorParamsConfig extends NodeParamsConfig {
	/** @param vector 1 */
	v1: ParamTemplate<ParamType.VECTOR3>;
	/** @param vector 2 */
	v2: ParamTemplate<ParamType.VECTOR3>;
}
declare class Vector3AngleToActorNode extends TypedActorNode<Vector3AngleToActorParamsConfig> {
	paramsConfig: Vector3AngleToActorParamsConfig;
	static type(): string;
	initializeNode(): void;
	outputValue(context: ActorNodeTriggerContext): number;
}
declare class Vector3ProjectActorParamsConfig extends NodeParamsConfig {
	/** @param vector3 */
	Vector3: ParamTemplate<ParamType.VECTOR3>;
}
declare class Vector3ProjectActorNode extends TypedActorNode<Vector3ProjectActorParamsConfig> {
	paramsConfig: Vector3ProjectActorParamsConfig;
	static type(): string;
	initializeNode(): void;
	outputValue(context: ActorNodeTriggerContext): Vector3;
}
declare class Vector3ProjectOnPlaneActorParamsConfig extends NodeParamsConfig {
	/** @param vector3 */
	Vector3: ParamTemplate<ParamType.VECTOR3>;
	/** @param planeNormal */
	planeNormal: ParamTemplate<ParamType.VECTOR3>;
}
declare class Vector3ProjectOnPlaneActorNode extends TypedActorNode<Vector3ProjectOnPlaneActorParamsConfig> {
	paramsConfig: Vector3ProjectOnPlaneActorParamsConfig;
	static type(): string;
	initializeNode(): void;
	outputValue(context: ActorNodeTriggerContext): Vector3;
}
declare class Vector3UnprojectActorParamsConfig extends NodeParamsConfig {
	/** @param vector3 */
	Vector3: ParamTemplate<ParamType.VECTOR3>;
}
declare class Vector3UnprojectActorNode extends TypedActorNode<Vector3UnprojectActorParamsConfig> {
	paramsConfig: Vector3UnprojectActorParamsConfig;
	static type(): string;
	initializeNode(): void;
	outputValue(context: ActorNodeTriggerContext): Vector3;
}
declare class Vector4ActorParamsConfig extends NodeParamsConfig {
	/** @param vector value */
	Vector4: ParamTemplate<ParamType.VECTOR4>;
}
declare class Vector4ActorNode extends TypedActorNode<Vector4ActorParamsConfig> {
	paramsConfig: Vector4ActorParamsConfig;
	static type(): string;
	initializeNode(): void;
	private _tmpV4;
	outputValue(context: ActorNodeTriggerContext): Vector4;
}
declare class ParamLessNetworkActorParamsConfig extends NodeParamsConfig {}
declare class BaseNetworkActorNode<K extends NodeParamsConfig> extends TypedNode<NodeContext.ACTOR, K> {
	static context(): NodeContext;
	cook(): void;
}
declare class ParamLessBaseNetworkActorNode extends BaseNetworkActorNode<ParamLessNetworkActorParamsConfig> {}
declare class ActorsNetworkActorNode extends ParamLessBaseNetworkActorNode {
	static type(): NetworkNodeType;
	protected _childrenControllerContext: NodeContext;
	createNode<S extends keyof ActorNodeChildrenMap>(
		node_class: S,
		options?: NodeCreateOptions
	): ActorNodeChildrenMap[S];
	createNode<K extends valueof<ActorNodeChildrenMap>>(node_class: Constructor<K>, options?: NodeCreateOptions): K;
	children(): BaseAnimNodeType[];
	nodesByType<K extends keyof ActorNodeChildrenMap>(type: K): ActorNodeChildrenMap[K][];
}
declare class AnimationsNetworkActorNode extends ParamLessBaseNetworkActorNode {
	static type(): NetworkNodeType;
	protected _childrenControllerContext: NodeContext;
	createNode<S extends keyof AnimNodeChildrenMap>(node_class: S, options?: NodeCreateOptions): AnimNodeChildrenMap[S];
	createNode<K extends valueof<AnimNodeChildrenMap>>(node_class: Constructor<K>, options?: NodeCreateOptions): K;
	children(): BaseAnimNodeType[];
	nodesByType<K extends keyof AnimNodeChildrenMap>(type: K): AnimNodeChildrenMap[K][];
}
declare class AudioNetworkActorNode extends ParamLessBaseNetworkActorNode {
	static type(): NetworkNodeType;
	protected _childrenControllerContext: NodeContext;
	createNode<S extends keyof AudioNodeChildrenMap>(
		node_class: S,
		options?: NodeCreateOptions
	): AudioNodeChildrenMap[S];
	createNode<K extends valueof<AudioNodeChildrenMap>>(node_class: Constructor<K>, options?: NodeCreateOptions): K;
	children(): BaseAnimNodeType[];
	nodesByType<K extends keyof AudioNodeChildrenMap>(type: K): AudioNodeChildrenMap[K][];
}
declare class CopNetworkActorNode extends ParamLessBaseNetworkActorNode {
	static type(): NetworkNodeType;
	protected _childrenControllerContext: NodeContext;
	createNode<S extends keyof CopNodeChildrenMap>(node_class: S, options?: NodeCreateOptions): CopNodeChildrenMap[S];
	createNode<K extends valueof<CopNodeChildrenMap>>(node_class: Constructor<K>, options?: NodeCreateOptions): K;
	children(): BaseCopNodeType[];
	nodesByType<K extends keyof CopNodeChildrenMap>(type: K): CopNodeChildrenMap[K][];
}
declare class EventsNetworkActorNode extends ParamLessBaseNetworkActorNode {
	static type(): NetworkNodeType;
	protected _childrenControllerContext: NodeContext;
	createNode<S extends keyof EventNodeChildrenMap>(
		node_class: S,
		options?: NodeCreateOptions
	): EventNodeChildrenMap[S];
	createNode<K extends valueof<EventNodeChildrenMap>>(node_class: Constructor<K>, options?: NodeCreateOptions): K;
	children(): BaseEventNodeType[];
	nodesByType<K extends keyof EventNodeChildrenMap>(type: K): EventNodeChildrenMap[K][];
}
declare class MaterialsNetworkActorNode extends ParamLessBaseNetworkActorNode {
	static type(): NetworkNodeType;
	protected _childrenControllerContext: NodeContext;
	createNode<S extends keyof MatNodeChildrenMap>(node_class: S, options?: NodeCreateOptions): MatNodeChildrenMap[S];
	createNode<K extends valueof<MatNodeChildrenMap>>(node_class: Constructor<K>, options?: NodeCreateOptions): K;
	children(): BaseMatNodeType[];
	nodesByType<K extends keyof MatNodeChildrenMap>(type: K): MatNodeChildrenMap[K][];
}
declare class PostProcessNetworkActorNode extends BaseNetworkActorNode<PostProcessNetworkParamsConfig> {
	paramsConfig: PostProcessNetworkParamsConfig;
	static type(): NetworkNodeType;
	readonly effectsComposerController: EffectComposerController;
	readonly displayNodeController: DisplayNodeController;
	protected _childrenControllerContext: NodeContext;
	createNode<S extends keyof PostNodeChildrenMap>(node_class: S, options?: NodeCreateOptions): PostNodeChildrenMap[S];
	createNode<K extends valueof<PostNodeChildrenMap>>(node_class: Constructor<K>, options?: NodeCreateOptions): K;
	children(): BasePostProcessNodeType[];
	nodesByType<K extends keyof PostNodeChildrenMap>(type: K): PostNodeChildrenMap[K][];
}
declare class RenderersNetworkActorNode extends ParamLessBaseNetworkActorNode {
	static type(): NetworkNodeType;
	protected _childrenControllerContext: NodeContext;
	createNode<S extends keyof RopNodeChildrenMap>(node_class: S, options?: NodeCreateOptions): RopNodeChildrenMap[S];
	createNode<K extends valueof<RopNodeChildrenMap>>(node_class: Constructor<K>, options?: NodeCreateOptions): K;
	children(): BaseRopNodeType[];
	nodesByType<K extends keyof RopNodeChildrenMap>(type: K): RopNodeChildrenMap[K][];
}
export interface ActorNodeChildrenMap {
	abs: AbsActorNode;
	acos: AcosActorNode;
	add: AddActorNode;
	and: AndActorNode;
	anyTrigger: AnyTriggerActorNode;
	asin: AsinActorNode;
	atan: AtanActorNode;
	animationAction: AnimationActionActorNode;
	animationActionCrossFade: AnimationActionCrossFadeActorNode;
	animationActionFadeOut: AnimationActionFadeOutActorNode;
	animationActionFadeIn: AnimationActionFadeInActorNode;
	animationActionPlay: AnimationActionPlayActorNode;
	animationActionStop: AnimationActionStopActorNode;
	animationMixer: AnimationMixerActorNode;
	animationMixerUpdate: AnimationMixerUpdateActorNode;
	boolToInt: BoolToIntActorNode;
	box3: Box3ActorNode;
	cache: CacheActorNode;
	catmullRomCurve3GetPoint: CatmullRomCurve3GetPointActorNode;
	ceil: CeilActorNode;
	clamp: ClampActorNode;
	code: CodeActorNode;
	colorToVec3: ColorToVec3ActorNode;
	compare: CompareActorNode;
	complement: ComplementActorNode;
	constant: ConstantActorNode;
	cookNode: CookNodeActorNode;
	cos: CosActorNode;
	cross: CrossActorNode;
	cursor: CursorActorNode;
	debug: DebugActorNode;
	divide: DivideActorNode;
	distance: DistanceActorNode;
	dot: DotActorNode;
	easing: EasingActorNode;
	elementsToArray: ElementsToArrayActorNode;
	fit: FitActorNode;
	floatToInt: FloatToIntActorNode;
	floatToVec2: FloatToVec2ActorNode;
	floatToVec3: FloatToVec3ActorNode;
	floatToVec4: FloatToVec4ActorNode;
	floor: FloorActorNode;
	getWebXRARSessionProperty: GetWebXRARSessionPropertyActorNode;
	getBox3Property: GetBox3PropertyActorNode;
	getChildrenAttributes: GetChildrenAttributesActorNode;
	getChildrenProperties: GetChildrenPropertiesActorNode;
	getChildrenPhysicsRBDProperties: GetChildrenPhysicsRBDPropertiesActorNode;
	getObjectChild: GetObjectChildActorNode;
	getDefaultCamera: GetDefaultCameraActorNode;
	getIntersectionProperty: GetIntersectionPropertyActorNode;
	getMaterial: GetMaterialActorNode;
	getObject: GetObjectActorNode;
	getObjectAttribute: GetObjectAttributeActorNode;
	getObjectProperty: GetObjectPropertyActorNode;
	getObjectUserData: GetObjectUserDataActorNode;
	getObjectWorldPosition: GetObjectWorldPositionActorNode;
	getParent: GetParentActorNode;
	getPhysicsRBDCapsuleProperty: GetPhysicsRBDCapsulePropertyActorNode;
	getPhysicsRBDConeProperty: GetPhysicsRBDConePropertyActorNode;
	getPhysicsRBDCylinderProperty: GetPhysicsRBDCylinderPropertyActorNode;
	getPhysicsRBDCuboidProperty: GetPhysicsRBDCuboidPropertyActorNode;
	getPhysicsRBDSphereProperty: GetPhysicsRBDSpherePropertyActorNode;
	getPhysicsRBDProperty: GetPhysicsRBDPropertyActorNode;
	getPlaneProperty: GetPlanePropertyActorNode;
	getRayProperty: GetRayPropertyActorNode;
	getSphereProperty: GetSpherePropertyActorNode;
	getTexture: GetTextureActorNode;
	getTrackedHandProperty: GetTrackedHandPropertyActorNode;
	getVideoProperty: GetVideoPropertyActorNode;
	getWebXRControllerProperty: GetWebXRControllerPropertyActorNode;
	getWebXRTrackedMarkerProperty: GetWebXRTrackedMarkerPropertyActorNode;
	intToBool: IntToBoolActorNode;
	intToFloat: IntToFloatActorNode;
	length: LengthActorNode;
	lerp: LerpActorNode;
	manhattanDistance: ManhattanDistanceActorNode;
	max: MaxActorNode;
	maxLength: MaxLengthActorNode;
	min: MinActorNode;
	mix: MixActorNode;
	mult: MultActorNode;
	multAdd: MultAddActorNode;
	multScalar: MultScalarActorNode;
	nearestPosition: NearestPositionActorNode;
	negate: NegateActorNode;
	normalize: NormalizeActorNode;
	null: NullActorNode;
	object3DLocalToWorld: Object3DLocalToWorldActorNode;
	object3DUpdateMatrix: Object3DUpdateMatrixActorNode;
	object3DUpdateWorldMatrix: Object3DUpdateWorldMatrixActorNode;
	object3DWorldToLocal: Object3DWorldToLocalActorNode;
	objectDispatchEvent: ObjectDispatchEventActorNode;
	onChildAttributeUpdate: OnChildAttributeUpdateActorNode;
	onKeydown: OnKeydownActorActorNode;
	onKeypress: OnKeypressActorActorNode;
	onKeyup: OnKeyupActorActorNode;
	onManualTrigger: OnManualTriggerActorNode;
	onMapboxCameraMove: OnMapboxCameraMoveActorNode;
	onMapboxCameraMoveStart: OnMapboxCameraMoveStartActorNode;
	onMapboxCameraMoveEnd: OnMapboxCameraMoveEndActorNode;
	onObjectAttributeUpdate: OnObjectAttributeUpdateActorNode;
	onObjectClick: OnObjectClickActorNode;
	onObjectDispatchEvent: OnObjectDispatchEventActorNode;
	onObjectHover: OnObjectHoverActorNode;
	onObjectPointerdown: OnObjectPointerdownActorNode;
	onObjectPointerup: OnObjectPointerupActorNode;
	onPerformanceChange: OnPerformanceChangeActorNode;
	onPlayerEvent: OnPlayerEventActorNode;
	onPointerdown: OnPointerdownActorNode;
	onPointerup: OnPointerupActorNode;
	onScenePlayState: OnScenePlayStateActorNode;
	onSceneReset: OnSceneResetActorNode;
	onTick: OnTickActorNode;
	onVideoEvent: OnVideoEventActorNode;
	onWebXRControllerEvent: OnWebXRControllerEventActorNode;
	or: OrActorNode;
	paramButtonPress: ParamButtonPressActorNode;
	pauseAudioSource: PauseAudioSourceActorNode;
	particlesSystemReset: ParticlesSystemResetActorNode;
	particlesSystemStepSimulation: ParticlesSystemStepSimulationActorNode;
	physicsPlayerUpdate: PhysicsPlayerUpdateActorNode;
	physicsRBDAddForceAtPoint: PhysicsRBDAddForceAtPointActorNode;
	physicsRBDAddForce: PhysicsRBDAddForceActorNode;
	physicsRBDAddTorque: PhysicsRBDAddTorqueActorNode;
	physicsRBDApplyImpulse: PhysicsRBDApplyImpulseActorNode;
	physicsRBDApplyTorqueImpulse: PhysicsRBDApplyTorqueImpulseActorNode;
	physicsRBDApplyImpulseAtPoint: PhysicsRBDApplyImpulseAtPointActorNode;
	PhysicsRBDRemove: PhysicsRBDRemoveActorNode;
	physicsRBDResetAll: PhysicsRBDResetAllActorNode;
	physicsRBDResetForces: PhysicsRBDResetForcesActorNode;
	physicsRBDResetTorques: PhysicsRBDResetTorquesActorNode;
	physicsWorldReset: PhysicsWorldResetActorNode;
	physicsWorldStepSimulation: PhysicsWorldStepSimulationActorNode;
	plane: PlaneActorNode;
	playerUpdate: PlayerUpdateActorNode;
	playAnimation: PlayAnimationActorNode;
	playAudioSource: PlayAudioSourceActorNode;
	playInstrumentNote: PlayInstrumentNoteActorNode;
	pressButtonParam: PressButtonParamActorNode;
	pow: PowActorNode;
	rand: RandActorNode;
	random: RandomActorNode;
	ray: RayActorNode;
	rayDistanceToPlane: RayDistanceToPlaneActorNode;
	rayFromCamera: RayFromCameraActorNode;
	rayFromCursor: RayFromCursorActorNode;
	rayIntersectBox: RayIntersectBoxActorNode;
	rayIntersectObject: RayIntersectObjectActorNode;
	rayIntersectPlane: RayIntersectPlaneActorNode;
	rayIntersectSphere: RayIntersectSphereActorNode;
	rayIntersectsBox: RayIntersectsBoxActorNode;
	rayIntersectsObject: RayIntersectsObjectActorNode;
	rayIntersectsPlane: RayIntersectsPlaneActorNode;
	rayIntersectsSphere: RayIntersectsSphereActorNode;
	round: RoundActorNode;
	setGeometryPositions: SetGeometryPositionsActorNode;
	setGeometryInstanceAttribute: SetGeometryInstanceAttributeActorNode;
	setGeometryInstancePositions: SetGeometryInstancePositionsActorNode;
	setGeometryInstanceQuaternions: SetGeometryInstanceQuaternionsActorNode;
	setGeometryInstanceScales: SetGeometryInstanceScalesActorNode;
	setGeometryInstanceTransforms: SetGeometryInstanceTransformsActorNode;
	setMaterialColor: SetMaterialColorActorNode;
	setMaterialEmissiveColor: SetMaterialEmissiveColorActorNode;
	setMaterialOpacity: SetMaterialOpacityActorNode;
	setMaterialUniform: SetMaterialUniformActorNode;
	setObjectAttribute: SetObjectAttributeActorNode;
	setObjectCastShadow: SetObjectCastShadowActorNode;
	setObjectFrustumCulled: SetObjectFrustumCulledActorNode;
	setObjectMatrix: SetObjectMatrixActorNode;
	setObjectMatrixAutoUpdate: SetObjectMatrixAutoUpdateActorNode;
	setObjectLookAt: SetObjectLookAtActorNode;
	setObjectReceiveShadow: SetObjectReceiveShadowActorNode;
	setObjectMaterial: SetObjectMaterialActorNode;
	setObjectMaterialColor: SetObjectMaterialColorActorNode;
	setObjectVisible: SetObjectVisibleActorNode;
	setObjectPolarTransform: SetObjectPolarTransformActorNode;
	setObjectPosition: SetObjectPositionActorNode;
	setObjectRotation: SetObjectRotationActorNode;
	setObjectScale: SetObjectScaleActorNode;
	setPhysicsRBDAngularVelocity: SetPhysicsRBDAngularVelocityActorNode;
	setPhysicsRBDLinearVelocity: SetPhysicsRBDLinearVelocityActorNode;
	setPhysicsRBDPosition: SetPhysicsRBDPositionActorNode;
	setPhysicsRBDRotation: SetPhysicsRBDRotationActorNode;
	setPhysicsRBDCapsuleProperty: SetPhysicsRBDCapsulePropertyActorNode;
	setPhysicsRBDConeProperty: SetPhysicsRBDConePropertyActorNode;
	setPhysicsRBDCylinderProperty: SetPhysicsRBDCylinderPropertyActorNode;
	setPhysicsRBDCuboidProperty: SetPhysicsRBDCuboidPropertyActorNode;
	setPhysicsRBDSphereProperty: SetPhysicsRBDSpherePropertyActorNode;
	setPhysicsWorldGravity: SetPhysicsWorldGravityActorNode;
	setParam: SetParamActorNode;
	setPerspectiveCameraFov: SetPerspectiveCameraFovActorNode;
	setPerspectiveCameraNearFar: SetPerspectiveCameraNearFarActorNode;
	setSpotLightIntensity: SetSpotLightIntensityActorNode;
	setViewer: SetViewerActorNode;
	sign: SignActorNode;
	sin: SinActorNode;
	smoothstep: SmoothstepActorNode;
	sphere: SphereActorNode;
	sqrt: SqrtActorNode;
	subnet: SubnetActorNode;
	subnetInput: SubnetInputActorNode;
	subnetOutput: SubnetOutputActorNode;
	subtract: SubtractActorNode;
	switch: SwitchActorNode;
	tan: TanActorNode;
	trackFace: TrackFaceActorNode;
	trackHand: TrackHandActorNode;
	triggerDelay: TriggerDelayActorNode;
	triggerFilter: TriggerFilterActorNode;
	triggerTwoWaySwitch: TriggerTwoWaySwitchActorNode;
	twoWaySwitch: TwoWaySwitchActorNode;
	vec2ToFloat: Vec2ToFloatActorNode;
	vec2ToVec3: Vec2ToVec3ActorNode;
	vec3ToColor: Vec3ToColorActorNode;
	vec3ToFloat: Vec3ToFloatActorNode;
	vec3ToVec2: Vec3ToVec2ActorNode;
	vec3ToVec4: Vec3ToVec4ActorNode;
	vec4ToFloat: Vec4ToFloatActorNode;
	vec4ToVec3: Vec4ToVec3ActorNode;
	vector2: Vector2ActorNode;
	vector3: Vector3ActorNode;
	vector3AngleTo: Vector3AngleToActorNode;
	vector3Project: Vector3ProjectActorNode;
	vector3ProjectOnPlane: Vector3ProjectOnPlaneActorNode;
	vector3Unproject: Vector3UnprojectActorNode;
	vector4: Vector4ActorNode;
	actorsNetwork: ActorsNetworkActorNode;
	animationsNetwork: AnimationsNetworkActorNode;
	audioNetwork: AudioNetworkActorNode;
	copNetwork: CopNetworkActorNode;
	eventsNetwork: EventsNetworkActorNode;
	materialsNetwork: MaterialsNetworkActorNode;
	postProcessNetwork: PostProcessNetworkActorNode;
	renderersNetwork: RenderersNetworkActorNode;
}
export interface NodeChildrenMapByContext {
	[NodeContext.ACTOR]: ActorNodeChildrenMap;
	[NodeContext.ANIM]: AnimNodeChildrenMap;
	[NodeContext.AUDIO]: AudioNodeChildrenMap;
	[NodeContext.COP]: CopNodeChildrenMap;
	[NodeContext.EVENT]: EventNodeChildrenMap;
	[NodeContext.GL]: GlNodeChildrenMap;
	[NodeContext.JS]: JsNodeChildrenMap;
	[NodeContext.MANAGER]: {};
	[NodeContext.MAT]: MatNodeChildrenMap;
	[NodeContext.OBJ]: ObjNodeChildrenMap;
	[NodeContext.POST]: PostNodeChildrenMap;
	[NodeContext.ROP]: RopNodeChildrenMap;
	[NodeContext.SOP]: GeoNodeChildrenMap;
}
export declare type NodeByNodeId = Map<CoreGraphNodeId, BaseNodeType>;
export declare type NodeMapByType<NC extends NodeContext> = Map<keyof NodeChildrenMapByContext[NC], NodeByNodeId>;
declare class NodesController {
	private scene;
	constructor(scene: PolyScene);
	_root: RootManagerNode;
	_nodeContextSignatures: PolyDictionary<boolean>;
	_instanciatedNodesByContextAndType: Map<NodeContext, NodeMapByType<NodeContext>>;
	createRoot(options?: NodeCreateOptions): void;
	root(): RootManagerNode;
	private _traverseNode;
	traverseNodes(callback: (node: BaseNodeType) => void): void;
	clear(): void;
	node(path: string): BaseNodeType | RootManagerNode | null;
	allNodes(): BaseNodeType[];
	nodesFromMask(mask: string): BaseNodeType[];
	resetNodeContextSignatures(): void;
	registerNodeContextSignature(node: BaseNodeType): void;
	nodeContextSignatures(): string[];
	addToInstanciatedNode<NC extends NodeContext>(node: BaseNodeType): void;
	removeFromInstanciatedNode<NC extends NodeContext>(node: BaseNodeType): void;
	nodesByType(type: string): BaseNodeType[];
	nodesByContextAndType<T extends keyof NodeChildrenMapByContext[NodeContext.ACTOR]>(
		context: NodeContext.ACTOR,
		node_type: T
	): NodeChildrenMapByContext[NodeContext.ACTOR][T][];
	nodesByContextAndType<T extends keyof NodeChildrenMapByContext[NodeContext.ANIM]>(
		context: NodeContext.ANIM,
		node_type: T
	): NodeChildrenMapByContext[NodeContext.ANIM][T][];
	nodesByContextAndType<T extends keyof NodeChildrenMapByContext[NodeContext.AUDIO]>(
		context: NodeContext.AUDIO,
		node_type: T
	): NodeChildrenMapByContext[NodeContext.AUDIO][T][];
	nodesByContextAndType<T extends keyof NodeChildrenMapByContext[NodeContext.COP]>(
		context: NodeContext.COP,
		node_type: T
	): NodeChildrenMapByContext[NodeContext.COP][T][];
	nodesByContextAndType<T extends keyof NodeChildrenMapByContext[NodeContext.EVENT]>(
		context: NodeContext.EVENT,
		node_type: T
	): NodeChildrenMapByContext[NodeContext.EVENT][T][];
	nodesByContextAndType<T extends keyof NodeChildrenMapByContext[NodeContext.GL]>(
		context: NodeContext.GL,
		node_type: T
	): NodeChildrenMapByContext[NodeContext.GL][T][];
	nodesByContextAndType<T extends keyof NodeChildrenMapByContext[NodeContext.JS]>(
		context: NodeContext.JS,
		node_type: T
	): NodeChildrenMapByContext[NodeContext.JS][T][];
	nodesByContextAndType<T extends keyof NodeChildrenMapByContext[NodeContext.MAT]>(
		context: NodeContext.MAT,
		node_type: T
	): NodeChildrenMapByContext[NodeContext.MAT][T][];
	nodesByContextAndType<T extends keyof NodeChildrenMapByContext[NodeContext.OBJ]>(
		context: NodeContext.OBJ,
		node_type: T
	): NodeChildrenMapByContext[NodeContext.OBJ][T][];
	nodesByContextAndType<T extends keyof NodeChildrenMapByContext[NodeContext.POST]>(
		context: NodeContext.POST,
		node_type: T
	): NodeChildrenMapByContext[NodeContext.POST][T][];
	nodesByContextAndType<T extends keyof NodeChildrenMapByContext[NodeContext.ROP]>(
		context: NodeContext.ROP,
		node_type: T
	): NodeChildrenMapByContext[NodeContext.ROP][T][];
	nodesByContextAndType<T extends keyof NodeChildrenMapByContext[NodeContext.SOP]>(
		context: NodeContext.SOP,
		node_type: T
	): NodeChildrenMapByContext[NodeContext.SOP][T][];
	hasNodesByContextAndType<NC extends NodeContext>(context: NC, nodeType: string): boolean;
}
export declare type CorePathObjCallback = (obj: Object3D) => void;
declare class ObjectsController {
	private scene;
	constructor(scene: PolyScene);
	findObjectByMask(mask: string): Object3D | undefined;
	objectsByMask(mask: string, parent?: Object3D): Object3D[];
	traverseObjectsWithMask(
		mask: string,
		callback: CorePathObjCallback,
		object: Object3D | undefined,
		invertMask?: boolean
	): void;
}
declare class ScenePerformanceMonitor {
	protected scene: PolyScene;
	private _performanceRef;
	constructor(scene: PolyScene);
	ref(): import('@vue/reactivity').Ref<number>;
	onPerformanceChange(perf: number): void;
}
export declare type BasePathParam = TypedPathParam<any>;
declare class ReferencesController {
	protected scene: PolyScene;
	private _referenced_nodes_by_src_param_id;
	private _referencing_params_by_referenced_node_id;
	private _referencing_params_by_all_named_node_ids;
	constructor(scene: PolyScene);
	setReferenceFromParam(src_param: BasePathParam, referencedGraphNode: BaseNodeType | BaseParamType): void;
	setNamedNodesFromParam(src_param: BasePathParam): void;
	resetReferenceFromParam(src_param: BasePathParam): void;
	referencing_params(node: BaseNodeType): BasePathParam[] | undefined;
	referencing_nodes(node: BaseNodeType): BaseNodeType[] | undefined;
	nodes_referenced_by(node: BaseNodeType): BaseNodeType[];
	private _check_param;
	notifyNameUpdated(node: BaseNodeType): void;
	notifyParamsUpdated(node: BaseNodeType): void;
}
export interface GetViewerOptions {
	camera: Camera;
	canvas?: HTMLCanvasElement;
}
declare class ViewersRegister {
	protected scene: PolyScene;
	private _viewersById;
	private _firstViewer;
	private _lastRenderedViewer;
	constructor(scene: PolyScene);
	registerViewer(viewer: BaseViewerType): void;
	unregisterViewer(viewer: BaseViewerType): void;
	traverseViewers(callback: (viewer: BaseViewerType) => void): void;
	viewer(options: GetViewerOptions): TypedViewer<Camera> | undefined;
	firstViewer(): BaseViewerType | undefined;
	markViewerAsRendered(viewer: BaseViewerType): void;
	lastRenderedViewer(): BaseViewerType | undefined;
	private _updateCache;
}
declare class SceneWebGLController {
	constructor();
	_require_webgl2: boolean;
	require_webgl2(): boolean;
	set_require_webgl2(): void;
}
declare class WindowController {
	private _scene;
	private _coreGraphNode;
	constructor(_scene: PolyScene);
	graphNode(): CoreGraphNode;
	private _createGraphNode;
	private _onWindowResizeBound;
	private _onWindowResize;
	dispose(): void;
}
declare class SceneAssetsController {
	private _params_by_id;
	register_param(param: StringParam): void;
	deregister_param(param: StringParam): void;
	traverse_params(callback: (param: StringParam) => void): void;
	private _assetsRoot;
	root(): string | null;
	setRoot(url: string | null): void;
}
declare class SceneTraverserController {
	protected scene: PolyScene;
	private _spotLightsRayMarching;
	private _directionalLightsRayMarching;
	private _pointLightsRayMarching;
	private _updateUniformsFunctionByLight;
	private _uniformsByLight;
	constructor(scene: PolyScene);
	traverseScene(scene?: Scene): void;
	private _onObjectTraverseBound;
	private _onObjectTraverse;
	private _updateUniformsForLight;
	addLightsRayMarchingUniform(uniforms: IUniforms): void;
	removeLightsRayMarchingUniform(uniforms: IUniforms): void;
}
export interface RegisterRendererOptions {
	assignId: boolean;
}
declare class SceneRenderersRegister {
	protected scene: PolyScene;
	private _renderersById;
	private _registerTimeByRenderer;
	private _lastRegisteredRenderer;
	private _resolves;
	constructor(scene: PolyScene);
	registerRenderer(renderer: AbstractRenderer, options?: RegisterRendererOptions): void;
	deregisterRenderer(renderer: AbstractRenderer): void;
	lastRegisteredRenderer(): AbstractRenderer | undefined;
	renderers(): AbstractRenderer[];
	private _updateCache;
	private _flushCallbacksWithRenderer;
	waitForRenderer(): Promise<AbstractRenderer>;
}
export interface CoreWebXRControllerOptions {
	overrideReferenceSpaceType: boolean;
	referenceSpaceType?: XRReferenceSpaceType;
}
declare enum WebXRARFeature {
	HIT_TEST = 'hit-test',
	LIGHT_ESTIMATION = 'light-estimation',
}
export interface CoreWebXRARControllerOptions extends CoreWebXRControllerOptions {
	optionalFeatures: WebXRARFeature[];
	requiredFeatures: WebXRARFeature[];
}
declare enum WebXRVRFeature {
	LOCAL_FLOOR = 'local-floor',
	BOUNDED_FLOOR = 'bounded-floor',
	HAND_TRACKING = 'hand-tracking',
	LAYERS = 'layers',
}
export interface CoreWebXRVRControllerOptions extends CoreWebXRControllerOptions {
	requiredFeatures: WebXRVRFeature[];
	optionalFeatures: WebXRVRFeature[];
}
export interface BaseCoreXRControllerEvent extends BaseEvent {
	controllerContainer: CoreWebXRControllerContainer;
}
declare class CoreWebXRControllerContainer extends EventDispatcher<BaseCoreXRControllerEvent> {
	readonly renderer: WebGLRenderer;
	readonly index: number;
	readonly ray: Ray;
	readonly controller: XRTargetRaySpace;
	constructor(renderer: WebGLRenderer, index: number);
	initialize(camera: Camera | null): void;
}
export declare type OnWebXRSessionStartedCallback = (session: XRSession) => Promise<void>;
declare abstract class BaseCoreWebXRController {
	protected scene: PolyScene;
	protected renderer: WebGLRenderer;
	protected camera: Camera;
	private canvas;
	protected options: CoreWebXRControllerOptions;
	protected controllerContainers: CoreWebXRControllerContainer[];
	constructor(
		scene: PolyScene,
		renderer: WebGLRenderer,
		camera: Camera,
		canvas: HTMLCanvasElement,
		options: CoreWebXRControllerOptions
	);
	getController(controllerIndex: number): CoreWebXRControllerContainer;
	mount(): void;
	unmount(): void;
	requestSession(sessionInit: XRSessionInit, callback: OnWebXRSessionStartedCallback): void;
	private _addStartEndEvents;
	private _removedStartEndEvents;
	private _createController;
	protected _addControllerEvents(controllerContainer: CoreWebXRControllerContainer, controllerIndex: number): void;
	process(frame?: XRFrame): void;
	private _onSessionStartBound;
	private _onSessionEndBound;
	protected _onSessionStart(): void;
	protected _onSessionEnd(): void;
	/**
	 *
	 * BUTTONS
	 *
	 */
	private _buttonByCanvasId;
	abstract createButton(): HTMLElement;
	private _mountButton;
	abstract attachButton(parentElement: HTMLElement, buttonElement: HTMLElement): void;
	private _unmountButton;
}
declare class CoreWebXRARController extends BaseCoreWebXRController {
	protected options: CoreWebXRARControllerOptions;
	private hitTestSource;
	private hitTestSourceRequested;
	private _hitDetected;
	private _hitMatrix;
	private _hitPosition;
	private _hitQuaternion;
	constructor(
		scene: PolyScene,
		renderer: WebGLRenderer,
		camera: Camera,
		canvas: HTMLCanvasElement,
		options: CoreWebXRARControllerOptions
	);
	createButton(): HTMLElement;
	attachButton(parentElement: HTMLElement, buttonElement: HTMLElement): void;
	requestSession(
		sessionInit: XRSessionInit,
		onSessionStarted: OnWebXRSessionStartedCallback
	): Promise<void | undefined>;
	private _estimatedLightController;
	private _previousSceneBackground;
	protected _onSessionStart(): void;
	protected _onSessionEnd(): void;
	hitMatrix(target: Matrix4): void;
	hitPosition(target: Vector3): void;
	hitQuaternion(target: Quaternion): void;
	hitDetected(): boolean;
	process(frame?: XRFrame): void;
	private _resolveHit;
}
declare class CoreWebXRVRController extends BaseCoreWebXRController {
	protected options: CoreWebXRVRControllerOptions;
	private _baseReferenceSpace;
	constructor(
		scene: PolyScene,
		renderer: WebGLRenderer,
		camera: Camera,
		canvas: HTMLCanvasElement,
		options: CoreWebXRVRControllerOptions
	);
	mount(): void;
	requestSession(
		sessionInit: XRSessionInit,
		onSessionStarted: OnWebXRSessionStartedCallback
	): Promise<void | undefined>;
	protected _onSessionStart(): void;
	protected _onSessionEnd(): void;
	baseReferenceSpace(): XRReferenceSpace | null;
	setReferenceSpace(referenceSpace: XRReferenceSpace): void;
	protected _addControllerEvents(controllerContainer: CoreWebXRControllerContainer, controllerIndex: number): void;
	createButton(): HTMLAnchorElement | HTMLButtonElement;
	attachButton(parentElement: HTMLElement, buttonElement: HTMLElement): void;
}
export declare type ARControllerCreateFunction = (
	renderer: WebGLRenderer,
	camera: Camera,
	canvas: HTMLCanvasElement,
	options: CoreWebXRARControllerOptions
) => CoreWebXRARController;
export declare type VRControllerCreateFunction = (
	renderer: WebGLRenderer,
	camera: Camera,
	canvas: HTMLCanvasElement,
	options: CoreWebXRVRControllerOptions
) => CoreWebXRVRController;
declare class SceneWebXRController {
	protected scene: PolyScene;
	constructor(scene: PolyScene);
	/**
	 *
	 * WebXR
	 *
	 */
	private _activeXRController;
	private _setActiveXRController;
	activeXRController(): BaseCoreWebXRController | null;
	/**
	 *
	 * WebXR AR
	 *
	 */
	private _ARControllerCreateFunction;
	private _activeARController;
	setARControllerCreationFunction(func: ARControllerCreateFunction): void;
	ARControllerCreateFunction(): ARControllerCreateFunction | undefined;
	setActiveARController(ARController: CoreWebXRARController | null): void;
	activeARController(): CoreWebXRARController | null;
	/**
	 *
	 * WebXR VR
	 *
	 */
	private _VRControllerCreateFunction;
	private _activeVRController;
	setVRControllerCreationFunction(func: VRControllerCreateFunction): void;
	VRControllerCreateFunction(): VRControllerCreateFunction | undefined;
	setActiveVRController(VRController: CoreWebXRVRController | null): void;
	activeVRController(): CoreWebXRVRController | null;
}
export interface PolySceneCreateOptions {
	root: NodeCreateOptions;
}
export declare type SceneBatchUpdateCallback = () => void | Promise<void>;
export interface UpdateState {
	scene: Scene;
}
/**
 *
 *
 * PolyScene contains all nodes within a scene.
 *
 */
export declare class PolyScene {
	/**
	 * Returns the THREE.Scene.
	 *
	 * @remarks
	 *
	 * Read more about how to use a THREE.Scene on [THREE's documentation](https://threejs.org/docs/?q=scene#api/en/scenes/Scene)
	 *
	 */
	threejsScene(): Scene;
	private _uuid;
	setUuid(uuid: string): string;
	get uuid(): string;
	private _name;
	setName(newName: string): string;
	static sanitizeName(newName: string): string;
	name(): string | undefined;
	protected _camerasController: SceneCamerasController | undefined;
	get camerasController(): SceneCamerasController;
	/**
	 * Returns the camera object that has been set as main
	 *
	 */
	mainCamera(): Promise<Camera | null>;
	private _cooker;
	get cooker(): Cooker;
	private _actorsManager;
	get actorsManager(): ActorsManager;
	private _assets_controller;
	get assets(): SceneAssetsController;
	readonly cookController: SceneCookController;
	/**
	 * Returns a promise to wait for all nodes to have cooked when loading a scene.
	 *
	 */
	waitForCooksCompleted(): Promise<void>;
	private _dispatchController;
	get dispatchController(): DispatchController;
	private _eventsDispatcher;
	get eventsDispatcher(): SceneEventsDispatcher;
	private _webXRController;
	get webXR(): SceneWebXRController;
	/**
	 * When using Polygonjs viewers, a raycaster is created to use mouse events and detect if there are any object under the cursor.
	 * But if no viewer is created, such as when [importing a scene in react three fiber](/docs/integrations/react_three_fiber),
	 * It is then useful to give a raycaster.
	 *
	 */
	setRaycaster(raycaster: Raycaster): void;
	private _graph;
	get graph(): CoreGraph;
	private _lifecycleController;
	get lifecycleController(): SceneLifeCycleController;
	private _loading_controller;
	get loadingController(): LoadingController;
	private _missing_expression_references_controller;
	get missingExpressionReferencesController(): MissingReferencesController;
	private _expressions_controller;
	get expressionsController(): ExpressionsController;
	protected _nodesController: NodesController;
	get nodesController(): NodesController;
	readonly renderersRegister: SceneRenderersRegister;
	/**
	 * Creates a new node.
	 *
	 * nodeClass can be either a string or a node class. Both examples below work:
	 *
	 * - polyScene.createNode('box'): returns a BoxSopNode
	 * - polyScene.createNode(boxSopNode): returns a BoxSopNode
	 *
	 */
	createNode<S extends keyof ObjNodeChildrenMap>(
		nodeClass: S,
		paramsInitValueOverrides?: ParamsInitData
	): ObjNodeChildrenMap[S];
	createNode<K extends valueof<ObjNodeChildrenMap>>(
		nodeClass: Constructor<K>,
		paramsInitValueOverrides?: ParamsInitData
	): K;
	/**
	 * returns all nodes with a given type
	 *
	 * - polyScene.nodesByType('box'): returns all BoxSopNodes
	 */
	nodesByType(type: string): BaseNodeType[];
	protected _objectsController: ObjectsController;
	get objectsController(): ObjectsController;
	/**
	 * returns a THREE.Object3D whose name matches the mask
	 *
	 */
	findObjectByMask(mask: string): Object3D | undefined;
	/**
	 * returns a list THREE.Object3Ds whose names matche the mask
	 *
	 */
	objectsByMask(mask: string, parent?: Object3D): Object3D[];
	protected _references_controller: ReferencesController;
	get referencesController(): ReferencesController;
	protected _performance: CorePerformance | undefined;
	get performance(): CorePerformance;
	readonly perfMonitor: ScenePerformanceMonitor;
	protected _viewers_register: ViewersRegister | undefined;
	get viewersRegister(): ViewersRegister;
	readonly sceneTraverser: SceneTraverserController;
	/**
	 * updates Polygonjs scene internals. This is called automatically when using Polygonjs viewers,
	 * but you would need to call it yourself in the render loop when adding your scene to threejs or react-three-fiber.
	 * See [https://polygonjs.com/docs/integrations](https://polygonjs.com/docs/integrations)
	 *
	 */
	update(delta: number, state?: UpdateState): void;
	protected _time_controller: TimeController;
	get timeController(): TimeController;
	/**
	 * sets the current frame
	 *
	 */
	setFrame(frame: number): void;
	setFrameToStart(): void;
	/**
	 * returns the current frame
	 *
	 */
	frame(): number;
	/**
	 * returns the current time
	 *
	 */
	time(): number;
	maxFrame(): number;
	/**
	 * starts playing the scene
	 *
	 */
	play(): void;
	/**
	 * pauses the scene
	 *
	 */
	pause(): void;
	/**
	 * increments the time
	 *
	 */
	incrementTime(options?: TimeControllerUpdateTimeOptions): void;
	/**
	 * increments the time if the scene is playing()
	 *
	 */
	incrementTimeIfPlaying(options?: TimeControllerUpdateTimeOptions): void;
	/**
	 * registers a renderer
	 *
	 */
	registerRenderer(renderer: WebGLRenderer, options?: RegisterRendererOptions): void;
	private _serializer;
	private get serializer();
	toJSON(): {
		nodes_by_graph_node_id: PolyDictionary<object>;
		params_by_graph_node_id: PolyDictionary<object>;
	};
	private _uniformsController;
	get uniformsController(): UniformsController;
	private _webgl_controller;
	get webgl_controller(): SceneWebGLController;
	private _windowController;
	get windowController(): WindowController;
	constructor(options?: PolySceneCreateOptions);
	dispose(): void;
	/**
	 * batchUpdates can be useful to set multiple parameter values without triggering a recook for each update.
	 *
	 */
	batchUpdates(callback: SceneBatchUpdateCallback): Promise<void>;
	/**
	 * returns a node based on its path
	 *
	 * - polyScene.node('/geo1')
	 *
	 */
	node(path: string): BaseNodeType | RootManagerNode | null;
	/**
	 * returns the root node
	 *
	 */
	root(): RootManagerNode;
	/**
	 * traverse all nodes and runs a callback for each
	 *
	 */
	traverseNodes(callback: (node: BaseNodeType) => void): void;
	/**
	 * registers a BeforeTick callback. BeforeTick callbacks are run before updating the frame (and therefore before any time dependent node has changed)
	 *
	 */
	registerOnBeforeTick(callbackName: string, callback: onTimeTickHook): void;
	/**
	 * unregisters BeforeTick callback
	 *
	 */
	unRegisterOnBeforeTick(callbackName: string): void;
	/**
	 * Returns the list registered BeforeTick callback names
	 *
	 */
	registeredBeforeTickCallbacks(): Map<string, onTimeTickHook>;
	/**
	 * registers AfterTick callback. AfterTick callbacks are run after updating the frame (and therefore after any time dependent node has changed)
	 *
	 */
	registerOnAfterTick(callbackName: string, callback: onTimeTickHook): void;
	/**
	 * unregisters AfterTick callback
	 *
	 */
	unRegisterOnAfterTick(callbackName: string): void;
	/**
	 * Returns the list registered AfterTick callback names
	 *
	 */
	registeredAfterTickCallbacks(): Map<string, onTimeTickHook>;
}
export interface Versions {
	polygonjs: string;
}
export interface SceneJsonExporterDataProperties {
	frame: number;
	maxFrame: number;
	maxFrameLocked: boolean;
	realtimeState: boolean;
	mainCameraPath?: string | null;
	mainCameraNodePath?: string | null;
	versions?: Versions;
}
export interface SceneJsonExporterData {
	properties?: SceneJsonExporterDataProperties;
	root?: NodeJsonExporterData;
	ui?: NodeJsonExporterUIData;
	shaders?: NodeJSONShadersData;
	jsFunctionBodies?: NodeJSONFunctionBodiesData;
	embeddedPolyNodes?: PolyDictionary<PolyNodeDefinition>;
}
declare class ImportReport {
	private _warnings;
	private _readonly;
	private _loadedWithoutAssemblers;
	constructor(_sceneImporter: SceneJsonImporter);
	warnings(): string[];
	readonly(): boolean;
	loadedWithoutAssemblers(): boolean;
	reset(): void;
	markAsLoadedWithoutAssemblers(): void;
	addWarning(message: string): void;
}
export declare type ConfigureSceneCallback = (scene: PolyScene) => void;
export declare type NodeCookWatchCallback = (scene: PolyScene) => void;
export interface SceneJSONImporterOptions {
	sceneName?: string;
	configureScene?: ConfigureSceneCallback;
	nodeCookWatcher?: NodeCookWatchCallback;
	measurePerformanceOnLoad?: boolean;
}
export interface MigrateHelper {
	migrateNodeType: (parentNode: BaseNodeType, nodeData: NodeJsonExporterData) => string;
	migrateParams: (parentNode: BaseNodeType, nodeData: NodeJsonExporterData) => void;
}
export declare class SceneJsonImporter {
	private _data;
	private _options?;
	readonly report: ImportReport;
	private _base_operations_composer_nodes_with_resolve_required;
	constructor(_data: SceneJsonExporterData, _options?: SceneJSONImporterOptions | undefined);
	static loadData(data: SceneJsonExporterData, options?: SceneJSONImporterOptions): Promise<PolyScene>;
	private _migrateHelper;
	setMigrateHelper(migrateHelper: MigrateHelper): void;
	migrateHelper(): MigrateHelper | undefined;
	oldPolygonjsSceneVersion(): string | undefined;
	scene(): PolyScene;
	shadersData(): NodeJSONShadersData | undefined;
	jsFunctionBodiesData(): NodeJSONFunctionBodiesData | undefined;
	add_operations_composer_node_with_path_param_resolve_required(
		operations_composer_node: OperationsComposerSopNode
	): void;
	private _resolve_operation_containers_with_path_param_resolve;
}
export declare type ManifestNodesData = PolyDictionary<string>;
export declare type NodeJSONShadersTimestampData = PolyDictionary<PolyDictionary<string>>;
export declare type JsFunctionBodyDataTimestampData = PolyDictionary<string>;
export interface ManifestContent {
	properties: string;
	root: string;
	nodes: ManifestNodesData;
	shaders: NodeJSONShadersTimestampData;
	jsFunctionBodies: JsFunctionBodyDataTimestampData;
}
export declare type ProgressCallback = (ratio: number) => void;
export interface ImportData {
	sceneName?: string;
	urlPrefix?: string;
	manifest: ManifestContent;
	editorMode?: boolean;
	onProgress?: ProgressCallback;
}
export interface SceneDataElements {
	root: NodeJsonExporterData;
	properties: SceneJsonExporterDataProperties;
	ui?: NodeJsonExporterUIData;
	shaders?: NodeJSONShadersData;
	jsFunctionBodies?: NodeJSONFunctionBodiesData;
}
export declare class SceneDataManifestImporter {
	static importSceneData(importData: ImportData): Promise<SceneJsonExporterData>;
	static assemble(
		assembleData: SceneDataElements,
		manifestNodes: string[],
		jsonByName: PolyDictionary<object>
	): Promise<SceneJsonExporterData>;
	private static _insertChildData;
}
export interface LoadSceneOptions {
	onProgress?: OnProgressUpdateCallback;
}
export interface ImportCommonOptions extends LoadSceneOptions {
	domElement?: HTMLElement | string;
	sceneName: string;
	configureScene?: ConfigureSceneCallback;
	assetUrls?: string[];
}
export interface SceneDataImportOptions extends ImportCommonOptions {
	sceneData: SceneJsonExporterData;
	autoPlay?: boolean;
	createViewer?: boolean;
	renderer?: WebGLRenderer;
	cameraMaskOverride?: string;
}
export interface SceneLoadReturnData {
	scene: PolyScene;
	viewer: BaseViewerType | undefined;
}
export declare class ScenePlayerImporter {
	private options;
	private _scene;
	private _viewer;
	private _onLoadCompleteCalled;
	private _onCameraCreatorNodeLoadedResolve;
	private _progress;
	constructor(options: SceneDataImportOptions);
	static loadSceneData(options: SceneDataImportOptions): Promise<SceneLoadReturnData>;
	private _onLoadComplete;
	private _viewerMarkedAsReady;
	private _markViewerAsReady;
	private _sceneMarkedAsReady;
	private _markSceneAsReady;
	private _onNodesCookProgress;
	private _watchNodesProgress;
	loadScene(): Promise<PolyScene>;
	private _domElement;
	private _dispatchEvent;
	protected _debug(arg0: any): void;
	protected _debug2(arg0: any, arg1: any): void;
	protected static _debug(arg0: any): void;
	protected static _debug2(arg0: any, arg1: any): void;
}
export declare class AllRegister {
	private static _started;
	static registerAll(): Promise<void>;
}

export {};
