{"version":3,"sources":["webpack://POLY/./src/engine/nodes/gl/utils/GLDefinition.ts","webpack://POLY/./src/core/ThreeToGl.ts","webpack://POLY/./src/engine/nodes/utils/shaders/ShaderName.ts","webpack://POLY/./src/engine/nodes/gl/utils/SpareParamsController.ts","webpack://POLY/./src/engine/nodes/gl/_Base.ts","webpack://POLY/./src/engine/containers/Material.ts","webpack://POLY/./src/engine/nodes/mat/_Base.ts","webpack://POLY/./src/engine/nodes/utils/flags/Base.ts","webpack://POLY/./src/engine/nodes/utils/flags/Bypass.ts","webpack://POLY/./src/engine/nodes/utils/flags/Display.ts","webpack://POLY/./src/engine/nodes/utils/FlagsController.ts","webpack://POLY/./src/engine/nodes/gl/code/assemblers/materials/_BaseMaterial.ts","webpack://POLY/./src/engine/nodes/gl/code/globals/Geometry.ts","webpack://POLY/./src/engine/containers/Texture.ts","webpack://POLY/./src/engine/nodes/cop/_Base.ts","webpack://POLY/./src/engine/nodes/gl/utils/ConnectionsController.ts","webpack://POLY/./src/core/Transform.ts","webpack://POLY/./src/core/loader/Texture.ts","webpack://POLY/./src/engine/nodes/cop/File.ts","webpack://POLY/./src/engine/poly/registers/Category.ts","webpack://POLY/./src/engine/nodes/mat/utils/_BaseController.ts","webpack://POLY/./src/engine/nodes/mat/utils/SideController.ts","webpack://POLY/./src/engine/nodes/gl/Attribute.ts","webpack://POLY/./src/engine/nodes/gl/code/configs/ShaderConfig.ts","webpack://POLY/./src/engine/nodes/gl/code/configs/VariableConfig.ts","webpack://POLY/./src/engine/nodes/mat/utils/SkinningController.ts","webpack://POLY/./src/engine/nodes/mat/utils/TextureMapController.ts","webpack://POLY/./src/engine/nodes/mat/utils/TextureAlphaMapController.ts","webpack://POLY/./src/engine/io/json/export/Scene.ts","webpack://POLY/./src/engine/io/json/export/Node.ts","webpack://POLY/./src/engine/io/json/export/Param.ts","webpack://POLY/./src/engine/io/json/export/param/Numeric.ts","webpack://POLY/./src/engine/io/json/export/param/OperatorPath.ts","webpack://POLY/./src/engine/io/json/export/param/String.ts","webpack://POLY/./src/engine/io/json/export/param/Ramp.ts","webpack://POLY/./src/engine/io/json/export/Dispatcher.ts","webpack://POLY/./src/engine/nodes/gl/code/Controller.ts","webpack://POLY/./src/engine/nodes/gl/code/utils/LineType.ts","webpack://POLY/./src/engine/nodes/gl/code/utils/LinesController.ts","webpack://POLY/./src/engine/nodes/gl/code/utils/ShadersCollectionController.ts","webpack://POLY/./src/engine/nodes/gl/code/utils/CodeFormatter.ts","webpack://POLY/./src/engine/nodes/gl/code/utils/CodeBuilder.ts","webpack://POLY/./src/engine/nodes/gl/code/assemblers/_Base.ts","webpack://POLY/./src/engine/nodes/utils/shaders/BaseAssembler.ts","webpack://POLY/./src/engine/nodes/gl/utils/GLDefinitionCollection.ts","webpack://POLY/./src/engine/nodes/utils/code/configs/ParamConfig.ts","webpack://POLY/./src/engine/nodes/utils/code/controllers/ParamConfigsController.ts","webpack://POLY/./src/engine/nodes/gl/code/globals/_Base.ts","webpack://POLY/./src/engine/nodes/utils/shaders/NodeTraverser.ts","webpack://POLY/./src/engine/nodes/gl/Globals.ts","webpack://POLY/./src/engine/nodes/gl/code/utils/NodeFinder.ts","webpack://POLY/./src/engine/nodes/mat/utils/_BaseTextureController.ts","webpack://POLY/./src/engine/nodes/mat/utils/UniformsColorsController.ts","webpack://POLY/./src/engine/nodes/mat/_BaseBuilder.ts","webpack://POLY/./src/engine/nodes/gl/code/templates/CustomMeshDepthDOF.frag.glsl","webpack://POLY/./src/engine/nodes/utils/code/controllers/TranspiledFilter.ts","webpack://POLY/./src/engine/nodes/gl/Constant.ts","webpack://POLY/./src/engine/nodes/gl/code/assemblers/materials/CustomPointsDepth.ts","webpack://POLY/./src/engine/nodes/gl/code/templates/CustomPointsDepth.vert.glsl","webpack://POLY/./src/engine/nodes/gl/code/assemblers/materials/CustomPointsDistance.ts","webpack://POLY/./src/engine/nodes/gl/code/templates/CustomPointsDistance.vert.glsl","webpack://POLY/./src/engine/nodes/gl/code/templates/CustomPointsDepthDOF.vert.glsl","webpack://POLY/./src/engine/nodes/gl/code/assemblers/materials/CustomPointsDepthDOF.ts","webpack://POLY/./src/engine/nodes/gl/code/assemblers/materials/Points.ts","webpack://POLY/./src/engine/nodes/mat/PointsBuilder.ts","webpack://POLY/./src/core/geometry/Constant.ts","webpack://POLY/./src/core/geometry/Entity.ts","webpack://POLY/./src/core/geometry/Point.ts","webpack://POLY/./src/core/geometry/Face.ts","webpack://POLY/./src/core/geometry/MonkeyPatcher.ts","webpack://POLY/./src/core/geometry/Material.ts","webpack://POLY/./modules/three/examples/jsm/utils/BufferGeometryUtils.js","webpack://POLY/./src/core/geometry/Geometry.ts","webpack://POLY/./src/core/geometry/Object.ts","webpack://POLY/./src/core/geometry/Group.ts","webpack://POLY/./src/engine/containers/Geometry.ts","webpack://POLY/./src/engine/nodes/sop/_Base.ts","webpack://POLY/./src/engine/nodes/sop/Add.ts","webpack://POLY/./src/engine/nodes/sop/AnimationCopy.ts","webpack://POLY/./src/engine/nodes/sop/AnimationMixer.ts","webpack://POLY/./src/engine/nodes/sop/AttribAddMult.ts","webpack://POLY/./src/engine/nodes/sop/AttribCopy.ts","webpack://POLY/./src/engine/nodes/sop/AttribCreate.ts","webpack://POLY/./src/engine/nodes/sop/AttribDelete.ts","webpack://POLY/./src/engine/nodes/sop/AttribNormalize.ts","webpack://POLY/./src/engine/nodes/sop/AttribPromote.ts","webpack://POLY/./src/engine/nodes/sop/AttribRemap.ts","webpack://POLY/./src/engine/nodes/sop/AttribRename.ts","webpack://POLY/./src/core/math/octree/Node.ts","webpack://POLY/./src/core/math/octree/Octree.ts","webpack://POLY/./src/core/Iterator.ts","webpack://POLY/./src/engine/nodes/sop/AttribTransfer.ts","webpack://POLY/./src/core/math/Interpolate.ts","webpack://POLY/./src/engine/nodes/sop/BboxScatter.ts","webpack://POLY/./src/engine/nodes/sop/Blend.ts","webpack://POLY/./src/engine/nodes/sop/Box.ts","webpack://POLY/./src/engine/nodes/sop/Cache.ts","webpack://POLY/./src/core/geometry/util/Circle.ts","webpack://POLY/./src/engine/nodes/sop/Circle.ts","webpack://POLY/./src/engine/nodes/sop/Code.ts","webpack://POLY/./src/core/Color.ts","webpack://POLY/./src/engine/nodes/sop/Color.ts","webpack://POLY/./src/engine/nodes/sop/Cone.ts","webpack://POLY/./src/core/geometry/Instancer.ts","webpack://POLY/./src/engine/nodes/sop/utils/CopyStamp.ts","webpack://POLY/./src/engine/nodes/sop/Copy.ts","webpack://POLY/./src/core/geometry/AttributeData.ts","webpack://POLY/./src/core/loader/geometry/JsonData.ts","webpack://POLY/./src/engine/nodes/sop/Data.ts","webpack://POLY/./src/engine/nodes/sop/DataUrl.ts","webpack://POLY/./src/engine/nodes/sop/Delay.ts","webpack://POLY/./src/engine/nodes/sop/Delete.ts","webpack://POLY/./src/engine/nodes/sop/Face.ts","webpack://POLY/./src/core/loader/Geometry.ts","webpack://POLY/./src/engine/nodes/sop/File.ts","webpack://POLY/./src/engine/nodes/sop/Fuse.ts","webpack://POLY/./src/core/geometry/operation/Hexagon.ts","webpack://POLY/./src/engine/nodes/sop/Hexagons.ts","webpack://POLY/./src/engine/nodes/sop/Hierarchy.ts","webpack://POLY/./src/engine/nodes/sop/Instance.ts","webpack://POLY/./src/engine/nodes/sop/Jitter.ts","webpack://POLY/./src/engine/nodes/sop/Layer.ts","webpack://POLY/./src/engine/nodes/sop/Line.ts","webpack://POLY/./src/engine/nodes/sop/Material.ts","webpack://POLY/./src/engine/nodes/sop/Merge.ts","webpack://POLY/./src/engine/nodes/sop/Noise.ts","webpack://POLY/./modules/three/examples/jsm/math/SimplexNoise.js","webpack://POLY/./src/engine/nodes/sop/Normals.ts","webpack://POLY/./src/engine/nodes/sop/Null.ts","webpack://POLY/./src/engine/nodes/sop/ObjectMerge.ts","webpack://POLY/./src/engine/nodes/sop/Occlusion.ts","webpack://POLY/./src/engine/nodes/gl/code/utils/TextureAllocation.ts","webpack://POLY/./src/engine/nodes/gl/code/utils/TextureVariable.ts","webpack://POLY/./src/engine/nodes/gl/code/utils/TextureAllocationsController.ts","webpack://POLY/./src/engine/nodes/gl/code/assemblers/particles/Particles.ts","webpack://POLY/./src/engine/nodes/gl/code/templates/particles/Default.glsl","webpack://POLY/./src/engine/nodes/gl/code/globals/Texture.ts","webpack://POLY/./src/engine/nodes/sop/utils/ParticlesSystemGPU/RenderController.ts","webpack://POLY/./src/engine/nodes/sop/utils/ParticlesSystemGPU/GPUComputationRenderer.js","webpack://POLY/./src/engine/nodes/sop/utils/ParticlesSystemGPU/GPUComputeController.ts","webpack://POLY/./src/engine/nodes/sop/ParticlesSystemGpu.ts","webpack://POLY/./src/engine/nodes/sop/Peak.ts","webpack://POLY/./src/engine/nodes/sop/Plane.ts","webpack://POLY/./src/engine/nodes/sop/Point.ts","webpack://POLY/./src/core/geometry/util/Curve.ts","webpack://POLY/./src/core/geometry/operation/Skin.ts","webpack://POLY/./src/engine/nodes/sop/Polywire.ts","webpack://POLY/./src/engine/nodes/sop/Ray.ts","webpack://POLY/./src/engine/nodes/sop/Resample.ts","webpack://POLY/./src/engine/nodes/sop/Scatter.ts","webpack://POLY/./src/engine/nodes/sop/Shadows.ts","webpack://POLY/./src/engine/nodes/sop/Skin.ts","webpack://POLY/./src/engine/nodes/sop/Sphere.ts","webpack://POLY/./src/engine/nodes/sop/Switch.ts","webpack://POLY/./src/engine/nodes/sop/Text.ts","webpack://POLY/./src/engine/nodes/sop/Torus.ts","webpack://POLY/./src/engine/nodes/sop/TorusKnot.ts","webpack://POLY/./src/engine/nodes/sop/Transform.ts","webpack://POLY/./src/engine/nodes/sop/Tube.ts","webpack://POLY/./src/core/CameraController.ts","webpack://POLY/./src/engine/nodes/sop/UvProject.ts","webpack://POLY/./src/engine/poly/registers/Sop.ts"],"names":["GLDefinitionType","TypedGLDefinition","_definition_type","_data_type","_node","_name","this","AttributeGLDefinition","super","ATTRIBUTE","data_type","name","FunctionGLDefinition","FUNCTION","UniformGLDefinition","UNIFORM","VaryingGLDefinition","VARYING","ThreeToGl","value","ensure_float","values","toArray","map","v","length","join","vec","num","vector3","x","y","z","w","ShaderName","ParticleShaderNames","PARTICLES_0","PARTICLES_1","PARTICLES_2","PARTICLES_3","PARTICLES_4","PARTICLES_5","PARTICLES_6","PARTICLES_7","PARTICLES_8","PARTICLES_9","node","_allow_inputs_created_from_params","params","set_post_create_params_hook","create_inputs_from_params","bind","connections","param_name","names","add_input","_inputless_param_names","includes","has","param","get","parent_param","connection_type","type","connection","push","io","inputs","set_named_input_connection_points","raw_input_serialized_by_param_name","Map","default_value_serialized_by_param_name","current_param_names","spare_names","params_update_options","set","raw_input_serialized","default_value_serialized","names_to_delete","connection_point","named_input_connection_points","param_type","init_value","last_param_init_value","default_value_from_name","gl_input_default_value","array","Array","i","to_add","options","spare","scene","loading_controller","is_loading","update_params","spare_param","raw_input","spare_params_controller","NodeContext","GL","init_inputs","ui_data","set_layout_horizontal","outputs","set_named_output_connection_points","initialize_node","node_sibbling","console","warn","material_node","assembler_controller","set_compilation_required_and_dirty","parent","input_index","get_input_index","input_connection","input_node","node_src","output_connection_point","named_output_connection_points","output_index","output_name","gl_var_name","full_path","any","shaders_collection_controller","_param_configs_controller","reset","list","ParamlessTypedGlNode","params_config","content","set_content","material","_content","dispose","has_content","container_controller","_cook_main_without_inputs_when_dirty_bound","_cook_main_without_inputs_when_dirty","MAT","initialize_base_node","name_controller","add_post_set_full_path_hook","set_material_name","add_post_dirty_hook","cook_controller","cook_main_without_inputs","_material","create_material","set_container","object","BaseFlag","_state","_hooks","hook","new_state","on_update","run_hooks","emit","NodeEvent","FLAG_BYPASS_UPDATED","set_dirty","FLAG_DISPLAY_UPDATED","FlagsController","Display","Base","display","Bypass","bypass","FlagsControllerD","FlagsControllerB","FlagsControllerDB","CustomMaterialName","ShaderAssemblerMaterial","_assemblers_by_custom_name","class_by_custom_name","custom_assembler_class_by_custom_name","forEach","assembler_class","custom_name","_add_custom_material","custom_assembler","_gl_parent_node","custom_materials","_code_builder","assembler","set_root_nodes","_root_nodes","set_param_configs_owner","set_shader_configs","shader_configs","set_variable_configs","variable_configs","custom_material","compile_material","compile_allowed","output_nodes","find_output_nodes","states","error","_update_shaders","new_vertex_shader","_shaders_by_name","VERTEX","new_fragment_shader","FRAGMENT","vertexShader","fragmentShader","add_uniforms","uniforms","needsUpdate","uniforms_time_dependent","uniforms_controller","add_time_dependent_uniform_owner","uuid","remove_time_dependent_uniform_owner","compile_custom_materials","_lines","shader_name","shader_names","template","_template_shader_for_shader_name","split","build_code_from_nodes","_build_lines","lines","output_node","input_name","input","named_input","var_input","variable_for_input","variable_config","new_var","default_from_attribute","named_input_connection_points_by_name","gl_type","attr_read","globals_handler","read_attribute","variable_config_default","default","prefix","suffix","if_condition","add_body_lines","current_shader_name","input_names","shader_config","add_output_body_line","attribute_node","attribute_name","var_name","body_lines","globals_node","dependencies","definitions_by_shader_name","body_lines_by_shader_name","definition","body_line","used_output_names","globals_shader_name","FLOAT","push_on_array_at_entry","dependency","set_uniforms_time_dependent","handle_gl_FragCoord","handle_resolution","VEC2","set_resolution_dependent","handle_globals_node","definitions","add_definitions","VARIABLE_CONFIG_DEFAULT_BY_NAME","position","GlobalsGeometryHandler","named_output_connection_points_by_name","variable_name","attrib_name","PRE_DEFINED_ATTRIBUTES","indexOf","varying_definition","set_varying_body_line","IF_RULE","uv","log","texture","clone","image","width","height","DEFAULT_INPUT_NAMES","data","Uint16Array","EMPTY_DATA_TEXTURE","DataTexture","flags","COP","set_has_one_output","BaseCopNodeClass","GlConnectionsController","_input_name_function","index","_output_name_function","_expected_input_types_function","first_input_connection_type","_expected_output_types_function","_update_signature_if_required_bound","update_signature_if_required","_initialized","func","add_on_set_input_hook","add_on_scene_load_hook","dirty_trigger","lifecycle","creation_completed","_connections_match_inputs","update_connection_types","remove_dirty_state","make_successors_update_signatures","successor","graph_all_successors","gl_node","gl_connections_controller","expected_input_types","expected_output_types","named_input_connections","named_outputs","create_spare_parameters","current_input_types","c","current_output_types","input_connections","first_connection","connection_type_from_connection","CoreTransform","_translation_matrix","_translation_matrix_q","_translation_matrix_s","_matrix","identity","_matrix_q","_matrix_e","_matrix_s","_rotate_geometry_m","_rotate_geometry_q","_rotate_geometry_vec_dest","matrix","update_scale","quaternion","scale","decompose","rotation","setFromQuaternion","toVector3","divideScalar","Math","PI","batch_update","set_vector3","set_float","t","compose","quat","s","r","degToRad","setFromEuler","copy","multiplyScalar","geometry","vec_origin","vec_dest","normalize","setFromUnitVectors","makeRotationFromQuaternion","applyMatrix4","Extension","_param","url","found_node","substring","node_path","find_node","request_container","load_url","texture_as_env","set_texture_for_mapping","graph_predecessors","graph_disconnect_predecessors","add_graph_input","Promise","resolve","reject","ext","_ext","VIDEO_EXTENSIONS","_load_as_video","loader_for_ext","then","loader","load","undefined","toLowerCase","EXR","EXRLoader","HDR","RGBELoader","setDataType","BASIS","BasisTextureLoader","setTranscoderPath","renderer","Poly","instance","renderers_controller","wait_for_renderer","detectSupport","TextureLoader","video","document","createElement","setAttribute","onloadedmetadata","pause","VideoTexture","source","VIDEO_SOURCE_TYPE_BY_EXT","_default_video_source_type","appendChild","img","canvas","context","getContext","drawImage","getImageData","elements","PARAM_DEFAULT","PARAM_ENV_DEFAULT","ogg","ogv","mp4","MAPPINGS","UVMapping","CubeReflectionMapping","CubeRefractionMapping","EquirectangularReflectionMapping","EquirectangularRefractionMapping","SphericalReflectionMapping","CubeUVReflectionMapping","CubeUVRefractionMapping","WRAPPINGS","ClampToEdgeWrapping","RepeatWrapping","MirroredRepeatWrapping","MAG_FILTERS","LinearFilter","NearestFilter","MIN_FILTERS","NearestMipMapNearestFilter","NearestMipMapLinearFilter","LinearMipMapNearestFilter","LinearMipMapLinearFilter","ATTRIB_MAPPING_KEYS","ATTRIB_MAPPING","mapping","wrapS","wrapT","minFilter","magFilter","STRING","desktop_browse","file_type","reload","BUTTON","callback","PARAM_CALLBACK_reload","INTEGER","menu","entries","m","Object","keys","wrap_s","wrap_t","mag_filter","min_filter","_is_static_image_url","pv","cook_for_image","cook_for_video","_load_texture","_update_texture_params","set_texture","clear_texture","_param_url_changed","_add_video_spare_params_if_required","_previous_param_url","_set_video_current_time","end_cook","texture_attrib","param_value","float","param_callback_reload","p","set_successors_dirty","_video","currentTime","constructor","has_param","VIDEO_TIME_PARAM_NAME","duration","add_param","ParamType","cook","range","range_locked","PARAMS_UPDATED","_remove_spare_params","_texture_loader","load_texture_from_url_or_op","e","DEFAULT_NODE_PATH","UV","ENV_MAP","CATEGORY_OBJ","LIGHT","MANAGER","GEOMETRY","CAMERA","MISC","CATEGORY_COP","INPUT","ADVANCED","CATEGORY_EVENT","CATEGORY_GL","COLOR","CONVERSION","DYNAMICS","GLOBALS","LOGIC","MATH","QUAT","TRIGO","UTIL","INSTANCE","CATEGORY_MAT","MESH","POINTS","LINE","VOLUME","CATEGORY_SOP","ANIMATION","MODIFIER","PRIMITIVES","RENDER","BaseController","SideParamConfig","double_sided","BOOLEAN","front","visible_if","SideController","single_side","new_side","side","ConnectionPointTypesAvailableForAttribute","VEC3","VEC4","AttributeGlParamsConfig","ParamsConfig","AttributeGlNode","_on_create_set_name_if_none_bound","_on_create_set_name_if_none","_set_mat_to_recompile_if_is_exporting","add_on_create_hook","set_expected_input_types_function","set_expected_output_types_function","allow_attribute_exports","INPUT_NAME","OUTPUT_NAME","set_node_lines_attribute","named_input_connection_point","export_when_connected","is_exporting","_set_mat_to_recompile","ShaderConfig","_input_names","_dependencies","VariableConfig","_options","SkinningParamConfig","skinning","SkinningController","new_skinning","TextureMapParamConfig","use_map","TextureMapController","OPERATOR_PATH","_update_options","add_hooks","_update","texture_map_controller","update","TextureAlphaMapParamConfig","use_alpha_map","TextureAlphaMapController","alpha_map","texture_alpha_map_controller","_scene","_data","nodes_controller","reset_node_context_signatures","root_exporter","dispatch_node","root","nodes_data","properties","frame","frame_range","frame_range_locked","time_controller","master_camera_node_path","cameras_controller","ui","word","replace","escape_line_breaks","is_root","register_node_context_signature","children_controller","params_data","inputs_data","has_bypass","active","has_display","children_allowed","selection","children","selected_children","selected_ids","selected_node","nodes","graph_node_id","child","n","override_clonable_state_allowed","override","override_clonable_state","add_custom","comment","sanitize_string","node_exporter","has_named_inputs","output","param_exporter","dispatch_param","required","ParamJsonExporter","_complex_data","is_spare_and_not_component","is_spare","value_changed","is_default","_require_data_complex","_data_complex","_data_simple","current","add_main","has_options_overridden","overridden_options","options_overridden","option_name","option_value","JSON","stringify","val","OperatorPath","Ramp","_globals_handler","_compile_required","_deleted_params_data","_assembler","id","reset_configs","output_child","add_output_params","add_globals_params","globals","create_node","set_position","Vector2","trigger_node","set_compilation_required","param_config","param_configs","set_uniform_value","current_spare_param_names","assembler_param_names","spare_param_names_to_add","spare_param_names_to_remove","spare_params_with_same_name_as_params","error_message","param_options","default_value","LineType","_shader_name","_definitions_by_node_id","_body_lines_by_node_id","MapUtils","line","_shader_names","_current_shader_name","_lines_controller_by_shader_name","lines_controller","LINE_SUFFIXES","FUNCTION_DECLARATION","DEFINE","BODY","LINE_PREFIXES","line_type","add_suffix","ParamConfigsController","_param_configs_set_allowed","_function_declared","root_nodes","node_traverser","traverse","nodes_by_shader_name","nodes_for_shader_name","sorted_nodes","root_nodes_for_shader","root_nodes_by_shader_name","root_node","sorted_node_ids","reset_code","eval_all","_shaders_collection_controller","set_current_shader_name","set_param_configs","set_lines","set_code_lines","lines_map","add_code_lines","GLDefinition","add_code_line_for_nodes_and_line_type","definition_type","node_definitions","filter","d","collection","uniq_definitions","uniq","errored","definitions_by_node_id","node_ids","node_id","lines_for_shader","boolean","first_definition","node_comment","line_wrap","separator","post_line_separator","nodes_count","is_last","add_code_line_for_node_and_line_type","INSERT_DEFINE_AFTER_MAP","INSERT_BODY_AFTER_MAP","LINES_TO_REMOVE_MAP","_leaf_nodes","_uniforms_time_dependent","_resolution_dependent","_template_shader","_replace_template","current_uniforms","uniform_name","uniform","time","resolution_dependent","Globals","Attribute","code_builder","build_from_nodes","allow_new_param_configs","disallow_new_param_configs","all_lines","_param_config_owner","param_config_owner","VECTOR3","hidden","VECTOR2","ConnectionPointType","create_globals_node_output_connections","_reset_shader_configs","_reset_variable_configs","_reset_uniforms_time_dependency","_reset_resolution_dependency","_shader_configs","create_shader_configs","sc","_variable_configs","create_variable_configs","vc","if","function_declaration","builder_lines","define","body","template_lines","new_lines","line_before_define","insert_define_after","line_before_body","insert_body_after","lines_to_remove","line_before_define_found","line_before_body_found","template_line","_insert_lines","line_remove_required","line_to_remove","lines_to_add","line_to_add","TypedGLDefinitionCollection","_definitions","_errored","_error_message","definitions_by_name","existing","_type","_default_value","_uniform_name","_uniform","_create_uniform","uniform_by_type","callback_bound","_callback","node_selection","Vector3","FOLDER","RAMP","SEPARATOR","VECTOR4","Vector4","unreachable","compute","has_value_changed","is_video_texture","set_uniform_value_from_texture","set_uniform_value_from_ramp","ramp_texture","new_value","param_constructor","ParamConstructorByType","_cached_param_value","has_changed","are_values_equal","clone_value","result","_param_configs","GlobalsBaseController","_id","__next_id","TypedNodeTraverser","_leaves_graph_id","_graph_ids_by_shader_name","_outputs_by_graph_id","_depth_by_graph_id","_graph_id_by_depth","_graph","graph","clear","input_names_for_shader_name","find_leaves_from_root_node","set_nodes_depth","depth","graph_id","LEAVES_FROM_NODES_SHADER","find_leaves","key","nodes_from_ids","depths","sort","a","b","graph_ids_for_depth","node_from_id","ids","unique_inputs","booleans_by_graph_id","set_node_depth","current_depth","max","output_ids","output_id","GlobalsGlParamsConfig","GlobalsGlNode","set_node_lines_globals","GlNodeFinder","nodes_by_type","BooleanParamOptions","controller_class","OperatorPathOptions","controller","use_map_name","BaseTextureMapController","use_map_param","path_param","mat_attrib_name","shader_material","attr_name","_update_texture_on_uniforms","direct_params","mat","_update_texture_on_material","_update_required_attribute","_apply_texture_on_uniforms","_remove_texture_from_uniforms","has_texture","new_texture_is_different","_do_update_define","define_name","_define_name","defines","toUpperCase","_apply_texture_on_material","_remove_texture_from_material","texture_owner","update_callback","remove_callback","is_dirty","node_context","texture_node","ColorParamConfig","transparent","opacity","alpha_test","use_fog","ColorsController","depthTest","alphaTest","fog","TypedBuilderMatNode","_children_controller_context","on_create","init","_assembler_controller","_create_assembler_controller","compile_required","_compile","post_compile","TranspiledFilter","transpiled_javascript","filtered_lines","match","typed_visible_options","ConstantGlParamsConfig","bool","BOOL","int","INT","vec2","vec3","vec4","ConstantGlNode","set_output_name_function","_current_connection_type","_current_param","_current_var_name","_params_by_type","ShaderLib","UniformsUtils","template_shader","ShaderMaterial","USE_SIZEATTENUATION","DEPTH_PACKING","distanceRGBA","size","mNear","mFar","CUSTOM_ASSEMBLER_MAP","DISTANCE","DEPTH","DEPTH_DOF","points","_add_custom_materials","concat","compile_if_required","set_material","ObjectType","ObjectTypes","LINE_SEGMENTS","ObjectTypeMenuEntries","materials","MeshStandard","MeshStandardMaterial","color","metalness","roughness","MeshLambertMaterial","Color","vertexColors","PointsMaterial","LineBasicMaterial","linewidth","AttribClass","AttribClassMenuEntries","OBJECT","AttribType","AttribTypeMenuEntries","NUMERIC","CoreConstant","ATTRIB_CLASS","ATTRIB_TYPE","OBJECT_TYPE","OBJECT_TYPES","CONSTRUCTOR_NAMES_BY_CONSTRUCTOR_NAME","Scene","Group","Object3D","Mesh","Points","LineSegments","Bone","SkinnedMesh","CONSTRUCTORS_BY_NAME","MATERIALS","CoreEntity","_index","ATTRIB_NAMES","ComponentName","COMPONENT_INDICES","g","_core_geometry","_geometry","remap_name","getAttribute","itemSize","remapped_name","has_attrib","component_name","component_index","remaped_name","attrib","message","attributes","is_attrib_indexed","value_index","attrib_value_index","user_data_attrib","start_index","_position","fromArray","new_position","set_attrib_value_vector3","_normal","new_normal","attrib_size","v2","col","v3","new_value_index","_points","_get_points","index_array","start","_positions","_get_positions","_triangle","_get_triangle","positions","Triangle","_deltas","_get_deltas","sub","triangle","getArea","target","seed","weights","rand_float","add","deltas","barycentric_coordinates","getBarycoord","point_values","point","attrib_value","new_attrib_value","sum","point_value","weighted_value","face","intersect_point","point_indices","position_attrib_array","point_positions","point_index","attrib_array","attrib_values","dist_to_points","distanceTo","distance_total","point_indx","attribute","assign","InterleavedBufferAttribute","offset","normalized","BufferGeometryUtils","computeTangents","normal","indices","normals","uvs","nVertices","tangent","BufferAttribute","Float32Array","tangents","tan1","tan2","vA","vB","vC","uvA","uvB","uvC","sdir","tdir","groups","count","il","j","group","jl","handleTriangle","test","tmp","tmp2","n2","handleVertex","isFinite","addScaledVector","dot","crossVectors","mergeBufferGeometries","geometries","useGroups","isIndexed","attributesUsed","Set","morphAttributesUsed","morphAttributes","morphTargetsRelative","mergedGeometry","BufferGeometry","userData","mergedUserData","addGroup","indexOffset","mergedIndex","getX","setIndex","mergedAttribute","mergeBufferAttributes","numMorphTargets","morphAttributesToMerge","mergedMorphAttribute","TypedArray","arrayLength","isInterleavedBufferAttribute","interleaveAttributes","stride","l","interleavedBuffer","InterleavedBuffer","res","getters","setters","iba","k","estimateBytesUsed","mem","attr","BYTES_PER_ELEMENT","getIndex","mergeVertices","tolerance","Number","EPSILON","hashToIndex","vertexCount","nextIndex","attributeNames","attrArrays","morphAttrsArrays","newIndices","morphAttr","fill","decimalShift","log10","shiftMultiplier","pow","hash","newarray","newMorphArrays","getterFunc","ml","oldAttribute","buffer","oldMorphAttribute","morphAttribute","toTrianglesDrawMode","drawMode","numberOfTriangles","newGeometry","clearGroups","_bounding_box","_create_bounding_box","computeBoundingBox","boundingBox","marked_as_instance","computeVertexNormals","user_data_attribs","h","attrib_names","set_indexed_attribute_values","attribute_added","points_count","attrib_data","add_numeric_attrib","old_name","new_name","old_attrib","deleteAttribute","src_geometry","src_userData","patch","new_geometry","position_attrib_name","points_from_geometry","position_attrib","object_type","geometry_wrapper","first_point","old_geometry","old_geometry_wrapper","new_index_by_old_index","_indices_from_points","new_values","new_index_by_value","new_attrib_indices","new_index","index_attrib","old_indices","new_indices","old_index","old_index0","old_index1","old_index2","new_index0","new_index1","new_index2","core_geometries","indexed_attribute_names","new_values_by_attribute_name","indexed_attribute_name","index_by_values","all_geometries_points","core_geometry","geometry_points","set_attrib_index","merged_geometry","merged_geometry_wrapper","faces_from_geometry","faces_count","src_material","clone_single","material_with_custom","mat_name","uniform_value","_object","geo","compute_vertex_normals","add_attribute","attribute_names","delete_attribute","src_object","new_object","sourceLookup","cloneLookup","parallelTraverse","sourceNode","clonedNode","src_node","mesh_node","src_node_geometry","mesh_node_geometry","apply_custom_materials","material_with_color","src_node_with_animations","animations","animation","skinned_node","isSkinnedMesh","clonedMesh","sourceMesh","sourceBones","skeleton","bones","bindMatrix","new_bones","bone","touch","_timestamp","performance","now","_core_geometries","_core_objects","core_group","_objects","objects","set_objects","_create_core_objects","core_object","core_objects","create_core_geometries","isMesh","isLine","isPoints","faces","group_name","core_objects_from_group","co","parseInt","match_mask","_compute_bounding_box","center","bounding_box","getCenter","getSize","bbox","expandByObject","Box3","first_geometry","attrib_type","attrib_class","geometry_from_object","rename_attribute","first_object","masks_string","masks","matching_attrib_names","mask","attrib_sizes","src_group","new_group","visible","count_by_type","human_type","names_by_type","sizes_by_name","types_by_name","core_geo","MESSAGE","SOP","add_hook","display_node_controller","set_display_node","_set_object_attributes","FROM_SET_CORE_GROUP","set_container_objects","FROM_SET_OBJECT","FROM_SET_OBJECTS","create_object","FROM_SET_GEOMETRY","FROM_SET_GEOMETRIES","container","core_content","position_array","object_constructor","castShadow","receiveShadow","frustumCulled","add_render_hook","create_point","open","connect_to_last_point","set_count","input_contents","_create_point","init_inputs_clonable_state","InputCloneMode","FROM_NODE","NEVER","core_group_target","target_object","src_animations","set_core_group","prepare","PARAM_CALLBACK_prepare","_previous_time","_mixer","_actions_by_name","_values_by_param_name","_update_mixer","create_mixer","_animation_target","AnimationMixer","prev_value","action","clipAction","play","materials_by_id","object3d","morphTargets","_update_mixer_weights","set_object","get_float","_update_mixer_time","delta","cache_value","setEffectiveWeight","prepare_animation_mixer","eval_required_input","core_content_cloned","pre_add","mult","post_add","attrib_names_matching_mask","_update_attrib","input_cloned","tnew_name","core_group_dest","core_group_src","copy_vertex_attribute_between_core_groups","src_objects","dest_objects","dest_geometry","copy_vertex_attribute_between_geometries","src_attrib","src_points_count","dest_points_count","sub_array","slice","dest_name","class","value1","expression","for_entities","value2","value3","value4","string","_x_arrays_by_geometry_uuid","_y_arrays_by_geometry_uuid","_z_arrays_by_geometry_uuid","_w_arrays_by_geometry_uuid","add_point_attribute","add_object_attribute","add_numeric_attribute_to_points","add_string_attribute_to_points","add_numeric_attribute_to_object","add_string_attribute_to_object","points_from_group","has_expression","expression_controller","compute_expression_for_points","components","tmp_arrays","component_param","arrays_by_geometry_uuid","_init_array_if_required","tmp_array","add_numeric_vertex_attrib","compute_expression_for_objects","set_attrib_value","values_by_core_object_index","string_values","index_data","array_to_indexed_arrays","set_indexed_attribute","current_array","delete_vertex_attribute","delete_object_attribute","change_name","_normalize_attribute","min","normalized_values","normalized_value","target_name","AttribPromoteMode","PromoteModeMenuEntries","MIN","MAX","FIRST_FOUND","class_from","class_to","mode","_values_per_attrib_name","_filtered_values_per_attrib_name","_core_group","_core_object","find_values","filter_values","set_values","find_values_from_points","find_values_from_object","set_values_to_points","set_values_to_object","param_size","ramp","_remap_attribute","only_integer_values","sorted_values","index_by_value","sorted_value","rename_attrib","_bbox","_level","_leaves_by_octant","_points_by_octant_id","_leaves","_bounding_boxes_by_octant","_bounding_boxes_by_octant_prepared","_center","sphere","intersectsSphere","accumulated_points","containsPoint","leaf","intersects_sphere","points_in_sphere","add_point","octant_ids","octant_id","create_leaf","box","_leaf_bbox","set_points","_octant_id","_prepare_leaves_bboxes","x_pos","y_pos","z_pos","corner","bbox_centers","_bbox_center","bbox_size_quarter","bbox_center","_root","distance","max_points_count","Sphere","found_points","_array_index","_count","_current_count_index","_resolve","_max_time_per_chunk","max_time_per_chunk","_check_every_interations","check_every_interations","iteratee_method","_iteratee_method_count","_bound_next_with_count","next_with_count","start_time","setTimeout","_array","_iteratee_method_array","_bound_next_with_array","next_with_array","_current_array_element","dest_group","max_samples_count","distance_threshold","blend_width","_core_group_dest","dest_points","_core_group_src","_attrib_names","_error_if_attribute_not_found_on_second_input","_build_octree_if_required","_add_attribute_if_required","_transfer_attributes","second_input_changed","_octree_timestamp","timestamp","_prev_param_src_group","points_src","_octree","iterator","start_with_array","_transfer_attributes_for_point","dest_point","total_dist","nearest_points","find_points","_interpolate_points","point_dest","src_points","blend_with","_interpolate_with_1_point","_interpolate_with_multiple_points","point_src","position_dest","position_src","value_src","_weighted_value_from_distance","value_dest","blend","_weight_from_distance","weighted_values_src","current_position","other_positions","_weights_from_2","_weights_from_3","dist_to_positions","other_position","perform","step_size","set_geometry","core_group0","core_group1","objects0","objects1","object0","object1","geometry0","geometry1","attrib0","attrib1","attrib0_array","attrib1_array","c0","c1","divisions","_core_transform","_cook_with_input","_cook_without_input","translate","translation_matrix","cache","PARAM_CALLBACK_reset","is_cache_empty","json","toJSON","obj_loader","ObjectLoader","jsons","parse","all_objects","param_callback_PARAM_CALLBACK_reset","radius","segments_count","arc_angle","radian_per_segment","degrees_to_radians","point_radian","cos","sin","positions_2d","position_2d","DEFAULT_UP","segments","direction","_create_circle","_create_disk","create","rotate_geometry","BaseCodeSopProcessor","core_groups","code_typescript","label","language","TYPESCRIPT","code_javascript","set_width","_compile_if_required","_processor","_last_compiled_code","function_body","processor_class","AsyncFunction","processor_creator_function","set_node","MathUtils","euclideanModulo","clamp","setHSL","DEFAULT_COLOR","from_attribute","as_hsv","_r_arrays_by_geometry_uuid","_g_arrays_by_geometry_uuid","_b_arrays_by_geometry_uuid","_set_from_attribute","_eval_expressions","_eval_simple_values","_create_init_color","src_attrib_size","src_array","dest_array","dest_i","src_i","new_color","set_hsv","tmp_array_r","_update_from_param","tmp_array_g","tmp_array_b","_commit_tmp_values","target_array","segments_radial","segments_height","cap","theta_start","theta_length","DEFAULT","SCALE","PSCALE","EYE","UP","DEFAULT_UV","_group_wrapper","_matrices","_is_pscale_present","_is_scale_present","_is_normal_present","_is_up_present","_do_rotate_matrices","Matrix4","_matrix_from_point","pscale","scale_matrix","makeScale","translate_matrix","makeTranslation","multiply","rotate_matrix","eye","up","lookAt","geometry_to_instance","template_core_group","attributes_to_copy","instance_pts","InstancedBufferGeometry","instances_count","colors","scales","orients","has_color","Quaternion","instance_matrices","matrices","instance_pt","index3","index4","has_uv","index2","InstancedBufferAttribute","pt","mark_as_instance","CoreGraphNode","_global_index","_point","transform_only","copy_attributes","use_copy_expr","_attribute_names_to_copy","ALWAYS","container0","request_input_container","has_input","container1","cook_with_template","cook_without_template","instance_core_group","template_points","_copy_moved_objects_on_template_points","_copy_moved_object_on_template_point","template_point","stamp_node","set_point","_get_moved_objects_for_template_point","moved_object","_copy_attributes_from_template","_stamp_instance_group_if_required","moved_objects","stamp_value","_copy_moved_objects_for_instance","set_global_index","stamped_instance_core_group","_copy_moved_objects_for_each_instance","_stamp_node","create_stamp_node","dirty_controller","set_forbidden_trigger_nodes","_size","THREE","Float32BufferAttribute","_attribute_datas_by_name","data_keys_prefix","skip_entries","do_convert","convert_to_numeric","success_callback","progress_callback","error_callback","fetch","response","_json","get_prefixed_json","catch","prefixes","first_prefix","shift","init_position_attribute","_find_attributes","convert_to_numeric_masks","_attribute_values_for_name","matches_one_mask","numerical_attrib_values","parseFloat","first_pt","_value_has_subentries","deep_attrib_name","deep_attrib_value","from_value","json_element","DEFAULT_DATA_STR","set_json","json_data_keys_prefix","convert","_on_load","_on_error","inputs_contents","ComparisonOperator","ComparisonOperatorMenuEntries","invert","hide_objects","by_object_type","by_expression","by_attrib","attrib_string","attrib_numeric","attrib_comparison_operator","by_bbox","bbox_size","by_visible","keep_points","_marked_for_deletion_per_object_index","_bbox_cache","_eval_for_points","_eval_for_objects","objects_to_keep","_eval_expressions_for_objects","_eval_type_for_objects","_eval_attrib_for_objects","marked_for_deletion","object_index","point_objects_from_deleted_objects","_point_object","init_points_count","_eval_expressions_for_points","_eval_attrib_for_points","_eval_bbox_for_points","geometry_from_points","remove","kept_points","keep_point","first_attrib_value","comparison_attrib_value","_comparison","attrib_ComparisonOperator","object_type_name","attrib_float","in_bbox","core_points","make_faces_unique","add_face_center_attribute","add_face_id","transform","_make_faces_unique","_add_face_center_attribute","_add_face_id","_transform_faces","current_value","face_center","fi","pi","on_success","on_error","load_auto","obj","on_load_success","object2","on_load_succes_gltf","on_load_succes_drc","gltf","loader_for_gltf","loader_for_glb","loader_for_drc","loader_for_obj","GLTFLoader","DRACOLoader","draco_loader","setDecoderPath","setDecoderConfig","setDRACOLoader","OBJLoader","always_reference_asset","dist","new_objects","_fuse_core_object","precision","points_by_position","round","_param_size","_param_hexagon_radius","_param_points_only","side_length","half_side_length","steps_count","floor","hexagon_radius","points_only","process","HierarchyMode","HIERARCHY_MODES","ADD_PARENT","REMOVE_PARENT","levels","_add_parent_to_core_group","_remove_parent_from_core_group","_add_parent_to_object","new_parent","_add_new_parent","new_parent2","new_children","_remove_parent_from_object","new_child","current_children","_get_children_from_objects","pop","apply_material","dependent_on_found_node","_on_create_bound","_on_create","core_group_to_instance","object_to_instance","_create_instance","_apply_material","mat_builder_node","set_assembler_globals_handler","create_instance_buffer_geo","node_with_mat_name","set_name","mesh_lambert_mat","mesh_lambert_mat_name","mat_node","instance_transform1","output1","set_input","create_mesh_lambert","amount","rand","layer","layers","origin","last_pt","i_n","apply_to_children","objects_from_group","grand_child","compact","input_core_group","_make_compact","objects_by_type","merged_objects","isLineSegments","merge_geometries","Operation","SimplexNoise","grad3","grad4","random","perm","simplex","prototype","dot3","dot4","noise","xin","yin","i1","j1","sqrt","G2","x0","y0","x1","y1","x2","y2","ii","jj","gi0","gi1","gi2","t0","t1","t2","noise3d","zin","k1","i2","j2","k2","G3","z0","z1","z2","x3","y3","z3","kk","gi3","t3","noise4d","l1","l2","i3","j3","k3","l3","F4","G4","w0","w1","w2","w3","x4","y4","z4","w4","ll","gi4","t4","Operations","ADD","SET","MULT","SUBSTRACT","DIVIDE","freq","octaves","amp_attenuation","freq_increase","use_normals","operation","compute_normals","_simplex_by_seed","_rest_points","core_group_rest","_rest_core_group_timestamp","_get_simplex","target_attrib_size","rest_point","current_attrib_value","pos","noise_value","_fbm","divide","amplitude","_create_simplex","delete","edit","update_x","update_y","update_z","recompute","_eval_expressions_for_core_group","_invert_normals","_eval_expressions_for_core_object","normal_attrib","set_border_radius","input_containers","geometry_node","import_input","samples","sep","buffer_resolution","bias","_process_occlusion_on_object","normal_array","aoSampler","cells","resolution","sample","ao","report","TextureAllocation","variable","_variables","set_allocation","graph_node_ids","variables_for_input_node","to_json","TextureVariable","allocation","_allocation","_graph_node_ids","splice","_allocations","_next_allocation_index","leaf_nodes","variables","add_graph_node_id","attrib_node","connected_input_node","connected_input_connection_point","output_names_attributes","allocate_variables","variables_by_size_inverse","allocate_variable","new_variable","allocated","has_variable","allocated_variable","has_space_for_variable","add_variable","new_allocation","next_allocation_name","explicit_shader_names","allocation_for_shader_name","input_names_for_node","texture_name","setup_shader_names_and_variables","update_shaders","_texture_allocations_controller","leaves_from_nodes","allocate_connections_from_root_nodes","set_texture_allocations_controller","texture_allocations_controller","export_node","texture_variable","component","add_export_body_line","is_importing","_handle_globals_time","_handle_globals_default","attrib_read","_uv_name","globals_geometry_handler","add_particles_sim_uv_attribute","var_name_texture","texture_definition","SAMPLER_2D","particles_sim_uv_attrib_definition","UV_ATTRIB","particles_sim_uv_varying_definition","UV_VARYING","PARTICLE_SIM_UV","_particles_group_objects","shaders_by_name","reset_render_material","_render_material","matrixAutoUpdate","updateMatrix","update_render_material_uniforms","gpu_controller","getCurrentRenderTarget","assign_custom_uniforms","new_texture_allocations_json","_texture_allocations_json","shader","init_custom_material_uniforms","assign_render_material","GPUComputationRenderer","sizeX","sizeY","currentTextureIndex","camera","Camera","passThruUniforms","passThruTexture","passThruShader","createShaderMaterial","mesh","addResolutionDefine","materialShader","toFixed","computeFragmentShader","addVariable","variableName","initialValueTexture","renderTargets","setVariableDependencies","capabilities","isWebGL2","extensions","maxVertexTextures","createRenderTarget","renderTexture","depVar","found","nextTextureIndex","dl","doRenderTarget","getAlternateRenderTarget","sizeXTexture","sizeYTexture","WebGLRenderTarget","format","navigator","userAgent","stencilBuffer","depthBuffer","createTexture","currentRenderTarget","getRenderTarget","setRenderTarget","render","_simulation_restart_required","variables_by_name","_created_textures_by_name","_used_textures_size","reset_gpu_compute","init_particle_group_points","create_gpu_compute","_gpu_compute","_particles_core_group","start_frame","_last_simulated_frame","_compute_simulation","update_simulation_material_uniforms","render_controller","auto_textures_size","nearest_power_of_two","nearestPower2","max_textures_size","isPowerOfTwo","textures_size","max_particles_count","time_dependent","force_time_dependent","_init_particles_uvs","_renderer","all_variables","_create_texture_render_targets","_fill_textures","create_simulation_material_uniforms","cmptr","uv_attrib_name","attribute_constructor","texture_allocation","texture_variables","texture_position","_restart_simulation","selected_geometries","_reset_material_if_dirty_bound","_reset_material_if_dirty","_on_create_prepare_material_bound","_on_create_prepare_material","reset_gpu_compute_and_set_dirty","is_on_frame_start","init_render_material","set_restart_not_required","reset_particle_groups","initialized","init_core_group","restart_simulation_if_required","compute_similation_if_required","run_assembler","_find_root_nodes","compile","set_shaders_by_name","assign_uniform_values","find_attribute_export_nodes","points_mat","PointsBuilder","points_mat_constant_point_size","Constant","points_mat_output1","create_points_mat","new_path","child_object","ROTATE_START","ROTATE_END","use_segments_count","_create_plane","size2d","update_normals","tmp_array_x","tmp_array_y","tmp_array_z","do_update_param","value_param","do_update","new_array","_array_for_component","curve_point_indices","accumulated_curve_point_indices","last_index_added","previous_index","attrib_sizes_by_name","new_attribute_values_by_name","attribute_sizes_by_name","create_line_segment_geometry","geometry_wrapper0","geometry_wrapper1","segments0","segments1","geometries_by_segments_count","smallest_geometry","largest_geometry","smallest_segments","largest_segments","smallest_points","largest_points","smallest_points_count","all_points","points_indices","segment","matched_segment","DEFAULT_R","DEFAULT_S","closed","_geometries","_create_tube","line_segment","current_points","_create_tube_from_points","circle_template","circles","new_circle","circle","prev_circle","_skin","MAT_DOUBLE_SIDED","transfer_face_normals","_bound_assign_mat","_assign_double_sided_material_to_object","_raycaster","Raycaster","core_group_collision","ray","first_intersect","_assign_double_sided_material_to_core_group","intersectObjects","set_normal","double_sided_material","METHOD","METHODS","POINTS_COUNT","SEGMENT_LENGTH","CURVE_TYPE","CURVE_TYPES","CENTRIPETAL","CHORDAL","CATMULLROM","method","curve_type","tension","segment_length","resampled_objects","resampled_object","_resample","_create_curve_from_points","old_curve_positions","curve","CatmullRomCurve3","new_curve_points","_get_points_from_curve","getSpacedPoints","getLength","transfer_attributes","attributes_to_transfer","add_id_attribute","areas_thresholds","area_sum","area_by_face_index","area","sorted_faces","f","attrib_values_by_name","start_with_count","face_index","random_position","attrib_value_at_position","cast_shadow","receive_shadow","process_one_input","process_two_inputs","line_segments0","_get_line_segments","first_line_segment","src_geometries","line_segment_to_geometries","prev_src_geometry","set_geometries","line_segments1","line_segments","smallest_array","largest_array","other_line_segment","other_geo","SphereType","SPHERE_TYPE","isocahedron","SPHERE_TYPES","ISOCAHEDRON","angle_range_x","angle_range_y","detail","_create_required_geometry","_create_default_sphere","_create_default_isocahedron","disallow_inputs_evaluation","opentype","TEXT_TYPE","TEXT_TYPES","FLAT","STROKE","font","text","multiline","extrude","stroke_width","_font_loader","FontLoader","_loaded_fonts","_load_url","err","_create_geometry_from_type_mesh","_create_geometry_from_type_flat","_create_geometry_from_type_line","_create_geometry_from_type_stroke","displayed_text","parameters","curveSegments","shapes","_get_shapes","shapes_from_font","current_index","getPoints","_svg_loader","_load_svg_loader","style","getStrokeStyle","arcDivisions","minDistance","pointsToStroke","holeShapes","shape","holes","hole","apply","generateShapes","elements2","Date","_load_ttf","_load_json","_ttf_loader","_load_ttf_loader","window","fnt","parsed","TTFLoader","SVGLoader","radius_tube","segments_tube","TorusKnotBufferGeometry","q","look_at","pivot","from_objects","EVENT","CameraController","_update_always","_listener_added","_listener","_execute_callback","set_target","_remove_camera_event","old_target","_target","_add_camera_event","new_update_always","CHANGE","MOVEEND","addEventListener","_current_event_name","removeEventListener","OBJ","_camera_controller","_update_uvs_from_camera","_processed_core_group","camera_node","_camera_object","remove_target","look_at_target","obj_world_matrix","matrixWorld","uvw","_vector_in_camera_space","vector","project","poly","register_node"],"mappings":"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","file":"Sop.bundle.js","sourcesContent":["import {BaseGlNodeType} from '../_Base';\nimport {TypedGLDefinitionCollection} from './GLDefinitionCollection';\nimport {ConnectionPointType} from '../../utils/connections/ConnectionPointType';\n\nexport enum GLDefinitionType {\n\tATTRIBUTE = 'attribute',\n\tFUNCTION = 'function',\n\tUNIFORM = 'uniform',\n\tVARYING = 'varying',\n}\n\nexport abstract class TypedGLDefinition<T extends GLDefinitionType> {\n\t// constructor(protected _node: BaseGlNodeType, protected _name: string) {}\n\tconstructor(\n\t\tprotected _definition_type: T,\n\t\tprotected _data_type: ConnectionPointType,\n\t\tprotected _node: BaseGlNodeType,\n\t\tprotected _name: string\n\t) {\n\t\t// super(_node, _name);\n\t}\n\n\tget definition_type() {\n\t\treturn this._definition_type;\n\t}\n\tget data_type() {\n\t\treturn this._data_type;\n\t}\n\tget node() {\n\t\treturn this._node;\n\t}\n\tget name() {\n\t\treturn this._name;\n\t}\n\t// get id() {\n\t// \treturn this._data_type;\n\t// }\n\n\tabstract get line(): string;\n\tcollection_instance() {\n\t\treturn new TypedGLDefinitionCollection<T>();\n\t}\n}\n\nexport class AttributeGLDefinition extends TypedGLDefinition<GLDefinitionType.ATTRIBUTE> {\n\tconstructor(protected _node: BaseGlNodeType, protected _data_type: ConnectionPointType, protected _name: string) {\n\t\tsuper(GLDefinitionType.ATTRIBUTE, _data_type, _node, _name);\n\t}\n\tget line() {\n\t\treturn `attribute ${this.data_type} ${this.name}`;\n\t}\n}\n\nexport class FunctionGLDefinition extends TypedGLDefinition<GLDefinitionType.FUNCTION> {\n\tconstructor(protected _node: BaseGlNodeType, protected _data_type: ConnectionPointType, protected _name: string) {\n\t\tsuper(GLDefinitionType.FUNCTION, _data_type, _node, _name);\n\t}\n\tget line() {\n\t\treturn this.name;\n\t}\n}\n\nexport class UniformGLDefinition extends TypedGLDefinition<GLDefinitionType.UNIFORM> {\n\tconstructor(protected _node: BaseGlNodeType, protected _data_type: ConnectionPointType, protected _name: string) {\n\t\tsuper(GLDefinitionType.UNIFORM, _data_type, _node, _name);\n\t}\n\tget line() {\n\t\treturn `uniform ${this.data_type} ${this.name}`;\n\t}\n}\n\nexport class VaryingGLDefinition extends TypedGLDefinition<GLDefinitionType.VARYING> {\n\tconstructor(protected _node: BaseGlNodeType, protected _data_type: ConnectionPointType, protected _name: string) {\n\t\tsuper(GLDefinitionType.VARYING, _data_type, _node, _name);\n\t}\n\tget line() {\n\t\treturn `varying ${this.data_type} ${this.name}`;\n\t}\n}\nexport type BaseGLDefinition = TypedGLDefinition<GLDefinitionType>;\n","import {CoreString} from './String';\nimport {Vector3} from 'three/src/math/Vector3';\nimport {Vector2} from 'three/src/math/Vector2';\nimport lodash_isNumber from 'lodash/isNumber';\nimport lodash_isBoolean from 'lodash/isBoolean';\nimport lodash_isString from 'lodash/isString';\n\nexport class ThreeToGl {\n\tstatic any(value: any) {\n\t\tif (lodash_isString(value)) {\n\t\t\treturn value;\n\t\t}\n\t\tif (lodash_isBoolean(value)) {\n\t\t\treturn `${value}`;\n\t\t}\n\n\t\tif (lodash_isNumber(value)) {\n\t\t\treturn `${CoreString.ensure_float(value)}`;\n\t\t} else {\n\t\t\tconst values = value.toArray().map((v: number) => {\n\t\t\t\treturn `${CoreString.ensure_float(v)}`;\n\t\t\t});\n\t\t\tconst gl_type = `vec${values.length}`;\n\t\t\treturn `${gl_type}(${values.join(', ')})`;\n\t\t}\n\t}\n\n\tstatic vector3(vec: Vector3 | string): string {\n\t\tif (lodash_isString(vec)) {\n\t\t\treturn vec;\n\t\t}\n\t\tconst values = vec.toArray().map((v) => {\n\t\t\treturn `${CoreString.ensure_float(v)}`;\n\t\t});\n\t\treturn `vec3(${values.join(', ')})`;\n\t}\n\tstatic vector2(vec: Vector2 | string): string {\n\t\tif (lodash_isString(vec)) {\n\t\t\treturn vec;\n\t\t}\n\t\tconst values = vec.toArray().map((v) => {\n\t\t\treturn `${CoreString.ensure_float(v)}`;\n\t\t});\n\t\treturn `vec2(${values.join(', ')})`;\n\t}\n\n\tstatic vector3_float(vec: Vector3 | string, num: number | string): string {\n\t\tif (!lodash_isString(num)) {\n\t\t\tnum = CoreString.ensure_float(num);\n\t\t}\n\t\treturn `vec4(${this.vector3(vec)}, ${num})`;\n\t}\n\n\tstatic float4(x: number | string, y: number | string, z: number | string, w: number | string) {\n\t\tif (!lodash_isString(x)) {\n\t\t\tx = CoreString.ensure_float(x);\n\t\t}\n\t\tif (!lodash_isString(y)) {\n\t\t\ty = CoreString.ensure_float(y);\n\t\t}\n\t\tif (!lodash_isString(z)) {\n\t\t\tz = CoreString.ensure_float(z);\n\t\t}\n\t\tif (!lodash_isString(w)) {\n\t\t\tw = CoreString.ensure_float(w);\n\t\t}\n\t\treturn `vec4(${x}, ${y}, ${z}, ${w})`;\n\t}\n\tstatic float3(x: number | string, y: number | string, z: number | string) {\n\t\tif (!lodash_isString(x)) {\n\t\t\tx = CoreString.ensure_float(x);\n\t\t}\n\t\tif (!lodash_isString(y)) {\n\t\t\ty = CoreString.ensure_float(y);\n\t\t}\n\t\tif (!lodash_isString(z)) {\n\t\t\tz = CoreString.ensure_float(z);\n\t\t}\n\t\treturn `vec3(${x}, ${y}, ${z})`;\n\t}\n\tstatic float2(x: number | string, y: number | string) {\n\t\tif (!lodash_isString(x)) {\n\t\t\tx = CoreString.ensure_float(x);\n\t\t}\n\t\tif (!lodash_isString(y)) {\n\t\t\ty = CoreString.ensure_float(y);\n\t\t}\n\t\treturn `vec2(${x}, ${y})`;\n\t}\n\tstatic float(x: number | string) {\n\t\tif (!lodash_isString(x)) {\n\t\t\tx = CoreString.ensure_float(x);\n\t\t}\n\t\treturn `${x}`;\n\t}\n\tstatic int(x: number | string) {\n\t\treturn `${x}`;\n\t}\n\tstatic bool(x: number | string) {\n\t\treturn `${x}`;\n\t}\n}\n","export enum ShaderName {\n\tVERTEX = 'vertex',\n\tFRAGMENT = 'fragment',\n\tLEAVES_FROM_NODES_SHADER = 'leaves_from_nodes_shader',\n\tPARTICLES_0 = 'particles_0',\n\tPARTICLES_1 = 'particles_1',\n\tPARTICLES_2 = 'particles_2',\n\tPARTICLES_3 = 'particles_3',\n\tPARTICLES_4 = 'particles_4',\n\tPARTICLES_5 = 'particles_5',\n\tPARTICLES_6 = 'particles_6',\n\tPARTICLES_7 = 'particles_7',\n\tPARTICLES_8 = 'particles_8',\n\tPARTICLES_9 = 'particles_9',\n}\nexport const ParticleShaderNames: Array<ShaderName> = [\n\tShaderName.PARTICLES_0,\n\tShaderName.PARTICLES_1,\n\tShaderName.PARTICLES_2,\n\tShaderName.PARTICLES_3,\n\tShaderName.PARTICLES_4,\n\tShaderName.PARTICLES_5,\n\tShaderName.PARTICLES_6,\n\tShaderName.PARTICLES_7,\n\tShaderName.PARTICLES_8,\n\tShaderName.PARTICLES_9,\n];\n","import {ParamTypeToConnectionPointTypeMap} from '../../utils/connections/ConnectionPointType';\nimport {BaseGlNodeType} from '../_Base';\nimport {BaseNamedConnectionPointType, TypedNamedConnectionPoint} from '../../utils/connections/NamedConnectionPoint';\n// import {ParamValue} from '../../../params/types/ParamValue';\nimport {ParamType} from '../../../poly/ParamType';\n// import {ParamValueToDefaultConverter} from '../../utils/params/ParamValueToDefaultConverter';\n// import {NodeEvent} from '../../../poly/NodeEvent';\nimport {ParamsUpdateOptions} from '../../utils/params/ParamsController';\n// import {ParamInitValueSerializedTypeMap} from '../../../params/types/ParamInitValueSerializedTypeMap';\nimport {ParamInitValueSerialized} from '../../../params/types/ParamInitValueSerialized';\nimport lodash_clone from 'lodash/clone';\nimport lodash_isArray from 'lodash/isArray';\nimport lodash_isNumber from 'lodash/isNumber';\n\nexport class GlNodeSpareParamsController {\n\tprivate _allow_inputs_created_from_params: boolean = true;\n\tprivate _inputless_param_names: string[] | undefined;\n\tconstructor(private node: BaseGlNodeType) {}\n\n\tdisallow_inputs_created_from_params() {\n\t\tthis._allow_inputs_created_from_params = false;\n\t}\n\n\tinitialize_node() {\n\t\tthis.node.params.set_post_create_params_hook(this.create_inputs_from_params.bind(this));\n\t}\n\n\tcreate_inputs_from_params() {\n\t\tif (!this._allow_inputs_created_from_params) {\n\t\t\treturn;\n\t\t}\n\t\tconst connections: BaseNamedConnectionPointType[] = [];\n\t\tfor (let param_name of this.node.params.names) {\n\t\t\tlet add_input = true;\n\t\t\tif (\n\t\t\t\tthis._inputless_param_names &&\n\t\t\t\tthis._inputless_param_names.length > 0 &&\n\t\t\t\tthis._inputless_param_names.includes(param_name)\n\t\t\t) {\n\t\t\t\tadd_input = false;\n\t\t\t}\n\t\t\tif (add_input) {\n\t\t\t\tif (this.node.params.has(param_name)) {\n\t\t\t\t\tconst param = this.node.params.get(param_name);\n\t\t\t\t\tif (param && !param.parent_param) {\n\t\t\t\t\t\tconst connection_type = ParamTypeToConnectionPointTypeMap[param.type];\n\t\t\t\t\t\tif (connection_type) {\n\t\t\t\t\t\t\tconst connection = new TypedNamedConnectionPoint(param.name, connection_type);\n\t\t\t\t\t\t\tconnections.push(connection);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tthis.node.io.inputs.set_named_input_connection_points(connections);\n\t}\n\n\tset_inputless_param_names(names: string[]) {\n\t\treturn (this._inputless_param_names = names);\n\t}\n\n\tcreate_spare_parameters() {\n\t\tconst raw_input_serialized_by_param_name: Map<string, ParamInitValueSerialized> = new Map();\n\t\tconst default_value_serialized_by_param_name: Map<string, ParamInitValueSerialized> = new Map();\n\t\tconst current_param_names: string[] = this.node.params.spare_names;\n\t\tconst params_update_options: ParamsUpdateOptions = {};\n\n\t\tfor (let param_name of current_param_names) {\n\t\t\tif (this.node.params.has(param_name)) {\n\t\t\t\tconst param = this.node.params.get(param_name);\n\t\t\t\tif (param) {\n\t\t\t\t\traw_input_serialized_by_param_name.set(param_name, param.raw_input_serialized);\n\t\t\t\t\tdefault_value_serialized_by_param_name.set(param_name, param.default_value_serialized);\n\t\t\t\t\tparams_update_options.names_to_delete = params_update_options.names_to_delete || [];\n\t\t\t\t\tparams_update_options.names_to_delete.push(param_name);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (let connection_point of this.node.io.inputs.named_input_connection_points) {\n\t\t\tconst param_name = connection_point.name;\n\t\t\tconst param_type: ParamType = connection_point.param_type;\n\t\t\tlet init_value = connection_point.init_value;\n\t\t\t// let raw_input: ParamInitValueSerialized= null\n\n\t\t\t// const raw_input = raw_input_serialized_by_param_name.get(param_name);\n\t\t\tconst last_param_init_value = default_value_serialized_by_param_name.get(param_name);\n\t\t\t// if (last_param_raw_input != null && last_param_init_value != null) {\n\t\t\t// init_value = ParamValueToDefaultConverter.from_value(param_type, last_param_raw_input);\n\t\t\t// if (init_value == null) {\n\t\t\tconst default_value_from_name = this.node.gl_input_default_value(param_name);\n\n\t\t\t// TODO: this should really store the largest set value\n\t\t\t// (as in the ones with the most components)\n\t\t\t// so that for an Add Gl Node, if I set a vec4 to [1,2,3,4]\n\t\t\t// and then set an input type, which will transform the param to a float\n\t\t\t// it will have a value of 1.\n\t\t\t// But if I then set it to a vec4 again, it will remember [1,2,3,4]\n\t\t\tif (default_value_from_name != null) {\n\t\t\t\tinit_value = default_value_from_name;\n\t\t\t} else {\n\t\t\t\tif (last_param_init_value != null) {\n\t\t\t\t\tinit_value = last_param_init_value;\n\t\t\t\t} else {\n\t\t\t\t\tinit_value = connection_point.init_value;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (lodash_isArray(connection_point.init_value) && lodash_isNumber(init_value)) {\n\t\t\t\tconst array = new Array(connection_point.init_value.length) as Number2;\n\t\t\t\tfor (let i = 0; i < array.length; i++) {\n\t\t\t\t\tarray[i] = init_value;\n\t\t\t\t}\n\t\t\t\tinit_value = array;\n\t\t\t}\n\n\t\t\tif (init_value != null) {\n\t\t\t\tparams_update_options.to_add = params_update_options.to_add || [];\n\t\t\t\tparams_update_options.to_add.push({\n\t\t\t\t\tname: param_name,\n\t\t\t\t\ttype: param_type,\n\t\t\t\t\tinit_value: lodash_clone(init_value as any),\n\t\t\t\t\toptions: {\n\t\t\t\t\t\tspare: true,\n\t\t\t\t\t},\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t\tif (!this.node.scene.loading_controller.is_loading) {\n\t\t\tthis.node.params.update_params(params_update_options);\n\n\t\t\tfor (let spare_param of this.node.params.spare) {\n\t\t\t\tif (!spare_param.parent_param) {\n\t\t\t\t\tconst raw_input = raw_input_serialized_by_param_name.get(spare_param.name);\n\t\t\t\t\tif (raw_input) {\n\t\t\t\t\t\tspare_param.set(raw_input as any);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n","import {TypedNode} from '../_Base';\nimport {ThreeToGl} from '../../../core/ThreeToGl';\nimport {BaseGlShaderAssembler} from './code/assemblers/_Base';\nimport {AssemblerControllerNode} from './code/Controller';\nimport {NodeContext} from '../../poly/NodeContext';\nimport {NodeParamsConfig} from '../utils/params/ParamsConfig';\nimport {ParamConfigsController} from '../utils/code/controllers/ParamConfigsController';\nimport {ShadersCollectionController} from './code/utils/ShadersCollectionController';\nimport {ParamInitValueSerialized} from '../../params/types/ParamInitValueSerialized';\nimport {GlNodeSpareParamsController} from './utils/SpareParamsController';\nimport {GlConnectionsController} from './utils/ConnectionsController';\n\nexport class TypedGlNode<K extends NodeParamsConfig> extends TypedNode<'GL', BaseGlNodeType, K> {\n\tstatic node_context(): NodeContext {\n\t\treturn NodeContext.GL;\n\t}\n\tprotected _param_configs_controller: ParamConfigsController | undefined;\n\tprotected _assembler: BaseGlShaderAssembler | undefined;\n\n\treadonly spare_params_controller: GlNodeSpareParamsController = new GlNodeSpareParamsController(this);\n\tpublic readonly gl_connections_controller: GlConnectionsController | undefined;\n\n\tinitialize_base_node() {\n\t\t// this.io.inputs.set_depends_on_inputs(false);\n\t\tthis.io.connections.init_inputs();\n\t\tthis.ui_data.set_layout_horizontal();\n\t\tthis.io.outputs.set_named_output_connection_points([]);\n\n\t\tthis.spare_params_controller.initialize_node();\n\t}\n\tnode_sibbling(name: string): BaseGlNodeType | null {\n\t\treturn super.node_sibbling(name) as BaseGlNodeType | null;\n\t}\n\tcook() {\n\t\tconsole.warn('gl nodes should never cook');\n\t}\n\n\tprotected _set_mat_to_recompile() {\n\t\tthis.material_node?.assembler_controller.set_compilation_required_and_dirty(this);\n\t}\n\tget material_node(): AssemblerControllerNode | undefined {\n\t\tif (this.parent) {\n\t\t\tif (this.parent.type == this.type) {\n\t\t\t\treturn (this.parent as BaseGlNodeType)?.material_node;\n\t\t\t} else {\n\t\t\t\treturn this.parent as AssemblerControllerNode;\n\t\t\t}\n\t\t}\n\t}\n\n\t//\n\t//\n\t// VARIABLES\n\t//\n\t//\n\tgl_var_name(name: string) {\n\t\treturn `v_POLY_${this.name}_${name}`;\n\t}\n\n\tvariable_for_input(name: string): string {\n\t\tconst input_index = this.io.inputs.get_input_index(name);\n\t\tconst connection = this.io.connections.input_connection(input_index);\n\t\tif (connection) {\n\t\t\tconst input_node = (<unknown>connection.node_src) as BaseGlNodeType;\n\t\t\tconst output_connection_point =\n\t\t\t\tinput_node.io.outputs.named_output_connection_points[connection.output_index];\n\t\t\tif (output_connection_point) {\n\t\t\t\tconst output_name = output_connection_point.name;\n\t\t\t\treturn input_node.gl_var_name(output_name);\n\t\t\t} else {\n\t\t\t\tconsole.warn(`no output called '${name}' for gl node ${input_node.full_path()}`);\n\t\t\t\tthrow 'variable_for_input ERROR';\n\t\t\t}\n\t\t} else {\n\t\t\treturn ThreeToGl.any(this.params.get(name)?.value);\n\t\t}\n\t}\n\n\t//\n\t//\n\t// ADDED LINES\n\t//\n\t//\n\tset_lines(shaders_collection_controller: ShadersCollectionController) {}\n\n\treset_code() {\n\t\tthis._param_configs_controller?.reset();\n\t\t// this.reset_lines();\n\t}\n\n\t//\n\t//\n\t// PARAM CONFIGS\n\t//\n\t//\n\tpublic set_param_configs() {}\n\tparam_configs() {\n\t\treturn this._param_configs_controller?.list;\n\t}\n\t// private reset_param_configs() {\n\t// \tthis._param_configs = [];\n\t// }\n\t// add_param_config<T extends ParamType>(\n\t// \ttype: T,\n\t// \tname: string,\n\t// \tdefault_value: ParamInitValuesTypeMap[T],\n\t// \tuniform_name: string\n\t// ) {\n\t// \tconst param_config = new ParamConfig(type, name, default_value, uniform_name);\n\t// \tthis._param_configs.push(param_config);\n\t// }\n\t// param_configs() {\n\t// \treturn this._param_configs;\n\t// }\n\t//\n\t//\n\t// INPUT\n\t//\n\t//\n\tgl_input_default_value(name: string): ParamInitValueSerialized {\n\t\treturn null;\n\t}\n\n\t//\n\t//\n\t// MISC\n\t//\n\t//\n\n\t//\n\t//\n\t// NEEDED?\n\t//\n\t//\n\t// set_assembler(assembler: BaseGlShaderAssembler) {\n\t// \tthis._assembler = assembler;\n\t// }\n\t// get assembler(): BaseGlShaderAssembler | undefined {\n\t// \treturn this._assembler;\n\t// }\n\n\t// shader_configs() {\n\t// \treturn this.assembler?.shader_configs || [];\n\t// }\n\t// shader_config(name: string) {\n\t// \treturn this.assembler?.shader_config(name);\n\t// }\n\t// shader_names() {\n\t// \treturn this.assembler?.shader_names || [];\n\t// }\n}\n\nexport type BaseGlNodeType = TypedGlNode<NodeParamsConfig>;\nexport class BaseGlNodeClass extends TypedGlNode<NodeParamsConfig> {}\n\nclass ParamlessParamsConfig extends NodeParamsConfig {}\nconst ParamsConfig = new ParamlessParamsConfig();\nexport class ParamlessTypedGlNode extends TypedGlNode<ParamlessParamsConfig> {\n\tparams_config = ParamsConfig;\n}\n","import {Material} from 'three/src/materials/Material';\nimport {TypedContainer} from './_Base';\nimport {ContainableMap} from './utils/ContainableMap';\n\nexport class MaterialContainer extends TypedContainer<ContainableMap['MATERIAL']> {\n\tset_content(content: ContainableMap['MATERIAL']) {\n\t\tsuper.set_content(content);\n\t}\n\tset_material(material: Material) {\n\t\tif (this._content != null) {\n\t\t\tthis._content.dispose();\n\t\t}\n\t\tthis.set_content(material);\n\t}\n\thas_material() {\n\t\treturn this.has_content();\n\t}\n\tmaterial() {\n\t\treturn this.content();\n\t}\n}\n","import {TypedNode} from '../_Base';\n\nimport {Material} from 'three/src/materials/Material';\n\n// import DisplayFlag from '../Concerns/DisplayFlag';\n\nimport {MaterialContainer} from '../../containers/Material';\nimport {Object3D} from 'three/src/core/Object3D';\nimport {NodeContext} from '../../poly/NodeContext';\nimport {TypedContainerController} from '../utils/ContainerController';\nimport {NodeParamsConfig} from '../utils/params/ParamsConfig';\n// type RenderHook = (object: Object3D) => void;\n\nexport abstract class TypedMatNode<M extends Material, K extends NodeParamsConfig> extends TypedNode<\n\t'MATERIAL',\n\tBaseMatNodeType,\n\tK\n> {\n\tcontainer_controller: TypedContainerController<MaterialContainer> = new TypedContainerController<MaterialContainer>(\n\t\tthis,\n\t\tMaterialContainer\n\t);\n\tstatic node_context(): NodeContext {\n\t\treturn NodeContext.MAT;\n\t}\n\n\tprotected _material: M | undefined;\n\t// protected _update_methods: RenderHook[] = [];\n\n\tinitialize_base_node() {\n\t\tsuper.initialize_base_node();\n\t\t// this._update_methods = [];\n\n\t\t// this._init_bypass_flag({\n\t\t// \thas_bypass_flag: false,\n\t\t// });\n\t\t// this._init_display_flag({\n\t\t// \thas_display_flag: false,\n\t\t// });\n\n\t\t// this.set_inputs_count_to_zero();\n\t\t// this._init_outputs({has_outputs: false});\n\n\t\t// this.container_controller.init(MaterialContainer);\n\n\t\tthis.name_controller.add_post_set_full_path_hook(this.set_material_name.bind(this));\n\n\t\tthis.add_post_dirty_hook(\n\t\t\t'_cook_main_without_inputs_when_dirty',\n\t\t\tthis._cook_main_without_inputs_when_dirty_bound\n\t\t);\n\n\t\t// it's probably good not to have to create any material in the constructor\n\t\t// but only on request\n\t\t// this._material = this.create_material();\n\t\t// this.set_material(this._material);\n\t}\n\tnode_sibbling(name: string): BaseMatNodeType | null {\n\t\treturn super.node_sibbling(name) as BaseMatNodeType | null;\n\t}\n\tprivate _cook_main_without_inputs_when_dirty_bound = this._cook_main_without_inputs_when_dirty.bind(this);\n\tprivate async _cook_main_without_inputs_when_dirty() {\n\t\tawait this.cook_controller.cook_main_without_inputs();\n\t}\n\n\tprivate set_material_name() {\n\t\t// ensures the material has a full path set\n\t\t// allowing the render hook to be set\n\t\t//this.set_material(@_material)\n\t\tif (this._material) {\n\t\t\tthis._material.name = this.full_path();\n\t\t}\n\t}\n\n\tabstract create_material(): M;\n\tget material() {\n\t\treturn (this._material = this._material || this.create_material());\n\t}\n\t//\n\n\tset_material(material: Material) {\n\t\tthis.set_container(material);\n\t}\n\n\t// add_update_method(method, arg?: any) {\n\t// \tthis._update_methods.push([method.bind(this), arg]);\n\t// }\n\n\t//run_update_methods: ->\n\n\tadd_render_hook(object: Object3D) {}\n}\n//delete object.onBeforeRender\n\nexport type BaseMatNodeType = TypedMatNode<Material, any>;\nexport class BaseMatNodeClass extends TypedMatNode<Material, any> {\n\tcreate_material() {\n\t\treturn new Material();\n\t}\n}\n","import {BaseNodeType} from '../../_Base';\n\ntype FlagHookCallback = () => void;\n\nexport class BaseFlag {\n\t// protected _available_states: [boolean, boolean] = [];\n\tprotected _state: boolean = true;\n\tprotected _hooks: FlagHookCallback[] | null = null;\n\tconstructor(protected node: BaseNodeType) {}\n\n\t// set_available_states(states: T[]) {}\n\tadd_hook(hook: FlagHookCallback) {\n\t\tthis._hooks = this._hooks || [];\n\t\tthis._hooks.push(hook);\n\t}\n\tprotected on_update() {}\n\tset(new_state: boolean) {\n\t\tif (this._state != new_state) {\n\t\t\tthis._state = new_state;\n\t\t\tthis.on_update();\n\t\t\tthis.run_hooks();\n\t\t}\n\t}\n\tget active() {\n\t\treturn this._state;\n\t}\n\ttoggle() {\n\t\tthis.set(!this._state);\n\t}\n\trun_hooks() {\n\t\tif (this._hooks) {\n\t\t\tfor (let hook of this._hooks) {\n\t\t\t\thook();\n\t\t\t}\n\t\t}\n\t}\n}\n","import {BaseFlag} from './Base';\nimport {NodeEvent} from '../../../poly/NodeEvent';\n\n// export interface BypassOptions {\n// \thas_bypass_flag?: boolean;\n// }\n\nexport class BypassFlag extends BaseFlag {\n\tprotected _state: boolean = false;\n\ton_update() {\n\t\tthis.node.emit(NodeEvent.FLAG_BYPASS_UPDATED);\n\t\tthis.node.set_dirty();\n\t}\n}\n\n// export function Bypass<TBase extends Constructor>(Base: TBase) {\n// \treturn class Mixin extends Base {\n// \t\tprotected self: BaseNode = (<unknown>this) as BaseNode;\n// \t\t_has_bypass_flag: boolean = true;\n// \t\t_bypass_flag: boolean = false;\n\n// \t\t_init_bypass_flag(options: BypassOptions = {}) {\n// \t\t\tif (options['has_bypass_flag'] == null) {\n// \t\t\t\toptions['has_bypass_flag'] = true;\n// \t\t\t}\n\n// \t\t\tthis._has_bypass_flag = options['has_bypass_flag'];\n// \t\t\tthis._bypass_flag = false;\n// \t\t}\n\n// \t\thas_bypass_flag(): boolean {\n// \t\t\treturn this._has_bypass_flag;\n// \t\t}\n\n// \t\tis_bypassed(): boolean {\n// \t\t\treturn this._bypass_flag;\n// \t\t}\n\n// \t\tset_bypass_flag(state: boolean) {\n// \t\t\tif (state == null) {\n// \t\t\t\tstate = true;\n// \t\t\t}\n// \t\t\tif (state !== this._bypass_flag) {\n// \t\t\t\tthis._bypass_flag = state;\n// \t\t\t\tthis.self.emit('bypass_flag_update');\n// \t\t\t\tthis.self.set_dirty();\n// \t\t\t\t// this.post_set_bypass_flag()\n// \t\t\t}\n// \t\t}\n\n// \t\t// post_process_container_request_as_bypassed(input_node: BaseNode){}\n// \t\t// post_set_bypass_flag(){}\n\n// \t\ttoggle_bypass_flag() {\n// \t\t\tthis.set_bypass_flag(!this.is_bypassed());\n// \t\t}\n// \t};\n// }\n","import {BaseFlag} from './Base';\nimport {NodeEvent} from '../../../poly/NodeEvent';\n\nexport class DisplayFlag extends BaseFlag {\n\ton_update() {\n\t\tthis.node.emit(NodeEvent.FLAG_DISPLAY_UPDATED);\n\t\t// this.node.set_dirty();\n\t}\n}\n","import {BaseNodeType} from '../_Base';\n\nimport {BypassFlag} from './flags/Bypass';\nimport {DisplayFlag} from './flags/Display';\n\nexport class FlagsController {\n\tpublic readonly bypass: DisplayFlag | undefined;\n\tpublic readonly display: BypassFlag | undefined;\n\tconstructor(protected node: BaseNodeType) {}\n\thas_display(): boolean {\n\t\treturn false;\n\t}\n\thas_bypass(): boolean {\n\t\treturn false;\n\t}\n}\n\nfunction Display<TBase extends Constructor>(Base: TBase) {\n\treturn class Mixin extends Base {\n\t\tprotected node!: BaseNodeType;\n\t\tpublic display: DisplayFlag = new DisplayFlag(this.node);\n\t\thas_display(): boolean {\n\t\t\treturn true;\n\t\t}\n\t};\n}\nfunction Bypass<TBase extends Constructor>(Base: TBase) {\n\treturn class Mixin extends Base {\n\t\tprotected node!: BaseNodeType;\n\t\tpublic readonly bypass: BypassFlag = new BypassFlag(this.node);\n\t\thas_bypass(): boolean {\n\t\t\treturn true;\n\t\t}\n\t};\n}\n\nexport class FlagsControllerD extends Display(FlagsController) {}\nexport class FlagsControllerB extends Bypass(FlagsController) {}\nexport class FlagsControllerDB extends Bypass(Display(FlagsController)) {}\n","import {BaseGlShaderAssembler} from '../_Base';\n\nimport {ThreeToGl} from '../../../../../../core/ThreeToGl';\nimport {OutputGlNode} from '../../../Output';\nimport {AttributeGlNode} from '../../../Attribute';\nimport {ShaderName} from '../../../../utils/shaders/ShaderName';\nimport {GlobalsGlNode} from '../../../Globals';\nimport {BaseGLDefinition, UniformGLDefinition} from '../../../utils/GLDefinition';\nimport {ConnectionPointType} from '../../../../utils/connections/ConnectionPointType';\nimport {MapUtils} from '../../../../../../core/MapUtils';\nimport {ShaderMaterialWithCustomMaterials} from '../../../../../../core/geometry/Material';\nimport {ShadersCollectionController} from '../../utils/ShadersCollectionController';\nimport {ShaderMaterial} from 'three/src/materials/ShaderMaterial';\nimport {GlNodeFinder} from '../../utils/NodeFinder';\nimport {IUniformsWithTime} from '../../../../../scene/utils/UniformsController';\n// import {BaseNodeType} from '../../_Base';\n// import {GlobalsGeometryHandler} from './Globals/Geometry'\n\nexport enum CustomMaterialName {\n\tDISTANCE = 'customDistanceMaterial',\n\tDEPTH = 'customDepthMaterial',\n\tDEPTH_DOF = 'customDepthDOFMaterial',\n}\n// export type ShaderAssemblerRenderDerivated = {new (node: BaseNodeType): ShaderAssemblerRender};\n// type ShaderAssemblerRenderDerivatedClass = new (...args: any[]) => ShaderAssemblerRender;\nexport type CustomAssemblerMap = Map<CustomMaterialName, typeof ShaderAssemblerMaterial>;\n\nexport class ShaderAssemblerMaterial extends BaseGlShaderAssembler {\n\tprivate _assemblers_by_custom_name: Map<CustomMaterialName, ShaderAssemblerMaterial> = new Map();\n\n\tcreate_material(): ShaderMaterial {\n\t\treturn new ShaderMaterial();\n\t}\n\n\tcustom_assembler_class_by_custom_name(): CustomAssemblerMap | undefined {\n\t\treturn undefined;\n\t}\n\n\tprotected _add_custom_materials(material: ShaderMaterial) {\n\t\tconst class_by_custom_name = this.custom_assembler_class_by_custom_name();\n\t\tif (class_by_custom_name) {\n\t\t\tclass_by_custom_name.forEach(\n\t\t\t\t(assembler_class: typeof ShaderAssemblerMaterial, custom_name: CustomMaterialName) => {\n\t\t\t\t\tthis._add_custom_material(\n\t\t\t\t\t\tmaterial as ShaderMaterialWithCustomMaterials,\n\t\t\t\t\t\tcustom_name,\n\t\t\t\t\t\tassembler_class\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t);\n\t\t}\n\t}\n\tprivate _add_custom_material(\n\t\tmaterial: ShaderMaterialWithCustomMaterials,\n\t\tcustom_name: CustomMaterialName,\n\t\tassembler_class: typeof ShaderAssemblerMaterial\n\t) {\n\t\tlet custom_assembler: ShaderAssemblerMaterial | undefined = this._assemblers_by_custom_name.get(custom_name);\n\t\tif (!custom_assembler) {\n\t\t\tcustom_assembler = new assembler_class(this._gl_parent_node);\n\t\t\tthis._assemblers_by_custom_name.set(custom_name, custom_assembler);\n\t\t}\n\t\tmaterial.custom_materials = material.custom_materials || {};\n\t\tmaterial.custom_materials[custom_name] = custom_assembler.create_material();\n\t}\n\n\tasync compile_custom_materials(material: ShaderMaterialWithCustomMaterials): Promise<void> {\n\t\t// const custom_materials_by_name: Map<CustomMaterialName, ShaderMaterial> = new Map();\n\t\t// this._assemblers_by_custom_name.clear();\n\n\t\tconst class_by_custom_name = this.custom_assembler_class_by_custom_name();\n\t\tif (class_by_custom_name) {\n\t\t\tclass_by_custom_name.forEach(\n\t\t\t\tasync (assembler_class: typeof ShaderAssemblerMaterial, custom_name: CustomMaterialName) => {\n\t\t\t\t\tif (this._code_builder) {\n\t\t\t\t\t\tlet assembler: ShaderAssemblerMaterial | undefined = this._assemblers_by_custom_name.get(\n\t\t\t\t\t\t\tcustom_name\n\t\t\t\t\t\t);\n\t\t\t\t\t\tif (!assembler) {\n\t\t\t\t\t\t\tassembler = new assembler_class(this._gl_parent_node);\n\t\t\t\t\t\t\tthis._assemblers_by_custom_name.set(custom_name, assembler);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tassembler.set_root_nodes(this._root_nodes);\n\t\t\t\t\t\tassembler.set_param_configs_owner(this._code_builder);\n\t\t\t\t\t\tassembler.set_shader_configs(this.shader_configs);\n\t\t\t\t\t\tassembler.set_variable_configs(this.variable_configs());\n\n\t\t\t\t\t\tconst custom_material = material.custom_materials[custom_name];\n\t\t\t\t\t\tif (custom_material) {\n\t\t\t\t\t\t\tawait assembler.compile_material(custom_material);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// if (material) {\n\t\t\t\t\t\t// \t// add needsUpdate = true, as we always get the same material\n\t\t\t\t\t\t// \t// material.needsUpdate = true;\n\t\t\t\t\t\t// \tcustom_materials_by_name.set(custom_name, material);\n\t\t\t\t\t\t// }\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t);\n\t\t}\n\n\t\t// for (let custom_name of Object.keys(class_by_custom_name)) {\n\t\t// \tconst assembler_class = class_by_custom_name[custom_name];\n\t\t// \t// const assembler = new assembler_class(this._gl_parent_node)\n\n\t\t// }\n\n\t\t// return custom_materials_by_name;\n\t}\n\tasync compile_material(material: ShaderMaterial) {\n\t\t// no need to compile if the globals handler has not been declared\n\t\tif (!this.compile_allowed()) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst output_nodes = GlNodeFinder.find_output_nodes(this._gl_parent_node);\n\t\tif (output_nodes.length > 1) {\n\t\t\tthis._gl_parent_node.states.error.set('only one output node allowed');\n\t\t}\n\t\tthis.set_root_nodes(output_nodes);\n\t\tawait this._update_shaders();\n\n\t\tconst new_vertex_shader = this._shaders_by_name.get(ShaderName.VERTEX);\n\t\tconst new_fragment_shader = this._shaders_by_name.get(ShaderName.FRAGMENT);\n\t\tif (new_vertex_shader && new_fragment_shader) {\n\t\t\tmaterial.vertexShader = new_vertex_shader;\n\t\t\tmaterial.fragmentShader = new_fragment_shader;\n\t\t\t// if (this._template_shader && this._template_shader.uniforms) {\n\t\t\tthis.add_uniforms(material.uniforms);\n\t\t\t// }\n\t\t\tmaterial.needsUpdate = true;\n\t\t}\n\n\t\tconst scene = this._gl_parent_node.scene;\n\t\tif (this.uniforms_time_dependent()) {\n\t\t\t// make sure not to use this._gl_parent_node.graph_node_id() as the id,\n\t\t\t// as we need several materials:\n\t\t\t// - the visible one\n\t\t\t// - the multiple shadow ones\n\t\t\t// - and possibly a depth one\n\t\t\tscene.uniforms_controller.add_time_dependent_uniform_owner(\n\t\t\t\tmaterial.uuid,\n\t\t\t\tmaterial.uniforms as IUniformsWithTime\n\t\t\t);\n\t\t} else {\n\t\t\tscene.uniforms_controller.remove_time_dependent_uniform_owner(material.uuid);\n\t\t}\n\n\t\t// const material = await this._assembler.get_material();\n\t\t// if (material) {\n\t\t// this._shaders_by_name.set(ShaderName.VERTEX, this._template_shader!.vertexShader!);\n\t\t// this._shaders_by_name.set(ShaderName.FRAGMENT, this._template_shader!.fragmentShader!);\n\n\t\t// assign custom materials\n\t\tif ((material as ShaderMaterialWithCustomMaterials).custom_materials) {\n\t\t\tawait this.compile_custom_materials(material as ShaderMaterialWithCustomMaterials);\n\t\t}\n\t\t// const custom_materials = await this.get_custom_materials();\n\t\t// const material_with_custom_materials = material as ShaderMaterialWithCustomMaterials;\n\t\t// material_with_custom_materials.custom_materials = {};\n\t\t// custom_materials.forEach((custom_material, shader_name) => {\n\t\t// \tmaterial_with_custom_materials.custom_materials[shader_name] = custom_material;\n\t\t// });\n\n\t\t// material.needsUpdate = true;\n\t\t// }\n\n\t\t// this.create_spare_parameters();\n\t}\n\tprivate async _update_shaders() {\n\t\tthis._shaders_by_name = new Map();\n\t\tthis._lines = new Map();\n\t\tfor (let shader_name of this.shader_names) {\n\t\t\tconst template = this._template_shader_for_shader_name(shader_name);\n\t\t\tif (template) {\n\t\t\t\tthis._lines.set(shader_name, template.split('\\n'));\n\t\t\t}\n\t\t}\n\t\tif (this._root_nodes.length > 0) {\n\t\t\t// this._output_node.set_assembler(this)\n\t\t\tawait this.build_code_from_nodes(this._root_nodes);\n\n\t\t\tthis._build_lines();\n\t\t}\n\t\t// this._material.uniforms = this.build_uniforms(template_shader)\n\t\tfor (let shader_name of this.shader_names) {\n\t\t\tconst lines = this._lines.get(shader_name);\n\t\t\tif (lines) {\n\t\t\t\tthis._shaders_by_name.set(shader_name, lines.join('\\n'));\n\t\t\t}\n\t\t}\n\t}\n\n\tshadow_assembler_class_by_custom_name() {\n\t\treturn {};\n\t}\n\n\tadd_output_body_line(\n\t\toutput_node: OutputGlNode,\n\t\tshaders_collection_controller: ShadersCollectionController,\n\t\tinput_name: string\n\t) {\n\t\tconst input = output_node.io.inputs.named_input(input_name);\n\t\tconst var_input = output_node.variable_for_input(input_name);\n\t\tconst variable_config = this.variable_config(input_name);\n\n\t\tlet new_var: string | null = null;\n\t\tif (input) {\n\t\t\tnew_var = ThreeToGl.vector3(var_input);\n\t\t} else {\n\t\t\tif (variable_config.default_from_attribute()) {\n\t\t\t\tconst connection_point = output_node.io.inputs.named_input_connection_points_by_name(input_name);\n\t\t\t\tif (connection_point) {\n\t\t\t\t\tconst gl_type = connection_point.type;\n\t\t\t\t\tconst attr_read = this.globals_handler?.read_attribute(\n\t\t\t\t\t\toutput_node,\n\t\t\t\t\t\tgl_type,\n\t\t\t\t\t\tinput_name,\n\t\t\t\t\t\tshaders_collection_controller\n\t\t\t\t\t);\n\t\t\t\t\tif (attr_read) {\n\t\t\t\t\t\tnew_var = attr_read;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconst variable_config_default = variable_config.default();\n\t\t\t\tif (variable_config_default) {\n\t\t\t\t\tnew_var = variable_config_default;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// const default_value = variable_config.default()\n\t\t\t// new_var = default_value\n\t\t\t// const definition_configs = variable_config.required_definitions() || []\n\t\t\t// for(let definition_config of definition_configs){\n\t\t\t// \tconst definition = definition_config.create_definition(output_node)\n\t\t\t// \toutput_node.add_definitions([definition])\n\t\t\t// }\n\t\t}\n\t\tif (new_var) {\n\t\t\tconst prefix = variable_config.prefix();\n\t\t\tconst suffix = variable_config.suffix();\n\t\t\tconst if_condition = variable_config.if_condition();\n\t\t\tif (if_condition) {\n\t\t\t\tshaders_collection_controller.add_body_lines(output_node, [`#if ${if_condition}`]);\n\t\t\t}\n\t\t\tshaders_collection_controller.add_body_lines(output_node, [`${prefix}${new_var}${suffix}`]);\n\t\t\tif (if_condition) {\n\t\t\t\tshaders_collection_controller.add_body_lines(output_node, [`#endif`]);\n\t\t\t}\n\t\t}\n\t}\n\n\tset_node_lines_output(output_node: OutputGlNode, shaders_collection_controller: ShadersCollectionController) {\n\t\t// const body_lines = [];\n\t\tconst shader_name = shaders_collection_controller.current_shader_name;\n\t\tconst input_names = this.shader_config(shader_name)?.input_names();\n\t\tif (input_names) {\n\t\t\t// shaders_collection_controller.set_body_lines([], shader_name);\n\t\t\tfor (let input_name of input_names) {\n\t\t\t\tthis.add_output_body_line(output_node, shaders_collection_controller, input_name);\n\t\t\t}\n\t\t}\n\t}\n\tset_node_lines_attribute(\n\t\tattribute_node: AttributeGlNode,\n\t\tshaders_collection_controller: ShadersCollectionController\n\t) {\n\t\t// const named_output = attribute_node.connected_output()\n\t\t// const named_connection = attribute_node.connected_input()\n\t\tconst gl_type = attribute_node.gl_type();\n\t\tconst new_var = this.globals_handler?.read_attribute(\n\t\t\tattribute_node,\n\t\t\tgl_type,\n\t\t\tattribute_node.attribute_name,\n\t\t\tshaders_collection_controller\n\t\t);\n\t\tconst var_name = attribute_node.gl_var_name(attribute_node.output_name);\n\t\tshaders_collection_controller.add_body_lines(attribute_node, [`${gl_type} ${var_name} = ${new_var}`]);\n\t\t// this.add_output_body_line(\n\t\t// \tattribute_node,\n\t\t// \tshader_name,\n\t\t// \tinput_name\n\t\t// \t)\n\n\t\t// const vertex_definitions = []\n\t\t// const vertex_body_lines = []\n\t\t// const fragment_definitions = []\n\n\t\t// const named_output = attribute_node.named_outputs()[0]\n\t\t// const gl_type = named_output.type()\n\t\t// const var_name = attribute_node.gl_var_name(named_output.name())\n\n\t\t// const attribute_name = attribute_node.attribute_name()\n\t\t// // TODO: I should probably raise an error in the node\n\t\t// // maybe when doint the initial eval of all nodes and check for errors?\n\t\t// if(!attribute_name){\n\t\t// \tconsole.error(attribute_node.full_path())\n\t\t// \tthrow new Error(\"empty attr name\")\n\t\t// }\n\t\t// if(GlobalsGeometryHandler.PRE_DEFINED_ATTRIBUTES.indexOf(attribute_name) < 0){\n\t\t// \tvertex_definitions.push(new Definition.Attribute(attribute_node, gl_type, attribute_name))\n\t\t// }\n\t\t// vertex_definitions.push(new Definition.Varying(attribute_node, gl_type, var_name))\n\t\t// vertex_body_lines.push( `${var_name} = ${attribute_name}` )\n\t\t// fragment_definitions.push(new Definition.Varying(attribute_node, gl_type, var_name))\n\n\t\t// attribute_node.set_definitions(vertex_definitions, 'vertex')\n\t\t// attribute_node.set_definitions(fragment_definitions, 'fragment')\n\t\t// attribute_node.add_body_lines(vertex_body_lines, 'vertex')\n\t}\n\n\thandle_gl_FragCoord(body_lines: string[], shader_name: ShaderName, var_name: string) {\n\t\tif (shader_name == ShaderName.FRAGMENT) {\n\t\t\tbody_lines.push(`vec4 ${var_name} = gl_FragCoord`);\n\t\t}\n\t}\n\thandle_resolution(body_lines: string[], shader_name: ShaderName, var_name: string) {\n\t\tif (shader_name == ShaderName.FRAGMENT) {\n\t\t\tbody_lines.push(`vec2 ${var_name} = resolution`);\n\t\t}\n\t}\n\n\tset_node_lines_globals(globals_node: GlobalsGlNode, shaders_collection_controller: ShadersCollectionController) {\n\t\t// const vertex_definitions = [];\n\t\t// const fragment_definitions = [];\n\t\t// const definitions = [];\n\t\t// const vertex_body_lines = []\n\t\t// const fragment_body_lines = [];\n\t\tconst body_lines = [];\n\t\tconst shader_name = shaders_collection_controller.current_shader_name;\n\t\tconst shader_config = this.shader_config(shader_name);\n\t\tif (!shader_config) {\n\t\t\treturn;\n\t\t}\n\t\tconst dependencies = shader_config.dependencies();\n\n\t\tconst definitions_by_shader_name: Map<ShaderName, BaseGLDefinition[]> = new Map();\n\t\t// definitions_by_shader_nameshader_name] = [];\n\t\t// for (let dependency of dependencies) {\n\t\t// \tdefinitions_by_shader_name[dependency] = [];\n\t\t// }\n\n\t\tconst body_lines_by_shader_name: Map<ShaderName, string[]> = new Map();\n\t\t// body_lines_by_shader_name[shader_name] = [];\n\t\t// for (let dependency of dependencies) {\n\t\t// \tbody_lines_by_shader_name[dependency] = [];\n\t\t// }\n\n\t\tlet definition;\n\t\tlet body_line;\n\t\tfor (let output_name of globals_node.io.outputs.used_output_names()) {\n\t\t\tconst var_name = globals_node.gl_var_name(output_name);\n\t\t\tconst globals_shader_name = shaders_collection_controller.current_shader_name;\n\n\t\t\tswitch (output_name) {\n\t\t\t\tcase 'time':\n\t\t\t\t\tdefinition = new UniformGLDefinition(globals_node, ConnectionPointType.FLOAT, output_name);\n\t\t\t\t\tif (globals_shader_name) {\n\t\t\t\t\t\tMapUtils.push_on_array_at_entry(definitions_by_shader_name, globals_shader_name, definition);\n\t\t\t\t\t}\n\n\t\t\t\t\tbody_line = `float ${var_name} = ${output_name}`;\n\t\t\t\t\tfor (let dependency of dependencies) {\n\t\t\t\t\t\tMapUtils.push_on_array_at_entry(definitions_by_shader_name, dependency, definition);\n\t\t\t\t\t\tMapUtils.push_on_array_at_entry(body_lines_by_shader_name, dependency, body_line);\n\t\t\t\t\t}\n\n\t\t\t\t\t// vertex_body_lines.push(`float ${var_name} = ${output_name}`)\n\t\t\t\t\tbody_lines.push(body_line);\n\t\t\t\t\tthis.set_uniforms_time_dependent();\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'gl_FragCoord':\n\t\t\t\t\tthis.handle_gl_FragCoord(body_lines, shader_name, var_name);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'resolution':\n\t\t\t\t\tthis.handle_resolution(body_lines, shader_name, var_name);\n\t\t\t\t\tdefinition = new UniformGLDefinition(globals_node, ConnectionPointType.VEC2, output_name);\n\t\t\t\t\tif (globals_shader_name) {\n\t\t\t\t\t\tMapUtils.push_on_array_at_entry(definitions_by_shader_name, globals_shader_name, definition);\n\t\t\t\t\t}\n\t\t\t\t\tfor (let dependency of dependencies) {\n\t\t\t\t\t\tMapUtils.push_on_array_at_entry(definitions_by_shader_name, dependency, definition);\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.set_resolution_dependent();\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'gl_PointCoord':\n\t\t\t\t\tif (shader_name == ShaderName.FRAGMENT) {\n\t\t\t\t\t\tbody_lines.push(`vec2 ${var_name} = gl_PointCoord`);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\t// const named_output = globals_node.named_output_by_name(output_name)\n\t\t\t\t\t// const gl_type = named_output.gl_type()\n\t\t\t\t\t// const new_var = this.globals_handler().read_attribute(\n\t\t\t\t\t// \tglobals_node,\n\t\t\t\t\t// \tgl_type,\n\t\t\t\t\t// \toutput_name\n\t\t\t\t\t// )\n\t\t\t\t\t// const body_line = `${var_name} = ${new_var}`\n\t\t\t\t\t// globals_node.add_body_lines([body_line])\n\t\t\t\t\tthis.globals_handler?.handle_globals_node(\n\t\t\t\t\t\tglobals_node,\n\t\t\t\t\t\toutput_name,\n\t\t\t\t\t\tshaders_collection_controller\n\t\t\t\t\t\t// definitions_by_shader_name,\n\t\t\t\t\t\t// body_lines_by_shader_name,\n\t\t\t\t\t\t// body_lines,\n\t\t\t\t\t\t// dependencies,\n\t\t\t\t\t\t// shader_name\n\t\t\t\t\t);\n\t\t\t\t// const named_output = globals_node.named_output_by_name(output_name)\n\t\t\t\t// const gl_type = named_output.gl_type()\n\t\t\t\t// definition = new Definition.Varying(globals_node, gl_type, var_name)\n\t\t\t\t// definitions_by_shader_name[shader_name].push(definition)\n\t\t\t\t// throw \"debug\"\n\n\t\t\t\t// body_line = `${var_name} = vec3(${output_name})`\n\t\t\t\t// for(let dependency of dependencies){\n\t\t\t\t// \tdefinitions_by_shader_name[dependency].push(definition)\n\t\t\t\t// \tbody_lines_by_shader_name[dependency].push(body_line)\n\t\t\t\t// }\n\t\t\t\t// if(dependencies.length == 0){\n\t\t\t\t// \tbody_lines.push(body_line)\n\t\t\t\t// }\n\t\t\t}\n\t\t}\n\t\t// this.set_vertex_definitions(vertex_definitions)\n\t\t// this.set_fragment_definitions(fragment_definitions)\n\t\tdefinitions_by_shader_name.forEach((definitions, shader_name) => {\n\t\t\tshaders_collection_controller.add_definitions(globals_node, definitions, shader_name);\n\t\t});\n\t\tbody_lines_by_shader_name.forEach((body_lines, shader_name) => {\n\t\t\tshaders_collection_controller.add_body_lines(globals_node, body_lines, shader_name);\n\t\t});\n\t\t// this.add_definitions(definitions)\n\t\t// this.set_vertex_body_lines(vertex_body_lines)\n\t\t// this.set_fragment_body_lines(fragment_body_lines)\n\n\t\tshaders_collection_controller.add_body_lines(globals_node, body_lines);\n\t}\n}\n","import {GlobalsBaseController} from './_Base';\nimport {GlobalsGlNode} from '../../Globals';\nimport {AttributeGlNode} from '../../Attribute';\n// import {Definition} from '../../Definition/_Module';\n// import {DefinitionBaseConfig} from '../Config/DefinitionBaseConfig';\n// import {BaseGlNodeType} from '../../_Base';\nimport {VaryingGLDefinition, AttributeGLDefinition} from '../../utils/GLDefinition';\nimport {ConnectionPointType} from '../../../utils/connections/ConnectionPointType';\n// import {TypeAssert} from '../../../../poly/Assert';\nimport {MapUtils} from '../../../../../core/MapUtils';\nimport {ShaderName} from '../../../utils/shaders/ShaderName';\nimport {BaseGlNodeType} from '../../_Base';\nimport {ShadersCollectionController} from '../utils/ShadersCollectionController';\n\nconst VARIABLE_CONFIG_DEFAULT_BY_NAME: Dictionary<string> = {\n\tposition: 'vec3( position )',\n};\n\nexport class GlobalsGeometryHandler extends GlobalsBaseController {\n\tstatic PRE_DEFINED_ATTRIBUTES = [\n\t\t'position',\n\t\t'color',\n\t\t'normal',\n\t\t'uv',\n\t\t'uv2',\n\t\t'morphTarget0',\n\t\t'morphTarget1',\n\t\t'morphTarget2',\n\t\t'morphTarget3',\n\t\t'skinIndex',\n\t\t'skinWeight',\n\t];\n\n\tstatic IF_RULE = {\n\t\tuv:\n\t\t\t'defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )',\n\t};\n\n\thandle_globals_node(\n\t\tglobals_node: GlobalsGlNode,\n\t\toutput_name: string,\n\t\tshaders_collection_controller: ShadersCollectionController\n\t\t// definitions_by_shader_name: Map<ShaderName, BaseGLDefinition[]>,\n\t\t// body_lines_by_shader_name: Map<ShaderName, string[]>,\n\t\t// body_lines: string[],\n\t\t// dependencies: ShaderName[],\n\t\t// shader_name: ShaderName\n\t): void {\n\t\tconst connection_point = globals_node.io.outputs.named_output_connection_points_by_name(output_name);\n\t\tif (!connection_point) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst var_name = globals_node.gl_var_name(output_name);\n\t\tconst gl_type = connection_point.type;\n\t\tconst definition = new VaryingGLDefinition(globals_node, gl_type, var_name);\n\n\t\t// MapUtils.push_on_array_at_entry(definitions_by_shader_name, shader_name, definition);\n\t\tshaders_collection_controller.add_definitions(globals_node, [definition]);\n\t\t// definitions_by_shader_name.get(shader_name)!.push(definition);\n\t\tconst assembler = globals_node.material_node?.assembler_controller.assembler;\n\t\tif (!assembler) {\n\t\t\treturn;\n\t\t}\n\t\tconst shader_config = assembler.shader_config(shaders_collection_controller.current_shader_name);\n\t\tif (!shader_config) {\n\t\t\treturn;\n\t\t}\n\t\tconst dependencies = shader_config.dependencies();\n\n\t\tconst body_line = `${var_name} = ${gl_type}(${output_name})`;\n\t\tfor (let dependency of dependencies) {\n\t\t\t// MapUtils.push_on_array_at_entry(definitions_by_shader_name, dependency, definition);\n\t\t\t// MapUtils.push_on_array_at_entry(body_lines_by_shader_name, dependency, body_line);\n\t\t\tshaders_collection_controller.add_definitions(globals_node, [definition], dependency);\n\t\t\tshaders_collection_controller.add_body_lines(globals_node, [body_line], dependency);\n\t\t}\n\t\tif (dependencies.length == 0) {\n\t\t\t// body_lines.push(body_line);\n\t\t\tshaders_collection_controller.add_body_lines(globals_node, [body_line]);\n\t\t}\n\t}\n\n\tstatic variable_config_default(variable_name: string): string | undefined {\n\t\treturn VARIABLE_CONFIG_DEFAULT_BY_NAME[variable_name];\n\t}\n\tvariable_config_default(variable_name: string): string | undefined {\n\t\treturn GlobalsGeometryHandler.variable_config_default(variable_name);\n\t}\n\t// variable_config_required_definitions(variable_name:string):DefinitionBaseConfig[]{\n\t// \treturn null\n\t// }\n\tread_attribute(\n\t\tnode: BaseGlNodeType,\n\t\tgl_type: ConnectionPointType,\n\t\tattrib_name: string,\n\t\tshaders_collection_controller: ShadersCollectionController\n\t) {\n\t\treturn GlobalsGeometryHandler.read_attribute(node, gl_type, attrib_name, shaders_collection_controller);\n\t}\n\n\tstatic read_attribute(\n\t\tnode: BaseGlNodeType,\n\t\tgl_type: ConnectionPointType,\n\t\tattrib_name: string,\n\t\tshaders_collection_controller: ShadersCollectionController\n\t): string | undefined {\n\t\tif (GlobalsGeometryHandler.PRE_DEFINED_ATTRIBUTES.indexOf(attrib_name) < 0) {\n\t\t\tshaders_collection_controller.add_definitions(\n\t\t\t\tnode,\n\t\t\t\t[new AttributeGLDefinition(node, gl_type, attrib_name)],\n\t\t\t\tShaderName.VERTEX\n\t\t\t);\n\t\t} else {\n\t\t\t// const if_rule = GlobalsGeometryHandler.IF_RULE[attrib_name]\n\t\t\t// if(if_rule){\n\t\t\t// \tconst definition = new Definition.Attribute(node, gl_type, attrib_name)\n\t\t\t// \tdefinition.set_if_rule(if_rule)\n\t\t\t// \tnode.add_definitions([definition])\n\t\t\t// }\n\t\t}\n\n\t\t// if (!shader_name) {\n\t\t// \tthrow 'no shader name';\n\t\t// }\n\t\tconst shader_name = shaders_collection_controller.current_shader_name;\n\t\tswitch (shader_name) {\n\t\t\tcase ShaderName.VERTEX: {\n\t\t\t\treturn attrib_name;\n\t\t\t}\n\t\t\tcase ShaderName.FRAGMENT: {\n\t\t\t\t// let's assume it can only be an attribute gl node\n\t\t\t\tif (!(node instanceof AttributeGlNode)) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tconst var_name = 'varying_' + node.gl_var_name(node.output_name);\n\t\t\t\tconst varying_definition = new VaryingGLDefinition(node, gl_type, var_name);\n\n\t\t\t\tconst definitions_by_shader_name: Map<ShaderName, VaryingGLDefinition[]> = new Map();\n\t\t\t\t// definitions_by_shader_name.set(ShaderName.VERTEX, [])\n\t\t\t\tdefinitions_by_shader_name.set(ShaderName.FRAGMENT, []);\n\t\t\t\t// {\n\t\t\t\t// \t[ShaderName.VERTEX]: [],\n\t\t\t\t// \t[ShaderName.FRAGMENT]: [],\n\t\t\t\t// };\n\t\t\t\tconst body_lines_by_shader_name: Map<ShaderName, string[]> = new Map();\n\t\t\t\t// body_lines_by_shader_name.set(ShaderName.VERTEX, [])\n\t\t\t\tbody_lines_by_shader_name.set(ShaderName.FRAGMENT, []);\n\t\t\t\tMapUtils.push_on_array_at_entry(definitions_by_shader_name, shader_name, varying_definition);\n\n\t\t\t\tconst set_varying_body_line = `${var_name} = ${gl_type}(${attrib_name})`;\n\n\t\t\t\tconst shader_config = node.material_node?.assembler_controller.assembler.shader_config(shader_name);\n\t\t\t\tif (shader_config) {\n\t\t\t\t\tconst dependencies = shader_config.dependencies();\n\t\t\t\t\tfor (let dependency of dependencies) {\n\t\t\t\t\t\tMapUtils.push_on_array_at_entry(definitions_by_shader_name, dependency, varying_definition);\n\t\t\t\t\t\tMapUtils.push_on_array_at_entry(body_lines_by_shader_name, dependency, set_varying_body_line);\n\t\t\t\t\t}\n\t\t\t\t\tdefinitions_by_shader_name.forEach((definitions, shader_name) => {\n\t\t\t\t\t\tshaders_collection_controller.add_definitions(node, definitions, shader_name);\n\t\t\t\t\t});\n\t\t\t\t\tbody_lines_by_shader_name.forEach((body_lines, shader_name) => {\n\t\t\t\t\t\tshaders_collection_controller.add_body_lines(node, body_lines, shader_name);\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\treturn var_name;\n\t\t\t}\n\t\t}\n\t\t// TypeAssert.unreachable(shader_name);\n\n\t\t// const shader_name = node._shader_name // TODO: this is hack\n\t\t// const varying_definition = new Definition.Varying(node, gl_type, attrib_name)\n\t\t// const var_name = varying_definition.name()\n\t\t// definitions_by_shader_name[shader_name].push(varying_definition)\n\t\t// const shader_config = node.shader_config(shader_name)\n\t\t// const dependencies = shader_config.dependencies()\n\t\t// const body_line = `${var_name} = ${gl_type}(${attrib_name})`\n\t\t// for(let dependency of dependencies){\n\t\t// \tdefinitions_by_shader_name[dependency].push(varying_definition)\n\t\t// \tbody_lines_by_shader_name[dependency].push(body_line)\n\t\t// }\n\t\t// // if(dependencies.length == 0){\n\t\t// \t// body_lines.push(body_line)\n\t\t// \tnode.add_body_lines([body_line])\n\t\t// // }\n\t\t// for(let shader_name of Object.keys(definitions_by_shader_name)){\n\t\t// \tnode.add_definitions(definitions_by_shader_name[shader_name], shader_name)\n\t\t// }\n\t\t// for(let shader_name of Object.keys(body_lines_by_shader_name)){\n\t\t// \tnode.add_body_lines(body_lines_by_shader_name[shader_name], shader_name)\n\t\t// }\n\t\t// node.add_body_lines(body_lines)\n\t}\n\thandle_attribute_node(\n\t\tnode: AttributeGlNode,\n\t\tgl_type: ConnectionPointType,\n\t\tattrib_name: string,\n\t\tshaders_collection_controller: ShadersCollectionController\n\t) {\n\t\treturn GlobalsGeometryHandler.read_attribute(node, gl_type, attrib_name, shaders_collection_controller);\n\t}\n}\n","import {TypedContainer} from './_Base';\nimport {ContainableMap} from './utils/ContainableMap';\n\nexport class TextureContainer extends TypedContainer<ContainableMap['TEXTURE']> {\n\t// _content: Texture;\n\tset_content(content: ContainableMap['TEXTURE']) {\n\t\tsuper.set_content(content);\n\t}\n\n\t// set_texture(texture: Texture){\n\t// \tif (this._content != null) {\n\t// \t\tthis._content.dispose();\n\t// \t}\n\t// \tthis.set_content(texture);\n\t// }\n\ttexture(): ContainableMap['TEXTURE'] {\n\t\treturn this._content;\n\t}\n\tcore_content(): ContainableMap['TEXTURE'] {\n\t\treturn this._content;\n\t}\n\tcore_content_cloned(): ContainableMap['TEXTURE'] | undefined {\n\t\tconsole.log('clone', this._content);\n\t\tconst texture = this._content?.clone();\n\t\tif (texture) {\n\t\t\ttexture.needsUpdate = true;\n\t\t}\n\t\treturn texture;\n\t}\n\n\tobject() {\n\t\treturn this.texture();\n\t}\n\n\tinfos() {\n\t\tif (this._content != null) {\n\t\t\treturn [this._content];\n\t\t}\n\t}\n\tresolution(): [number, number] {\n\t\tif (this._content) {\n\t\t\tif (this._content.image) {\n\t\t\t\treturn [this._content.image.width, this._content.image.height];\n\t\t\t}\n\t\t}\n\t\treturn [-1, -1];\n\t}\n}\n","import {TypedNode} from '../_Base';\nimport {TextureContainer} from '../../containers/Texture';\nimport {Texture} from 'three/src/textures/Texture';\nimport {TypedContainerController} from '../utils/ContainerController';\nimport {NodeParamsConfig} from '../utils/params/ParamsConfig';\nimport {NodeContext} from '../../poly/NodeContext';\nimport {PolyScene} from '../../scene/PolyScene';\nimport {FlagsControllerB} from '../utils/FlagsController';\nimport {DataTexture} from 'three/src/textures/DataTexture';\nimport {LuminanceFormat, HalfFloatType} from 'three/src/constants';\n\nconst INPUT_COP_NAME = 'input texture';\nconst DEFAULT_INPUT_NAMES = [INPUT_COP_NAME, INPUT_COP_NAME, INPUT_COP_NAME, INPUT_COP_NAME];\n\nvar size = 32;\nvar data = new Uint16Array(size);\nfor (var i = 0; i < size; i++) {\n\tdata[i] = 0x70e2; // Half float 10000\n}\nconst EMPTY_DATA_TEXTURE = new DataTexture(data, size, 1, LuminanceFormat, HalfFloatType);\n\nexport class TypedCopNode<K extends NodeParamsConfig> extends TypedNode<'TEXTURE', BaseCopNodeType, K> {\n\tcontainer_controller: TypedContainerController<TextureContainer> = new TypedContainerController<TextureContainer>(\n\t\tthis,\n\t\tTextureContainer\n\t);\n\tpublic readonly flags: FlagsControllerB = new FlagsControllerB(this);\n\t// private _typed_array = new Uint8ClampedArray(512 * 512 * 4);\n\t// protected _texture: Texture = new DataTexture(this._typed_array, 512, 512, RGBFormat);\n\t// get texture() {\n\t// \treturn this._data_texture;\n\t// }\n\n\tstatic node_context(): NodeContext {\n\t\treturn NodeContext.COP;\n\t}\n\tstatic displayed_input_names(): string[] {\n\t\treturn DEFAULT_INPUT_NAMES;\n\t}\n\n\tconstructor(scene: PolyScene) {\n\t\tsuper(scene, 'BaseCopNode');\n\t}\n\n\tinitialize_base_node() {\n\t\t// this.flags.add_bypass();\n\n\t\t// this.flags.add_display();\n\t\t// if (this.flags.display) {\n\t\t// \tthis.flags.display.set(false);\n\t\t// }\n\t\tthis.io.outputs.set_has_one_output();\n\t\t// this.container_controller.init(CONTAINER_CLASS);\n\t}\n\tnode_sibbling(name: string): BaseCopNodeType | null {\n\t\treturn super.node_sibbling(name) as BaseCopNodeType | null;\n\t}\n\n\tset_texture(texture: Texture) {\n\t\t// this._copy_texture(texture);\n\t\ttexture.name = this.full_path();\n\t\tthis.set_container(texture);\n\t}\n\tclear_texture() {\n\t\tthis.set_container(EMPTY_DATA_TEXTURE);\n\t}\n\n\t// private _copy_texture(texture: Texture) {\n\t// \tconsole.log('_copy_texture', texture);\n\t// \tif (texture instanceof DataTexture) {\n\t// \t\tthis._data_texture.image = texture.image;\n\t// \t} else {\n\t// \t\tconst canvas = document.createElement('canvas');\n\t// \t\t// document.body.appendChild(canvas);\n\t// \t\tconst width = texture.image.width;\n\t// \t\tconst height = texture.image.height;\n\t// \t\tcanvas.width = width;\n\t// \t\tcanvas.height = height;\n\t// \t\tconst context = canvas.getContext('2d') as CanvasRenderingContext2D;\n\t// \t\tcontext.drawImage(texture.image, 0, 0);\n\t// \t\tconst image_data = context.getImageData(0, 0, width, height);\n\t// \t\tconsole.log(this._typed_array.length, image_data.data.length, image_data);\n\t// \t\tthis._data_texture.image = image_data;\n\t// \t}\n\t// \tthis._data_texture.format = texture.format;\n\t// \t// this._data_texture.mapping = texture.mapping;\n\t// \t// this._data_texture.wrapS = texture.wrapS;\n\t// \t// this._data_texture.wrapT = texture.wrapT;\n\t// \t// this._data_texture.minFilter = texture.minFilter;\n\t// \t// this._data_texture.magFilter = texture.magFilter;\n\t// \tthis._data_texture.needsUpdate = true;\n\t// \tconsole.log('updated data tex', this._data_texture);\n\n\t// \t// if (!this._texture || this._texture.uuid != texture.uuid) {\n\t// \t// \tif (!this._texture) {\n\t// \t// \t\tconsole.log('assign');\n\t// \t// \t\tthis._texture = texture.clone();\n\t// \t// \t\t// this._texture.name = this.full_path();\n\t// \t// \t} else {\n\t// \t// \t\tconsole.log('copy');\n\t// \t// \t\tconst keys = Object.keys(texture) as Array<keyof Texture>;\n\t// \t// \t\tconst protected_keys = ['uuid', 'name', 'node'];\n\t// \t// \t\tfor (let key of keys) {\n\t// \t// \t\t\tif (!protected_keys.includes(key)) {\n\t// \t// \t\t\t\tthis._texture[key] = texture[key] as never; // but why is 'never' needed?!\n\t// \t// \t\t\t}\n\t// \t// \t\t}\n\t// \t// \t}\n\t// \t// }\n\t// }\n}\n\nexport type BaseCopNodeType = TypedCopNode<any>;\nexport class BaseCopNodeClass extends TypedCopNode<any> {}\n","import {ConnectionPointType} from '../../utils/connections/ConnectionPointType';\nimport {BaseGlNodeType} from '../_Base';\nimport {CoreGraphNode} from '../../../../core/graph/CoreGraphNode';\nimport {TypedNamedConnectionPoint} from '../../utils/connections/NamedConnectionPoint';\nimport {NodeConnection} from '../../utils/connections/NodeConnection';\n\ntype IONameFunction = (index: number) => string;\ntype ExpectedConnectionTypesFunction = () => ConnectionPointType[];\n\nexport class GlConnectionsController {\n\tprivate _input_name_function: IONameFunction = (index: number) => {\n\t\treturn `in${index}`;\n\t};\n\tprivate _output_name_function: IONameFunction = (index: number) => {\n\t\treturn index == 0 ? 'val' : `val${index}`;\n\t};\n\t// private _default_input_type: ConnectionPointType = ConnectionPointType.FLOAT;\n\tprivate _expected_input_types_function: ExpectedConnectionTypesFunction = () => {\n\t\tconst type = this.first_input_connection_type() || ConnectionPointType.FLOAT;\n\t\treturn [type, type];\n\t};\n\tprivate _expected_output_types_function: ExpectedConnectionTypesFunction = () => {\n\t\treturn [this._expected_input_types_function()[0]];\n\t};\n\n\tconstructor(private node: BaseGlNodeType) {}\n\n\tset_input_name_function(func: IONameFunction) {\n\t\tthis._input_name_function = func;\n\t}\n\tset_output_name_function(func: IONameFunction) {\n\t\tthis._output_name_function = func;\n\t}\n\t// set_default_input_type(type: ConnectionPointType) {\n\t// \tthis._default_input_type = type;\n\t// }\n\tset_expected_input_types_function(func: ExpectedConnectionTypesFunction) {\n\t\tthis._expected_input_types_function = func;\n\t}\n\tset_expected_output_types_function(func: ExpectedConnectionTypesFunction) {\n\t\tthis._expected_output_types_function = func;\n\t}\n\n\toutput_name(index: number) {\n\t\treturn this._output_name_function(index);\n\t}\n\n\tprivate _update_signature_if_required_bound = this.update_signature_if_required.bind(this);\n\tprivate _initialized: boolean = false;\n\tinitialize_node() {\n\t\tif (this._initialized) {\n\t\t\tconsole.warn('already initialized', this.node);\n\t\t\treturn;\n\t\t}\n\t\tthis._initialized = true;\n\n\t\tthis.node.io.inputs.add_on_set_input_hook(\n\t\t\t'_update_signature_if_required',\n\t\t\tthis._update_signature_if_required_bound\n\t\t);\n\t\tthis.node.params.add_on_scene_load_hook(\n\t\t\t'_update_signature_if_required',\n\t\t\tthis._update_signature_if_required_bound\n\t\t);\n\t\tthis.node.params.set_post_create_params_hook(this._update_signature_if_required_bound);\n\t\tthis.node.add_post_dirty_hook('_update_signature_if_required', this._update_signature_if_required_bound);\n\t}\n\n\tupdate_signature_if_required(dirty_trigger?: CoreGraphNode) {\n\t\tif (!this.node.lifecycle.creation_completed || !this._connections_match_inputs()) {\n\t\t\tthis.update_connection_types();\n\t\t\tthis.node.remove_dirty_state();\n\t\t\tthis.make_successors_update_signatures();\n\t\t}\n\t}\n\t// used when a node changes its signature, adn the output nodes need to adapt their own signatures\n\tprivate make_successors_update_signatures() {\n\t\tfor (let successor of this.node.graph_all_successors()) {\n\t\t\tconst gl_node = successor as BaseGlNodeType;\n\t\t\tif (gl_node.gl_connections_controller) {\n\t\t\t\tgl_node.gl_connections_controller.update_signature_if_required(this.node);\n\t\t\t}\n\t\t}\n\t\t// this.node.io.connections\n\t\t// \t.output_connections()\n\t\t// \t.map((c) => c.node_dest)\n\t\t// \t.forEach((o) => {\n\t\t// \t\to.set_dirty(this.node);\n\t\t// \t});\n\t}\n\n\tupdate_connection_types() {\n\t\tconst set_dirty = false;\n\t\tconst expected_input_types = this._expected_input_types_function();\n\t\tconst expected_output_types = this._expected_output_types_function();\n\n\t\tconst named_input_connections = expected_input_types.map((type: ConnectionPointType, i: number) => {\n\t\t\treturn new TypedNamedConnectionPoint(this._input_name_function(i), type);\n\t\t});\n\t\tconst named_outputs = expected_output_types.map((type: ConnectionPointType, i: number) => {\n\t\t\treturn new TypedNamedConnectionPoint(this._output_name_function(i), type);\n\t\t});\n\n\t\tthis.node.io.inputs.set_named_input_connection_points(named_input_connections);\n\t\tthis.node.io.outputs.set_named_output_connection_points(named_outputs, set_dirty);\n\t\tthis.node.spare_params_controller.create_spare_parameters();\n\t}\n\n\tprotected _connections_match_inputs(): boolean {\n\t\tconst current_input_types = this.node.io.inputs.named_input_connection_points.map((c) => c.type);\n\t\tconst current_output_types = this.node.io.outputs.named_output_connection_points.map((c) => c.type);\n\t\tconst expected_input_types = this._expected_input_types_function();\n\t\tconst expected_output_types = this._expected_output_types_function();\n\n\t\tif (expected_input_types.length != current_input_types.length) {\n\t\t\treturn false;\n\t\t}\n\t\tif (expected_output_types.length != current_output_types.length) {\n\t\t\treturn false;\n\t\t}\n\n\t\tfor (let i = 0; i < current_input_types.length; i++) {\n\t\t\tif (current_input_types[i] != expected_input_types[i]) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\tfor (let i = 0; i < current_output_types.length; i++) {\n\t\t\tif (current_output_types[i] != expected_output_types[i]) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t// protected input_connection_type() {\n\t// \treturn this.first_input_connection_type();\n\t// }\n\t// protected output_connection_type() {\n\t// \treturn this.first_input_connection_type();\n\t// }\n\n\tfirst_input_connection_type(): ConnectionPointType | undefined {\n\t\tconst connections = this.node.io.connections.input_connections();\n\t\tif (connections) {\n\t\t\tconst first_connection = connections[0];\n\t\t\tif (first_connection) {\n\t\t\t\treturn this.connection_type_from_connection(first_connection);\n\t\t\t}\n\t\t}\n\t}\n\tconnection_type_from_connection(connection: NodeConnection): ConnectionPointType {\n\t\tconst node_src = connection.node_src;\n\t\tconst output_index = connection.output_index;\n\t\tconst node_src_output_connection = node_src.io.outputs.named_output_connection_points[output_index];\n\t\treturn node_src_output_connection.type;\n\t}\n}\n","/// <reference path=\"../../custom_typings/math.d.ts\" />\n\nimport {Vector3} from 'three/src/math/Vector3';\nimport {Quaternion} from 'three/src/math/Quaternion';\nimport {Object3D} from 'three/src/core/Object3D';\nimport {Matrix4} from 'three/src/math/Matrix4';\nimport {Euler} from 'three/src/math/Euler';\nimport {BufferGeometry} from 'three/src/core/BufferGeometry';\nimport {MathUtils} from 'three/src/math/MathUtils';\n\nimport {BaseNodeType} from '../engine/nodes/_Base';\n\nconst ROTATION_ORDER = 'XYZ';\n\nexport interface SetParamsFromMatrixOptions {\n\tscale?: boolean;\n}\n\n// TODO: remove the \"new\" in this whole file\n// const euler = new Euler(0, 0, 0, ROTATION_ORDER)\n\nexport class CoreTransform {\n\t// static create_params(node: BaseNodeType) {\n\t// \tnode.add_param(ParamType.VECTOR3, 't', [0, 0, 0]);\n\t// \tnode.add_param(ParamType.VECTOR3, 'r', [0, 0, 0]);\n\t// \tnode.add_param(ParamType.VECTOR3, 's', [1, 1, 1]);\n\t// \tnode.add_param(ParamType.FLOAT, 'scale', 1, {range: [0, 10]});\n\t// \tnode.add_param(ParamType.OPERATOR_PATH, 'look_at', '');\n\t// \tnode.add_param(ParamType.VECTOR3, 'up', [0, 1, 0]);\n\t// }\n\n\t// static matrix_from_node_with_transform_params(node: BaseNodeType): Matrix4 {\n\t// \tconst t = node.params.vector3('t');\n\t// \tconst r = node.params\n\t// \t\t.vector3('r')\n\t// \t\t.clone()\n\t// \t\t.multiplyScalar(Math.PI / 180);\n\t// \tconst s = node.params.vector3('s');\n\t// \tconst scale = node.params.float('scale');\n\t// \treturn this.matrix(t, r, s, scale);\n\t// }\n\n\t// if this is done, make sure to use eval with a  callback\n\t// @matrix_from_params: (node) ->\n\t// \tt = node.param('t').eval()\n\t// \tr = node.param('r').eval().multiplyScalar( Math.PI / 180 )\n\t// \ts = node.param('s').eval()\n\t// \tscale = node.param('scale').eval()\n\t// \tthis.matrix(t, r, s, scale)\n\n\tstatic set_params_from_matrix(matrix: Matrix4, node: BaseNodeType, options: SetParamsFromMatrixOptions = {}) {\n\t\tlet update_scale = options['scale'];\n\t\tif (update_scale == null) {\n\t\t\tupdate_scale = true;\n\t\t}\n\n\t\t// EPSILON = 0.0000001\n\t\t// PRECISION = 1000\n\t\t// components = ['x', 'y', 'z']\n\n\t\tconst position = new Vector3();\n\t\tconst quaternion = new Quaternion();\n\t\tconst scale = new Vector3();\n\t\tmatrix.decompose(position, quaternion, scale);\n\n\t\tconst euler = new Euler().setFromQuaternion(quaternion);\n\t\tconst rotation = euler.toVector3();\n\t\trotation.divideScalar(Math.PI / 180);\n\n\t\t// limit precision of position and rotation\n\t\t// lodash_each [position, rotation], (vector)->\n\t\t// \tlodash_each ['x', 'y', 'z'], (c)->\n\t\t// \t\tval = vector[c]\n\t\t// \t\tapproximation = parseInt(val * PRECISION) / PRECISION\n\t\t// \t\tvector[c] = approximation\n\n\t\t// round scale if we get values like 0.9999999999 or 1.00000000001\n\t\t// lodash_each ['x', 'y', 'z'], (c)->\n\t\t// \tval = scale[c]\n\t\t// \trounded = Math.round(val)\n\t\t// \tif Math.abs(val - rounded) < EPSILON\n\t\t// \t\tscale[c] = rounded\n\n\t\tnode.scene.batch_update(() => {\n\t\t\tnode.params.set_vector3('r', rotation.toArray() as Number3);\n\t\t\tnode.params.set_vector3('t', position.toArray() as Number3);\n\t\t\tnode.params.set_vector3('s', scale.toArray() as Number3);\n\t\t\tif (update_scale) {\n\t\t\t\tnode.params.set_float('scale', 1);\n\t\t\t}\n\t\t});\n\t}\n\t// this.object().position.copy(position)\n\t// this.object().quaternion.copy(quaternion)\n\t// this.object().scale.copy(scale)\n\n\tstatic set_params_from_object(object: Object3D, node: BaseNodeType) {\n\t\tconst position = object.position.toArray() as Number3;\n\t\tconst rotation = object.rotation.toArray().map((c) => c * (180 / Math.PI)) as Number3;\n\n\t\tnode.scene.batch_update(() => {\n\t\t\tnode.params.set_vector3('t', position);\n\t\t\tnode.params.set_vector3('r', rotation);\n\t\t});\n\t}\n\n\t// static translation_matrix(x: number, y: number, z: number): Matrix4 {\n\t// \tconst t = new Vector3(x, y, z);\n\t// \tconst quaternion = new Quaternion();\n\t// \tconst s = new Vector3(1, 1, 1);\n\n\t// \tconst matrix = new Matrix4();\n\t// \tmatrix.compose(t, quaternion, s);\n\t// \treturn matrix;\n\t// }\n\n\tprivate _translation_matrix: Matrix4 = new Matrix4();\n\tprivate _translation_matrix_q = new Quaternion();\n\tprivate _translation_matrix_s = new Vector3(1, 1, 1);\n\ttranslation_matrix(t: Vector3): Matrix4 {\n\t\tthis._translation_matrix.compose(t, this._translation_matrix_q, this._translation_matrix_s);\n\t\treturn this._translation_matrix;\n\t}\n\n\tstatic matrix_quaternion(matrix: Matrix4): Quaternion {\n\t\tconst t = new Vector3();\n\t\tconst quat = new Quaternion();\n\t\tconst s = new Vector3();\n\t\tmatrix.decompose(t, quat, s);\n\t\treturn quat;\n\t}\n\n\t// static matrix(t: Vector3, r: Vector3, s: Vector3, scale: number) {\n\t// \t// if I don't clone here, it created issues in the transform SOP\n\t// \ts = s.clone().multiplyScalar(scale);\n\n\t// \tconst quaternion = new Quaternion();\n\t// \tconst euler = new Euler(r.x, r.y, r.z, ROTATION_ORDER);\n\t// \tquaternion.setFromEuler(euler);\n\n\t// \tconst matrix = new Matrix4();\n\t// \tmatrix.compose(t, quaternion, s);\n\t// \treturn matrix;\n\t// }\n\tprivate _matrix = new Matrix4().identity();\n\tprivate _matrix_q = new Quaternion();\n\tprivate _matrix_e = new Euler();\n\tprivate _matrix_s = new Vector3();\n\tmatrix(t: Vector3, r: Vector3, s: Vector3, scale: number) {\n\t\tthis._matrix_e.set(MathUtils.degToRad(r.x), MathUtils.degToRad(r.y), MathUtils.degToRad(r.z), ROTATION_ORDER);\n\t\tthis._matrix_q.setFromEuler(this._matrix_e);\n\n\t\tthis._matrix_s.copy(s).multiplyScalar(scale);\n\n\t\tthis._matrix.compose(t, this._matrix_q, this._matrix_s);\n\t\treturn this._matrix;\n\t}\n\n\t// static rotate_geometry(geometry: BufferGeometry, vec_origin: Vector3, vec_dest: Vector3) {\n\t// \tconst quaternion = new Quaternion();\n\t// \tquaternion.setFromUnitVectors(vec_origin, vec_dest.clone().normalize());\n\t// \tconst matrix = new Matrix4();\n\t// \tmatrix.makeRotationFromQuaternion(quaternion);\n\t// \tgeometry.applyMatrix(matrix);\n\t// }\n\n\tprivate _rotate_geometry_m = new Matrix4();\n\tprivate _rotate_geometry_q = new Quaternion();\n\tprivate _rotate_geometry_vec_dest = new Vector3();\n\trotate_geometry(geometry: BufferGeometry, vec_origin: Vector3, vec_dest: Vector3) {\n\t\tthis._rotate_geometry_vec_dest.copy(vec_dest);\n\t\tthis._rotate_geometry_vec_dest.normalize();\n\t\tthis._rotate_geometry_q.setFromUnitVectors(vec_origin, this._rotate_geometry_vec_dest);\n\t\t// this._rotate_geometry_m.identity(); // not entirely sure this is necessary\n\t\tthis._rotate_geometry_m.makeRotationFromQuaternion(this._rotate_geometry_q);\n\t\tgeometry.applyMatrix4(this._rotate_geometry_m);\n\t}\n}\n","import {VideoTexture} from 'three/src/textures/VideoTexture';\nimport {TextureLoader} from 'three/src/loaders/TextureLoader';\nimport {Texture} from 'three/src/textures/Texture';\n// import {RepeatWrapping} from 'three/src/constants';\n// import {Float32BufferAttribute} from 'three/src/core/BufferAttribute';\n// import lodash_isArray from 'lodash/isArray';\n// import {CoreScriptLoader} from '/Script';\n// import {CoreGeometry} from '../geometry/Geometry';\nimport {UnsignedByteType} from 'three/src/constants';\nimport {CoreWalker} from '../Walker';\n\nimport {BaseNodeType} from '../../engine/nodes/_Base';\nimport {BaseParamType} from '../../engine/params/_Base';\nimport {BaseCopNodeClass} from '../../engine/nodes/cop/_Base';\nimport {TextureContainer} from '../../engine/containers/Texture';\nimport {Poly} from '../../engine/Poly';\n// import {BufferGeometry} from 'three/src/core/BufferGeometry';\n\ninterface VideoSourceTypeByExt {\n\togg: string;\n\togv: string;\n\tmp4: string;\n}\n// interface ImageScriptUrlByExt {\n// \texr: string;\n// \tbasis: string;\n// }\ninterface ThreeLoaderByExt {\n\texr: string;\n\tbasis: string;\n\thdr: string;\n}\n\nenum Extension {\n\tEXR = 'exr',\n\tBASIS = 'basis',\n\tHDR = 'hdr',\n}\n\nexport class CoreTextureLoader {\n\tstatic PARAM_DEFAULT = '/examples/textures/uv.jpg';\n\tstatic PARAM_ENV_DEFAULT = '/examples/textures/piz_compressed.exr';\n\n\tstatic VIDEO_EXTENSIONS = ['mp4', 'webm', 'ogv'];\n\tstatic VIDEO_SOURCE_TYPE_BY_EXT: VideoSourceTypeByExt = {\n\t\togg: 'video/ogg; codecs=\"theora, vorbis\"',\n\t\togv: 'video/ogg; codecs=\"theora, vorbis\"',\n\t\tmp4: 'video/mp4; codecs=\"avc1.42E01E, mp4a.40.2\"',\n\t};\n\t// static SCRIPT_URL_BY_EXT: ImageScriptUrlByExt = {\n\t// \texr: 'EXRLoader',\n\t// \tbasis: 'BasisTextureLoader',\n\t// };\n\t// static THREE_LOADER_BY_EXT: ThreeLoaderByExt = {\n\t// \texr: 'EXRLoader',\n\t// \tbasis: 'BasisTextureLoader',\n\t// };\n\t// @load_texture: (url, callback)->\n\t// \tif url\n\t// \t\tloader = this._texture_loader(url)\n\n\t// \t\tloader.load(\n\t// \t\t\turl,\n\t// \t\t\tcallback,\n\t// \t\t\tnull,\n\t// \t\t\t(error)=>\n\t// \t\t\t\tthis.set_error(\"could not load texture #{url}\")\n\t// \t\t\t\t#this._on_error(error)\n\t// \t\t\t)\n\t// \telse\n\t// \t\tthis.set_error(\"not url given to Mat/Base._load_texture\")\n\t// _on_error: (error)->\n\t// \tconsole.log(\"ERROR\")\n\t// \tconsole.log(error)\n\t// \tthis.set_error_message()\n\n\tconstructor(private _node: BaseNodeType, private _param: BaseParamType) {}\n\n\tasync load_texture_from_url_or_op(url: string): Promise<Texture | VideoTexture | null> {\n\t\tlet texture: Texture | null = null;\n\t\tlet found_node;\n\n\t\tif (url.substring(0, 3) == 'op:') {\n\t\t\tconst node_path = url.substring(3);\n\t\t\tfound_node = CoreWalker.find_node(this._node, node_path);\n\t\t\tif (found_node) {\n\t\t\t\tif (found_node instanceof BaseCopNodeClass) {\n\t\t\t\t\tconst container: TextureContainer = await found_node.request_container();\n\t\t\t\t\ttexture = container.texture();\n\t\t\t\t} else {\n\t\t\t\t\tthis._node.states.error.set(`found node is not a texture node`);\n\t\t\t\t}\n\n\t\t\t\t// this._assign_texture(attrib, texture)\n\t\t\t} else {\n\t\t\t\tthis._node.states.error.set(`no node found in path '${node_path}'`);\n\t\t\t}\n\t\t} else {\n\t\t\ttexture = await this.load_url(url);\n\t\t\tif (texture) {\n\t\t\t\t// param.mark_as_referencing_asset(url)\n\t\t\t\tif (this._param.options.texture_as_env()) {\n\t\t\t\t\t// texture = await CoreTextureLoader.set_texture_for_env(texture, this._node);\n\t\t\t\t} else {\n\t\t\t\t\ttexture = CoreTextureLoader.set_texture_for_mapping(texture);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis._node.states.error.set(`could not load texture ${url}`);\n\t\t\t}\n\t\t}\n\n\t\t// NOTE: if this._param gets its value from an expression like `ch('/CONTROL/photo_url')`\n\t\t// then found_node will be null, so the graph should not be changed\n\t\tif (found_node && this._param.graph_predecessors()[0] != found_node) {\n\t\t\tthis._param.graph_disconnect_predecessors();\n\t\t\tthis._param.add_graph_input(found_node);\n\t\t}\n\n\t\t// this._assign_texture(attrib, texture)\n\t\treturn texture;\n\t}\n\n\tasync load_url(url: string): Promise<Texture> {\n\t\treturn new Promise(async (resolve, reject) => {\n\t\t\t// url = this._resolve_url(url)\n\t\t\tconst ext = CoreTextureLoader._ext(url);\n\n\t\t\tif (CoreTextureLoader.VIDEO_EXTENSIONS.includes(ext)) {\n\t\t\t\tconst texture: VideoTexture = await this._load_as_video(url);\n\t\t\t\treturn texture;\n\t\t\t} else {\n\t\t\t\tthis.loader_for_ext(ext).then((loader) => {\n\t\t\t\t\tloader.load(url, resolve, undefined, (error: any) => {\n\t\t\t\t\t\tconsole.warn('error', error);\n\t\t\t\t\t\treject();\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\t}\n\n\tasync loader_for_ext(ext: string) {\n\t\tconst ext_lowercase = ext.toLowerCase() as keyof ThreeLoaderByExt;\n\t\t// const script_name = CoreTextureLoader.SCRIPT_URL_BY_EXT[ext_lowercase];\n\t\t// var loader;\n\n\t\tswitch (ext_lowercase) {\n\t\t\tcase Extension.EXR: {\n\t\t\t\tconst {EXRLoader} = await import('../../../modules/three/examples/jsm/loaders/EXRLoader');\n\t\t\t\treturn new EXRLoader();\n\t\t\t}\n\t\t\tcase Extension.HDR: {\n\t\t\t\tconst {RGBELoader} = await import('../../../modules/three/examples/jsm/loaders/RGBELoader');\n\t\t\t\tconst loader = new RGBELoader();\n\t\t\t\tloader.setDataType(UnsignedByteType); // FloatType,HalfFloatType\n\t\t\t\t// loader.setPath('/examples/textures/equirectangular/');\n\t\t\t\treturn loader;\n\t\t\t}\n\t\t\tcase Extension.BASIS: {\n\t\t\t\tconst {BasisTextureLoader} = await import(\n\t\t\t\t\t'../../../modules/three/examples/jsm/loaders/BasisTextureLoader'\n\t\t\t\t);\n\t\t\t\tconst loader = new BasisTextureLoader();\n\t\t\t\tloader.setTranscoderPath('/three/js/libs/basis/');\n\t\t\t\tconst renderer = await Poly.instance().renderers_controller.wait_for_renderer();\n\t\t\t\tif (renderer) {\n\t\t\t\t\tloader.detectSupport(renderer);\n\t\t\t\t} else {\n\t\t\t\t\tconsole.warn('texture loader found no renderer for basis texture loader');\n\t\t\t\t}\n\t\t\t\treturn loader;\n\t\t\t}\n\t\t}\n\n\t\t// if (script_name) {\n\t\t// const imported_classes = await CoreScriptLoader.load_module_three_loader(script_name)\n\t\t// const imported_classes = await CoreScriptLoader.three_module(`loaders/${script_name}`);\n\t\t// const imported_classes = await import(`modules/three/examples/jsm/loaders/${script_name}`);\n\t\t// const loader_class_name = CoreTextureLoader.THREE_LOADER_BY_EXT[ext_lowercase];\n\t\t// const loader_class = imported_classes[loader_class_name];\n\t\t// if (loader_class) {\n\t\t// \tloader = new loader_class();\n\t\t// \tif (ext == 'basis') {\n\t\t// \t\tloader.setTranscoderPath('/three/js/libs/basis/');\n\t\t// \t\tconst renderer = POLY.renderers_controller.first_renderer();\n\t\t// \t\tloader.detectSupport(renderer);\n\t\t// \t}\n\t\t// }\n\t\t// }\n\t\treturn new TextureLoader();\n\n\t\t// const constructor = (() => { switch (ext) {\n\t\t// \tcase 'exr': return EXRLoader;\n\t\t// \tdefault: return TextureLoader;\n\t\t// } })();\n\t\t// return new constructor();\n\t}\n\n\t_load_as_video(url: string): Promise<VideoTexture> {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tconst video = document.createElement('video');\n\t\t\t// document.body.appendChild(video)\n\t\t\t// video.id = 'video'\n\t\t\t// console.log(\"video\", video)\n\t\t\tvideo.setAttribute('crossOrigin', 'anonymous');\n\t\t\tvideo.setAttribute('autoplay', `${true}`); // to ensure it loads\n\t\t\tvideo.setAttribute('loop', `${true}`);\n\n\t\t\t// wait for onloadedmetadata to ensure that we have a duration\n\t\t\tvideo.onloadedmetadata = function () {\n\t\t\t\tvideo.pause();\n\t\t\t\tconst texture = new VideoTexture(video);\n\t\t\t\tresolve(texture);\n\t\t\t};\n\t\t\t// video.setAttribute('controls', true)\n\t\t\t// video.style=\"display:none\"\n\t\t\tconst source = document.createElement('source');\n\t\t\tconst ext = CoreTextureLoader._ext(url) as keyof VideoSourceTypeByExt;\n\t\t\tlet type: string = CoreTextureLoader.VIDEO_SOURCE_TYPE_BY_EXT[ext];\n\t\t\ttype = type || CoreTextureLoader._default_video_source_type(url);\n\t\t\tsource.setAttribute('type', type);\n\t\t\tsource.setAttribute('src', url);\n\n\t\t\tvideo.appendChild(source);\n\t\t});\n\t}\n\tstatic _default_video_source_type(url: string) {\n\t\tconst ext = this._ext(url);\n\t\treturn `video/${ext}`;\n\t}\n\n\tstatic pixel_data(texture: Texture) {\n\t\tconst img = texture.image;\n\t\tconst canvas = document.createElement('canvas');\n\t\tcanvas.width = img.width;\n\t\tcanvas.height = img.height;\n\t\tconst context = canvas.getContext('2d');\n\t\tif (context) {\n\t\t\tcontext.drawImage(img, 0, 0, img.width, img.height);\n\t\t\treturn context.getImageData(0, 0, img.width, img.height);\n\t\t}\n\t}\n\n\t// TODO: typescript: check what type the pixel_data is\n\t// static pixel_data_to_attribute(pixel_data: Pixel, geometry: BufferGeometry, attrib_name_with_component:string, convert_method: (x:number, y:number, z:number, w:number)=>number) {\n\t// \tconst {data} = pixel_data;\n\t// \tconst geometry_wrapper = new CoreGeometry(geometry);\n\t// \t// TODO: add error if no uvs\n\t// \tconst values = [];\n\t// \tconst points = geometry_wrapper.points();\n\t// \tfor (let point of points) {\n\t// \t\tconst uv = point.attrib_value('uv');\n\t// \t\tconst x = Math.floor((pixel_data.width - 1) * uv.x);\n\t// \t\tconst y = Math.floor((pixel_data.height - 1) * (1 - uv.y));\n\t// \t\tconst i = y * pixel_data.width + x;\n\t// \t\t// const val = data[4*i] / 255.0;\n\t// \t\tif (convert_method) {\n\t// \t\t\tconst val = convert_method(data[4 * i + 0], data[4 * i + 1], data[4 * i + 2], data[4 * i + 3]);\n\t// \t\t\tvalues.push(val);\n\t// \t\t} else {\n\t// \t\t\tvalues.push([data[4 * i + 0], data[4 * i + 1], data[4 * i + 2]]);\n\t// \t\t}\n\t// \t}\n\n\t// \tconst attrib_name_elements = attrib_name_with_component.split('.');\n\t// \tlet attrib_name = attrib_name_elements[0];\n\t// \tlet component_offset = null;\n\t// \tif (attrib_name_elements.length > 1) {\n\t// \t\tconst component = attrib_name_elements[1] as keyof Vector4Like\n\t// \t\tcomponent_offset = {x: 0, y: 1, z: 2, w: 3}[component];\n\t// \t}\n\n\t// \tlet attrib = geometry.attributes[attrib_name];\n\t// \tif (attrib) {\n\t// \t\tconst array = attrib.array;\n\t// \t\tlet index = 0;\n\t// \t\tlet is_array = null;\n\t// \t\tfor (let value of values) {\n\t// \t\t\tif (is_array || lodash_isArray(value)) {\n\t// \t\t\t\tis_array = true;\n\t// \t\t\t\tlet component_index = 0;\n\t// \t\t\t\tfor (let value_c of value) {\n\t// \t\t\t\t\tarray[attrib.itemSize * index + component_index] = value_c;\n\t// \t\t\t\t\tcomponent_index++;\n\t// \t\t\t\t}\n\t// \t\t\t} else {\n\t// \t\t\t\tarray[attrib.itemSize * index + component_offset] = value;\n\t// \t\t\t}\n\t// \t\t\tindex++;\n\t// \t\t}\n\t// \t} else {\n\t// \t\tattrib = geometry.setAttribute(attrib_name, new Float32BufferAttribute(values, 1));\n\t// \t}\n\t// \tattrib.needsUpdate = true;\n\t// }\n\n\tstatic _ext(url: string) {\n\t\tconst elements = url.split('.');\n\t\treturn elements[elements.length - 1].toLowerCase();\n\t}\n\t// static private _resolve_url(url: string):string{\n\t// \tif(url[0] == '/'){\n\t// \t\tconst root_url = POLY.env_is_production() ? 'https://polygonjs.com' : 'http://localhost:5000'\n\t// \t\turl = `${root_url}${url}`\n\t// \t}\n\t// \treturn url\n\t// }\n\n\tstatic set_texture_for_mapping(texture: Texture) {\n\t\t// let val = texture['wrapS']\n\t\t// Object.defineProperty(texture, 'wrapS', {\n\t\t// \tget () {\n\t\t// \t\treturn val // Simply return the cached value\n\t\t// \t},\n\t\t// \tset (newVal) {\n\t\t// \t\tval = newVal // Save the newVal\n\t\t// \t\tconsole.warn(\"set\", newVal)\n\t\t// \t}\n\t\t// })\n\n\t\t// texture.wrapS = RepeatWrapping\n\t\t// texture.wrapT = RepeatWrapping\n\t\t// console.log(\"set_texture_for_mapping\", RepeatWrapping, texture, texture.wrapS)\n\t\treturn texture;\n\t}\n\n\t// static async set_texture_for_env(texture: Texture, registerer: BaseNode) {\n\t// \tif (registerer._registered_env_map) {\n\t// \t\tPOLY.renderers_controller.deregister_env_map(registerer._registered_env_map);\n\t// \t}\n\t// \tregisterer._registered_env_map = await POLY.renderers_controller.register_env_map(texture);\n\t// \treturn registerer._registered_env_map;\n\t// }\n}\n","import {VideoTexture} from 'three/src/textures/VideoTexture';\nimport {\n\tUVMapping,\n\tCubeReflectionMapping,\n\tCubeRefractionMapping,\n\tEquirectangularReflectionMapping,\n\tEquirectangularRefractionMapping,\n\tSphericalReflectionMapping,\n\tCubeUVReflectionMapping,\n\tCubeUVRefractionMapping,\n\tClampToEdgeWrapping,\n\tRepeatWrapping,\n\tMirroredRepeatWrapping,\n\tLinearFilter,\n\tNearestFilter,\n\tNearestMipMapNearestFilter,\n\tNearestMipMapLinearFilter,\n\tLinearMipMapNearestFilter,\n\tLinearMipMapLinearFilter,\n\t// UnsignedByteType,\n\t// ByteType,\n\t// ShortType,\n\t// UnsignedShortType,\n\t// IntType,\n\t// UnsignedIntType,\n\t// FloatType,\n\t// HalfFloatType,\n\t// UnsignedShort4444Type,\n\t// UnsignedShort5551Type,\n\t// UnsignedShort565Type,\n\t// UnsignedInt248Type,\n\t// AlphaFormat,\n\t// RGBFormat,\n\t// RGBAFormat,\n\t// LuminanceFormat,\n\t// LuminanceAlphaFormat,\n\t// RGBEFormat,\n\t// DepthFormat,\n\t// DepthStencilFormat,\n\t// LinearEncoding,\n\t// sRGBEncoding,\n\t// GammaEncoding,\n\t// RGBEEncoding,\n\t// LogLuvEncoding,\n\t// RGBM7Encoding,\n\t// RGBM16Encoding,\n\t// RGBDEncoding,\n\t// BasicDepthPacking,\n\t// RGBADepthPacking,\n} from 'three/src/constants';\nimport {Texture} from 'three/src/textures/Texture';\n// const THREE = {\n// \tTexture,\n// \tUVMapping,\n// \tVideoTexture,\n// \tCubeReflectionMapping,\n// \tCubeRefractionMapping,\n// \tEquirectangularReflectionMapping,\n// \tEquirectangularRefractionMapping,\n// \tSphericalReflectionMapping,\n// \tCubeUVReflectionMapping,\n// \tCubeUVRefractionMapping,\n// \tClampToEdgeWrapping,\n// \tRepeatWrapping,\n// \tMirroredRepeatWrapping,\n// \tLinearFilter,\n// \tNearestFilter,\n// \tNearestMipMapNearestFilter,\n// \tNearestMipMapLinearFilter,\n// \tLinearMipMapNearestFilter,\n// \tLinearMipMapLinearFilter,\n// \tUnsignedByteType,\n// \tByteType,\n// \tShortType,\n// \tUnsignedShortType,\n// \tIntType,\n// \tUnsignedIntType,\n// \tFloatType,\n// \tHalfFloatType,\n// \tUnsignedShort4444Type,\n// \tUnsignedShort5551Type,\n// \tUnsignedShort565Type,\n// \tUnsignedInt248Type,\n// \tAlphaFormat,\n// \tRGBFormat,\n// \tRGBAFormat,\n// \tLuminanceFormat,\n// \tLuminanceAlphaFormat,\n// \tRGBEFormat,\n// \tDepthFormat,\n// \tDepthStencilFormat,\n// \tLinearEncoding,\n// \tsRGBEncoding,\n// \tGammaEncoding,\n// \tRGBEEncoding,\n// \tLogLuvEncoding,\n// \tRGBM7Encoding,\n// \tRGBM16Encoding,\n// \tRGBDEncoding,\n// \tBasicDepthPacking,\n// \tRGBADepthPacking,\n// };\n// import lodash_last from 'lodash/last';\n// import NodeBase from '../_Base'\n\nimport {TypedCopNode} from './_Base';\n// import {BaseParam} from '../../../Engine/Param/_Base'\nimport {CoreTextureLoader} from '../../../core/loader/Texture';\nimport {ParamType} from '../../poly/ParamType';\nimport {NodeEvent} from '../../poly/NodeEvent';\n\n// this used to be named file_in, but I can't recall the decision of not calling it simply 'file'\n// so renaming it back to file for now\n\nconst MAPPINGS = [\n\t{UVMapping},\n\t{CubeReflectionMapping},\n\t{CubeRefractionMapping},\n\t{EquirectangularReflectionMapping},\n\t{EquirectangularRefractionMapping},\n\t{SphericalReflectionMapping},\n\t{CubeUVReflectionMapping},\n\t{CubeUVRefractionMapping},\n];\n\nconst WRAPPINGS: Dictionary<number>[] = [{ClampToEdgeWrapping}, {RepeatWrapping}, {MirroredRepeatWrapping}];\n\nconst MAG_FILTERS: Dictionary<number>[] = [{LinearFilter}, {NearestFilter}];\nconst MIN_FILTERS: Dictionary<number>[] = [\n\t{NearestFilter},\n\t{NearestMipMapNearestFilter},\n\t{NearestMipMapLinearFilter},\n\t{LinearFilter},\n\t{LinearMipMapNearestFilter},\n\t{LinearMipMapLinearFilter},\n];\n\n// const TYPES = [\n// \t\"UnsignedByteType\",\n// \t\"ByteType\",\n// \t\"ShortType\",\n// \t\"UnsignedShortType\",\n// \t\"IntType\",\n// \t\"UnsignedIntType\",\n// \t\"FloatType\",\n// \t\"HalfFloatType\",\n// \t\"UnsignedShort4444Type\",\n// \t\"UnsignedShort5551Type\",\n// \t\"UnsignedShort565Type\",\n// \t\"UnsignedInt248Type\"\n// ];\n\n// const FORMATS = [\n// \t\"AlphaFormat\",\n// \t\"RGBFormat\",\n// \t\"RGBAFormat\",\n// \t\"LuminanceFormat\",\n// \t\"LuminanceAlphaFormat\",\n// \t\"RGBEFormat\",\n// \t\"DepthFormat\",\n// \t\"DepthStencilFormat\"\n// ];\n\n// const ENCODINGS = [\n// \t\"LinearEncoding\",\n// \t\"sRGBEncoding\",\n// \t\"GammaEncoding\",\n// \t\"RGBEEncoding\",\n// \t\"LogLuvEncoding\",\n// \t\"RGBM7Encoding\",\n// \t\"RGBM16Encoding\",\n// \t\"RGBDEncoding\",\n// \t\"BasicDepthPacking\",\n// \t\"RGBADepthPacking\"\n// ];\n\ninterface AttribMapping {\n\tmapping: string;\n\twrapS: string;\n\twrapT: string;\n\tminFilter: string;\n\tmagFilter: string;\n}\nconst ATTRIB_MAPPING_KEYS: Array<keyof AttribMapping> = ['mapping', 'wrapS', 'wrapT', 'minFilter', 'magFilter'];\nconst ATTRIB_MAPPING: AttribMapping = {\n\tmapping: 'mapping',\n\twrapS: 'wrap_s',\n\twrapT: 'wrap_t',\n\tminFilter: 'min_filter',\n\tmagFilter: 'mag_filter',\n\t// type: 'type',\n\t// encoding: 'encoding'\n\t// format: 'format',\n};\n\nimport {BaseNodeType} from '../_Base';\nimport {BaseParamType} from '../../params/_Base';\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nclass FileCopParamsConfig extends NodeParamsConfig {\n\t// video_time = ParamConfig.FLOAT(1);\n\turl = ParamConfig.STRING(CoreTextureLoader.PARAM_DEFAULT, {\n\t\tdesktop_browse: {file_type: 'texture'},\n\t});\n\treload = ParamConfig.BUTTON(null, {\n\t\tcallback: (node: BaseNodeType, param: BaseParamType) => {\n\t\t\tFileCopNode.PARAM_CALLBACK_reload(node as FileCopNode, param);\n\t\t},\n\t});\n\tmapping = ParamConfig.INTEGER(UVMapping, {\n\t\tmenu: {\n\t\t\tentries: MAPPINGS.map((m) => {\n\t\t\t\treturn {\n\t\t\t\t\tname: Object.keys(m)[0],\n\t\t\t\t\tvalue: Object.values(m)[0] as number,\n\t\t\t\t};\n\t\t\t}),\n\t\t},\n\t});\n\twrap_s = ParamConfig.INTEGER(Object.values(WRAPPINGS[0])[0], {\n\t\tmenu: {\n\t\t\t// type: 'radio',\n\t\t\tentries: WRAPPINGS.map((m) => {\n\t\t\t\treturn {\n\t\t\t\t\tname: Object.keys(m)[0],\n\t\t\t\t\tvalue: Object.values(m)[0] as number,\n\t\t\t\t};\n\t\t\t}),\n\t\t},\n\t});\n\twrap_t = ParamConfig.INTEGER(Object.values(WRAPPINGS[0])[0], {\n\t\tmenu: {\n\t\t\t// type: 'radio',\n\t\t\tentries: WRAPPINGS.map((m) => {\n\t\t\t\treturn {\n\t\t\t\t\tname: Object.keys(m)[0],\n\t\t\t\t\tvalue: Object.values(m)[0] as number,\n\t\t\t\t};\n\t\t\t}),\n\t\t},\n\t});\n\tmag_filter = ParamConfig.INTEGER(Object.values(MAG_FILTERS[0])[0], {\n\t\tmenu: {\n\t\t\t// type: 'radio',\n\t\t\tentries: MAG_FILTERS.map((m) => {\n\t\t\t\treturn {\n\t\t\t\t\tname: Object.keys(m)[0],\n\t\t\t\t\tvalue: Object.values(m)[0] as number,\n\t\t\t\t};\n\t\t\t}),\n\t\t},\n\t});\n\tmin_filter = ParamConfig.INTEGER(Object.values(MIN_FILTERS[0])[0], {\n\t\tmenu: {\n\t\t\t// type: 'radio',\n\t\t\tentries: MIN_FILTERS.map((m) => {\n\t\t\t\treturn {\n\t\t\t\t\tname: Object.keys(m)[0],\n\t\t\t\t\tvalue: Object.values(m)[0] as number,\n\t\t\t\t};\n\t\t\t}),\n\t\t},\n\t});\n}\n\nconst ParamsConfig = new FileCopParamsConfig();\n\nexport class FileCopNode extends TypedCopNode<FileCopParamsConfig> {\n\tparams_config = ParamsConfig;\n\t// @ParamF('video_time') _param_video_time: number;\n\t// @ParamS('url') _param_url: string;\n\tprivate _previous_param_url: string | undefined;\n\tprivate _video: HTMLVideoElement | undefined;\n\n\tstatic type() {\n\t\treturn 'file';\n\t}\n\n\t// _param_video_time_param: BaseParam\n\tprivate _texture_loader: CoreTextureLoader | undefined;\n\n\tstatic readonly VIDEO_TIME_PARAM_NAME = 'video_time';\n\tstatic readonly DEFAULT_NODE_PATH = {\n\t\tUV: '/COP/file_uv',\n\t\tENV_MAP: '/COP/env_map',\n\t};\n\n\t// initialize_node() {\n\t// \t// this.io.inputs.set_count_to_zero();\n\t// }\n\n\t// create_params() {\n\t// \t// this.add_param(ParamType.STRING, 'url', CoreTextureLoader.PARAM_DEFAULT, {\n\t// \t// \tdesktop_browse: {file_type: 'texture'},\n\t// \t// });\n\t// \t// this.add_param(ParamType.BUTTON, 'reload', null, {\n\t// \t// \tcallback: this._reload.bind(this),\n\t// \t// });\n\t// \t// this.add_param(ParamType.FLOAT, 'video_time', 0, {range: [0, 10]})\n\t// \t// this.add_param(ParamType.INTEGER, 'mapping', UVMapping as number, {\n\t// \t// \tmenu: {\n\t// \t// \t\tentries: MAPPINGS.map((m) => {\n\t// \t// \t\t\treturn {\n\t// \t// \t\t\t\tname: Object.keys(m)[0],\n\t// \t// \t\t\t\tvalue: Object.values(m)[0] as number,\n\t// \t// \t\t\t};\n\t// \t// \t\t}),\n\t// \t// \t},\n\t// \t// });\n\t// \t// for (let wrap_name of ['wrap_s', 'wrap_t']) {\n\t// \t// \tconst wrap = Object.values(WRAPPINGS[0])[0] as number;\n\t// \t// \tthis.add_param(ParamType.INTEGER, wrap_name, wrap, {\n\t// \t// \t\tmenu: {\n\t// \t// \t\t\t// type: 'radio',\n\t// \t// \t\t\tentries: WRAPPINGS.map((m) => {\n\t// \t// \t\t\t\treturn {\n\t// \t// \t\t\t\t\tname: Object.keys(m)[0],\n\t// \t// \t\t\t\t\tvalue: Object.values(m)[0] as number,\n\t// \t// \t\t\t\t};\n\t// \t// \t\t\t}),\n\t// \t// \t\t},\n\t// \t// \t});\n\t// \t// }\n\t// \t// const mag_filter = Object.values(MAG_FILTERS[0])[0] as number;\n\t// \t// this.add_param(ParamType.INTEGER, 'mag_filter', mag_filter, {\n\t// \t// \tmenu: {\n\t// \t// \t\t// type: 'radio',\n\t// \t// \t\tentries: MAG_FILTERS.map((m) => {\n\t// \t// \t\t\treturn {\n\t// \t// \t\t\t\tname: Object.keys(m)[0],\n\t// \t// \t\t\t\tvalue: Object.values(m)[0] as number,\n\t// \t// \t\t\t};\n\t// \t// \t\t}),\n\t// \t// \t},\n\t// \t// });\n\t// \t// const min_filter: number = Object.values(MIN_FILTERS[0])[0] as number;\n\t// \t// this.add_param(ParamType.INTEGER, 'min_filter', min_filter, {\n\t// \t// \tmenu: {\n\t// \t// \t\t// type: 'radio',\n\t// \t// \t\tentries: MIN_FILTERS.map((m) => {\n\t// \t// \t\t\treturn {\n\t// \t// \t\t\t\tname: Object.keys(m)[0],\n\t// \t// \t\t\t\tvalue: Object.values(m)[0] as number,\n\t// \t// \t\t\t};\n\t// \t// \t\t}),\n\t// \t// \t},\n\t// \t// });\n\t// \t// TODO: to be added when I have some level of control\n\t// \t// for now, the type attribute overrides what piz_compressed.exr creates\n\t// \t// which in turns fucks up with the env_map\n\t// \t// advanced\n\t// \t// this.add_param(ParamType.TOGGLE, 'advanced', 0)\n\t// \t// this.add_param(ParamType.INTEGER, 'type', THREE[TYPES[0]], {\n\t// \t// \tmenu: { type: 'radio', entries: TYPES.map(m=>{ return { name: m, value: THREE[m] } })},\n\t// \t// \tvisible_if: {advanced: 1}\n\t// \t// })\n\t// \t// this.add_param(ParamType.INTEGER, 'format', THREE[FORMATS[0]], {\n\t// \t// \tmenu: { type: 'radio', entries: FORMATS.map(m=>{ return { name: m, value: THREE[m] } })},\n\t// \t// \tvisible_if: {advanced: 1}\n\t// \t// })\n\t// \t// this.add_param(ParamType.INTEGER, 'encoding', THREE[ENCODINGS[0]], {\n\t// \t// \tmenu: { type: 'radio', entries: ENCODINGS.map(m=>{ return { name: m, value: THREE[m] } })},\n\t// \t// \tvisible_if: {advanced: 1}\n\t// \t// })\n\t// }\n\n\tasync cook() {\n\t\tif (this._is_static_image_url(this.pv.url)) {\n\t\t\tawait this.cook_for_image();\n\t\t} else {\n\t\t\tawait this.cook_for_video();\n\t\t}\n\t}\n\n\tprivate _is_static_image_url(url: string) {\n\t\treturn true;\n\t}\n\n\tprivate async cook_for_image() {\n\t\tconst texture = await this._load_texture(this.pv.url);\n\n\t\tif (texture) {\n\t\t\tthis._update_texture_params(texture);\n\t\t\tthis.set_texture(texture);\n\t\t} else {\n\t\t\tthis.clear_texture();\n\t\t}\n\t}\n\n\tprivate async cook_for_video() {\n\t\tif (this._param_url_changed()) {\n\t\t\tconst texture = await this._load_texture(this.pv.url);\n\t\t\t// if (texture) {\n\t\t\t// \tthis._texture = texture;\n\t\t\t// }\n\n\t\t\tif (texture) {\n\t\t\t\tthis._add_video_spare_params_if_required(texture);\n\t\t\t}\n\t\t\tthis._previous_param_url = this.pv.url;\n\n\t\t\tthis._set_video_current_time();\n\n\t\t\tif (texture) {\n\t\t\t\tthis._update_texture_params(texture);\n\t\t\t\tthis.set_texture(texture);\n\t\t\t} else {\n\t\t\t\tthis.cook_controller.end_cook();\n\t\t\t}\n\t\t} else {\n\t\t\t// this._set_video_current_time();\n\t\t\t// this._update_texture_params();\n\t\t\t// if (texture?.needsUpdate) {\n\t\t\t// \tthis.set_texture(texture);\n\t\t\t// } else {\n\t\t\t// \tthis.cook_controller.end_cook();\n\t\t\t// }\n\t\t}\n\t}\n\n\tresolved_url() {\n\t\treturn this.pv.url;\n\t}\n\n\tprivate _update_texture_params(texture: Texture) {\n\t\t// const keys = Object.keys(ATTRIB_MAPPING) as keyof AttribMapping\n\t\tfor (let texture_attrib of ATTRIB_MAPPING_KEYS) {\n\t\t\tconst param_name = ATTRIB_MAPPING[texture_attrib];\n\t\t\tconst param_value = this.params.float(param_name);\n\t\t\t// const texture_attrib = ATTRIB_MAPPING[attrib];\n\n\t\t\tif (param_value != null && texture) {\n\t\t\t\tif (texture[texture_attrib] != param_value) {\n\t\t\t\t\ttexture[texture_attrib] = param_value;\n\t\t\t\t\ttexture.needsUpdate = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tstatic PARAM_CALLBACK_reload(node: FileCopNode, param: BaseParamType) {\n\t\tnode.param_callback_reload();\n\t}\n\tprivate param_callback_reload() {\n\t\tthis._previous_param_url = undefined;\n\n\t\t// set the param dirty is preferable, in case this is used to refresh a local asset\n\t\tthis.p.url.set_successors_dirty();\n\t\t// this.set_dirty()\n\t}\n\n\tprivate _set_video_current_time() {\n\t\tif (this._video) {\n\t\t\tif (this.params.has('video_time')) {\n\t\t\t\tthis._video.currentTime = this.params.float('video_time');\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate _add_video_spare_params_if_required(texture: Texture | VideoTexture | null) {\n\t\tif (texture) {\n\t\t\tconst is_video = texture.constructor == VideoTexture;\n\t\t\tif (is_video) {\n\t\t\t\tthis._video = texture.image;\n\t\t\t\tif (this._video) {\n\t\t\t\t\tif (!this.params.has_param(FileCopNode.VIDEO_TIME_PARAM_NAME)) {\n\t\t\t\t\t\tconst duration = this._video.duration;\n\n\t\t\t\t\t\tthis.add_param(ParamType.FLOAT, FileCopNode.VIDEO_TIME_PARAM_NAME, '$T', {\n\t\t\t\t\t\t\tspare: true,\n\t\t\t\t\t\t\tcook: true,\n\t\t\t\t\t\t\trange: [0, duration],\n\t\t\t\t\t\t\trange_locked: [true, true],\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\tthis.emit(NodeEvent.PARAMS_UPDATED);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis._remove_spare_params();\n\t\t\t}\n\t\t} else {\n\t\t\tthis._remove_spare_params();\n\t\t}\n\t}\n\n\tprivate _remove_spare_params() {\n\t\tif (this.params.has_param(FileCopNode.VIDEO_TIME_PARAM_NAME)) {\n\t\t\tthis.params.update_params({names_to_delete: [FileCopNode.VIDEO_TIME_PARAM_NAME]});\n\t\t\t// this.emit(NodeEvent.PARAMS_UPDATED);\n\t\t}\n\t}\n\n\tprivate _param_url_changed(): boolean {\n\t\treturn this._previous_param_url != this.pv.url;\n\t}\n\n\tprivate async _load_texture(url: string) {\n\t\tlet texture: Texture | VideoTexture | null = null;\n\t\tconst param = this.params.get('url');\n\t\tif (url && param) {\n\t\t\tthis._texture_loader = this._texture_loader || new CoreTextureLoader(this, param);\n\t\t\t// const ext = lodash_last(url.split('.')).toLowerCase()\n\t\t\ttry {\n\t\t\t\ttexture = await this._texture_loader.load_texture_from_url_or_op(url);\n\t\t\t} catch (e) {\n\t\t\t\t//console.log('FAIL');\n\t\t\t}\n\t\t\t// if(texture){\n\t\t\t// \tcallback(texture)\n\t\t\t// } else {\n\t\t\tif (!texture) {\n\t\t\t\tthis.states.error.set(`could not load texture '${url}'`);\n\t\t\t}\n\t\t\t// }).catch(error=>{\n\t\t\t// \tthis.self.set_error(`could not load texture ${url} (${error})`);\n\t\t\t// })\n\t\t} else {\n\t\t\tthis.states.error.set('not url given to Mat/Base._load_texture');\n\t\t}\n\t\treturn texture;\n\t}\n}\n","export const CATEGORY_OBJ = {\n\tLIGHT: 'lights',\n\tMANAGER: 'managers',\n\tGEOMETRY: 'geometries',\n\tCAMERA: 'cameras',\n\tMISC: 'misc',\n};\nexport const CATEGORY_COP = {\n\tINPUT: 'inputs',\n\tADVANCED: 'advanced',\n\tMISC: 'misc',\n};\nexport const CATEGORY_EVENT = {\n\tCAMERA: 'cameras',\n\tMISC: 'misc',\n};\nexport const CATEGORY_GL = {\n\tCOLOR: 'color',\n\tCONVERSION: 'conversion',\n\tDYNAMICS: 'dynamics',\n\tGEOMETRY: 'geometry',\n\tGLOBALS: 'globals',\n\tLOGIC: 'logic',\n\tMATH: 'math',\n\tQUAT: 'quat',\n\tTRIGO: 'trigo',\n\tUTIL: 'util',\n\tINSTANCE: 'instance',\n};\nexport const CATEGORY_MAT = {\n\tADVANCED: 'advanced',\n\tMESH: 'meshes',\n\tPOINTS: 'points',\n\tLINE: 'lines',\n\tVOLUME: 'volumes',\n\tINSTANCE: 'instances',\n};\nexport const CATEGORY_SOP = {\n\tADVANCED: 'advanced',\n\tANIMATION: 'animation',\n\tATTRIBUTE: 'attributes',\n\tDYNAMICS: 'dynamics',\n\tINPUT: 'inputs',\n\tMISC: 'misc',\n\tMODIFIER: 'modifiers',\n\tPRIMITIVES: 'primitives',\n\tRENDER: 'render',\n};\nexport const CATEGORY_POST = {\n\tPASS: 'passes',\n};\n","import {BaseMatNodeType} from '../_Base';\n\nexport class BaseController {\n\tconstructor(protected node: BaseMatNodeType) {}\n\tadd_params() {}\n\n\tupdate() {}\n\n\tget material() {\n\t\treturn this.node.material;\n\t}\n}\n","import {BaseController} from './_BaseController';\n\nimport {FrontSide} from 'three/src/constants';\nimport {DoubleSide} from 'three/src/constants';\nimport {BackSide} from 'three/src/constants';\nimport {Material} from 'three/src/materials/Material';\nimport {TypedMatNode} from '../_Base';\n\nimport {NodeParamsConfig, ParamConfig} from '../../utils/params/ParamsConfig';\nexport function SideParamConfig<TBase extends Constructor>(Base: TBase) {\n\treturn class Mixin extends Base {\n\t\tdouble_sided = ParamConfig.BOOLEAN(0);\n\t\tfront = ParamConfig.BOOLEAN(1, {visible_if: {double_sided: false}});\n\t};\n}\n\nclass SidedMaterial extends Material {\n\tside!: number;\n}\nclass SideParamsConfig extends SideParamConfig(NodeParamsConfig) {}\nclass SideMatNode extends TypedMatNode<SidedMaterial, SideParamsConfig> {\n\tcreate_material() {\n\t\treturn new SidedMaterial();\n\t}\n}\n\nexport class SideController extends BaseController {\n\tstatic update(node: SideMatNode) {\n\t\tconst single_side = node.pv.front ? FrontSide : BackSide;\n\t\tconst new_side = node.pv.double_sided ? DoubleSide : single_side;\n\t\tif (new_side != node.material.side) {\n\t\t\tnode.material.side = new_side;\n\t\t\tnode.material.needsUpdate = true;\n\t\t}\n\t}\n}\n","import lodash_trim from 'lodash/trim';\n\nimport {TypedGlNode, BaseGlNodeType} from './_Base';\n// import {BaseNodeGlMathFunctionArg1} from './_BaseMathFunctionArg1';\nimport {ConnectionPointType} from '../utils/connections/ConnectionPointType';\nimport {BaseNamedConnectionPointType} from '../utils/connections/NamedConnectionPoint';\nimport {ParamType} from '../../poly/ParamType';\nimport {ShadersCollectionController} from './code/utils/ShadersCollectionController';\nimport {GlConnectionsController} from './utils/ConnectionsController';\n\nexport const ConnectionPointTypesAvailableForAttribute = [\n\tConnectionPointType.FLOAT,\n\tConnectionPointType.VEC2,\n\tConnectionPointType.VEC3,\n\tConnectionPointType.VEC4,\n];\n\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nclass AttributeGlParamsConfig extends NodeParamsConfig {\n\tname = ParamConfig.STRING('');\n\ttype = ParamConfig.INTEGER(0, {\n\t\tmenu: {\n\t\t\tentries: ConnectionPointTypesAvailableForAttribute.map((name, i) => {\n\t\t\t\treturn {name: name, value: i};\n\t\t\t}),\n\t\t},\n\t});\n}\nconst ParamsConfig = new AttributeGlParamsConfig();\n\nexport class AttributeGlNode extends TypedGlNode<AttributeGlParamsConfig> {\n\tparams_config = ParamsConfig;\n\tstatic type() {\n\t\treturn 'attribute';\n\t}\n\tstatic readonly INPUT_NAME = 'export';\n\tstatic readonly OUTPUT_NAME = 'val';\n\n\tprivate _on_create_set_name_if_none_bound = this._on_create_set_name_if_none.bind(this);\n\t// private _update_signature_if_required_bound = this._update_signature_if_required.bind(this);\n\tpublic readonly gl_connections_controller: GlConnectionsController = new GlConnectionsController(this);\n\tinitialize_node() {\n\t\tthis.add_post_dirty_hook('_set_mat_to_recompile', this._set_mat_to_recompile_if_is_exporting.bind(this));\n\t\tthis.lifecycle.add_on_create_hook(this._on_create_set_name_if_none_bound);\n\t\tthis.gl_connections_controller.initialize_node();\n\n\t\tthis.gl_connections_controller.set_expected_input_types_function(() => []);\n\t\tthis.gl_connections_controller.set_expected_output_types_function(() => [\n\t\t\tConnectionPointTypesAvailableForAttribute[this.pv.type],\n\t\t]);\n\t\t// this.params.add_on_scene_load_hook('_update_signature_if_required', this._update_signature_if_required_bound);\n\t\t// this.params.set_post_create_params_hook(this._update_signature_if_required_bound);\n\t\t// this.add_post_dirty_hook('_update_signature_if_required', this._update_signature_if_required_bound);\n\t}\n\tcreate_params() {\n\t\tif (this.material_node?.assembler_controller.allow_attribute_exports()) {\n\t\t\tthis.add_param(ParamType.BOOLEAN, 'export_when_connected', 0);\n\t\t}\n\t}\n\t// inputless_params_names(): string[] {\n\t// \treturn ['type'];\n\t// }\n\n\tget input_name() {\n\t\treturn AttributeGlNode.INPUT_NAME;\n\t}\n\tget output_name() {\n\t\treturn AttributeGlNode.OUTPUT_NAME;\n\t}\n\n\t// private create_inputs_from_params() {\n\t// \tif (this.material_node.allow_attribute_exports) {\n\t// \t\t// this.set_named_inputs([new TypedConnectionFloat(AttributeGlNode.input_name())]);\n\t// \t\tthis.io.inputs.set_named_input_connection_points([\n\t// \t\t\tnew TypedNamedConnectionPoint(INPUT_NAME, ConnectionPointTypes[this.pv.type]),\n\t// \t\t]);\n\t// \t\t// this._init_graph_node_inputs();\n\t// \t}\n\t// }\n\n\tset_lines(shaders_collection_controller: ShadersCollectionController) {\n\t\t// if (lines_controller.shader_name) {\n\t\tthis.material_node?.assembler_controller.assembler.set_node_lines_attribute(\n\t\t\tthis,\n\t\t\tshaders_collection_controller\n\t\t);\n\t\t// }\n\t}\n\n\t// update_output_type(constructor) {\n\t// \tconst named_output = new constructor(Attribute.output_name());\n\t// \tthis.set_named_outputs([named_output]);\n\t// }\n\t// update_input_type(constructor) {\n\t// \tconst named_input = new constructor(Attribute.input_name());\n\t// \tthis.set_named_inputs([named_input]);\n\t// \tthis._init_graph_node_inputs();\n\t// }\n\n\tget attribute_name(): string {\n\t\treturn lodash_trim(this.pv.name);\n\t}\n\tgl_type(): ConnectionPointType {\n\t\treturn this.io.outputs.named_output_connection_points[0].type;\n\t}\n\t//\n\t//\n\t// Utility methods for SOP/ParticlesSystemGPU and Assembler/Particles\n\t//\n\t//\n\tconnected_input_node(): BaseGlNodeType | null {\n\t\t// if (this.io.inputs.has_named_inputs) {\n\t\treturn this.io.inputs.named_input(AttributeGlNode.INPUT_NAME);\n\t\t// }\n\t}\n\tconnected_input_connection_point(): BaseNamedConnectionPointType | undefined {\n\t\treturn this.io.inputs.named_input_connection_point(AttributeGlNode.INPUT_NAME);\n\t}\n\t// connected_input(): NamedConnection {\n\t// \tconst connection_point = this.connected_input_connection_point();\n\t// \tif (connection_point) {\n\t// \t\treturn this.io.inputs.named_inputs().filter((ni) => ni.name() == Attribute.input_name())[0];\n\t// \t}\n\t// }\n\toutput_connection_point(): BaseNamedConnectionPointType | undefined {\n\t\t// if (this.io.inputs.has_named_inputs) {\n\t\treturn this.io.outputs.named_output_connection_points_by_name(this.input_name);\n\t\t// }\n\t}\n\t// connected_output(): NamedConnection {\n\t// \tconst output = this.named_output(0);\n\t// \tif (output) {\n\t// \t\treturn output; //this.named_inputs().filter(ni=>ni.name() == Attribute.input_name())[0]\n\t// \t}\n\t// }\n\tget is_importing(): boolean {\n\t\treturn this.io.outputs.used_output_names().length > 0; // TODO: typescript - ensure that we can check that the connected outputs are part of the nodes retrived by the node traverser\n\t}\n\tget is_exporting(): boolean {\n\t\tif (this.pv.export_when_connected) {\n\t\t\tconst input_node = this.io.inputs.named_input(AttributeGlNode.INPUT_NAME);\n\t\t\treturn input_node != null;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\tprivate _set_mat_to_recompile_if_is_exporting() {\n\t\tif (this.is_exporting) {\n\t\t\tthis._set_mat_to_recompile();\n\t\t}\n\t}\n\t//\n\t//\n\t// HOOKS\n\t//\n\t//\n\tprivate _on_create_set_name_if_none() {\n\t\tif (this.pv.name == '') {\n\t\t\tthis.p.name.set(this.name);\n\t\t}\n\t}\n\n\t//\n\t//\n\t// SIGNATURE\n\t//\n\t//\n\t// private _update_signature_if_required(dirty_trigger?: CoreGraphNode) {\n\t// \tif (!this.lifecycle.creation_completed || dirty_trigger == this.p.type) {\n\t// \t\tthis.update_input_and_output_types();\n\t// \t\tthis.remove_dirty_state();\n\t// \t\tthis.make_output_nodes_dirty();\n\t// \t}\n\t// \tthis.material_node?.assembler_controller.set_compilation_required_and_dirty(this);\n\t// }\n\t// private update_input_and_output_types() {\n\t// \tconst set_dirty = false;\n\t// \tthis.io.outputs.set_named_output_connection_points(\n\t// \t\t[new TypedNamedConnectionPoint(this.output_name, ConnectionPointTypesAvailableForAttribute[this.pv.type])],\n\t// \t\tset_dirty\n\t// \t);\n\t// \tif (this.material_node?.assembler_controller.allow_attribute_exports()) {\n\t// \t\tthis.io.inputs.set_named_input_connection_points([\n\t// \t\t\tnew TypedNamedConnectionPoint(this.input_name, ConnectionPointTypesAvailableForAttribute[this.pv.type]),\n\t// \t\t]);\n\t// \t}\n\t// }\n}\n","import {ShaderName} from '../../../utils/shaders/ShaderName';\n\nexport class ShaderConfig {\n\tconstructor(private _name: ShaderName, private _input_names: string[], private _dependencies: ShaderName[]) {}\n\n\tname() {\n\t\treturn this._name;\n\t}\n\tinput_names() {\n\t\treturn this._input_names;\n\t}\n\tdependencies() {\n\t\treturn this._dependencies;\n\t}\n}\n","interface VariableConfigOptions {\n\t// asset refererences\n\tdefault_from_attribute?: boolean;\n\tdefault?: string;\n\tif?: string;\n\tprefix?: string;\n\tsuffix?: string;\n}\n\nexport class VariableConfig {\n\tconstructor(private _name: string, private _options: VariableConfigOptions = {}) {}\n\n\tname() {\n\t\treturn this._name;\n\t}\n\tdefault_from_attribute() {\n\t\treturn this._options['default_from_attribute'] || false;\n\t}\n\tdefault() {\n\t\treturn this._options['default'];\n\t}\n\tif_condition() {\n\t\treturn this._options['if'];\n\t}\n\t// required_definitions(){\n\t// \treturn this._options['required_definitions']\n\t// }\n\tprefix() {\n\t\treturn this._options['prefix'] || '';\n\t}\n\tsuffix() {\n\t\treturn this._options['suffix'] || '';\n\t}\n}\n","import {BaseController} from './_BaseController';\nimport {Material} from 'three/src/materials/Material';\nimport {NodeParamsConfig, ParamConfig} from '../../utils/params/ParamsConfig';\nimport {TypedMatNode} from '../_Base';\nexport function SkinningParamConfig<TBase extends Constructor>(Base: TBase) {\n\treturn class Mixin extends Base {\n\t\tskinning = ParamConfig.BOOLEAN(0);\n\t};\n}\n\nclass SkinnedMaterial extends Material {\n\tskinning!: boolean;\n}\nclass SkinningParamsConfig extends SkinningParamConfig(NodeParamsConfig) {}\nclass SkinningMatNode extends TypedMatNode<SkinnedMaterial, SkinningParamsConfig> {\n\tcreate_material() {\n\t\treturn new SkinnedMaterial();\n\t}\n}\n\nexport class SkinningController extends BaseController {\n\tstatic update(node: SkinningMatNode) {\n\t\tconst new_skinning = node.pv.skinning;\n\t\tif (new_skinning != node.material.skinning) {\n\t\t\tnode.material.skinning = new_skinning;\n\t\t\tnode.material.needsUpdate = true;\n\t\t}\n\t}\n}\n","import {Material} from 'three/src/materials/Material';\nimport {Texture} from 'three/src/textures/Texture';\nimport {FileCopNode} from '../../cop/File';\nimport {TypedMatNode} from '../_Base';\nimport {\n\tBaseTextureMapController,\n\tBooleanParamOptions,\n\tOperatorPathOptions,\n\tUpdateOptions,\n} from './_BaseTextureController';\nimport {ShaderMaterial} from 'three/src/materials/ShaderMaterial';\n\nimport {NodeParamsConfig, ParamConfig} from '../../utils/params/ParamsConfig';\nexport function TextureMapParamConfig<TBase extends Constructor>(Base: TBase) {\n\treturn class Mixin extends Base {\n\t\tuse_map = ParamConfig.BOOLEAN(0, BooleanParamOptions(TextureMapController));\n\t\tmap = ParamConfig.OPERATOR_PATH(\n\t\t\tFileCopNode.DEFAULT_NODE_PATH.UV,\n\t\t\tOperatorPathOptions(TextureMapController, 'use_map')\n\t\t);\n\t};\n}\nclass TextureMapMaterial extends Material {\n\tmap!: Texture | null;\n}\ntype CurrentMaterial = TextureMapMaterial | ShaderMaterial;\nclass TextureMapParamsConfig extends TextureMapParamConfig(NodeParamsConfig) {}\nabstract class TextureMapMatNode extends TypedMatNode<CurrentMaterial, TextureMapParamsConfig> {\n\ttexture_map_controller!: TextureMapController;\n\tabstract create_material(): CurrentMaterial;\n}\n\nexport class TextureMapController extends BaseTextureMapController {\n\tconstructor(node: TextureMapMatNode, _update_options: UpdateOptions) {\n\t\tsuper(node, _update_options);\n\t}\n\tinitialize_node() {\n\t\tthis.add_hooks(this.node.p.use_map, this.node.p.map);\n\t}\n\tasync update() {\n\t\tthis._update(this.node.material, 'map', this.node.p.use_map, this.node.p.map);\n\t}\n\tstatic async update(node: TextureMapMatNode) {\n\t\tnode.texture_map_controller.update();\n\t}\n}\n","import {Material} from 'three/src/materials/Material';\nimport {Texture} from 'three/src/textures/Texture';\nimport {FileCopNode} from '../../cop/File';\nimport {TypedMatNode} from '../_Base';\nimport {\n\tBaseTextureMapController,\n\tBooleanParamOptions,\n\tOperatorPathOptions,\n\tUpdateOptions,\n} from './_BaseTextureController';\nimport {ShaderMaterial} from 'three/src/materials/ShaderMaterial';\n\nimport {NodeParamsConfig, ParamConfig} from '../../utils/params/ParamsConfig';\n// import {NodeContext} from '../../../poly/NodeContext';\n// import {BaseCopNodeType} from '../../cop/_Base';\nexport function TextureAlphaMapParamConfig<TBase extends Constructor>(Base: TBase) {\n\treturn class Mixin extends Base {\n\t\tuse_alpha_map = ParamConfig.BOOLEAN(0, BooleanParamOptions(TextureAlphaMapController));\n\t\talpha_map = ParamConfig.OPERATOR_PATH(\n\t\t\tFileCopNode.DEFAULT_NODE_PATH.UV,\n\t\t\tOperatorPathOptions(TextureAlphaMapController, 'use_alpha_map')\n\t\t);\n\t};\n}\nclass TextureAlphaMaterial extends Material {\n\talphaMap!: Texture | null;\n}\ntype CurrentMaterial = TextureAlphaMaterial | ShaderMaterial;\nclass TextureAlphaMapParamsConfig extends TextureAlphaMapParamConfig(NodeParamsConfig) {}\nabstract class TextureAlphaMapMatNode extends TypedMatNode<CurrentMaterial, TextureAlphaMapParamsConfig> {\n\ttexture_alpha_map_controller!: TextureAlphaMapController;\n\tabstract create_material(): CurrentMaterial;\n}\n\nexport class TextureAlphaMapController extends BaseTextureMapController {\n\tconstructor(node: TextureAlphaMapMatNode, _update_options: UpdateOptions) {\n\t\tsuper(node, _update_options);\n\t}\n\tinitialize_node() {\n\t\tthis.add_hooks(this.node.p.use_alpha_map, this.node.p.alpha_map);\n\t}\n\tasync update() {\n\t\tthis._update(this.node.material, 'alphaMap', this.node.p.use_alpha_map, this.node.p.alpha_map);\n\t}\n\tstatic async update(node: TextureAlphaMapMatNode) {\n\t\tnode.texture_alpha_map_controller.update();\n\t}\n}\n","import {PolyScene} from '../../../scene/PolyScene';\n// import {JsonExporterVisitor} from './Visitor';\nimport {CoreString} from '../../../../core/String';\nimport {NodeJsonExporterData, NodeJsonExporterUIData} from './Node';\nimport {JsonExportDispatcher} from './Dispatcher';\n\nexport interface SceneJsonExporterData {\n\tproperties?: {\n\t\tframe: number;\n\t\tframe_range: Number2;\n\t\tframe_range_locked: Boolean2;\n\t\t// fps: number;\n\t\tmaster_camera_node_path: string | null;\n\t};\n\troot?: NodeJsonExporterData;\n\tui?: NodeJsonExporterUIData;\n}\n\nexport class SceneJsonExporter {\n\tprivate _data: SceneJsonExporterData = {};\n\tconstructor(private _scene: PolyScene) {}\n\n\tdata(): SceneJsonExporterData {\n\t\tthis._scene.nodes_controller.reset_node_context_signatures();\n\t\tconst root_exporter = JsonExportDispatcher.dispatch_node(this._scene.root);\n\t\tconst nodes_data = root_exporter.data();\n\t\tconst ui_data = root_exporter.ui_data();\n\n\t\tthis._data = {\n\t\t\t// __js_version: this._scene.js_version(),\n\t\t\tproperties: {\n\t\t\t\t// name: this._scene.name(), // this conflicts with saving the name from the admin page\n\t\t\t\tframe: this._scene.frame || 1,\n\t\t\t\tframe_range: this._scene.frame_range,\n\t\t\t\tframe_range_locked: this._scene.time_controller.frame_range_locked,\n\t\t\t\t// fps: this._scene.time_controller.fps,\n\t\t\t\tmaster_camera_node_path: this._scene.cameras_controller.master_camera_node_path,\n\t\t\t},\n\t\t\troot: nodes_data,\n\t\t\tui: ui_data,\n\t\t};\n\n\t\treturn this._data;\n\t}\n\n\tstatic sanitize_string(word: string): string {\n\t\tword = word.replace(/'/g, \"'\"); // escapes ' (used to be with 2 /, but now only one to have Ian's Mediation saved and loaded correctly - but is actually 2 in Code Exporter)\n\t\tword = CoreString.escape_line_breaks(word);\n\t\treturn word;\n\t}\n}\n","import {BaseNodeType} from '../../../nodes/_Base';\nimport {SceneJsonExporter} from './Scene';\n// import {JsonExporterVisitor} from './Visitor';\nimport {NodeContext} from '../../../poly/NodeContext';\nimport {JsonExportDispatcher} from './Dispatcher';\nimport {ParamJsonExporterData} from './Param';\nimport {ParamType} from '../../../poly/ParamType';\n\ninterface NamedInputData {\n\tname: string;\n\tnode: string;\n\toutput: string;\n}\ntype IndexedInputData = string | null;\nexport type InputData = NamedInputData | IndexedInputData;\n\ninterface FlagsData {\n\tbypass?: boolean;\n\tdisplay?: boolean;\n}\n\nexport interface NodeJsonExporterData {\n\ttype: string;\n\tnodes: Dictionary<NodeJsonExporterData>;\n\tchildren_context: NodeContext;\n\tparams?: Dictionary<ParamJsonExporterData<ParamType>>;\n\tinputs?: InputData[];\n\tselection?: string[];\n\tflags?: FlagsData;\n\toverride_clonable_state: boolean;\n}\n\nexport interface NodeJsonExporterUIData {\n\tpos?: Number2;\n\tcomment?: string;\n\tnodes: Dictionary<NodeJsonExporterUIData>;\n}\n\nexport class NodeJsonExporter<T extends BaseNodeType> {\n\tprivate _data: NodeJsonExporterData | undefined; // = {} as NodeJsonExporterData;\n\tconstructor(protected _node: T) {}\n\n\tdata(): NodeJsonExporterData {\n\t\tif (!this.is_root()) {\n\t\t\tthis._node.scene.nodes_controller.register_node_context_signature(this._node);\n\t\t}\n\t\tthis._data = {\n\t\t\ttype: this._node.type,\n\t\t} as NodeJsonExporterData;\n\n\t\t// const required_imports = this._node.required_imports()\n\t\t// if(required_imports){\n\t\t// \tthis._data['required_imports'] = required_imports\n\t\t// }\n\n\t\tconst nodes_data = this.nodes_data();\n\t\tif (Object.keys(nodes_data).length > 0) {\n\t\t\tthis._data['nodes'] = nodes_data;\n\n\t\t\t// required by the Store::Scene::Exporter.rb\n\t\t\tconst context = this._node.children_controller?.context;\n\t\t\tif (context) {\n\t\t\t\tthis._data['children_context'] = context;\n\t\t\t}\n\t\t}\n\n\t\tif (!this.is_root()) {\n\t\t\tthis._data['params'] = this.params_data();\n\t\t\t//data['custom'] = []\n\t\t\tthis._data['inputs'] = this.inputs_data();\n\t\t}\n\n\t\t// TODO: does that create flags automatically? it should not\n\t\tif (this._node.flags) {\n\t\t\tthis._data['flags'] = {};\n\t\t\tif (this._node.flags.has_bypass()) {\n\t\t\t\tif (this._node.flags.bypass?.active) {\n\t\t\t\t\tthis._data['flags']['bypass'] = this._node.flags.bypass.active;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (this._node.flags.has_display()) {\n\t\t\t\tthis._data['flags']['display'] = this._node.flags.display?.active;\n\t\t\t}\n\t\t}\n\n\t\tif (this._node.children_allowed()) {\n\t\t\tconst selection = this._node.children_controller?.selection;\n\t\t\tif (selection && this._node.children().length > 0) {\n\t\t\t\t// only save the nodes that are still present, in case the selection just got deleted\n\t\t\t\tconst selected_children: BaseNodeType[] = [];\n\t\t\t\tconst selected_ids: Dictionary<boolean> = {};\n\t\t\t\tfor (let selected_node of selection.nodes()) {\n\t\t\t\t\tselected_ids[selected_node.graph_node_id] = true;\n\t\t\t\t}\n\t\t\t\tfor (let child of this._node.children()) {\n\t\t\t\t\tif (child.graph_node_id in selected_ids) {\n\t\t\t\t\t\tselected_children.push(child);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tthis._data['selection'] = selected_children.map((n) => n.name);\n\t\t\t}\n\t\t}\n\n\t\t// inputs clone\n\t\tif (this._node.io.inputs.override_clonable_state_allowed()) {\n\t\t\tconst override = this._node.io.inputs.override_clonable_state();\n\t\t\tif (override) {\n\t\t\t\tthis._data['override_clonable_state'] = override;\n\t\t\t}\n\t\t}\n\n\t\t// custom\n\t\tthis.add_custom();\n\n\t\treturn this._data;\n\t}\n\n\tui_data(): NodeJsonExporterUIData {\n\t\tconst data: NodeJsonExporterUIData = {} as NodeJsonExporterUIData;\n\t\tif (!this.is_root()) {\n\t\t\tconst ui_data = this._node.ui_data;\n\t\t\tdata['pos'] = ui_data.position.toArray() as Number2;\n\t\t\tconst comment = ui_data.comment;\n\t\t\tif (comment) {\n\t\t\t\tdata['comment'] = SceneJsonExporter.sanitize_string(comment);\n\t\t\t}\n\t\t}\n\t\tconst children = this._node.children();\n\t\tif (children.length > 0) {\n\t\t\tdata['nodes'] = {};\n\t\t\tchildren.forEach((child) => {\n\t\t\t\tconst node_exporter = JsonExportDispatcher.dispatch_node(child); //.visit(JsonExporterVisitor); //.json_exporter()\n\t\t\t\tdata['nodes'][child.name] = node_exporter.ui_data();\n\t\t\t});\n\t\t}\n\n\t\treturn data;\n\t}\n\n\tprivate is_root() {\n\t\treturn this._node.parent === null && this._node.graph_node_id == this._node.root.graph_node_id;\n\t}\n\n\tprotected inputs_data() {\n\t\tconst data: InputData[] = [];\n\t\t// Object.keys(this._node.io.inputs.inputs()).forEach((input_index) => {\n\t\tthis._node.io.inputs.inputs().forEach((input, input_index) => {\n\t\t\t// const input = this._node.io.inputs.input(input_index);\n\t\t\tif (input) {\n\t\t\t\t// const connection_point = this._node.io.inputs.named_input_connection_points;\n\t\t\t\tconst connection = this._node.io.connections.input_connection(input_index)!;\n\t\t\t\tif (this._node.io.inputs.has_named_inputs) {\n\t\t\t\t\tconst input_name = this._node.io.inputs.named_input_connection_points[input_index].name;\n\t\t\t\t\t// const output_index = input_connections[input_index].output_index();\n\t\t\t\t\tconst output_index = connection.output_index;\n\t\t\t\t\tconst output_name = input.io.outputs.named_output_connection_points[output_index].name;\n\t\t\t\t\tdata.push({name: input_name, node: input.name, output: output_name});\n\t\t\t\t} else {\n\t\t\t\t\tdata.push(input.name);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\treturn data;\n\t}\n\n\tprotected params_data() {\n\t\tconst data: Dictionary<ParamJsonExporterData<ParamType>> = {};\n\n\t\tfor (let param_name of this._node.params.names) {\n\t\t\tconst param = this._node.params.get(param_name);\n\t\t\tif (param && !param.parent_param) {\n\t\t\t\tconst param_exporter = JsonExportDispatcher.dispatch_param(param); //.visit(JsonExporterVisitor); //.json_exporter()\n\t\t\t\tif (param_exporter.required) {\n\t\t\t\t\tconst params_data = param_exporter.data();\n\t\t\t\t\tdata[param.name] = params_data;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn data;\n\t}\n\n\tprotected nodes_data() {\n\t\tconst data: Dictionary<NodeJsonExporterData> = {};\n\t\tfor (let child of this._node.children()) {\n\t\t\tconst node_exporter = JsonExportDispatcher.dispatch_node(child); //.json_exporter()\n\t\t\tdata[child.name] = node_exporter.data();\n\t\t}\n\t\treturn data;\n\t}\n\n\tprotected add_custom() {}\n}\n","// import lodash_isArray from 'lodash/isArray'\n// import lodash_isString from 'lodash/isString'\nimport {BaseParamType} from '../../../params/_Base';\nimport {ParamType} from '../../../poly/ParamType';\nimport {ParamInitValueSerializedTypeMap} from '../../../params/types/ParamInitValueSerializedTypeMap';\n\nimport {ParamOptions} from '../../../params/utils/OptionsController';\n\ntype OverridenOptions = Dictionary<string>;\n\nexport type SimpleParamJsonExporterData<T extends ParamType> = ParamInitValueSerializedTypeMap[T];\n\nexport interface ComplexParamJsonExporterData<T extends ParamType> {\n\ttype?: T;\n\tdefault_value?: ParamInitValueSerializedTypeMap[T];\n\traw_input?: ParamInitValueSerializedTypeMap[T];\n\toptions?: ParamOptions;\n\toverriden_options?: OverridenOptions;\n\t// components?: ParamJsonExporterDataByName;\n\t// expression?: string;\n}\nexport type ParamJsonExporterData<T extends ParamType> =\n\t| SimpleParamJsonExporterData<T>\n\t| ComplexParamJsonExporterData<T>;\nexport type ParamJsonExporterDataByName = Dictionary<ParamJsonExporterData<ParamType>>;\n\nexport class ParamJsonExporter<T extends BaseParamType> {\n\t// protected _simple_data: SimpleParamJsonExporterData<ParamType>=0;\n\tprotected _complex_data: ComplexParamJsonExporterData<ParamType> = {};\n\tconstructor(protected _param: T) {}\n\n\tget required(): boolean {\n\t\tconst is_spare_and_not_component = this._param.options.is_spare && !this._param.parent_param;\n\n\t\t// we should not need to check if it has an expression anymore,\n\t\t// as it could have an expression AND be of default value\n\t\tconst value_changed = !this._param.is_default; //|| this._param.has_expression();\n\t\t// const referencing_asset = this._param.is_referencing_asset()\n\t\treturn is_spare_and_not_component || value_changed; // || referencing_asset\n\t}\n\n\tdata() {\n\t\tif (this._param.parent_param) {\n\t\t\tconsole.warn('no component should be saved');\n\t\t\tthrow 'no component should be saved';\n\t\t}\n\n\t\tif (this._require_data_complex()) {\n\t\t\treturn this._data_complex();\n\t\t} else {\n\t\t\treturn this._data_simple();\n\t\t}\n\t}\n\n\tprivate _data_simple() {\n\t\treturn this._param.raw_input_serialized;\n\t}\n\n\tprivate _data_complex() {\n\t\tthis._complex_data = {};\n\n\t\tif (this._param.options.is_spare && !this._param.parent_param) {\n\t\t\tthis._complex_data['type'] = this._param.type;\n\t\t\tthis._complex_data['default_value'] = this._param.default_value_serialized;\n\t\t\tthis._complex_data['raw_input'] = this._param.raw_input_serialized;\n\t\t\tthis._complex_data['options'] = this._param.options.current;\n\t\t}\n\n\t\tif (!this._param.is_default) {\n\t\t\tthis.add_main();\n\t\t}\n\n\t\t// if(this._param.is_referencing_asset()){\n\t\t// \t// console.log(\"this._param.is_referencing_asset()\", this._param.is_referencing_asset())\n\t\t// \tthis._data['referenced_asset'] = this._param.referenced_asset()\n\t\t// }\n\n\t\tif (this._param.options.has_options_overridden) {\n\t\t\tconst overridden_options: OverridenOptions = {};\n\t\t\tconst options_overridden = this._param.options.overridden_options;\n\t\t\tfor (let option_name of Object.keys(options_overridden)) {\n\t\t\t\tconst option_value = options_overridden[option_name as keyof ParamOptions];\n\t\t\t\toverridden_options[option_name] = JSON.stringify(option_value);\n\t\t\t}\n\t\t\tthis._complex_data['overriden_options'] = overridden_options;\n\t\t}\n\t\treturn this._complex_data;\n\t}\n\n\tprotected _require_data_complex() {\n\t\tif (this._param.options.is_spare) {\n\t\t\treturn true;\n\t\t}\n\t\tif (this._param.options.has_options_overridden) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\t// default_value(): ParamValueSerialized {\n\t// \treturn this._param.default_value_serialized;\n\t// }\n\n\t// cannot remember why this is useful, but it messes up\n\t// with gl nodes like the noise node, as the default value\n\t// gets saved as a string '[1,1]' instead of an array [1,1] (should be without quotes)\n\t// protected default_value(){\n\t// \tlet default_value = this._param.default_value()\n\t// \tif(lodash_isString(default_value)){\n\t// \t\tdefault_value = `'${default_value}'`\n\t// \t}\n\t// \tif (lodash_isArray(default_value)){\n\t// \t\tdefault_value = `[${default_value}]`\n\t// \t}\n\t// \treturn default_value\n\t// }\n\n\tprotected add_main() {}\n}\n","import {ParamJsonExporter} from '../Param';\nimport {TypedNumericParam} from '../../../../params/_Numeric';\nimport {ParamType} from '../../../../poly/ParamType';\n\nexport class ParamNumericJsonExporter extends ParamJsonExporter<TypedNumericParam<ParamType>> {\n\tadd_main() {\n\t\t// if (this._param.has_expression() && this._param.expression_controller?.expression) {\n\t\t// \t// const escaped_expression = this._param.expression().replace(/'/g, \"\\\\'\");\n\t\t// \tthis._data['expression'] = this._param.expression_controller?.expression;\n\t\t// } else {\n\t\tif (this._require_data_complex()) {\n\t\t\tthis._complex_data['raw_input'] = this._param.raw_input_serialized;\n\t\t} else {\n\t\t\treturn this._param.raw_input_serialized;\n\t\t}\n\t\t// }\n\t}\n}\n","import {ParamJsonExporter} from '../Param';\nimport {OperatorPathParam} from '../../../../params/OperatorPath';\nimport {SceneJsonExporter} from '../Scene';\n\nexport class ParamOperatorPathJsonExporter extends ParamJsonExporter<OperatorPathParam> {\n\tadd_main() {\n\t\tlet val = this._param.raw_input;\n\t\t// val = val.replace(/'/g, \"\\\\'\");\n\t\tval = SceneJsonExporter.sanitize_string(val);\n\n\t\tif (this._require_data_complex()) {\n\t\t\tthis._complex_data['raw_input'] = val;\n\t\t} else {\n\t\t\treturn val;\n\t\t}\n\t}\n}\n","// import lodash_isString from 'lodash/isString'\nimport {ParamJsonExporter} from '../Param';\nimport {SceneJsonExporter} from '../Scene';\nimport {StringParam} from '../../../../params/String';\n\nexport class ParamStringJsonExporter extends ParamJsonExporter<StringParam> {\n\tadd_main() {\n\t\t// let val = this._param.input_value();\n\t\tlet val = this._param.raw_input;\n\t\t// if (lodash_isString(val)){\n\t\tval = SceneJsonExporter.sanitize_string(val);\n\t\t// }\n\t\tif (this._require_data_complex()) {\n\t\t\tthis._complex_data['raw_input'] = val;\n\t\t} else {\n\t\t\treturn val;\n\t\t}\n\t}\n}\n","import {ParamJsonExporter} from '../Param';\nimport {RampParam} from '../../../../params/Ramp';\n\nexport class ParamRampJsonExporter extends ParamJsonExporter<RampParam> {\n\tadd_main() {\n\t\tif (this._require_data_complex()) {\n\t\t\tthis._complex_data['raw_input'] = this._param.raw_input_serialized;\n\t\t} else {\n\t\t\treturn this._param.raw_input_serialized;\n\t\t}\n\t}\n}\n","import {BaseNodeType} from '../../../nodes/_Base';\nimport {BaseParamType} from '../../../params/_Base';\n\nimport {NodeJsonExporter} from './Node';\n// import {BaseNodeObjJsonExporter} from './node/Obj';\n// import {BaseNodeSopSubnetworkJsonExporter} from './node/Subnetwork';\n\nimport {ParamJsonExporter} from './Param';\n// import {ParamMultipleJsonExporter} from './param/Multiple';\nimport {ParamNumericJsonExporter} from './param/Numeric';\nimport {ParamOperatorPathJsonExporter} from './param/OperatorPath';\nimport {ParamStringJsonExporter} from './param/String';\nimport {ParamRampJsonExporter} from './param/Ramp';\n// import {TypedObjNode} from '../../../nodes/obj/_Base';\n// import {TypedMultipleParam} from '../../../params/_Multiple';\nimport {TypedNumericParam} from '../../../params/_Numeric';\nimport {OperatorPathParam} from '../../../params/OperatorPath';\nimport {StringParam} from '../../../params/String';\nimport {RampParam} from '../../../params/Ramp';\n\nexport class JsonExportDispatcher {\n\tstatic dispatch_node(node: BaseNodeType) {\n\t\t// if (node instanceof TypedObjNode) {\n\t\t// \treturn new BaseNodeObjJsonExporter(node);\n\t\t// }\n\t\treturn new NodeJsonExporter(node);\n\t}\n\n\tstatic dispatch_param(param: BaseParamType) {\n\t\t// if (param instanceof TypedMultipleParam) {\n\t\t// \treturn new ParamMultipleJsonExporter(param);\n\t\t// }\n\t\tif (param instanceof TypedNumericParam) {\n\t\t\treturn new ParamNumericJsonExporter(param);\n\t\t}\n\t\tif (param instanceof OperatorPathParam) {\n\t\t\treturn new ParamOperatorPathJsonExporter(param);\n\t\t}\n\t\tif (param instanceof StringParam) {\n\t\t\treturn new ParamStringJsonExporter(param);\n\t\t}\n\t\tif (param instanceof RampParam) {\n\t\t\treturn new ParamRampJsonExporter(param);\n\t\t}\n\t\treturn new ParamJsonExporter(param);\n\t}\n}\n","import lodash_merge from 'lodash/merge';\nimport lodash_intersection from 'lodash/intersection';\nimport lodash_difference from 'lodash/difference';\nimport {Vector2} from 'three/src/math/Vector2';\nimport {BaseNodeType, TypedNode} from '../../_Base';\n\nimport {BaseGlShaderAssembler} from './assemblers/_Base';\nimport {GlobalsBaseController} from './globals/_Base';\nimport {GlobalsGeometryHandler} from './globals/Geometry';\n\nimport {JsonExportDispatcher} from '../../../io/json/export/Dispatcher';\n// import {NodeEvent} from '../../../poly/NodeEvent';\nimport {OutputGlNode} from '../Output';\nimport {GlobalsGlNode} from '../Globals';\n// import {BaseParamType} from '../../../params/_Base';\nimport {ParamJsonExporterData} from '../../../io/json/export/Param';\nimport {GlNodeChildrenMap} from '../../../poly/registers/Gl';\nimport {BaseGlNodeType} from '../_Base';\nimport {ParamType} from '../../../poly/ParamType';\nimport {ParamsUpdateOptions} from '../../utils/params/ParamsController';\n\n// interface BaseShaderAssemblerConstructor {\n// \tnew (): BaseGlShaderAssembler;\n// }\n// interface GlobalsBaseControllerConstructor {\n// \tnew (): GlobalsBaseController;\n// }\n\n// export function AssemblerOwner<TBase extends Constructor>(Base: TBase) {\n// \treturn class Mixin extends Base {\n// \t\tprotected self: BaseNode = (<unknown>this) as BaseNode;\n// \t\tchildren_context() {\n// \t\t\treturn NodeContext.GL;\n// \t\t}\n\nexport class AssemblerControllerNode extends TypedNode<any, BaseNodeType, any> {\n\tcreate_node<K extends keyof GlNodeChildrenMap>(type: K): GlNodeChildrenMap[K] {\n\t\treturn super.create_node(type) as GlNodeChildrenMap[K];\n\t}\n\tchildren() {\n\t\treturn super.children() as BaseGlNodeType[];\n\t}\n\tnodes_by_type<K extends keyof GlNodeChildrenMap>(type: K): GlNodeChildrenMap[K][] {\n\t\treturn super.nodes_by_type(type) as GlNodeChildrenMap[K][];\n\t}\n\n\tassembler_controller!: GlAssemblerController<BaseGlShaderAssembler>;\n\t// set_compilation_required_and_dirty() {\n\t// \tthis.assembler_controller.set_compilation_required_and_dirty();\n\t// }\n}\n\ntype BaseGlShaderAssemblerConstructor<A extends BaseGlShaderAssembler> = new (...args: any[]) => A;\nexport class GlAssemblerController<A extends BaseGlShaderAssembler> {\n\tprotected _assembler!: A;\n\tprivate _globals_handler: GlobalsBaseController | undefined = new GlobalsGeometryHandler();\n\tprivate _compile_required: boolean = true;\n\t// private _requester: BaseNodeSop;\n\t// private _recompiled: boolean = false;\n\t// private _shaders_by_name: Map<ShaderName, string> = new Map();\n\n\tprivate _deleted_params_data: Map<string, ParamJsonExporterData<ParamType>> = new Map();\n\t// private _new_params: BaseParamType[] = [];\n\n\tconstructor(private node: AssemblerControllerNode, assembler_class: BaseGlShaderAssemblerConstructor<A>) {\n\t\t// if (assembler_class) {\n\t\tthis._assembler = new assembler_class(this.node);\n\t\t// }\n\t\t// this._shadow_depth_assembler = new ShaderAssemblerDepth()\n\t\t// this._shadow_distance_assembler = new ShaderAssemblerDistance()\n\n\t\t// this.self._init_hierarchy_children_owner();\n\n\t\t// let has_display_flag = false;\n\t\t// if (options['has_display_flag']) {\n\t\t// \thas_display_flag = options['has_display_flag'];\n\t\t// }\n\n\t\t// this.self._init_display_flag({\n\t\t// \thas_display_flag: has_display_flag,\n\t\t// \tmultiple_display_flags_allowed: false,\n\t\t// \taffects_hierarchy: true,\n\t\t// });\n\n\t\t// this ensures that material re evaluate their uniforms\n\t\t// without having the SOP/Material recook\n\t\t// which can be a killer in an animation\n\t\t// But this should be tweaked so that it can recook all params of a node\n\t\t// this.self.add_post_dirty_hook(this.eval_params_and_assign_uniform_values.bind(this))\n\t\t// - UPDATE: this seems to work at the moment. The only issue is that\n\t\t// the particle system now updates 2x when recreating the shaders\n\t\t// but that's fixed with update_on_dirty\n\t\t// - UPDATE 2: now that the params have been refactored, let's try without this\n\t\t// if (options['update_on_dirty'] != false) {\n\t\t// \tthis.self.add_post_dirty_hook(this.cook_main_if_scene_loaded.bind(this));\n\t\t// }\n\t}\n\tset_assembler_globals_handler(globals_handler: GlobalsBaseController) {\n\t\tconst current_id = this._globals_handler ? this._globals_handler.id() : null;\n\t\tconst new_id = globals_handler ? globals_handler.id() : null;\n\n\t\tif (current_id != new_id) {\n\t\t\tthis._globals_handler = globals_handler;\n\t\t\tthis.set_compilation_required_and_dirty();\n\t\t\tthis._assembler.reset_configs();\n\t\t}\n\t}\n\tget assembler() {\n\t\treturn this._assembler;\n\t}\n\t// get shaders_by_name() {\n\t// \treturn this._shaders_by_name;\n\t// }\n\tget globals_handler() {\n\t\treturn this._globals_handler;\n\t}\n\n\t// gltf_supported_material() {\n\t// \treturn this._assembler.constructor.convert_material_to_gltf_supported(this._material);\n\t// }\n\n\tadd_output_params(output_child: OutputGlNode) {\n\t\tthis._assembler.add_output_params(output_child);\n\t}\n\tadd_globals_params(globals_node: GlobalsGlNode) {\n\t\tthis._assembler.add_globals_params(globals_node);\n\t}\n\tallow_attribute_exports() {\n\t\treturn this._assembler.allow_attribute_exports();\n\t}\n\n\ton_create() {\n\t\tconst globals = this.node.create_node('globals');\n\t\tconst output = this.node.create_node('output');\n\n\t\tglobals.ui_data.set_position(new Vector2(-200, 0));\n\t\toutput.ui_data.set_position(new Vector2(200, 0));\n\t}\n\n\t// async compile_if_required() {\n\t// \t// this._recompiled = false;\n\t// \tif (this.compile_required()) {\n\t// \t\t// && !this._param_locked){\n\t// \t\tconst new_material = await this.run_assembler();\n\t// \t\tif (new_material) {\n\t// \t\t\tawait this.node.params.eval_params(this._new_params);\n\t// \t\t\tthis._material = new_material;\n\t// \t\t\t// this._recompiled = true;\n\t// \t\t} else {\n\t// \t\t\tconsole.error(`${this.node.full_path()} failed to generate a material`);\n\t// \t\t}\n\t// \t}\n\t// \tawait this.assign_uniform_values();\n\t// }\n\tset_compilation_required(new_state = true) {\n\t\tthis._compile_required = new_state;\n\t}\n\tset_compilation_required_and_dirty(trigger_node?: BaseGlNodeType) {\n\t\tthis.set_compilation_required();\n\t\tthis.node.set_dirty(trigger_node);\n\t}\n\tcompile_required(): boolean {\n\t\treturn this._compile_required;\n\t}\n\n\t// set_root_nodes(nodes: BaseGlNodeType[]) {\n\t// \tthis.assembler.set_root_nodes(nodes);\n\t// }\n\t// set_node_lines_globals(globals_node: GlobalsGlNode, shader_name: ShaderName) {\n\t// \tthis.assembler.set_node_lines_globals(globals_node, shader_name);\n\t// }\n\t// set_node_lines_output(output_node: OutputGlNode, shader_name: ShaderName) {\n\t// \tthis.assembler.set_node_lines_output(output_node, shader_name);\n\t// }\n\t// set_node_lines_attribute(attribute_node: AttributeGlNode, shader_name: ShaderName) {\n\t// \tthis.assembler.set_node_lines_attribute(attribute_node, shader_name);\n\t// }\n\n\tasync post_compile() {\n\t\t// if (!this.compile_required()) {\n\t\t// \treturn;\n\t\t// }\n\t\t// this.assembler.compile_for_node(this._gl);\n\t\tthis.create_spare_parameters();\n\t\tthis.set_compilation_required(false);\n\t}\n\n\t// private async run_assembler() {\n\t// \tconst output_node = this.find_output_node();\n\t// \tif (output_node) {\n\t// \t\tthis._assembler.set_root_nodes([output_node]);\n\t// \t}\n\t// \tthis.assembler.compile();\n\t// \tconst material = await this._assembler.get_material();\n\t// \tif (material) {\n\t// \t\tthis._shaders_by_name.set(ShaderName.VERTEX, material.vertexShader);\n\t// \t\tthis._shaders_by_name.set(ShaderName.FRAGMENT, material.fragmentShader);\n\n\t// \t\t// assign custom materials\n\t// \t\tconst custom_materials = await this._assembler.get_custom_materials();\n\t// \t\tconst material_with_custom_materials = material as ShaderMaterialWithCustomMaterials;\n\t// \t\tmaterial_with_custom_materials.custom_materials = {};\n\t// \t\tcustom_materials.forEach((custom_material, shader_name) => {\n\t// \t\t\tmaterial_with_custom_materials.custom_materials[shader_name] = custom_material;\n\t// \t\t});\n\n\t// \t\tmaterial.needsUpdate = true;\n\t// \t}\n\n\t// \tthis.create_spare_parameters();\n\n\t// \tthis._compile_required = false;\n\t// \treturn material;\n\t// }\n\n\t// find_output_node() {\n\t// \tconst nodes = this.node.nodes_by_type('output');\n\t// \tif (nodes.length > 1) {\n\t// \t\tthis.node.states.error.set('only one output node allowed');\n\t// \t}\n\t// \treturn nodes[0];\n\t// }\n\t// find_attribute_export_nodes() {\n\t// \tconst nodes = this.node.nodes_by_type('attribute');\n\t// \treturn nodes.filter((node) => {\n\t// \t\t// do not use attributes that are used as an input, as export\n\t// \t\t// return (node.used_output_names().length == 0) &&\n\t// \t\treturn node.is_exporting;\n\t// \t});\n\t// }\n\t// add_output_body_line(output_node, shader_name: ShaderName, input_name: string){\n\t// \tconst input = output_node.named_input(input_name)\n\t// \tconst var_input = output_node.variable_for_input(input_name)\n\t// \tconst variable_config = this.variable_config(input_name)\n\t// \tconst default_value = variable_config.default()\n\t// \tconst prefix = variable_config.prefix()\n\t// \tconst suffix = variable_config.suffix()\n\t// \tconst new_var = input ? ThreeToGl.vector3(var_input) : default_value\n\t// \tif(new_var){\n\t// \t\toutput_node.add_body_lines([`${prefix}${new_var}${suffix}`], shader_name)\n\t// \t}\n\t// }\n\t// set_output_node_lines(output_node){\n\t// \tfor(let shader_name of this.shader_names()){\n\t// \t\tconst body_lines = []\n\t// \t\tconst input_names = this.shader_config(shader_name).input_names()\n\t// \t\toutput_node.set_body_lines([], shader_name)\n\t// \t\tif(input_names){\n\t// \t\t\tfor(let input_name of input_names){\n\t// \t\t\t\tthis.add_output_body_line(output_node, shader_name, input_name)\n\n\t// \t\t\t}\n\t// \t\t}\n\t// \t}\n\n\t// \t// const vertex_body_lines = []\n\t// \t// const fragment_body_lines = []\n\n\t// \t// const named_input_position = this.named_input('position')\n\t// \t// const named_input_point_size = this.named_input('gl_PointSize')\n\t// \t// const named_input_normal = this.named_input('normal')\n\n\t// \t// const var_position = this.variable_for_input('position')\n\t// \t// const var_normal = this.variable_for_input('normal')\n\t// \t// const color = this.variable_for_input('color')\n\t// \t// const alpha = this.variable_for_input('alpha')\n\t// \t// const var_point_size = this.variable_for_input('gl_PointSize')\n\n\t// \t// fragment_body_lines.push( `${this._color_declaration} = ${ThreeToGl.vector3_float(color, alpha)}` )\n\t// \t// this.set_fragment_body_lines(fragment_body_lines)\n\n\t// \t// const new_position_var = named_input_position ? ThreeToGl.vector3(var_position) : 'vec3( position )'\n\t// \t// vertex_body_lines.push( `vec3 transformed = ${new_position_var}` )\n\n\t// \t// if(this.parent().is_point_material()){\n\t// \t// \tconst new_point_size_var = named_input_point_size ? ThreeToGl.float(var_point_size) : '1.0'\n\t// \t// \tvertex_body_lines.push( `float size2 = size * ${new_point_size_var}` )\n\t// \t// }\n\n\t// \t// if(named_input_normal){\n\t// \t// \tconst new_normal_var = ThreeToGl.vector3(var_normal)\n\t// \t// \tvertex_body_lines.push(`objectNormal = ${new_normal_var}`)\n\t// \t// }\n\n\t// \t// this.set_vertex_body_lines(vertex_body_lines)\n\t// \t// this.set_fragment_body_lines(fragment_body_lines)\n\t// }\n\t// private async eval_params_and_assign_uniform_values() {\n\t// \tif (!this.self.scene().loaded()) {\n\t// \t\treturn;\n\t// \t}\n\n\t// \tif (this._assembler) {\n\t// \t\tawait this.self.eval_all_params();\n\t// \t\tawait this.assign_uniform_values();\n\t// \t}\n\t// }\n\t// private async cook_main_if_scene_loaded() {\n\t// \tif (!this.self.scene().loaded()) {\n\t// \t\treturn;\n\t// \t}\n\t// \tif (this.self.params_referree().length > 0) {\n\t// \t\tawait this.self.cook_main();\n\t// \t}\n\t// \t// this.cook_main_without_inputs()\n\t// }\n\tasync assign_uniform_values() {\n\t\tif (this._assembler) {\n\t\t\tfor (let param_config of this._assembler.param_configs()) {\n\t\t\t\tawait param_config.set_uniform_value(this.node);\n\t\t\t}\n\t\t}\n\t}\n\n\t// process_uniforms(renderer, display_scene, camera, geometry, material, group) {\n\t// \tconst scene_frame = this.scene().frame()\n\n\t// \tconst material_frame = material.uniforms.frame\n\t// \tif(material_frame){ // check needed in case this method is given a post process material\n\t// \t\tmaterial.uniforms.frame.value = scene_frame\n\t// \t}\n\n\t// \tconst custom_materials = material.custom_materials\n\t// \tif(custom_materials){\n\t// \t\tfor(let custom_material_name of Object.keys(custom_materials)){\n\t// \t\t\tconst custom_material = custom_materials[custom_material_name]\n\t// \t\t\tcustom_material.uniforms.frame.value = scene_frame\n\t// \t\t}\n\t// \t}\n\t// }\n\n\t// create_material(){\n\t// \tconst template_shader = THREE.ShaderLib.basic\n\n\t// \tconst uniforms = THREE.UniformsUtils.clone( template_shader.uniforms )\n\t// \t// uniforms['frame'] = {\n\t// \t// \ttype: '1f',\n\t// \t// \tvalue: 1\n\t// \t// }\n\n\t// \tconst material = new THREE.ShaderMaterial({\n\t// \t\t// vertexColors: THREE.VertexColors,\n\t// \t\t// side: THREE.FrontSide,\n\t// \t\t// transparent: true,\n\t// \t\t// fog: true,\n\t// \t\t// lights: false,\n\t// \t\tuniforms: uniforms,\n\t// \t\tvertexShader: template_shader.vertexShader,\n\t// \t\tfragmentShader: template_shader.fragmentShader\n\t// \t})\n\t// \tthrow \"wtf\"\n\t// \treturn material\n\t// }\n\tcreate_spare_parameters() {\n\t\tconst current_spare_param_names: string[] = this.node.params.spare_names;\n\t\tconst param_configs = this._assembler.param_configs();\n\t\tconst assembler_param_names = param_configs.map((c) => c.name);\n\t\t// TODO: also remove the params that change type\n\t\tconst spare_param_names_to_add = lodash_difference(assembler_param_names, current_spare_param_names);\n\t\tconst spare_param_names_to_remove = lodash_difference(current_spare_param_names, assembler_param_names);\n\t\t// this._new_params = [];\n\t\tconst params_update_options: ParamsUpdateOptions = {};\n\n\t\t// check that param_names_to_add does not include any currently existing param names (that are not spare)\n\t\tconst current_param_names = this.node.params.names;\n\t\tconst spare_params_with_same_name_as_params = lodash_intersection(\n\t\t\tspare_param_names_to_add,\n\t\t\tcurrent_param_names\n\t\t);\n\t\tif (spare_params_with_same_name_as_params.length > 0) {\n\t\t\tconst error_message = `${this.node.full_path()} attempts to create spare params called '${spare_params_with_same_name_as_params.join(\n\t\t\t\t', '\n\t\t\t)}' with same name as params`;\n\t\t\tconsole.warn(error_message);\n\t\t\tthis.node.states.error.set(error_message);\n\t\t}\n\n\t\tspare_param_names_to_remove.forEach((param_name) => {\n\t\t\t// store the param data, in case it gets recreated later\n\t\t\t// this allows expressions to be kept in memory\n\t\t\tconst param = this.node.params.get(param_name);\n\t\t\tif (param) {\n\t\t\t\tconst param_exporter = JsonExportDispatcher.dispatch_param(param);\n\t\t\t\tif (param_exporter.required) {\n\t\t\t\t\tconst params_data = param_exporter.data();\n\t\t\t\t\tthis._deleted_params_data.set(param.name, params_data);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tparams_update_options.names_to_delete = params_update_options.names_to_delete || [];\n\t\t\tparams_update_options.names_to_delete.push(param_name);\n\t\t});\n\n\t\t// this.within_param_folder('spare_params', () => {\n\t\tfor (let param_config of param_configs) {\n\t\t\tif (spare_param_names_to_add.indexOf(param_config.name) >= 0) {\n\t\t\t\t// TODO: shouldn't it be cook: false ??\n\t\t\t\t// as there is no need to cook the node if I'm only changing the uniform\n\t\t\t\t// unless maybe for textures?\n\t\t\t\t// but if cook is false, there is no reason for it to be updated\n\t\t\t\tconst options = lodash_merge(param_config.param_options, {spare: true, cook: true});\n\n\t\t\t\t// const param = this.node.add_param(\n\t\t\t\t// \tparam_config.type,\n\t\t\t\t// \tparam_config.name,\n\t\t\t\t// \tparam_config.default_value,\n\t\t\t\t// \toptions\n\t\t\t\t// );\n\t\t\t\tparams_update_options.to_add = params_update_options.to_add || [];\n\t\t\t\tparams_update_options.to_add.push({\n\t\t\t\t\tname: param_config.name,\n\t\t\t\t\ttype: param_config.type,\n\t\t\t\t\tinit_value: param_config.default_value as any,\n\t\t\t\t\toptions: options,\n\t\t\t\t});\n\n\t\t\t\t// if (param) {\n\t\t\t\t// \t// restore saved state, like expressions\n\t\t\t\t// \tconst param_data = this._deleted_params_data.get(param.name);\n\t\t\t\t// \tif (param_data) {\n\t\t\t\t// \t\t// TODO: typescript\n\t\t\t\t// \t\t// JsonImportDispatcher.dispatch_param(param).process_data(param_data);\n\t\t\t\t// \t\t// looks like there are still some cases where the expression are not recreated\n\t\t\t\t// \t\t// so commenting this out now\n\t\t\t\t// \t\t// delete this._deleted_params_data[param.name()]\n\t\t\t\t// \t}\n\n\t\t\t\t// \tthis._new_params.push(param);\n\t\t\t\t// }\n\t\t\t}\n\t\t}\n\n\t\tthis.node.params.update_params(params_update_options);\n\t\t// if (spare_param_names_to_add.length > 0 || spare_param_names_to_remove.length > 0) {\n\t\t// \tthis.node.params.post_create_spare_params();\n\t\t// \tthis.node.emit(NodeEvent.PARAMS_UPDATED);\n\t\t// }\n\t}\n}\n","export enum LineType {\n\tFUNCTION_DECLARATION = 'function_declaration',\n\tDEFINE = 'define',\n\tBODY = 'body',\n}\n","import {ShaderName} from '../../../utils/shaders/ShaderName';\nimport {BaseGLDefinition} from '../../utils/GLDefinition';\nimport {BaseGlNodeType} from '../../_Base';\nimport {MapUtils} from '../../../../../core/MapUtils';\n\nexport class LinesController {\n\tprivate _definitions_by_node_id: Map<string, BaseGLDefinition[]> = new Map();\n\tprivate _body_lines_by_node_id: Map<string, string[]> = new Map();\n\n\tconstructor(private _shader_name: ShaderName) {}\n\n\tget shader_name() {\n\t\treturn this._shader_name;\n\t}\n\n\tadd_definitions(node: BaseGlNodeType, definitions: BaseGLDefinition[]) {\n\t\tfor (let definition of definitions) {\n\t\t\tMapUtils.push_on_array_at_entry(this._definitions_by_node_id, node.graph_node_id, definition);\n\t\t}\n\t}\n\tdefinitions(node: BaseGlNodeType): BaseGLDefinition[] | undefined {\n\t\treturn this._definitions_by_node_id.get(node.graph_node_id);\n\t}\n\n\tadd_body_lines(node: BaseGlNodeType, lines: string[]) {\n\t\tfor (let line of lines) {\n\t\t\tMapUtils.push_on_array_at_entry(this._body_lines_by_node_id, node.graph_node_id, line);\n\t\t}\n\t}\n\tbody_lines(node: BaseGlNodeType): string[] | undefined {\n\t\treturn this._body_lines_by_node_id.get(node.graph_node_id);\n\t}\n}\n","import {ShaderName} from '../../../utils/shaders/ShaderName';\nimport {BaseGLDefinition} from '../../utils/GLDefinition';\nimport {LinesController} from './LinesController';\nimport {BaseGlNodeType} from '../../_Base';\n\nexport class ShadersCollectionController {\n\tprivate _lines_controller_by_shader_name: Map<ShaderName, LinesController> = new Map();\n\tconstructor(private _shader_names: ShaderName[], private _current_shader_name: ShaderName) {\n\t\tfor (let shader_name of this._shader_names) {\n\t\t\tthis._lines_controller_by_shader_name.set(shader_name, new LinesController(shader_name));\n\t\t}\n\t}\n\n\tget shader_names() {\n\t\treturn this._shader_names;\n\t}\n\n\tset_current_shader_name(shader_name: ShaderName) {\n\t\tthis._current_shader_name = shader_name;\n\t}\n\tget current_shader_name() {\n\t\treturn this._current_shader_name;\n\t}\n\n\tadd_definitions(node: BaseGlNodeType, definitions: BaseGLDefinition[], shader_name?: ShaderName) {\n\t\tif (definitions.length == 0) {\n\t\t\treturn;\n\t\t}\n\t\tshader_name = shader_name || this._current_shader_name;\n\t\tconst lines_controller = this._lines_controller_by_shader_name.get(shader_name);\n\t\tif (lines_controller) {\n\t\t\tlines_controller.add_definitions(node, definitions);\n\t\t}\n\t}\n\tdefinitions(shader_name: ShaderName, node: BaseGlNodeType) {\n\t\tconst lines_controller = this._lines_controller_by_shader_name.get(shader_name);\n\t\tif (lines_controller) {\n\t\t\treturn lines_controller.definitions(node);\n\t\t}\n\t}\n\n\tadd_body_lines(node: BaseGlNodeType, lines: string[], shader_name?: ShaderName) {\n\t\tif (lines.length == 0) {\n\t\t\treturn;\n\t\t}\n\t\tshader_name = shader_name || this._current_shader_name;\n\t\tconst lines_controller = this._lines_controller_by_shader_name.get(shader_name);\n\t\tif (lines_controller) {\n\t\t\tlines_controller.add_body_lines(node, lines);\n\t\t}\n\t}\n\tbody_lines(shader_name: ShaderName, node: BaseGlNodeType) {\n\t\tconst lines_controller = this._lines_controller_by_shader_name.get(shader_name);\n\t\tif (lines_controller) {\n\t\t\treturn lines_controller.body_lines(node);\n\t\t}\n\t}\n}\n","import {BaseGlNodeType} from '../../_Base';\nimport {LineType} from './LineType';\n\nconst LINE_SUFFIXES = {\n\t[LineType.FUNCTION_DECLARATION]: '',\n\t[LineType.DEFINE]: ';',\n\t[LineType.BODY]: ';',\n};\n\nconst LINE_PREFIXES = {\n\t[LineType.FUNCTION_DECLARATION]: '',\n\t[LineType.DEFINE]: '',\n\t[LineType.BODY]: '\t',\n};\n\nexport class CodeFormatter {\n\tstatic node_comment(node: BaseGlNodeType, line_type: LineType): string {\n\t\tlet line = `// ${node.full_path()}`;\n\t\tif (line_type == LineType.BODY) {\n\t\t\tline = `\t${line}`;\n\t\t}\n\t\treturn line;\n\t}\n\tstatic line_wrap(line: string, line_type: LineType) {\n\t\tlet add_suffix = true;\n\t\tif (line.indexOf('#if') == 0 || line.indexOf('#endif') == 0) {\n\t\t\tadd_suffix = false;\n\t\t}\n\t\tif (add_suffix) {\n\t\t\treturn `${LINE_PREFIXES[line_type]}${line}${LINE_SUFFIXES[line_type]}`;\n\t\t} else {\n\t\t\treturn `${LINE_PREFIXES[line_type]}${line}`;\n\t\t}\n\t}\n\tstatic post_line_separator(line_type: LineType) {\n\t\treturn line_type == LineType.BODY ? '\t' : '';\n\t}\n}\n","import lodash_uniq from 'lodash/uniq';\nimport {BaseGlNodeType} from '../../_Base';\nimport {TypedNodeTraverser} from '../../../utils/shaders/NodeTraverser';\nimport {BaseNodeType} from '../../../_Base';\nimport {BaseGlShaderAssembler} from '../assemblers/_Base';\nimport {MapUtils} from '../../../../../core/MapUtils';\nimport {ShaderName} from '../../../utils/shaders/ShaderName';\nimport {GLDefinitionType, BaseGLDefinition} from '../../utils/GLDefinition';\nimport {TypedGLDefinitionCollection} from '../../utils/GLDefinitionCollection';\nimport {ParamConfigsController} from '../../../../nodes/utils/code/controllers/ParamConfigsController';\nimport {ShadersCollectionController} from './ShadersCollectionController';\nimport {CodeFormatter} from './CodeFormatter';\n\nimport {LineType} from './LineType';\n\nexport class CodeBuilder {\n\t_param_configs_controller: ParamConfigsController = new ParamConfigsController();\n\t_param_configs_set_allowed: boolean = true;\n\n\tprivate _shaders_collection_controller: ShadersCollectionController | undefined;\n\t_lines: Map<ShaderName, Map<LineType, string[]>> = new Map();\n\t_function_declared: Map<ShaderName, Map<string, boolean>> = new Map();\n\n\tconstructor(private _assembler: BaseGlShaderAssembler, private _gl_parent_node: BaseNodeType) {}\n\n\tasync build_from_nodes(root_nodes: BaseGlNodeType[]) {\n\t\tconst node_traverser = new TypedNodeTraverser<BaseGlNodeType>(this._assembler, this._gl_parent_node);\n\t\tnode_traverser.traverse(root_nodes);\n\n\t\tconst nodes_by_shader_name: Map<ShaderName, BaseGlNodeType[]> = new Map();\n\t\tfor (let shader_name of this.shader_names()) {\n\t\t\tnodes_by_shader_name.set(shader_name, node_traverser.nodes_for_shader_name(shader_name));\n\t\t}\n\t\tconst sorted_nodes = node_traverser.sorted_nodes();\n\t\tfor (let shader_name of this.shader_names()) {\n\t\t\tconst root_nodes_for_shader = this._assembler.root_nodes_by_shader_name(shader_name);\n\t\t\t// const leaf_nodes_for_shader = this._assembler.leaf_nodes_by_shader_name(shader_name);\n\n\t\t\t// keep track of which nodes are both leaf and root, and do not use their code twice\n\t\t\t// as this may happen with an attribute node, when used as both import and export\n\t\t\t// TODO: that seems useless, as I surely should be able to filter duplicates if needed\n\n\t\t\t// ensure nodes are unique\n\t\t\t// const node_ids: Map<string, boolean> = new Map();\n\t\t\t// nodes_by_shader_name.forEach((nodes, shader_name) => {\n\t\t\t// \tfor (let node of nodes) {\n\t\t\t// \t\tnode_ids.set(node.graph_node_id, true);\n\t\t\t// \t}\n\t\t\t// });\n\n\t\t\tfor (let root_node of root_nodes_for_shader) {\n\t\t\t\t// if(!both_leaf_and_root_nodes_by_id[root_node.graph_node_id()]){\n\t\t\t\t// if (!node_ids.get(root_node.graph_node_id)) {\n\t\t\t\tMapUtils.push_on_array_at_entry(nodes_by_shader_name, shader_name, root_node);\n\t\t\t\t// node_ids.set(root_node.graph_node_id, true);\n\t\t\t\t// }\n\t\t\t\t// }\n\t\t\t}\n\t\t\t// for (let leaf_node of leaf_nodes_for_shader) {\n\t\t\t// if(!both_leaf_and_root_nodes_by_id[leaf_node.graph_node_id()]){\n\t\t\t// if (!node_ids.get(leaf_node.graph_node_id)) {\n\t\t\t// MapUtils.unshift_on_array_at_entry(nodes_by_shader_name, shader_name, leaf_node);\n\t\t\t// }\n\t\t\t// }\n\t\t\t// }\n\t\t}\n\n\t\t// ensure nodes are not added if already present\n\t\tconst sorted_node_ids: Map<string, boolean> = new Map();\n\t\tfor (let node of sorted_nodes) {\n\t\t\tsorted_node_ids.set(node.graph_node_id, true);\n\t\t}\n\n\t\tfor (let root_node of root_nodes) {\n\t\t\tif (!sorted_node_ids.get(root_node.graph_node_id)) {\n\t\t\t\tsorted_nodes.push(root_node);\n\t\t\t\tsorted_node_ids.set(root_node.graph_node_id, true);\n\t\t\t}\n\t\t}\n\t\tfor (let node of sorted_nodes) {\n\t\t\t// node.set_assembler(this._assembler);\n\t\t\tnode.reset_code();\n\t\t}\n\t\tfor (let node of sorted_nodes) {\n\t\t\tawait node.params.eval_all();\n\t\t}\n\n\t\t// const param_promises = sorted_nodes.map(node=>{\n\t\t// \treturn node.eval_all_params()\n\t\t// })\n\t\t// await Promise.all(param_promises)\n\n\t\tthis._shaders_collection_controller = new ShadersCollectionController(\n\t\t\tthis.shader_names(),\n\t\t\tthis.shader_names()[0]\n\t\t);\n\t\tthis.reset();\n\t\tfor (let shader_name of this.shader_names()) {\n\t\t\tconst nodes = lodash_uniq(nodes_by_shader_name.get(shader_name));\n\t\t\tthis._shaders_collection_controller.set_current_shader_name(shader_name);\n\t\t\tif (nodes) {\n\t\t\t\tfor (let node of nodes) {\n\t\t\t\t\t// node.set_shader_name(shader_name);\n\t\t\t\t\tif (this._param_configs_set_allowed) {\n\t\t\t\t\t\tnode.set_param_configs();\n\t\t\t\t\t}\n\t\t\t\t\tnode.set_lines(this._shaders_collection_controller);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// fragment_nodes.forEach(node=>{\n\t\t// \tnode.set_shader_name(ShaderName.FRAGMENT)\n\t\t// \tnode.set_param_configs()\n\t\t// \tnode.set_lines()\n\t\t// })\n\t\tif (this._param_configs_set_allowed) {\n\t\t\tthis.set_param_configs(sorted_nodes);\n\t\t}\n\t\tthis.set_code_lines(sorted_nodes);\n\t}\n\n\tdisallow_new_param_configs() {\n\t\tthis._param_configs_set_allowed = false;\n\t}\n\tallow_new_param_configs() {\n\t\tthis._param_configs_set_allowed = true;\n\t}\n\n\tshader_names() {\n\t\treturn this._assembler.shader_names;\n\t}\n\n\tprivate reset() {\n\t\tfor (let shader_name of this.shader_names()) {\n\t\t\tconst lines_map = new Map();\n\t\t\t// for (let line_type of LINE_TYPES) {\n\t\t\t// \tlines_map.set(line_type, []);\n\t\t\t// }\n\t\t\tthis._lines.set(shader_name, lines_map);\n\t\t\tthis._function_declared.set(shader_name, new Map());\n\t\t}\n\t}\n\n\tparam_configs() {\n\t\treturn this._param_configs_controller.list || [];\n\t}\n\tlines(shader_name: ShaderName, line_type: LineType) {\n\t\treturn this._lines.get(shader_name)!.get(line_type);\n\t}\n\tall_lines() {\n\t\treturn this._lines;\n\t}\n\n\tset_param_configs(nodes: BaseGlNodeType[]) {\n\t\tthis._param_configs_controller.reset();\n\t\tfor (let node of nodes) {\n\t\t\tconst param_configs = node.param_configs();\n\t\t\tif (param_configs) {\n\t\t\t\tfor (let param_config of param_configs) {\n\t\t\t\t\tthis._param_configs_controller.push(param_config);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tset_code_lines(nodes: BaseGlNodeType[]) {\n\t\tfor (let shader_name of this.shader_names()) {\n\t\t\t// nodes.forEach((node, i)=>{\n\t\t\tthis.add_code_lines(nodes, shader_name);\n\t\t\t// })\n\t\t}\n\t}\n\n\tadd_code_lines(nodes: BaseGlNodeType[], shader_name: ShaderName) {\n\t\tthis.add_definitions(nodes, shader_name, GLDefinitionType.FUNCTION, LineType.FUNCTION_DECLARATION);\n\t\tthis.add_definitions(nodes, shader_name, GLDefinitionType.UNIFORM, LineType.DEFINE);\n\t\tthis.add_definitions(nodes, shader_name, GLDefinitionType.VARYING, LineType.DEFINE);\n\t\tthis.add_definitions(nodes, shader_name, GLDefinitionType.ATTRIBUTE, LineType.DEFINE);\n\n\t\tthis.add_code_line_for_nodes_and_line_type(nodes, shader_name, LineType.BODY);\n\t}\n\n\tprivate add_definitions(\n\t\tnodes: BaseGlNodeType[],\n\t\tshader_name: ShaderName,\n\t\tdefinition_type: GLDefinitionType,\n\t\tline_type: LineType\n\t) {\n\t\tif (!this._shaders_collection_controller) {\n\t\t\treturn;\n\t\t}\n\t\tconst definitions = [];\n\t\tfor (let node of nodes) {\n\t\t\tlet node_definitions = this._shaders_collection_controller.definitions(shader_name, node);\n\t\t\tif (node_definitions) {\n\t\t\t\tnode_definitions = node_definitions.filter((d) => d.definition_type == definition_type);\n\t\t\t\tfor (let definition of node_definitions) {\n\t\t\t\t\tdefinitions.push(definition);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (definitions.length > 0) {\n\t\t\tconst collection = new TypedGLDefinitionCollection<GLDefinitionType>(definitions);\n\t\t\tconst uniq_definitions = collection.uniq();\n\t\t\tif (collection.errored) {\n\t\t\t\t// TODO: handle error\n\t\t\t\tthrow `code builder error: ${collection.error_message}`;\n\t\t\t}\n\n\t\t\tconst definitions_by_node_id: Map<string, BaseGLDefinition[]> = new Map();\n\t\t\tconst node_ids: Map<string, boolean> = new Map();\n\t\t\tfor (let definition of uniq_definitions) {\n\t\t\t\tconst node_id = definition.node.graph_node_id;\n\t\t\t\tif (!node_ids.has(node_id)) {\n\t\t\t\t\tnode_ids.set(node_id, true);\n\t\t\t\t}\n\t\t\t\tMapUtils.push_on_array_at_entry(definitions_by_node_id, node_id, definition);\n\t\t\t}\n\t\t\tconst lines_for_shader = this._lines.get(shader_name)!;\n\t\t\tnode_ids.forEach((boolean: boolean, node_id: string) => {\n\t\t\t\tconst definitions = definitions_by_node_id.get(node_id);\n\t\t\t\tif (definitions) {\n\t\t\t\t\tconst first_definition = definitions[0];\n\n\t\t\t\t\tif (first_definition) {\n\t\t\t\t\t\tconst comment = CodeFormatter.node_comment(first_definition.node, line_type);\n\t\t\t\t\t\tMapUtils.push_on_array_at_entry(lines_for_shader, line_type, comment);\n\n\t\t\t\t\t\tfor (let definition of definitions) {\n\t\t\t\t\t\t\tconst line = CodeFormatter.line_wrap(definition.line, line_type);\n\t\t\t\t\t\t\tMapUtils.push_on_array_at_entry(lines_for_shader, line_type, line);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tconst separator = CodeFormatter.post_line_separator(line_type);\n\t\t\t\t\t\tMapUtils.push_on_array_at_entry(lines_for_shader, line_type, separator);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n\tadd_code_line_for_nodes_and_line_type(nodes: BaseGlNodeType[], shader_name: ShaderName, line_type: LineType) {\n\t\tnodes = nodes.filter((node) => {\n\t\t\tif (this._shaders_collection_controller) {\n\t\t\t\tconst lines = this._shaders_collection_controller.body_lines(shader_name, node);\n\t\t\t\treturn lines && lines.length > 0;\n\t\t\t}\n\t\t});\n\n\t\tvar nodes_count = nodes.length;\n\t\tfor (let i = 0; i < nodes_count; i++) {\n\t\t\tconst is_last = i == nodes.length - 1;\n\t\t\tthis.add_code_line_for_node_and_line_type(nodes[i], shader_name, line_type, is_last);\n\t\t}\n\t}\n\tadd_code_line_for_node_and_line_type(\n\t\tnode: BaseGlNodeType,\n\t\tshader_name: ShaderName,\n\t\tline_type: LineType,\n\t\tis_last: boolean\n\t): void {\n\t\tif (!this._shaders_collection_controller) {\n\t\t\treturn;\n\t\t}\n\t\tconst lines = this._shaders_collection_controller.body_lines(shader_name, node);\n\n\t\tif (lines && lines.length > 0) {\n\t\t\tconst lines_for_shader = this._lines.get(shader_name)!;\n\t\t\tconst comment = CodeFormatter.node_comment(node, line_type);\n\t\t\tMapUtils.push_on_array_at_entry(lines_for_shader, line_type, comment);\n\t\t\tlodash_uniq(lines).forEach((line) => {\n\t\t\t\tline = CodeFormatter.line_wrap(line, line_type);\n\t\t\t\tMapUtils.push_on_array_at_entry(lines_for_shader, line_type, line);\n\t\t\t});\n\t\t\tif (!(line_type == LineType.BODY && is_last)) {\n\t\t\t\tconst separator = CodeFormatter.post_line_separator(line_type);\n\t\t\t\tMapUtils.push_on_array_at_entry(lines_for_shader, line_type, separator);\n\t\t\t}\n\t\t}\n\t}\n}\n","// import {UniformsUtils} from 'three/src/renderers/shaders/UniformsUtils';\nimport {ShaderMaterial} from 'three/src/materials/ShaderMaterial';\n// import {ShaderChunk} from 'three/src/renderers/shaders/ShaderChunk';\n// import {Shader} from 'three/src/renderers/shaders/ShaderLib'\n// import {MeshStandardMaterial} from 'three/src/materials/MeshStandardMaterial';\n// import {MeshPhysicalMaterial} from 'three/src/materials/MeshPhysicalMaterial';\n// import {Material} from 'three/src/materials/Material';\nimport {Vector2} from 'three/src/math/Vector2';\n\n// import {Connection} from '../../../../../Engine/Node/Gl/GlData';\nimport {LineType} from '../utils/LineType';\n// import {Output} from '../../../../../Engine/Node/Gl/Output'\n\nimport {ShaderConfig} from '../configs/ShaderConfig';\nimport {VariableConfig} from '../configs/VariableConfig';\n// import {ThreeToGl} from '../../../../../core/ThreeToGl';\n// const BODY_SPLIT_LINE = 'void main() {'\n// export const BODY_SEPARATOR_LINES = lodash_range(3).map(i=>'\t')\nimport {CodeBuilder} from '../utils/CodeBuilder';\n// import {BaseNode} from '../../../../../Engine/Node/_Base';\nimport {BaseGlNodeType} from '../../_Base';\nimport {GlobalsGeometryHandler} from '../globals/Geometry';\nimport {TypedAssembler} from '../../../utils/shaders/BaseAssembler';\nimport {ShaderName} from '../../../utils/shaders/ShaderName';\n// import {IUniformsWithFrame, IUniformsWithResolution} from '../../../../scene/utils/UniformsController';\nimport {OutputGlNode} from '../../Output';\nimport {ParamType} from '../../../../poly/ParamType';\nimport {TypedNamedConnectionPoint} from '../../../utils/connections/NamedConnectionPoint';\nimport {ConnectionPointType} from '../../../utils/connections/ConnectionPointType';\nimport {GlobalsGlNode} from '../../Globals';\nimport {AttributeGlNode} from '../../Attribute';\nimport {AssemblerControllerNode} from '../Controller';\nimport {GlobalsBaseController} from '../globals/_Base';\nimport {CustomMaterialName} from './materials/_BaseMaterial';\nimport {ShadersCollectionController} from '../utils/ShadersCollectionController';\nimport {IUniforms} from '../../../../../core/geometry/Material';\n\ntype StringArrayByShaderName = Map<ShaderName, string[]>;\n\ninterface ITemplateShader {\n\tvertexShader?: string;\n\tfragmentShader?: string;\n\tuniforms?: IUniforms;\n}\n\nconst INSERT_DEFINE_AFTER_MAP: Map<ShaderName, string> = new Map([\n\t[ShaderName.VERTEX, '#include <common>'],\n\t[ShaderName.FRAGMENT, '#include <common>'],\n]);\nconst INSERT_BODY_AFTER_MAP: Map<ShaderName, string> = new Map([\n\t[ShaderName.VERTEX, '#include <color_vertex>'],\n\t[ShaderName.FRAGMENT, 'vec4 diffuseColor = vec4( diffuse, opacity );'],\n]);\nconst LINES_TO_REMOVE_MAP: Map<ShaderName, string[]> = new Map([\n\t[ShaderName.VERTEX, ['#include <begin_vertex>', '#include <beginnormal_vertex>']],\n\t[ShaderName.FRAGMENT, []],\n]);\n\nconst SPACED_LINES = 3;\n\nexport class BaseGlShaderAssembler extends TypedAssembler<BaseGlNodeType> {\n\tprotected _shaders_by_name: Map<ShaderName, string> = new Map();\n\tprotected _lines: StringArrayByShaderName = new Map();\n\tprotected _code_builder: CodeBuilder | undefined;\n\tprivate _param_config_owner: CodeBuilder | undefined;\n\tprotected _root_nodes: BaseGlNodeType[] = [];\n\tprotected _leaf_nodes: BaseGlNodeType[] = [];\n\tprotected _material: ShaderMaterial | undefined;\n\n\tprivate _shader_configs: ShaderConfig[] | undefined;\n\tprivate _variable_configs: VariableConfig[] | undefined;\n\n\tprivate _uniforms_time_dependent: boolean = false;\n\tprivate _resolution_dependent: boolean = false;\n\n\tconstructor(protected _gl_parent_node: AssemblerControllerNode) {\n\t\tsuper();\n\t}\n\n\tasync compile() {}\n\n\t// private get material() {\n\t// \treturn (this._material = this._material || this._create_material());\n\t// }\n\t// async get_material(/*master_assembler?: BaseGlShaderAssembler*/) {\n\t// \tthis._material = this._material || this._create_material();\n\n\t// \tawait this._update_material(/*master_assembler*/);\n\t// \treturn this._material;\n\t// }\n\tprotected _template_shader_for_shader_name(shader_name: ShaderName): string | undefined {\n\t\tswitch (shader_name) {\n\t\t\tcase ShaderName.VERTEX:\n\t\t\t\treturn this._template_shader?.vertexShader;\n\t\t\tcase ShaderName.FRAGMENT:\n\t\t\t\treturn this._template_shader?.fragmentShader;\n\t\t}\n\t}\n\n\tget globals_handler(): GlobalsBaseController | undefined {\n\t\treturn this._gl_parent_node.assembler_controller.globals_handler;\n\t}\n\tcompile_allowed(): boolean {\n\t\treturn this._gl_parent_node.assembler_controller.globals_handler != null;\n\t}\n\tshaders_by_name() {\n\t\treturn this._shaders_by_name;\n\t}\n\n\t// protected create_material(): ShaderMaterial | undefined {\n\t// \treturn undefined;\n\t// }\n\tprotected _build_lines() {\n\t\tfor (let shader_name of this.shader_names) {\n\t\t\tconst template = this._template_shader_for_shader_name(shader_name);\n\t\t\tif (template) {\n\t\t\t\tthis._replace_template(template, shader_name);\n\t\t\t}\n\t\t}\n\t}\n\n\t// protected _build_lines_for_shader_name(shader_name: ShaderName){\n\t// \tconst template = this._template_shader()\n\t// \tthis._replace_template(template[`${shader_name}Shader`], shader_name)\n\t// }\n\n\tset_root_nodes(root_nodes: BaseGlNodeType[]) {\n\t\tthis._root_nodes = root_nodes;\n\t}\n\tprotected get _template_shader(): ITemplateShader | undefined {\n\t\treturn undefined;\n\t} //Shader - could not find the import?\n\t// abstract _color_declaration(): string\n\t// private async _update_material(/*master_assembler?: BaseGlShaderAssembler*/) {\n\t// \tif (!this.material || !this._material) {\n\t// \t\treturn;\n\t// \t}\n\t// \tconst template_shader = this._template_shader;\n\t// \tif (!template_shader) {\n\t// \t\treturn;\n\t// \t}\n\t// \tthis._lines = new Map();\n\t// \tfor (let shader_name of this.shader_names) {\n\t// \t\tconst template = this._template_shader_for_shader_name(shader_name);\n\t// \t\tif (template) {\n\t// \t\t\tthis._lines.set(shader_name, template.split('\\n'));\n\t// \t\t}\n\t// \t}\n\t// \tif (this._root_nodes.length > 0) {\n\t// \t\t// this._output_node.set_color_declaration(this._color_declaration())\n\t// \t\t// if(!master_assembler){\n\t// \t\t// this._output_node.set_assembler(this)\n\t// \t\tawait this.build_code_from_nodes(this._root_nodes);\n\t// \t\t// }\n\n\t// \t\t(this._material as any).extensions = {derivatives: true};\n\t// \t\t// this._material?.derivatives = true;\n\t// \t\tthis._build_lines();\n\t// \t\t// this._lines[ShaderName.FRAGMENT].unshift('#extension GL_OES_standard_derivatives : enable')\n\t// \t}\n\n\t// \t// TODO: typescript - not sure that is still useful\n\t// \t// for (let param_config of this.param_configs()) {\n\t// \t// \tparam_config.material = this._material;\n\t// \t// }\n\n\t// \t// instead of replacing fully the uniforms,\n\t// \t// I simply add to them the new ones or replace the existing ones\n\t// \t// otherwise this would break the particles_system_gpu\n\t// \t// which would not reset correctly when going back to first frame.\n\t// \t// Not entirely sure why, but this seems to be due to the texture uniforms\n\t// \t// which are removed and then readded. This seems to mess up somewhere with how\n\t// \t// the material updates itself...\n\t// \t// this._material.uniforms = this.build_uniforms(template_shader)\n\t// \tconst new_uniforms = this.build_uniforms(template_shader.uniforms);\n\t// \tthis.material.uniforms = this.material.uniforms || {};\n\t// \tfor (let uniform_name of Object.keys(new_uniforms)) {\n\t// \t\tthis.material.uniforms[uniform_name] = new_uniforms[uniform_name];\n\t// \t}\n\n\t// \tfor (let shader_name of this.shader_names) {\n\t// \t\tconst lines = this._lines.get(shader_name);\n\t// \t\tif (lines) {\n\t// \t\t\tconst shader = lines.join('\\n');\n\t// \t\t\tswitch (shader_name) {\n\t// \t\t\t\tcase ShaderName.VERTEX: {\n\t// \t\t\t\t\tthis._material.vertexShader = shader;\n\t// \t\t\t\t\tbreak;\n\t// \t\t\t\t}\n\t// \t\t\t\tcase ShaderName.FRAGMENT: {\n\t// \t\t\t\t\tthis._material.fragmentShader = shader;\n\t// \t\t\t\t\tbreak;\n\t// \t\t\t\t}\n\t// \t\t\t}\n\t// \t\t}\n\t// \t}\n\n\t// \tconst scene = this._gl_parent_node.scene;\n\t// \t// const id = this._gl_parent_node.graph_node_id()\n\t// \tif (this.frame_dependent()) {\n\t// \t\t// make sure not to use this._gl_parent_node.graph_node_id() as the id,\n\t// \t\t// as we need several materials:\n\t// \t\t// - the visible one\n\t// \t\t// - the multiple shadow ones\n\t// \t\t// - and possibly a depth one\n\t// \t\tscene.uniforms_controller.add_frame_dependent_uniform_owner(\n\t// \t\t\tthis._material.uuid,\n\t// \t\t\tthis._material.uniforms as IUniformsWithFrame\n\t// \t\t);\n\t// \t} else {\n\t// \t\tscene.uniforms_controller.remove_frame_dependent_uniform_owner(this._material.uuid);\n\t// \t}\n\n\t// \tif (this.resolution_dependent()) {\n\t// \t\tscene.uniforms_controller.add_resolution_dependent_uniform_owner(\n\t// \t\t\tthis._material.uuid,\n\t// \t\t\tthis._material.uniforms as IUniformsWithResolution\n\t// \t\t);\n\t// \t} else {\n\t// \t\tscene.uniforms_controller.remove_resolution_dependent_uniform_owner(this._material.uuid);\n\t// \t}\n\t// }\n\n\tprotected add_uniforms(current_uniforms: IUniforms) {\n\t\t// const new_uniforms = UniformsUtils.clone(template_uniforms);\n\n\t\t// copy the new uniforms onto the old ones, only adding, not removing\n\t\t// for (let uniform_name of Object.keys(new_uniforms)) {\n\n\t\t// }\n\n\t\t// copy the values of the old uniform\n\t\t// for (let uniform_name of Object.keys(old_uniforms)) {\n\t\t// \tconst new_uniform = new_uniforms[uniform_name];\n\t\t// \tif (new_uniform) {\n\t\t// \t\tnew_uniform.value = old_uniforms[uniform_name].value;\n\t\t// \t}\n\t\t// }\n\n\t\tfor (let param_config of this.param_configs()) {\n\t\t\tcurrent_uniforms[param_config.uniform_name] = param_config.uniform;\n\t\t}\n\n\t\tif (this.uniforms_time_dependent()) {\n\t\t\tcurrent_uniforms['time'] = {\n\t\t\t\t// type: '1f',\n\t\t\t\tvalue: this._gl_parent_node.scene.time,\n\t\t\t};\n\t\t}\n\t\tif (this.resolution_dependent()) {\n\t\t\tcurrent_uniforms['resolution'] = {\n\t\t\t\tvalue: new Vector2(1000, 1000),\n\t\t\t};\n\t\t}\n\n\t\t// return new_uniforms;\n\t}\n\n\t//\n\t//\n\t// ROOT NODES AND SHADER NAMES\n\t//\n\t//\n\troot_nodes_by_shader_name(shader_name: ShaderName): BaseGlNodeType[] {\n\t\t// return this._root_nodes\n\t\tconst list = [];\n\t\tfor (let node of this._root_nodes) {\n\t\t\tswitch (node.type) {\n\t\t\t\tcase 'output': {\n\t\t\t\t\tlist.push(node);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase 'attribute': {\n\t\t\t\t\t// TODO: typescript - gl - why is there a texture allocation controller in the base assembler?\n\t\t\t\t\t// const attrib_name = (node as AttributeGlNode).attribute_name;\n\t\t\t\t\t// const variable = this._texture_allocations_controller.variable(attrib_name);\n\t\t\t\t\t// if (variable) {\n\t\t\t\t\t// \tconst allocation_shader_name = variable.allocation().shader_name();\n\t\t\t\t\t// \tif (allocation_shader_name == shader_name) {\n\t\t\t\t\t// \t\tlist.push(node);\n\t\t\t\t\t// \t}\n\t\t\t\t\t// }\n\t\t\t\t\t// break;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn list;\n\t}\n\tleaf_nodes_by_shader_name(shader_name: ShaderName): BaseGlNodeType[] {\n\t\tconst list = [];\n\t\tfor (let node of this._leaf_nodes) {\n\t\t\tswitch (node.type) {\n\t\t\t\tcase GlobalsGlNode.type(): {\n\t\t\t\t\tlist.push(node);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase AttributeGlNode.type(): {\n\t\t\t\t\t// TODO: typescript - gl - why is there a texture allocation controller in the base assembler? AND especially since there is no way to assign it?\n\t\t\t\t\t// const attrib_name: string = (node as AttributeGlNode).attribute_name;\n\t\t\t\t\t// const variable = this._texture_allocations_controller.variable(attrib_name);\n\t\t\t\t\t// if (variable) {\n\t\t\t\t\t// \tconst allocation_shader_name = variable.allocation().shader_name();\n\t\t\t\t\t// \tif (allocation_shader_name == shader_name) {\n\t\t\t\t\t// \t\tlist.push(node);\n\t\t\t\t\t// \t}\n\t\t\t\t\t// }\n\t\t\t\t\t// break;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn list;\n\t}\n\tset_node_lines_globals(globals_node: GlobalsGlNode, shaders_collection_controller: ShadersCollectionController) {}\n\tset_node_lines_output(output_node: OutputGlNode, shaders_collection_controller: ShadersCollectionController) {}\n\tset_node_lines_attribute(\n\t\tattribute_node: AttributeGlNode,\n\t\tshaders_collection_controller: ShadersCollectionController\n\t) {}\n\n\t//\n\t//\n\t// CHILDREN NODES PARAMS\n\t//\n\t//\n\tget code_builder() {\n\t\treturn (this._code_builder = this._code_builder || new CodeBuilder(this, this._gl_parent_node));\n\t}\n\tasync build_code_from_nodes(root_nodes: BaseGlNodeType[]) {\n\t\tawait this.code_builder.build_from_nodes(root_nodes);\n\t}\n\tallow_new_param_configs() {\n\t\tthis.code_builder.allow_new_param_configs();\n\t}\n\tdisallow_new_param_configs() {\n\t\tthis.code_builder.disallow_new_param_configs();\n\t}\n\tbuilder_param_configs() {\n\t\treturn this.code_builder.param_configs();\n\t}\n\tbuilder_lines(shader_name: ShaderName, line_type: LineType) {\n\t\treturn this.code_builder.lines(shader_name, line_type);\n\t}\n\tall_builder_lines() {\n\t\treturn this.code_builder.all_lines();\n\t}\n\tparam_configs() {\n\t\tconst code_builder = this._param_config_owner || this.code_builder;\n\t\treturn code_builder.param_configs();\n\t}\n\tset_param_configs_owner(param_config_owner: CodeBuilder) {\n\t\tthis._param_config_owner = param_config_owner;\n\t\tif (this._param_config_owner) {\n\t\t\tthis.code_builder.disallow_new_param_configs();\n\t\t} else {\n\t\t\tthis.code_builder.allow_new_param_configs();\n\t\t}\n\t}\n\n\t//\n\t//\n\t// CHILDREN NODES PARAMS\n\t//\n\t//\n\tstatic add_output_params(output_child: OutputGlNode) {\n\t\toutput_child.params.add_param(ParamType.VECTOR3, 'position', [0, 0, 0], {hidden: true});\n\t\toutput_child.params.add_param(ParamType.VECTOR3, 'normal', [0, 0, 0], {hidden: true});\n\t\toutput_child.params.add_param(ParamType.COLOR, 'color', [1, 1, 1], {hidden: true});\n\t\toutput_child.params.add_param(ParamType.FLOAT, 'alpha', 1, {hidden: true});\n\t\toutput_child.params.add_param(ParamType.VECTOR2, 'uv', [0, 0], {hidden: true});\n\t}\n\tadd_output_params(output_child: OutputGlNode) {\n\t\tBaseGlShaderAssembler.add_output_params(output_child);\n\t}\n\tstatic create_globals_node_output_connections() {\n\t\treturn [\n\t\t\tnew TypedNamedConnectionPoint('position', ConnectionPointType.VEC3),\n\t\t\tnew TypedNamedConnectionPoint('normal', ConnectionPointType.VEC3),\n\t\t\tnew TypedNamedConnectionPoint('color', ConnectionPointType.VEC3),\n\t\t\tnew TypedNamedConnectionPoint('uv', ConnectionPointType.VEC2),\n\t\t\tnew TypedNamedConnectionPoint('gl_FragCoord', ConnectionPointType.VEC4),\n\t\t\tnew TypedNamedConnectionPoint('resolution', ConnectionPointType.VEC2),\n\t\t\t// new Connection.Vec2('gl_PointCoord'),\n\t\t\t// new TypedConnectionVec2('uv'),\n\t\t\tnew TypedNamedConnectionPoint('time', ConnectionPointType.FLOAT),\n\t\t];\n\t}\n\tcreate_globals_node_output_connections() {\n\t\treturn BaseGlShaderAssembler.create_globals_node_output_connections();\n\t}\n\tadd_globals_params(globals_node: GlobalsGlNode) {\n\t\tglobals_node.io.outputs.set_named_output_connection_points(this.create_globals_node_output_connections());\n\t}\n\tallow_attribute_exports() {\n\t\treturn false;\n\t}\n\n\t//\n\t//\n\t// CONFIGS\n\t//\n\t//\n\treset_configs() {\n\t\tthis._reset_shader_configs();\n\t\tthis._reset_variable_configs();\n\t\tthis._reset_uniforms_time_dependency();\n\t\tthis._reset_resolution_dependency();\n\t}\n\tget shader_configs() {\n\t\treturn (this._shader_configs = this._shader_configs || this.create_shader_configs());\n\t}\n\tset_shader_configs(shader_configs: ShaderConfig[]) {\n\t\tthis._shader_configs = shader_configs;\n\t}\n\tget shader_names(): ShaderName[] {\n\t\treturn this.shader_configs?.map((sc) => sc.name()) || [];\n\t}\n\tprotected _reset_shader_configs() {\n\t\tthis._shader_configs = undefined;\n\t\t// this.shader_configs; // TODO: typescript - why do I need to re-initialize here?\n\t}\n\tcreate_shader_configs(): ShaderConfig[] {\n\t\treturn [\n\t\t\tnew ShaderConfig(ShaderName.VERTEX, ['position', 'normal', 'uv'], []),\n\t\t\tnew ShaderConfig(ShaderName.FRAGMENT, ['color', 'alpha'], [ShaderName.VERTEX]),\n\t\t];\n\t}\n\tshader_config(name: string): ShaderConfig | undefined {\n\t\treturn this.shader_configs?.filter((sc) => {\n\t\t\treturn sc.name() == name;\n\t\t})[0];\n\t}\n\tvariable_configs() {\n\t\treturn (this._variable_configs = this._variable_configs || this.create_variable_configs());\n\t}\n\tset_variable_configs(variable_configs: VariableConfig[]) {\n\t\tthis._variable_configs = variable_configs;\n\t}\n\tvariable_config(name: string) {\n\t\treturn this.variable_configs().filter((vc) => {\n\t\t\treturn vc.name() == name;\n\t\t})[0];\n\t}\n\tstatic create_variable_configs() {\n\t\treturn [\n\t\t\tnew VariableConfig('position', {\n\t\t\t\tdefault_from_attribute: true,\n\t\t\t\t// default: this.globals_handler().variable_config_default('position'),\n\t\t\t\t// required_definitions: this.globals_handler().variable_config_required_definitions('position'),\n\t\t\t\tprefix: 'vec3 transformed = ',\n\t\t\t}),\n\t\t\tnew VariableConfig('normal', {\n\t\t\t\tdefault_from_attribute: true,\n\t\t\t\tprefix: 'vec3 objectNormal = ',\n\t\t\t\t// post_lines: ['#ifdef USE_TANGENT', 'vec3 objectTangent = vec3( tangent.xyz );', '#endif'],\n\t\t\t}),\n\t\t\tnew VariableConfig('color', {\n\t\t\t\tprefix: 'diffuseColor.xyz = ',\n\t\t\t}),\n\t\t\tnew VariableConfig('alpha', {\n\t\t\t\tprefix: 'diffuseColor.a = ',\n\t\t\t}),\n\t\t\tnew VariableConfig('uv', {\n\t\t\t\t// default_from_attribute: true,\n\t\t\t\tprefix: 'vUv = ',\n\t\t\t\tif: GlobalsGeometryHandler.IF_RULE.uv,\n\t\t\t}),\n\t\t];\n\t}\n\tcreate_variable_configs(): VariableConfig[] {\n\t\treturn BaseGlShaderAssembler.create_variable_configs();\n\t}\n\tprotected _reset_variable_configs() {\n\t\tthis._variable_configs = undefined;\n\t\tthis.variable_configs();\n\t}\n\tinput_names_for_shader_name(root_node: BaseGlNodeType, shader_name: ShaderName) {\n\t\treturn this.shader_config(shader_name)?.input_names() || [];\n\t}\n\n\t// time dependency\n\tprotected _reset_uniforms_time_dependency() {\n\t\tthis._uniforms_time_dependent = false;\n\t}\n\tset_uniforms_time_dependent() {\n\t\tthis._uniforms_time_dependent = true;\n\t}\n\tuniforms_time_dependent(): boolean {\n\t\treturn this._uniforms_time_dependent;\n\t}\n\t// resolution dependency\n\tprotected _reset_resolution_dependency() {\n\t\tthis._resolution_dependent = false;\n\t}\n\tset_resolution_dependent() {\n\t\tthis._resolution_dependent = true;\n\t}\n\tresolution_dependent(): boolean {\n\t\treturn this._resolution_dependent;\n\t}\n\n\t//\n\t//\n\t// TEMPLATE HOOKS\n\t//\n\t//\n\tprotected insert_define_after(shader_name: ShaderName): string | undefined {\n\t\treturn INSERT_DEFINE_AFTER_MAP.get(shader_name);\n\t}\n\tprotected insert_body_after(shader_name: ShaderName): string | undefined {\n\t\treturn INSERT_BODY_AFTER_MAP.get(shader_name);\n\t}\n\tprotected lines_to_remove(shader_name: ShaderName): string[] | undefined {\n\t\treturn LINES_TO_REMOVE_MAP.get(shader_name);\n\t}\n\n\t//\n\t//\n\t// TEMPLATE CODE REPLACEMENT\n\t//\n\t//\n\n\tprivate _replace_template(template: string, shader_name: ShaderName) {\n\t\tconst function_declaration = this.builder_lines(shader_name, LineType.FUNCTION_DECLARATION);\n\t\tconst define = this.builder_lines(shader_name, LineType.DEFINE);\n\t\t// let all_define = function_declaration.concat(define);\n\t\tconst body = this.builder_lines(shader_name, LineType.BODY);\n\n\t\tlet template_lines = template.split('\\n');\n\t\t// const scene = this._gl_parent_node.scene;\n\t\tconst new_lines = [\n\t\t\t// `#define FPS ${ThreeToGl.float(scene.time_controller.fps)}`,\n\t\t\t// `#define TIME_INCREMENT (1.0/${ThreeToGl.float(scene.time_controller.fps)})`,\n\t\t\t// `#define FRAME_RANGE_START ${ThreeToGl.float(scene.time_controller.frame_range[0])}`,\n\t\t\t// `#define FRAME_RANGE_END ${ThreeToGl.float(scene.time_controller.frame_range[1])}`,\n\t\t];\n\n\t\tconst line_before_define = this.insert_define_after(shader_name);\n\t\tconst line_before_body = this.insert_body_after(shader_name);\n\t\tconst lines_to_remove = this.lines_to_remove(shader_name);\n\t\tlet line_before_define_found = false;\n\t\tlet line_before_body_found = false;\n\n\t\tfor (let template_line of template_lines) {\n\t\t\tif (line_before_define_found == true) {\n\t\t\t\tif (function_declaration) {\n\t\t\t\t\tthis._insert_lines(new_lines, function_declaration);\n\t\t\t\t}\n\t\t\t\tif (define) {\n\t\t\t\t\tthis._insert_lines(new_lines, define);\n\t\t\t\t}\n\t\t\t\tline_before_define_found = false;\n\t\t\t}\n\t\t\tif (line_before_body_found == true) {\n\t\t\t\t// this._insert_default_body_declarations(new_lines, shader_name)\n\t\t\t\tif (body) {\n\t\t\t\t\tthis._insert_lines(new_lines, body);\n\t\t\t\t}\n\t\t\t\tline_before_body_found = false;\n\t\t\t}\n\n\t\t\tlet line_remove_required = false;\n\t\t\tif (lines_to_remove) {\n\t\t\t\tfor (let line_to_remove of lines_to_remove) {\n\t\t\t\t\tif (template_line.indexOf(line_to_remove) >= 0) {\n\t\t\t\t\t\tline_remove_required = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!line_remove_required) {\n\t\t\t\tnew_lines.push(template_line);\n\t\t\t} else {\n\t\t\t\tnew_lines.push('// removed:');\n\t\t\t\tnew_lines.push(`//${template_line}`);\n\t\t\t}\n\n\t\t\tif (line_before_define && template_line.indexOf(line_before_define) >= 0) {\n\t\t\t\tline_before_define_found = true;\n\t\t\t}\n\t\t\tif (line_before_body && template_line.indexOf(line_before_body) >= 0) {\n\t\t\t\tline_before_body_found = true;\n\t\t\t}\n\n\t\t\t// if(template_line.indexOf('// INSERT DEFINE') >= 0){\n\t\t\t// } else {\n\t\t\t// \tif(template_line.indexOf('// INSERT BODY') >= 0){\n\t\t\t// \t\tif(body.length > 0){\n\t\t\t// \t\t\tlodash_times(3, ()=>new_lines.push('\t'))\n\t\t\t// \t\t\tbody.forEach(body_line=>{\n\t\t\t// \t\t\t\tnew_lines.push(body_line)\n\t\t\t// \t\t\t})\n\t\t\t// \t\t\tlodash_times(3, ()=>new_lines.push('\t'))\n\t\t\t// \t\t}\n\t\t\t// \t} else {\n\t\t\t// \t\tif(template_line.indexOf('// TO REMOVE') < 0){\n\t\t\t// \t\t\tnew_lines.push(template_line)\n\t\t\t// \t\t}\n\t\t\t// \t}\n\t\t\t// }\n\t\t}\n\t\tthis._lines.set(shader_name, new_lines);\n\t}\n\n\t// protected _insert_default_body_declarations(new_lines, shader_name){\n\t// \tnew_lines.push('float POLY_roughness = 1.0;')\n\t// }\n\n\tprivate _insert_lines(new_lines: string[], lines_to_add: string[]) {\n\t\tif (lines_to_add.length > 0) {\n\t\t\tfor (let i = 0; i < SPACED_LINES; i++) {\n\t\t\t\tnew_lines.push('');\n\t\t\t}\n\n\t\t\tfor (let line_to_add of lines_to_add) {\n\t\t\t\tnew_lines.push(line_to_add);\n\t\t\t}\n\t\t\tfor (let i = 0; i < SPACED_LINES; i++) {\n\t\t\t\tnew_lines.push('');\n\t\t\t}\n\t\t}\n\t}\n\n\tasync get_custom_materials(): Promise<Map<CustomMaterialName, ShaderMaterial>> {\n\t\treturn new Map<CustomMaterialName, ShaderMaterial>();\n\t}\n\n\t// protected expand_shader(shader_string: string) {\n\t// \tfunction parseIncludes(string: string) {\n\t// \t\tvar pattern = /^[ \\t]*#include +<([\\w\\d./]+)>/gm;\n\t// \t\tfunction replace(match: string, include: string) {\n\t// \t\t\tvar replace = ShaderChunk[include];\n\n\t// \t\t\tif (replace === undefined) {\n\t// \t\t\t\tthrow new Error('Can not resolve #include <' + include + '>');\n\t// \t\t\t}\n\n\t// \t\t\treturn parseIncludes(replace);\n\t// \t\t}\n\n\t// \t\treturn string.replace(pattern, replace);\n\t// \t}\n\t// \treturn parseIncludes(shader_string);\n\t// }\n\n\t//\n\t//\n\t// GLTF EXPORT\n\t//\n\t//\n\t// static convert_material_to_gltf_supported(material: ShaderMaterial): Material{\n\t// \tconst gltf_constructor = this.is_physical() ? MeshPhysicalMaterial : MeshStandardMaterial\n\t// \tconst options = {}\n\t// \tthis._match_uniform('color', options, material, 'diffuse')\n\t// \tthis._match_uniform('map', options, material)\n\t// \tthis._match_uniform('envMap', options, material)\n\t// \tthis._match_uniform('envMapIntensity', options, material)\n\t// \tthis._match_uniform('metalness', options, material)\n\t// \tthis._match_uniform('roughness', options, material)\n\t// \tconst gltf_material = new gltf_constructor(options)\n\t// \treturn gltf_material\n\t// }\n\t// static _match_uniform(name: string, options: object, material: ShaderMaterial, uniform_name?: string) {\n\t// \tuniform_name = uniform_name || name;\n\t// \toptions[name] = material.uniforms[uniform_name].value;\n\t// }\n}\n","import {TypedNode} from '../../_Base';\nimport {ShaderName} from './ShaderName';\n\nexport abstract class TypedAssembler<T extends TypedNode<any, any, any>> {\n\tabstract get shader_names(): ShaderName[];\n\tabstract input_names_for_shader_name(node: T, shader_name: ShaderName): string[];\n}\n","import {TypedGLDefinition, GLDefinitionType} from './GLDefinition';\n\nexport class TypedGLDefinitionCollection<T extends GLDefinitionType> {\n\t_errored: boolean = false;\n\t_error_message: string | undefined;\n\n\tconstructor(private _definitions: TypedGLDefinition<T>[] = []) {}\n\n\tget errored() {\n\t\treturn this._errored;\n\t}\n\tget error_message() {\n\t\treturn this._error_message;\n\t}\n\n\tuniq(): TypedGLDefinition<T>[] {\n\t\tconst definitions_by_name: Map<string, TypedGLDefinition<T>> = new Map();\n\t\tconst names: string[] = [];\n\n\t\tfor (let definition of this._definitions) {\n\t\t\tif (!this._errored) {\n\t\t\t\tconst name = definition.name;\n\t\t\t\tconst existing = definitions_by_name.get(name);\n\t\t\t\tif (existing) {\n\t\t\t\t\tif (existing.data_type != definition.data_type) {\n\t\t\t\t\t\tthis._errored = true;\n\t\t\t\t\t\tthis._error_message = `attempt to create ${definition.name} with types ${definition.data_type}`;\n\t\t\t\t\t\tconsole.warn('emitting error message', this._error_message);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tdefinitions_by_name.set(name, definition);\n\t\t\t\t\tnames.push(name);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tconst uniq_definitions: TypedGLDefinition<T>[] = [];\n\t\tfor (let name of names) {\n\t\t\tconst definition = definitions_by_name.get(name);\n\t\t\tif (definition) {\n\t\t\t\tuniq_definitions.push(definition);\n\t\t\t}\n\t\t}\n\t\t// sorting may make dependencies be declared after the function calling them\n\t\t// const sorted_definitions = lodash_sortBy(uniq_definitions, (d)=>d.name())\n\t\treturn uniq_definitions;\n\t}\n}\n","import {VideoTexture} from 'three/src/textures/VideoTexture';\nimport {Vector4} from 'three/src/math/Vector4';\nimport {Vector3} from 'three/src/math/Vector3';\nimport {Vector2} from 'three/src/math/Vector2';\n\nimport {ParamType} from '../../../../poly/ParamType';\nimport {ParamInitValuesTypeMap} from '../../../../params/types/ParamInitValuesTypeMap';\nimport {ParamValuesTypeMap} from '../../../../params/types/ParamValuesTypeMap';\nimport {ParamConstructorByType} from '../../../../params/types/ParamConstructorByType';\n\nimport {BaseNodeType} from '../../../_Base';\nimport {TypedParam, BaseParamType} from '../../../../params/_Base';\nimport {NodeContext} from '../../../../poly/NodeContext';\nimport {TypeAssert} from '../../../../poly/Assert';\nimport {IUniform} from 'three/src/renderers/shaders/UniformsLib';\n// import { RampValue } from '../../../../params/ramp/RampValue';\nimport {RampParam} from '../../../../params/Ramp';\nimport {OperatorPathParam} from '../../../../params/OperatorPath';\n// import {ParamValueComparer} from '../../params/ParamValueComparer';\n// import {ParamValueCloner} from '../../params/ParamValueCloner';\n// import {CoreTextureLoader} from '../../../../../Core/Loader/Texture'\n\nexport class ParamConfig<T extends ParamType> {\n\tprivate _uniform: IUniform | undefined;\n\tprivate _cached_param_value: ParamValuesTypeMap[T] | undefined;\n\t// private _texture_loader: CoreTextureLoader\n\n\tconstructor(\n\t\tprivate _type: T,\n\t\tprivate _name: string,\n\t\tprivate _default_value: ParamInitValuesTypeMap[T],\n\t\tprivate _uniform_name: string\n\t) {}\n\n\tstatic from_param<K extends ParamType>(param: TypedParam<K>, uniform_name: string): ParamConfig<K> {\n\t\treturn new ParamConfig<K>(param.type, param.name, param.default_value, uniform_name);\n\t}\n\n\tget type() {\n\t\treturn this._type;\n\t}\n\tget name() {\n\t\treturn this._name;\n\t}\n\tget default_value() {\n\t\treturn this._default_value;\n\t}\n\tget uniform_name() {\n\t\treturn this._uniform_name;\n\t}\n\n\tget uniform() {\n\t\treturn (this._uniform = this._uniform || this._create_uniform());\n\t}\n\n\tprivate _create_uniform() {\n\t\treturn ParamConfig.uniform_by_type(this._type);\n\t}\n\n\tget param_options() {\n\t\tconst callback_bound = this._callback.bind(this);\n\t\tswitch (this._type) {\n\t\t\tcase ParamType.OPERATOR_PATH:\n\t\t\t\treturn {callback: callback_bound, node_selection: {context: NodeContext.COP}};\n\t\t\tdefault:\n\t\t\t\treturn {callback: callback_bound};\n\t\t}\n\t}\n\n\tprivate _callback(node: BaseNodeType, param: BaseParamType) {\n\t\tthis.uniform.value = param.value;\n\t}\n\n\t// TODO: refactor that to use the default values map?\n\tstatic uniform_by_type(type: ParamType): IUniform {\n\t\tswitch (type) {\n\t\t\tcase ParamType.BOOLEAN:\n\t\t\t\treturn {value: 0};\n\t\t\tcase ParamType.BUTTON:\n\t\t\t\treturn {value: 0};\n\t\t\tcase ParamType.COLOR:\n\t\t\t\treturn {value: new Vector3(0, 0, 0)};\n\t\t\tcase ParamType.FLOAT:\n\t\t\t\treturn {value: 0};\n\t\t\tcase ParamType.FOLDER:\n\t\t\t\treturn {value: 0};\n\t\t\tcase ParamType.INTEGER:\n\t\t\t\treturn {value: 0};\n\t\t\tcase ParamType.OPERATOR_PATH:\n\t\t\t\treturn {value: 0};\n\t\t\t// case ParamType.STRING: return {type: 't', value: null} // new Texture()}\n\t\t\tcase ParamType.RAMP:\n\t\t\t\treturn {value: null}; // new Texture()}\n\t\t\tcase ParamType.SEPARATOR:\n\t\t\t\treturn {value: 0};\n\t\t\tcase ParamType.STRING:\n\t\t\t\treturn {value: null};\n\t\t\tcase ParamType.VECTOR2:\n\t\t\t\treturn {value: new Vector2(0, 0)};\n\t\t\tcase ParamType.VECTOR3:\n\t\t\t\treturn {value: new Vector3(0, 0, 0)};\n\t\t\tcase ParamType.VECTOR4:\n\t\t\t\treturn {value: new Vector4(0, 0, 0, 0)};\n\t\t}\n\t\tTypeAssert.unreachable(type);\n\t}\n\n\tasync set_uniform_value(node: BaseNodeType) {\n\t\t// return new Promise( async (resolve, reject)=>{\n\t\tconst uniform = this.uniform;\n\t\t// the cache cannot be trusted...\n\t\tconst param = node.params.get(this._name) as TypedParam<T>;\n\t\tif (param) {\n\t\t\tawait param.compute(); //node[node.param_cache_name(this._name)]\n\t\t\tconst value = param.value;\n\n\t\t\tif ((value != null && this.has_value_changed(value)) || this.is_video_texture()) {\n\t\t\t\t// this._update_cached_value(value);\n\t\t\t\t// console.log(this._name, value)\n\n\t\t\t\tswitch (this._type) {\n\t\t\t\t\tcase ParamType.OPERATOR_PATH: {\n\t\t\t\t\t\tawait this.set_uniform_value_from_texture((<unknown>param) as OperatorPathParam, uniform);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcase ParamType.RAMP: {\n\t\t\t\t\t\tthis.set_uniform_value_from_ramp((<unknown>param) as RampParam, uniform);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tdefault: {\n\t\t\t\t\t\tuniform.value = param.value;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// resolve()\n\t\t\t} // else {\n\t\t\t//\tresolve()\n\t\t\t//}\n\t\t\t// })\n\t\t}\n\t}\n\n\tasync set_uniform_value_from_texture(param: OperatorPathParam, uniform: IUniform) {\n\t\t// this._texture_loader = this._texture_loader || new CoreTextureLoader(node, node.param(this.name()))\n\n\t\t// // param.graph_disconnect_predecessors()\n\t\t// const texture = await this._texture_loader.load_texture_from_url_or_op( url );\n\t\t// uniform.value = texture\n\t\tconst found_node = param.found_node();\n\t\tif (found_node) {\n\t\t\tconst container = await found_node.request_container();\n\t\t\tconst texture = container.texture();\n\t\t\tuniform.value = texture;\n\t\t} else {\n\t\t\tuniform.value = null;\n\t\t}\n\t}\n\n\tset_uniform_value_from_ramp(param: RampParam, uniform: IUniform) {\n\t\tuniform.value = param.ramp_texture();\n\t}\n\n\thas_value_changed(new_value: ParamValuesTypeMap[T]): boolean {\n\t\tconst param_constructor = ParamConstructorByType[this._type];\n\t\tif (this._cached_param_value) {\n\t\t\tconst has_changed = !param_constructor.are_values_equal(new_value, this._cached_param_value);\n\t\t\tif (has_changed) {\n\t\t\t\tthis._cached_param_value = param_constructor.clone_value(new_value);\n\t\t\t}\n\t\t\treturn has_changed;\n\t\t} else {\n\t\t\tthis._cached_param_value = param_constructor.clone_value(new_value);\n\t\t\treturn false;\n\t\t}\n\n\t\t// let has_changed = false;\n\t\t// if (this._type == ParamType.RAMP) {\n\t\t// \thas_changed = new_value.uuid() != this._cached_param_value;\n\t\t// \t// if(has_changed){ this._cached_param_value = new_value.uuid() }\n\t\t// } else {\n\t\t// \tif (this._cached_param_value != null) {\n\t\t// \t\tif (lodash_isString(new_value) || lodash_isNumber(new_value)) {\n\t\t// \t\t\t// console.log(\"new f\", new_value, this._cached_param_value)\n\t\t// \t\t\thas_changed = this._cached_param_value != new_value;\n\t\t// \t\t} else {\n\t\t// \t\t\tif (new_value != null) {\n\t\t// \t\t\t\t// console.log(\"new v\", new_value, this._cached_param_value)\n\t\t// \t\t\t\thas_changed = new_value.toArray().join('.') != this._cached_param_value.toArray().join('.');\n\t\t// \t\t\t} else {\n\t\t// \t\t\t\thas_changed = this._cached_param_value != new_value;\n\t\t// \t\t\t}\n\t\t// \t\t}\n\t\t// \t} else {\n\t\t// \t\thas_changed = true;\n\t\t// \t}\n\t\t// \t// this._cached_param_value = new_value\n\t\t// }\n\t\t// return has_changed;\n\t}\n\t// private _update_cached_value(new_value) {\n\t// \t// console.log(\"_update_cached_value\", this._name, new_value)\n\t// \tif (this._type == 'ramp') {\n\t// \t\tthis._cached_param_value = new_value.uuid();\n\t// \t} else {\n\t// \t\tif (lodash_isString(new_value) || lodash_isNumber(new_value)) {\n\t// \t\t\tthis._cached_param_value = new_value;\n\t// \t\t} else {\n\t// \t\t\t// make sure to copy the value, not assign to it\n\t// \t\t\t// otherwise we won't detect changes (since the objects would be the same)\n\t// \t\t\tthis._cached_param_value = this._cached_param_value || new_value.clone();\n\t// \t\t\tthis._cached_param_value.copy(new_value);\n\t// \t\t}\n\t// \t}\n\t// }\n\n\tis_video_texture(): boolean {\n\t\tlet result = false;\n\t\tconst uniform = this.uniform;\n\t\tif (uniform) {\n\t\t\tconst value = uniform.value;\n\t\t\tif (value) {\n\t\t\t\tresult = value.constructor == VideoTexture;\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t}\n}\n","import {ParamConfig} from '../configs/ParamConfig';\nimport {ParamType} from '../../../../poly/ParamType';\nimport {ParamInitValuesTypeMap} from '../../../../params/types/ParamInitValuesTypeMap';\n\nexport class ParamConfigsController {\n\tprivate _param_configs: ParamConfig<ParamType>[] = [];\n\n\treset() {\n\t\tthis._param_configs = [];\n\t}\n\n\tpush(param_config: ParamConfig<ParamType>) {\n\t\tthis._param_configs.push(param_config);\n\t}\n\tcreate_and_push<T extends ParamType>(\n\t\ttype: T,\n\t\tname: string,\n\t\tdefault_value: ParamInitValuesTypeMap[T],\n\t\tuniform_name: string\n\t) {\n\t\tconst param_config = new ParamConfig(type, name, default_value, uniform_name);\n\t\tthis._param_configs.push(param_config);\n\t}\n\n\tget list(): Readonly<ParamConfig<ParamType>[]> {\n\t\treturn this._param_configs;\n\t}\n}\n","import {GlobalsGlNode} from '../../Globals';\nimport {ConnectionPointType} from '../../../utils/connections/ConnectionPointType';\nimport {BaseGlNodeType} from '../../_Base';\nimport {ShadersCollectionController} from '../utils/ShadersCollectionController';\n\nexport abstract class GlobalsBaseController {\n\tprivate static __next_id: number = 0;\n\tprivate _id: number;\n\n\tconstructor() {\n\t\tthis._id = GlobalsBaseController.__next_id++;\n\t}\n\tid() {\n\t\treturn this._id;\n\t}\n\n\thandle_globals_node(\n\t\tglobals_node: GlobalsGlNode,\n\t\toutput_name: string,\n\t\tshaders_collection_controller: ShadersCollectionController\n\t\t// definitions_by_shader_name: Map<ShaderName, BaseGLDefinition[]>,\n\t\t// body_lines_by_shader_name: Map<ShaderName, string[]>,\n\t\t// body_lines: string[],\n\t\t// dependencies: ShaderName[],\n\t\t// shader_name: ShaderName\n\t): void {}\n\n\tabstract read_attribute(\n\t\tnode: BaseGlNodeType,\n\t\tgl_type: ConnectionPointType,\n\t\tattrib_name: string,\n\t\tshaders_collection_controller: ShadersCollectionController\n\t): string | undefined;\n}\n","import lodash_compact from 'lodash/compact';\nimport lodash_uniq from 'lodash/uniq';\n// import {BaseGlNodeType} from '../../gl/_Base';\n// import {OutputGlNode} from '../gl/Output';\nimport {CoreGraph} from '../../../../core/graph/CoreGraph';\nimport {BaseNodeType, TypedNode} from '../../_Base';\nimport {TypedAssembler} from './BaseAssembler';\nimport {MapUtils} from '../../../../core/MapUtils';\nimport {ShaderName} from './ShaderName';\n\ntype NumberByString = Map<string, number>;\ntype BooleanByString = Map<string, boolean>;\ntype BooleanByStringByShaderName = Map<ShaderName, BooleanByString>;\ntype StringArrayByString = Map<string, string[]>;\n\n// interface BaseNodeGlArrayByString {\n// \t[propName: string]: BaseNodeGl[]\n// }\n// interface StringArrayByString {\n// \t[propName: string]: string[]\n// }\n\n// import {LineType, LINE_TYPES} from './CodeBuilder'\n\n// const VERTEX_INPUT_NAMES = [\n// \t'position',\n// \t'normal',\n// \t'gl_PointSize'\n// ]\n// const FRAGMENT_INPUT_NAMES = [\n// \t'color',\n// \t'alpha'\n// ]\n\nexport class TypedNodeTraverser<T extends TypedNode<any, T, any>> {\n\tprivate _leaves_graph_id: BooleanByStringByShaderName = new Map();\n\tprivate _graph_ids_by_shader_name: BooleanByStringByShaderName = new Map();\n\tprivate _outputs_by_graph_id: StringArrayByString = new Map();\n\tprivate _depth_by_graph_id: NumberByString = new Map();\n\tprivate _graph_id_by_depth: Map<number, string[]> = new Map();\n\tprivate _graph: CoreGraph;\n\tprivate _shader_name!: ShaderName;\n\n\tconstructor(private _assembler: TypedAssembler<T>, private _gl_parent_node: BaseNodeType) {\n\t\tthis._graph = this._gl_parent_node.scene.graph;\n\t}\n\n\tprivate reset() {\n\t\tthis._leaves_graph_id.clear();\n\t\tthis._outputs_by_graph_id.clear();\n\t\tthis._depth_by_graph_id.clear();\n\t\tthis._graph_id_by_depth.clear();\n\n\t\tthis.shader_names().forEach((shader_name) => {\n\t\t\tthis._graph_ids_by_shader_name.set(shader_name, new Map());\n\t\t});\n\t}\n\n\tshader_names() {\n\t\treturn this._assembler.shader_names;\n\t}\n\tinput_names_for_shader_name(root_node: T, shader_name: ShaderName) {\n\t\treturn this._assembler.input_names_for_shader_name(root_node, shader_name);\n\t}\n\n\ttraverse(root_nodes: T[]) {\n\t\tthis.reset();\n\n\t\tfor (let shader_name of this.shader_names()) {\n\t\t\tthis._leaves_graph_id.set(shader_name, new Map());\n\t\t}\n\n\t\tfor (let shader_name of this.shader_names()) {\n\t\t\tthis._shader_name = shader_name;\n\t\t\tfor (let root_node of root_nodes) {\n\t\t\t\tthis.find_leaves_from_root_node(root_node);\n\t\t\t\tthis.set_nodes_depth();\n\t\t\t}\n\t\t}\n\n\t\t// graph_ids.forEach((graph_id) => {\n\t\tthis._depth_by_graph_id.forEach((depth: number, graph_id: string) => {\n\t\t\tif (depth != null) {\n\t\t\t\t// this._graph_id_by_depth.set(depth, this._graph_id_by_depth.get(depth) || []);\n\t\t\t\t// this._graph_id_by_depth.get(depth)?.push(graph_id);\n\t\t\t\tMapUtils.push_on_array_at_entry(this._graph_id_by_depth, depth, graph_id);\n\t\t\t}\n\t\t});\n\t}\n\n\tleaves_from_nodes(nodes: T[]) {\n\t\tthis._shader_name = ShaderName.LEAVES_FROM_NODES_SHADER;\n\t\tthis._graph_ids_by_shader_name.set(this._shader_name, new Map());\n\t\tthis._leaves_graph_id.set(this._shader_name, new Map());\n\t\tfor (let node of nodes) {\n\t\t\tthis.find_leaves(node);\n\t\t}\n\n\t\tconst node_ids: string[] = [];\n\t\tthis._leaves_graph_id.get(this._shader_name)?.forEach((value: boolean, key: string) => {\n\t\t\tnode_ids.push(key);\n\t\t});\n\t\treturn this._graph.nodes_from_ids(node_ids) as T[];\n\t}\n\n\tnodes_for_shader_name(shader_name: ShaderName) {\n\t\tconst depths: number[] = [];\n\t\tthis._graph_id_by_depth.forEach((value: string[], key: number) => {\n\t\t\tdepths.push(key);\n\t\t});\n\t\tdepths.sort((a, b) => a - b);\n\t\tconst nodes: T[] = [];\n\t\tdepths.forEach((depth) => {\n\t\t\tconst graph_ids_for_depth = this._graph_id_by_depth.get(depth);\n\t\t\tif (graph_ids_for_depth) {\n\t\t\t\tgraph_ids_for_depth.forEach((graph_id: string) => {\n\t\t\t\t\tconst is_present = this._graph_ids_by_shader_name.get(shader_name)?.get(graph_id);\n\t\t\t\t\tif (is_present) {\n\t\t\t\t\t\tconst node = this._graph.node_from_id(graph_id) as T;\n\t\t\t\t\t\tnodes.push(node);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\n\t\treturn nodes;\n\t}\n\tsorted_nodes() {\n\t\tconst depths: number[] = [];\n\t\tthis._graph_id_by_depth.forEach((ids: string[], depth: number) => {\n\t\t\tdepths.push(depth);\n\t\t});\n\t\tdepths.sort((a, b) => a - b);\n\t\tconst nodes: T[] = [];\n\t\tdepths.forEach((depth) => {\n\t\t\tconst graph_ids_for_depth = this._graph_id_by_depth.get(depth);\n\t\t\tif (graph_ids_for_depth) {\n\t\t\t\tfor (let graph_id of graph_ids_for_depth) {\n\t\t\t\t\tconst node = this._graph.node_from_id(graph_id) as T;\n\t\t\t\t\tif (node) {\n\t\t\t\t\t\tnodes.push(node);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\treturn nodes;\n\t}\n\tprivate find_leaves_from_root_node(root_node: T) {\n\t\t// if(this._shader_name == ShaderName.VERTEX){\n\t\t// this._leaves_graph_id[this._shader_name] = {}\n\t\tthis._graph_ids_by_shader_name.get(this._shader_name)?.set(root_node.graph_node_id, true);\n\n\t\tconst input_names = this.input_names_for_shader_name(root_node, this._shader_name);\n\t\tif (input_names) {\n\t\t\tfor (let input_name of input_names) {\n\t\t\t\t// if (root_node.type == 'output') {\n\t\t\t\tconst input = root_node.io.inputs.named_input(input_name);\n\t\t\t\tif (input) {\n\t\t\t\t\tMapUtils.push_on_array_at_entry(\n\t\t\t\t\t\tthis._outputs_by_graph_id,\n\t\t\t\t\t\tinput.graph_node_id,\n\t\t\t\t\t\troot_node.graph_node_id\n\t\t\t\t\t);\n\t\t\t\t\tthis.find_leaves(input);\n\t\t\t\t}\n\t\t\t\t// TODO: typescript - GL - check that I dont need to consider the Attrib as a special case\n\t\t\t\t// } else {\n\t\t\t\t// \t// if attribute\n\t\t\t\t// \tconst input = root_node.io.inputs.connected_named_input();\n\t\t\t\t// \tif (input) {\n\t\t\t\t// \t\tthis.find_leaves(input);\n\t\t\t\t// \t}\n\t\t\t\t// }\n\t\t\t}\n\t\t}\n\t\t// const position_input = this._output.named_input('position')\n\t\t// const normal_input = this._output.named_input('normal')\n\t\t// const instancePosition_input = this._output.named_input('instancePosition')\n\t\t// if(position_input){ this.find_leaves(position_input) }\n\t\t// if(normal_input){ this.find_leaves(normal_input) }\n\t\t// if(instancePosition_input){ this.find_leaves(instancePosition_input) }\n\t\t// }\n\t\t// if(this._shader_name == ShaderName.FRAGMENT){\n\t\t// \tthis._leaves_graph_id[this._shader_name] = {}\n\t\t// \tFRAGMENT_INPUT_NAMES.forEach(name=>{\n\t\t// \t\tconst input = this._output.named_input(name)\n\t\t// \t\tif(input){\n\t\t// \t\t\tthis.find_leaves(input)\n\t\t// \t\t}\n\t\t// \t})\n\t\t// \t// const color_input = this._output.named_input('color')\n\t\t// \t// const alpha_input = this._output.named_input('alpha')\n\t\t// \t// if(color_input){ this.find_leaves(color_input) }\n\t\t// \t// if(alpha_input){ this.find_leaves(alpha_input) }\n\t\t// }\n\n\t\tthis._outputs_by_graph_id.forEach((outputs: string[], graph_id: string) => {\n\t\t\tthis._outputs_by_graph_id.set(graph_id, lodash_uniq(outputs));\n\t\t});\n\t}\n\n\tprivate find_leaves(node: T) {\n\t\tthis._graph_ids_by_shader_name.get(this._shader_name)?.set(node.graph_node_id, true);\n\n\t\tconst inputs = lodash_compact(node.io.inputs.inputs());\n\t\tconst input_graph_ids = lodash_uniq(inputs.map((n) => n.graph_node_id));\n\t\tconst unique_inputs = input_graph_ids.map((graph_id) => this._graph.node_from_id(graph_id)) as T[];\n\t\tif (unique_inputs.length > 0) {\n\t\t\t// const promises = unique_inputs.forEach((input)=>{\n\t\t\tfor (let input of unique_inputs) {\n\t\t\t\tMapUtils.push_on_array_at_entry(this._outputs_by_graph_id, input.graph_node_id, node.graph_node_id);\n\n\t\t\t\tthis.find_leaves(input);\n\t\t\t}\n\t\t} else {\n\t\t\tthis._leaves_graph_id.get(this._shader_name)!.set(node.graph_node_id, true);\n\t\t}\n\t}\n\n\tprivate set_nodes_depth() {\n\t\tthis._leaves_graph_id.forEach((booleans_by_graph_id, shader_name) => {\n\t\t\tbooleans_by_graph_id.forEach((boolean, graph_id) => {\n\t\t\t\tthis.set_node_depth(graph_id);\n\t\t\t});\n\t\t});\n\t\t// const leave_ids = Object.keys(this._leaves_graph_id[this._shader_name]);\n\t\t// leave_ids.forEach((graph_id) => {\n\t\t// \tthis.set_node_depth(graph_id);\n\t\t// });\n\t}\n\n\tprivate set_node_depth(graph_id: string, depth: number = 0) {\n\t\tconst current_depth = this._depth_by_graph_id.get(graph_id);\n\t\tif (current_depth != null) {\n\t\t\tthis._depth_by_graph_id.set(graph_id, Math.max(current_depth, depth));\n\t\t} else {\n\t\t\tthis._depth_by_graph_id.set(graph_id, depth);\n\t\t}\n\n\t\t// const node = this._graph.node_from_id(graph_id);\n\n\t\tconst output_ids = this._outputs_by_graph_id.get(graph_id);\n\t\tif (output_ids) {\n\t\t\toutput_ids.forEach((output_id) => {\n\t\t\t\tthis.set_node_depth(output_id, depth + 1);\n\t\t\t});\n\t\t}\n\t}\n}\n","import {TypedGlNode} from './_Base';\n// import {ParamType} from '../../../Engine/Param/_Module';\n// import {Connection} from './GlData';\n// import {Definition} from './Definition/_Module';\n// import {ShaderName} from './Assembler/Util/CodeBuilder';\n\n// list of globals\n// https://www.khronos.org/opengl/wiki/Built-in_Variable_(GLSL)\n// gl_PointCoord\n\nimport {NodeParamsConfig} from '../utils/params/ParamsConfig';\nimport {ShadersCollectionController} from './code/utils/ShadersCollectionController';\nclass GlobalsGlParamsConfig extends NodeParamsConfig {}\nconst ParamsConfig = new GlobalsGlParamsConfig();\n\nexport class GlobalsGlNode extends TypedGlNode<GlobalsGlParamsConfig> {\n\tparams_config = ParamsConfig;\n\tstatic type() {\n\t\treturn 'globals';\n\t}\n\n\tcreate_params() {\n\t\tthis.material_node?.assembler_controller.add_globals_params(this);\n\t}\n\n\tset_lines(shaders_collection_controller: ShadersCollectionController) {\n\t\t// if (lines_controller.shader_name) {\n\t\tthis.material_node?.assembler_controller?.assembler.set_node_lines_globals(this, shaders_collection_controller);\n\t\t// }\n\t\t// const vertex_definitions = []\n\t\t// const fragment_definitions = []\n\t\t// const definitions = []\n\t\t// // const vertex_body_lines = []\n\t\t// const fragment_body_lines = []\n\t\t// const body_lines = []\n\n\t\t// const shader_config = this.shader_config(this._shader_name)\n\t\t// const dependencies = shader_config.dependencies()\n\n\t\t// const definitions_by_shader_name = {}\n\t\t// definitions_by_shader_name[this._shader_name] = []\n\t\t// for(let dependency of dependencies){ definitions_by_shader_name[dependency] = [] }\n\n\t\t// const body_lines_by_shader_name = {}\n\t\t// body_lines_by_shader_name[this._shader_name] = []\n\t\t// for(let dependency of dependencies){ body_lines_by_shader_name[dependency] = [] }\n\n\t\t// let definition\n\t\t// let body_line\n\t\t// for(let output_name of this.used_output_names()){\n\t\t// \tconst var_name = this.gl_var_name(output_name)\n\n\t\t// \tswitch (output_name){\n\t\t// \t\tcase 'frame':\n\t\t// \t\t\tdefinition = new Definition.Uniform(this, 'float', output_name)\n\t\t// \t\t\t// vertex_definitions.push(definition)\n\t\t// \t\t\t// fragment_definitions.push(definition)\n\t\t// \t\t\tdefinitions_by_shader_name[this._shader_name].push(definition)\n\n\t\t// \t\t\tbody_line = `float ${var_name} = ${output_name}`\n\t\t// \t\t\tfor(let dependency of dependencies){\n\t\t// \t\t\t\tdefinitions_by_shader_name[dependency].push(definition)\n\t\t// \t\t\t\tbody_lines_by_shader_name[dependency].push(body_line)\n\t\t// \t\t\t}\n\n\t\t// \t\t\t// vertex_body_lines.push(`float ${var_name} = ${output_name}`)\n\t\t// \t\t\tbody_lines.push(body_line)\n\t\t// \t\t\tbreak;\n\t\t// \t\tcase 'gl_FragCoord':\n\t\t// \t\t\tif( this._shader_name == ShaderName.FRAGMENT ){\n\t\t// \t\t\t\tfragment_body_lines.push(`vec4 ${var_name} = gl_FragCoord`)\n\t\t// \t\t\t}\n\t\t// \t\t\tbreak;\n\t\t// \t\tcase 'gl_PointCoord':\n\t\t// \t\t\tif( this._shader_name == ShaderName.FRAGMENT ){\n\t\t// \t\t\t\tif(this.parent().is_point_material()){\n\t\t// \t\t\t\t\tfragment_body_lines.push(`vec2 ${var_name} = gl_PointCoord`)\n\t\t// \t\t\t\t}\n\t\t// \t\t\t}\n\t\t// \t\t\tbreak;\n\t\t// \t\tdefault:\n\t\t// \t\t\tconst named_output = this.named_output_by_name(output_name)\n\t\t// \t\t\tconst gl_type = named_output.gl_type()\n\t\t// \t\t\tdefinition = new Definition.Varying(this, gl_type, var_name)\n\t\t// \t\t\tdefinitions_by_shader_name[this._shader_name].push(definition)\n\n\t\t// \t\t\tbody_line = `${var_name} = vec3(${output_name})`\n\t\t// \t\t\tfor(let dependency of dependencies){\n\t\t// \t\t\t\tdefinitions_by_shader_name[dependency].push(definition)\n\t\t// \t\t\t\tbody_lines_by_shader_name[dependency].push(body_line)\n\t\t// \t\t\t}\n\t\t// \t\t\tif(dependencies.length == 0){\n\t\t// \t\t\t\tbody_lines.push(body_line)\n\t\t// \t\t\t}\n\t\t// \t}\n\t\t// }\n\t\t// // this.set_vertex_definitions(vertex_definitions)\n\t\t// // this.set_fragment_definitions(fragment_definitions)\n\t\t// for(let shader_name of Object.keys(definitions_by_shader_name)){\n\t\t// \tthis.set_definitions(definitions_by_shader_name[shader_name], shader_name)\n\t\t// }\n\t\t// for(let shader_name of Object.keys(body_lines_by_shader_name)){\n\t\t// \tthis.add_body_lines(body_lines_by_shader_name[shader_name], shader_name)\n\t\t// }\n\t\t// // this.add_definitions(definitions)\n\t\t// // this.set_vertex_body_lines(vertex_body_lines)\n\t\t// // this.set_fragment_body_lines(fragment_body_lines)\n\n\t\t// this.add_body_lines(body_lines)\n\t}\n}\n","import {AssemblerControllerNode} from '../Controller';\n\nexport class GlNodeFinder {\n\tstatic find_output_nodes(node: AssemblerControllerNode) {\n\t\tconst nodes = node.nodes_by_type('output');\n\t\treturn nodes;\n\t\t// if (nodes.length > 1) {\n\t\t// \tnode.states.error.set('only one output node allowed');\n\t\t// }\n\t\t// return nodes[0];\n\t}\n\tstatic find_attribute_export_nodes(node: AssemblerControllerNode) {\n\t\tconst nodes = node.nodes_by_type('attribute');\n\t\treturn nodes.filter((node) => {\n\t\t\t// do not use attributes that are used as an input, as export\n\t\t\t// return (node.used_output_names().length == 0) &&\n\t\t\treturn node.is_exporting;\n\t\t});\n\t}\n}\n","import {BaseController} from './_BaseController';\nimport {Material} from 'three/src/materials/Material';\nimport {Texture} from 'three/src/textures/Texture';\nimport {FileCopNode} from '../../cop/File';\nimport {BaseMatNodeType} from '../_Base';\n\nimport {ParamConfig} from '../../utils/params/ParamsConfig';\nimport {NodeContext} from '../../../poly/NodeContext';\nimport {BaseCopNodeType} from '../../cop/_Base';\nimport {OperatorPathParam} from '../../../params/OperatorPath';\nimport {BooleanParam} from '../../../params/Boolean';\nimport {BaseNodeType} from '../../_Base';\nimport {BaseParamType} from '../../../params/_Base';\nimport {ShaderMaterial} from 'three/src/materials/ShaderMaterial';\nimport {IUniform} from 'three/src/renderers/shaders/UniformsLib';\nimport {IUniforms} from '../../../../core/geometry/Material';\n\nexport function TextureMapParamConfig<TBase extends Constructor>(Base: TBase) {\n\treturn class Mixin extends Base {\n\t\tuse_map = ParamConfig.BOOLEAN(0);\n\t\tmap = ParamConfig.OPERATOR_PATH(FileCopNode.DEFAULT_NODE_PATH.UV, {visible_if: {use_map: 1}});\n\t};\n}\n// class TextureMapMaterial<T extends string> extends Material {\n// \t[T]!: Texture | null;\n// }\n// class TextureMapParamsConfig extends TextureMapParamConfig(NodeParamsConfig) {}\n// class TextureMapMatNode extends TypedMatNode<TextureMapMaterial, TextureMapParamsConfig> {\n// \tcreate_material() {\n// \t\treturn new TextureMapMaterial();\n// \t}\n// }\n\ntype FilterFlags<Base, Condition> = {\n\t[Key in keyof Base]: Base[Key] extends Condition ? Key : never;\n};\ntype AllowedNames<Base, Condition> = FilterFlags<Base, Condition>[keyof Base];\ntype SubType<Base, Condition> = Pick<Base, AllowedNames<Base, Condition>>;\n\n// type test = FilterFlags<MeshLambertMaterial, Texture|null>\n// type test2 = AllowedNames<MeshLambertMaterial, Texture|null>\n// type test3 = SubType<MeshLambertMaterial, Texture|null>\n\nexport function BooleanParamOptions(controller_class: typeof BaseTextureMapController) {\n\treturn {\n\t\tcook: false,\n\t\tcallback: (node: BaseNodeType, param: BaseParamType) => {\n\t\t\tcontroller_class.update(node as BaseMatNodeType);\n\t\t},\n\t};\n}\nexport function OperatorPathOptions(controller: typeof BaseTextureMapController, use_map_name: string) {\n\treturn {\n\t\tvisible_if: {[use_map_name]: 1},\n\t\tnode_selection: {context: NodeContext.COP},\n\t\tcook: false,\n\t\tcallback: (node: BaseNodeType, param: BaseParamType) => {\n\t\t\tcontroller.update(node as BaseMatNodeType);\n\t\t},\n\t};\n}\n\ntype TextureUpdateCallback<O extends Object> = (\n\tmaterial: Material,\n\tobject: O,\n\tmat_attrib_name: keyof SubType<O, Texture | null>,\n\ttexture: Texture\n) => void;\ntype TextureRemoveCallback<O extends Object> = (\n\tmaterial: Material,\n\tobject: O,\n\tmat_attrib_name: keyof SubType<O, Texture | null>\n) => void;\n\ntype CurrentMaterial = Material | ShaderMaterial;\n\nexport interface UpdateOptions {\n\tdirect_params?: boolean;\n\tuniforms?: boolean;\n\tdefine?: boolean;\n}\nexport class BaseTextureMapController extends BaseController {\n\tconstructor(protected node: BaseMatNodeType, protected _update_options: UpdateOptions) {\n\t\tsuper(node);\n\t\tif (this._update_options.define == null) {\n\t\t\tthis._update_options.define = true;\n\t\t}\n\t}\n\n\tprotected add_hooks(use_map_param: BooleanParam, path_param: OperatorPathParam) {\n\t\tuse_map_param.add_post_dirty_hook('TextureController', () => {\n\t\t\tthis.update();\n\t\t});\n\t\tpath_param.add_post_dirty_hook('TextureController', () => {\n\t\t\tthis.update();\n\t\t});\n\t}\n\tstatic update(node: BaseNodeType) {}\n\n\tasync _update<M extends CurrentMaterial>(\n\t\tmaterial: M,\n\t\tmat_attrib_name: string,\n\t\tuse_map_param: BooleanParam,\n\t\tpath_param: OperatorPathParam\n\t) {\n\t\tif (this._update_options.uniforms) {\n\t\t\tconst shader_material = material as ShaderMaterial;\n\t\t\tconst attr_name = mat_attrib_name as keyof SubType<IUniforms, Texture | null>;\n\t\t\tawait this._update_texture_on_uniforms(shader_material, attr_name, use_map_param, path_param);\n\t\t}\n\t\tif (this._update_options.direct_params) {\n\t\t\tconst mat = material as Material;\n\t\t\tconst attr_name = mat_attrib_name as keyof SubType<Material, Texture | null>;\n\t\t\tawait this._update_texture_on_material(mat, attr_name, use_map_param, path_param);\n\t\t}\n\t}\n\n\t//\n\t//\n\t// FOR CASES WHERE THE TEXTURE IS ON THE UNIFORMS\n\t//\n\t//\n\tasync _update_texture_on_uniforms<O extends IUniform>(\n\t\tmaterial: ShaderMaterial,\n\t\tmat_attrib_name: keyof SubType<O, Texture | null>,\n\t\tuse_map_param: BooleanParam,\n\t\tpath_param: OperatorPathParam\n\t) {\n\t\tthis._update_required_attribute(\n\t\t\tmaterial,\n\t\t\tmaterial.uniforms,\n\t\t\tmat_attrib_name as never,\n\t\t\tuse_map_param,\n\t\t\tpath_param,\n\t\t\tthis._apply_texture_on_uniforms.bind(this),\n\t\t\tthis._remove_texture_from_uniforms.bind(this)\n\t\t);\n\t}\n\tprivate _apply_texture_on_uniforms<O extends IUniforms>(\n\t\tmaterial: Material,\n\t\tuniforms: O,\n\t\tmat_attrib_name: keyof SubType<O, Texture | null>,\n\t\ttexture: Texture\n\t) {\n\t\tconst has_texture = uniforms[mat_attrib_name] != null && uniforms[mat_attrib_name].value != null;\n\t\tlet new_texture_is_different = false;\n\t\tif (has_texture) {\n\t\t\tconst current_texture: Texture = (<unknown>uniforms[mat_attrib_name].value) as Texture;\n\t\t\tif (current_texture.uuid != texture.uuid) {\n\t\t\t\tnew_texture_is_different = true;\n\t\t\t}\n\t\t}\n\t\tif (!has_texture || new_texture_is_different) {\n\t\t\tuniforms[mat_attrib_name].value = texture as any;\n\t\t\tif (this._do_update_define()) {\n\t\t\t\tconst define_name = this._define_name(`${mat_attrib_name}`);\n\t\t\t\tmaterial.defines[define_name] = 1;\n\t\t\t}\n\t\t\tmaterial.defines['USE_UV'] = 1;\n\t\t\tmaterial.needsUpdate = true;\n\t\t}\n\t}\n\tprivate _remove_texture_from_uniforms<U extends IUniforms>(\n\t\tmaterial: Material,\n\t\tuniforms: U,\n\t\tmat_attrib_name: keyof SubType<U, Texture | null>\n\t) {\n\t\tif (uniforms[mat_attrib_name].value) {\n\t\t\tuniforms[mat_attrib_name].value = null;\n\t\t\tif (this._do_update_define()) {\n\t\t\t\tconst define_name = this._define_name(`${mat_attrib_name}`);\n\t\t\t\tdelete material.defines[define_name];\n\t\t\t}\n\t\t\tmaterial.needsUpdate = true;\n\t\t}\n\t}\n\tprivate _define_name(mat_attrib_name: string): string {\n\t\treturn 'USE_' + mat_attrib_name.replace('_', '').toUpperCase();\n\t}\n\n\t//\n\t//\n\t// FOR CASES WHERE THE TEXTURE IS ON THE MATERIAL\n\t//\n\t//\n\tasync _update_texture_on_material<M extends Material>(\n\t\tmaterial: M,\n\t\tmat_attrib_name: keyof SubType<M, Texture | null>,\n\t\tuse_map_param: BooleanParam,\n\t\tpath_param: OperatorPathParam\n\t) {\n\t\tthis._update_required_attribute(\n\t\t\tmaterial,\n\t\t\tmaterial,\n\t\t\tmat_attrib_name,\n\t\t\tuse_map_param,\n\t\t\tpath_param,\n\t\t\tthis._apply_texture_on_material.bind(this),\n\t\t\tthis._remove_texture_from_material.bind(this)\n\t\t);\n\t}\n\tprivate _apply_texture_on_material<M extends Material>(\n\t\tmaterial: Material,\n\t\ttexture_owner: M,\n\t\tmat_attrib_name: keyof SubType<M, Texture | null>,\n\t\ttexture: Texture\n\t) {\n\t\tconst has_texture = texture_owner[mat_attrib_name] != null;\n\t\tlet new_texture_is_different = false;\n\t\tif (has_texture) {\n\t\t\tconst current_texture: Texture = (<unknown>texture_owner[mat_attrib_name]) as Texture;\n\t\t\tif (current_texture.uuid != texture.uuid) {\n\t\t\t\tnew_texture_is_different = true;\n\t\t\t}\n\t\t}\n\t\tif (!has_texture || new_texture_is_different) {\n\t\t\ttexture_owner[mat_attrib_name] = texture as any;\n\t\t\tmaterial.needsUpdate = true;\n\t\t}\n\t}\n\tprivate _remove_texture_from_material<M extends Material>(\n\t\tmaterial: Material,\n\t\ttexture_owner: M,\n\t\tmat_attrib_name: keyof SubType<M, Texture | null>\n\t) {\n\t\tif (texture_owner[mat_attrib_name]) {\n\t\t\ttexture_owner[mat_attrib_name] = null as any;\n\t\t\tmaterial.needsUpdate = true;\n\t\t}\n\t}\n\n\t//\n\t//\n\t// MAIN ALGO to decide if texture should be updated\n\t//\n\t//\n\tprivate async _update_required_attribute<O extends Object>(\n\t\tmaterial: Material,\n\t\ttexture_owner: O,\n\t\tmat_attrib_name: keyof SubType<O, Texture | null>,\n\t\tuse_map_param: BooleanParam,\n\t\tpath_param: OperatorPathParam,\n\t\tupdate_callback: TextureUpdateCallback<O>,\n\t\tremove_callback: TextureRemoveCallback<O>\n\t) {\n\t\tif (use_map_param.is_dirty) {\n\t\t\tawait use_map_param.compute();\n\t\t}\n\t\tconst use_map: boolean = use_map_param.value;\n\n\t\tif (use_map) {\n\t\t\tif (path_param.is_dirty) {\n\t\t\t\tawait path_param.compute();\n\t\t\t}\n\n\t\t\tconst found_node = path_param.found_node();\n\t\t\tif (found_node) {\n\t\t\t\tif (found_node.node_context() == NodeContext.COP) {\n\t\t\t\t\tconst texture_node = found_node as BaseCopNodeType;\n\n\t\t\t\t\tconst container = await texture_node.request_container();\n\t\t\t\t\tconst texture = container.texture();\n\n\t\t\t\t\tif (texture) {\n\t\t\t\t\t\tupdate_callback(material, texture_owner, mat_attrib_name, texture);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.node.states.error.set(`found node has no texture`);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tthis.node.states.error.set(`found map node is not a COP node`);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis.node.states.error.set(`could not find map node ${path_param.name} with path ${path_param.value}`);\n\t\t\t}\n\t\t}\n\t\t// this is not wrapped in an else clause after the \"if (use_map) {\"\n\t\t// as we should come here after any of the errors above, if any is triggered\n\t\tremove_callback(material, texture_owner, mat_attrib_name);\n\t}\n\n\tprivate _do_update_define(): boolean {\n\t\tif (this._update_options.define == null) {\n\t\t\treturn true;\n\t\t}\n\t\treturn this._update_options.define;\n\t}\n}\n","import {BaseController} from './_BaseController';\nimport {TypedMatNode} from '../_Base';\nimport {Material} from 'three/src/materials/Material';\nimport {NodeParamsConfig, ParamConfig} from '../../utils/params/ParamsConfig';\nimport {IUniforms} from '../../../../core/geometry/Material';\n\nexport function ColorParamConfig<TBase extends Constructor>(Base: TBase) {\n\treturn class Mixin extends Base {\n\t\t// color = ParamConfig.COLOR([1, 1, 1]);\n\t\ttransparent = ParamConfig.BOOLEAN(0);\n\t\topacity = ParamConfig.FLOAT(1);\n\t\talpha_test = ParamConfig.FLOAT(0);\n\t\tuse_fog = ParamConfig.BOOLEAN(0);\n\t};\n}\n\nclass ColoredMaterial extends Material {\n\tvertexColors!: boolean;\n\ttransparent!: boolean;\n\tdepthTest!: boolean;\n\talphaTest!: number;\n\tfog!: boolean;\n\tuniforms!: IUniforms;\n}\nclass ColorParamsConfig extends ColorParamConfig(NodeParamsConfig) {}\n\nclass ColoredMatNode extends TypedMatNode<ColoredMaterial, ColorParamsConfig> {\n\tcreate_material() {\n\t\treturn new ColoredMaterial();\n\t}\n}\n\nexport class ColorsController extends BaseController {\n\tstatic update(node: ColoredMatNode) {\n\t\tconst material = node.material;\n\t\tconst pv = node.pv;\n\n\t\tif (material.uniforms.opacity) {\n\t\t\tmaterial.uniforms.opacity.value = pv.opacity;\n\t\t}\n\t\tmaterial.transparent = pv.transparent || pv.opacity < 1;\n\t\tmaterial.depthTest = true;\n\t\tmaterial.alphaTest = pv.alpha_test;\n\t\tmaterial.fog = pv.use_fog;\n\t}\n}\n","import {TypedMatNode} from './_Base';\nimport {GlAssemblerController} from '../gl/code/Controller';\nimport {NodeParamsConfig} from '../utils/params/ParamsConfig';\nimport {ShaderAssemblerMaterial} from '../gl/code/assemblers/materials/_BaseMaterial';\nimport {GlNodeChildrenMap} from '../../poly/registers/Gl';\nimport {BaseGlNodeType} from '../gl/_Base';\nimport {ShaderMaterialWithCustomMaterials} from '../../../core/geometry/Material';\nimport {NodeContext} from '../../poly/NodeContext';\n\nexport abstract class TypedBuilderMatNode<\n\tA extends ShaderAssemblerMaterial,\n\tK extends NodeParamsConfig\n> extends TypedMatNode<ShaderMaterialWithCustomMaterials, K> {\n\tprotected _assembler_controller: GlAssemblerController<A> | undefined;\n\tprotected _children_controller_context = NodeContext.GL;\n\tinitialize_base_node() {\n\t\tsuper.initialize_base_node();\n\n\t\tthis.lifecycle.add_on_create_hook(this.assembler_controller.on_create.bind(this.assembler_controller));\n\t\tthis.children_controller?.init();\n\t}\n\n\t//\n\t//\n\t// MATERIAL\n\t//\n\t//\n\tcreate_material() {\n\t\treturn this.assembler_controller.assembler.create_material() as ShaderMaterialWithCustomMaterials;\n\t}\n\t//\n\t//\n\t// ASSEMBLER\n\t//\n\t//\n\tget assembler_controller() {\n\t\treturn (this._assembler_controller = this._assembler_controller || this._create_assembler_controller());\n\t}\n\tprotected abstract _create_assembler_controller(): GlAssemblerController<A>;\n\n\tcreate_node<K extends keyof GlNodeChildrenMap>(type: K): GlNodeChildrenMap[K] {\n\t\treturn super.create_node(type) as GlNodeChildrenMap[K];\n\t}\n\tchildren() {\n\t\treturn super.children() as BaseGlNodeType[];\n\t}\n\tnodes_by_type<K extends keyof GlNodeChildrenMap>(type: K): GlNodeChildrenMap[K][] {\n\t\treturn super.nodes_by_type(type) as GlNodeChildrenMap[K][];\n\t}\n\n\t//\n\t//\n\t// COMPILATION\n\t//\n\t//\n\tasync compile_if_required() {\n\t\tif (this.assembler_controller.compile_required()) {\n\t\t\tthis._compile();\n\t\t}\n\t}\n\tprotected async _compile() {\n\t\tif (this.material) {\n\t\t\tawait this.assembler_controller.assembler.compile_material(this.material);\n\t\t\tawait this.assembler_controller.post_compile();\n\t\t}\n\t}\n}\n\nexport type BaseBuilderMatNodeType = TypedBuilderMatNode<ShaderAssemblerMaterial, NodeParamsConfig>;\n","export default \"uniform float mNear;\\nuniform float mFar;\\n\\nvarying float vViewZDepth;\\n\\nvoid main() {\\n\\n\\tfloat color = 1.0 - smoothstep( mNear, mFar, vViewZDepth );\\n\\tgl_FragColor = vec4( vec3( color ), 1.0 );\\n\\n}\\n\"","export class TranspiledFilter {\n\tstatic filter(transpiled_javascript: string) {\n\t\tconst lines = transpiled_javascript.split('\\n');\n\t\tconst filtered_lines: string[] = [];\n\t\tfor (let line of lines) {\n\t\t\tif (!line.match(/import {.*} from '.*'/)) {\n\t\t\t\tline = line.replace('export ', 'return ');\n\t\t\t\tfiltered_lines.push(line);\n\t\t\t}\n\t\t}\n\t\treturn filtered_lines.join('\\n');\n\t}\n}\n","import {TypedGlNode} from './_Base';\nimport {ThreeToGl} from '../../../core/ThreeToGl';\n\nimport {ConnectionPointType, ConnectionPointTypes} from '../utils/connections/ConnectionPointType';\n\nfunction typed_visible_options(type: ConnectionPointType) {\n\tconst val = ConnectionPointTypes.indexOf(type);\n\treturn {visible_if: {type: val}};\n}\n\nimport {BaseParamType} from '../../params/_Base';\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nimport {ShadersCollectionController} from './code/utils/ShadersCollectionController';\nimport {GlConnectionsController} from './utils/ConnectionsController';\n\nclass ConstantGlParamsConfig extends NodeParamsConfig {\n\ttype = ParamConfig.INTEGER(ConnectionPointTypes.indexOf(ConnectionPointType.FLOAT), {\n\t\tmenu: {\n\t\t\tentries: ConnectionPointTypes.map((name, i) => {\n\t\t\t\treturn {name: name, value: i};\n\t\t\t}),\n\t\t},\n\t});\n\tbool = ParamConfig.BOOLEAN(0, typed_visible_options(ConnectionPointType.BOOL));\n\tint = ParamConfig.INTEGER(0, typed_visible_options(ConnectionPointType.INT));\n\tfloat = ParamConfig.FLOAT(0, typed_visible_options(ConnectionPointType.FLOAT));\n\tvec2 = ParamConfig.VECTOR2([0, 0], typed_visible_options(ConnectionPointType.VEC2));\n\tvec3 = ParamConfig.VECTOR3([0, 0, 0], typed_visible_options(ConnectionPointType.VEC3));\n\tvec4 = ParamConfig.VECTOR4([0, 0, 0, 0], typed_visible_options(ConnectionPointType.VEC4));\n}\nconst ParamsConfig = new ConstantGlParamsConfig();\nexport class ConstantGlNode extends TypedGlNode<ConstantGlParamsConfig> {\n\tparams_config = ParamsConfig;\n\tstatic type() {\n\t\treturn 'constant';\n\t}\n\tstatic readonly OUTPUT_NAME = 'val';\n\tprivate _params_by_type: Map<ConnectionPointType, BaseParamType> | undefined;\n\tpublic readonly gl_connections_controller: GlConnectionsController = new GlConnectionsController(this);\n\tprotected _allow_inputs_created_from_params: boolean = false;\n\t// private _update_signature_if_required_bound = this._update_signature_if_required.bind(this);\n\tinitialize_node() {\n\t\tthis.gl_connections_controller.initialize_node();\n\n\t\tthis.gl_connections_controller.set_output_name_function((index: number) => ConstantGlNode.OUTPUT_NAME);\n\t\tthis.gl_connections_controller.set_expected_input_types_function(() => []);\n\t\tthis.gl_connections_controller.set_expected_output_types_function(() => [this._current_connection_type]);\n\t\t// this.params.add_on_scene_load_hook('_update_signature_if_required', this._update_signature_if_required_bound);\n\t\t// this.params.set_post_create_params_hook(this._update_signature_if_required_bound);\n\t\t// this.add_post_dirty_hook('_update_signature_if_required', this._update_signature_if_required_bound);\n\t}\n\t// _update_signature_if_required(dirty_trigger?: CoreGraphNode) {\n\t// \tif (!this.lifecycle.creation_completed || dirty_trigger == this.p.type) {\n\t// \t\tthis.update_output_type();\n\t// \t\tthis.remove_dirty_state();\n\t// \t\tthis.make_output_nodes_dirty();\n\t// \t}\n\t// }\n\n\tset_lines(shaders_collection_controller: ShadersCollectionController) {\n\t\tconst param = this._current_param;\n\t\tif (param) {\n\t\t\tconst connection_type = this._current_connection_type;\n\t\t\tconst value = ThreeToGl.any(param.value);\n\t\t\tconst var_value = this._current_var_name;\n\t\t\tconst body_line = `${connection_type} ${var_value} = ${value}`;\n\t\t\tshaders_collection_controller.add_body_lines(this, [body_line]);\n\t\t} else {\n\t\t\tconsole.warn(`no param found for constant node for type '${this.pv.type}'`);\n\t\t}\n\t}\n\n\tprivate get _current_connection_type() {\n\t\tif (this.pv.type == null) {\n\t\t\tconsole.warn('constant gl node type if not valid');\n\t\t}\n\t\tconst connection_type = ConnectionPointTypes[this.pv.type];\n\t\tif (connection_type == null) {\n\t\t\tconsole.warn('constant gl node type if not valid');\n\t\t}\n\t\treturn connection_type;\n\t}\n\n\tprivate get _current_param(): BaseParamType {\n\t\tthis._params_by_type =\n\t\t\tthis._params_by_type ||\n\t\t\tnew Map<ConnectionPointType, BaseParamType>([\n\t\t\t\t[ConnectionPointType.BOOL, this.p.bool],\n\t\t\t\t[ConnectionPointType.INT, this.p.int],\n\t\t\t\t[ConnectionPointType.FLOAT, this.p.float],\n\t\t\t\t[ConnectionPointType.VEC2, this.p.vec2],\n\t\t\t\t[ConnectionPointType.VEC3, this.p.vec3],\n\t\t\t\t[ConnectionPointType.VEC4, this.p.vec4],\n\t\t\t]);\n\t\tconst connection_type = ConnectionPointTypes[this.pv.type];\n\t\treturn this._params_by_type.get(connection_type)!;\n\t}\n\tprivate get _current_var_name(): string {\n\t\treturn this.gl_var_name(ConstantGlNode.OUTPUT_NAME);\n\t}\n\n\t// private update_output_type() {\n\t// \tconst set_dirty = false;\n\t// \tconst current_connection = this.io.outputs.named_output_connection_points[0];\n\t// \tif (current_connection && current_connection.type == this._current_connection_type) {\n\t// \t\treturn;\n\t// \t}\n\t// \tthis.io.outputs.set_named_output_connection_points(\n\t// \t\t[new TypedNamedConnectionPoint(this._current_connection_type, this._current_connection_type)],\n\t// \t\tset_dirty\n\t// \t);\n\t// }\n}\n","import {UniformsUtils} from 'three/src/renderers/shaders/UniformsUtils';\nimport {ShaderMaterial} from 'three/src/materials/ShaderMaterial';\nimport {ShaderLib} from 'three/src/renderers/shaders/ShaderLib';\nimport {RGBADepthPacking} from 'three/src/constants';\nimport {BasicDepthPacking} from 'three/src/constants';\n\nimport {ShaderAssemblerMaterial} from './_BaseMaterial';\n\nimport TemplateVertex from '../../templates/CustomPointsDepth.vert.glsl';\nimport {ShaderName} from '../../../../utils/shaders/ShaderName';\n\nconst INSERT_DEFINE_AFTER_MAP: Map<ShaderName, string> = new Map([[ShaderName.VERTEX, '// INSERT DEFINES']]);\nconst INSERT_BODY_AFTER_MAP: Map<ShaderName, string> = new Map([[ShaderName.VERTEX, '// INSERT BODY']]);\n\nexport class ShaderAssemblerCustomPointsDepth extends ShaderAssemblerMaterial {\n\t// _color_declaration() { return 'vec4 diffuseColor' }\n\t// _template_shader(){ return ShaderLib.standard }\n\tget _template_shader() {\n\t\tconst template = ShaderLib.depth;\n\n\t\tconst uniforms = UniformsUtils.clone(template.uniforms);\n\t\tuniforms['size'] = {value: 1};\n\t\tuniforms['scale'] = {value: 1};\n\n\t\treturn {\n\t\t\tvertexShader: TemplateVertex,\n\t\t\tfragmentShader: template.fragmentShader, //TemplateFragment,\n\t\t\tuniforms: uniforms,\n\t\t};\n\t}\n\tprotected insert_define_after(shader_name: ShaderName) {\n\t\treturn INSERT_DEFINE_AFTER_MAP.get(shader_name);\n\t}\n\tprotected insert_body_after(shader_name: ShaderName) {\n\t\treturn INSERT_BODY_AFTER_MAP.get(shader_name);\n\t}\n\n\tcreate_material() {\n\t\tconst template_shader = this._template_shader;\n\t\treturn new ShaderMaterial({\n\t\t\t// vertexColors: VertexColors,\n\t\t\t// side: FrontSide,\n\t\t\t// transparent: true,\n\t\t\t// fog: true,\n\t\t\t// lights: true,\n\t\t\tdefines: {\n\t\t\t\tUSE_SIZEATTENUATION: 1,\n\t\t\t\tDEPTH_PACKING: [RGBADepthPacking, BasicDepthPacking][0],\n\t\t\t},\n\n\t\t\tuniforms: UniformsUtils.clone(template_shader.uniforms),\n\t\t\tvertexShader: template_shader.vertexShader,\n\t\t\tfragmentShader: template_shader.fragmentShader,\n\t\t});\n\t}\n}\n","export default \"uniform float size;\\nuniform float scale;\\n#include <common>\\n#include <clipping_planes_pars_vertex>\\nvarying float vViewZDepth;\\n\\n// INSERT DEFINES\\n\\n\\n\\nvoid main() {\\n\\n\\t// INSERT BODY\\n\\n\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\n\\tvViewZDepth = - mvPosition.z;\\n\\t#ifdef USE_SIZEATTENUATION\\n\\t\\tbool isPerspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 );\\n\\t\\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\\n\\t#endif\\n\\n}\\n\\n\\n\"","import {UniformsUtils} from 'three/src/renderers/shaders/UniformsUtils';\nimport {ShaderMaterial} from 'three/src/materials/ShaderMaterial';\nimport {ShaderLib} from 'three/src/renderers/shaders/ShaderLib';\nimport {RGBADepthPacking} from 'three/src/constants';\nimport {BasicDepthPacking} from 'three/src/constants';\n\nimport {ShaderAssemblerMaterial} from './_BaseMaterial';\n\nimport TemplateVertex from '../../templates/CustomPointsDistance.vert.glsl';\n\nimport {ShaderName} from '../../../../utils/shaders/ShaderName';\n\nconst INSERT_DEFINE_AFTER_MAP: Map<ShaderName, string> = new Map([[ShaderName.VERTEX, '// INSERT DEFINES']]);\nconst INSERT_BODY_AFTER_MAP: Map<ShaderName, string> = new Map([[ShaderName.VERTEX, '// INSERT BODY']]);\n\nexport class ShaderAssemblerCustomPointsDistance extends ShaderAssemblerMaterial {\n\t// _color_declaration() { return 'vec4 diffuseColor' }\n\t// _template_shader(){ return ShaderLib.standard }\n\tget _template_shader() {\n\t\tconst template = ShaderLib.distanceRGBA;\n\n\t\tconst uniforms = UniformsUtils.clone(template.uniforms);\n\t\tuniforms['size'] = {value: 1};\n\t\tuniforms['scale'] = {value: 1};\n\n\t\treturn {\n\t\t\tvertexShader: TemplateVertex,\n\t\t\tfragmentShader: template.fragmentShader, //TemplateFragment,\n\t\t\tuniforms: uniforms,\n\t\t};\n\t}\n\tprotected insert_define_after(shader_name: ShaderName) {\n\t\treturn INSERT_DEFINE_AFTER_MAP.get(shader_name);\n\t}\n\tprotected insert_body_after(shader_name: ShaderName) {\n\t\treturn INSERT_BODY_AFTER_MAP.get(shader_name);\n\t}\n\n\tcreate_material() {\n\t\tconst template_shader = this._template_shader;\n\t\treturn new ShaderMaterial({\n\t\t\t// vertexColors: VertexColors,\n\t\t\t// side: FrontSide,\n\t\t\t// transparent: true,\n\t\t\t// fog: true,\n\t\t\t// lights: true,\n\t\t\tdefines: {\n\t\t\t\tUSE_SIZEATTENUATION: 1,\n\t\t\t\tDEPTH_PACKING: [RGBADepthPacking, BasicDepthPacking][0],\n\t\t\t},\n\n\t\t\tuniforms: UniformsUtils.clone(template_shader.uniforms),\n\t\t\tvertexShader: template_shader.vertexShader,\n\t\t\tfragmentShader: template_shader.fragmentShader,\n\t\t});\n\t}\n}\n","export default \"uniform float size;\\nuniform float scale;\\n#define DISTANCE\\nvarying vec3 vWorldPosition;\\n#include <common>\\n#include <clipping_planes_pars_vertex>\\nvarying float vViewZDepth;\\n\\n// INSERT DEFINES\\n\\n\\n\\nvoid main() {\\n\\n\\t// INSERT BODY\\n\\n\\n\\t#include <project_vertex>\\n\\t#include <worldpos_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\n\\t#ifdef USE_SIZEATTENUATION\\n\\t\\tbool isPerspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 );\\n\\t\\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\\n\\t#endif\\n\\tvWorldPosition = worldPosition.xyz;\\n}\\n\\n// #define DISTANCE\\n// varying vec3 vWorldPosition;\\n// #include <common>\\n// #include <uv_pars_vertex>\\n// #include <displacementmap_pars_vertex>\\n// #include <morphtarget_pars_vertex>\\n// #include <skinning_pars_vertex>\\n// #include <clipping_planes_pars_vertex>\\n// void main() {\\n// \\t#include <uv_vertex>\\n// \\t#include <skinbase_vertex>\\n// \\t#ifdef USE_DISPLACEMENTMAP\\n// \\t\\t#include <beginnormal_vertex>\\n// \\t\\t#include <morphnormal_vertex>\\n// \\t\\t#include <skinnormal_vertex>\\n// \\t#endif\\n// \\t#include <begin_vertex>\\n// \\t#include <morphtarget_vertex>\\n// \\t#include <skinning_vertex>\\n// \\t#include <displacementmap_vertex>\\n// \\t#include <project_vertex>\\n// \\t#include <worldpos_vertex>\\n// \\t#include <clipping_planes_vertex>\\n// \\tvWorldPosition = worldPosition.xyz;\\n// }\\n\\n\\n\"","export default \"uniform float size;\\nuniform float scale;\\n#include <common>\\n\\nvarying float vViewZDepth;\\n\\n// INSERT DEFINES\\n\\n\\n\\nvoid main() {\\n\\n\\t// INSERT BODY\\n\\n\\n\\t#include <project_vertex>\\n\\n\\tvViewZDepth = - mvPosition.z;\\n\\t#ifdef USE_SIZEATTENUATION\\n\\t\\tbool isPerspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 );\\n\\t\\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\\n\\t#endif\\n\\n}\\n\\n\"","import {UniformsUtils} from 'three/src/renderers/shaders/UniformsUtils';\nimport {ShaderMaterial} from 'three/src/materials/ShaderMaterial';\n// import {ShaderLib} from 'three/src/renderers/shaders/ShaderLib'\n// import {RGBADepthPacking} from 'three/src/constants'\n// import {BasicDepthPacking} from 'three/src/constants'\n\nimport {ShaderAssemblerMaterial} from './_BaseMaterial';\n\nimport TemplateVertex from '../../templates/CustomPointsDepthDOF.vert.glsl';\nimport TemplateFragment from '../../templates/CustomMeshDepthDOF.frag.glsl';\nimport {ShaderName} from '../../../../utils/shaders/ShaderName';\n\nconst INSERT_DEFINE_AFTER_MAP: Map<ShaderName, string> = new Map([[ShaderName.VERTEX, '// INSERT DEFINES']]);\nconst INSERT_BODY_AFTER_MAP: Map<ShaderName, string> = new Map([[ShaderName.VERTEX, '// INSERT BODY']]);\n\nexport class ShaderAssemblerCustomPointsDepthDOF extends ShaderAssemblerMaterial {\n\t// _color_declaration() { return 'vec4 diffuseColor' }\n\t// _template_shader(){ return ShaderLib.standard }\n\tget _template_shader() {\n\t\treturn {\n\t\t\tvertexShader: TemplateVertex,\n\t\t\tfragmentShader: TemplateFragment,\n\t\t\tuniforms: {\n\t\t\t\tsize: {value: 1},\n\t\t\t\tscale: {value: 1},\n\t\t\t\tmNear: {value: 0},\n\t\t\t\tmFar: {value: 10},\n\t\t\t},\n\t\t};\n\t}\n\tprotected insert_define_after(shader_name: ShaderName) {\n\t\treturn INSERT_DEFINE_AFTER_MAP.get(shader_name);\n\t}\n\tprotected insert_body_after(shader_name: ShaderName) {\n\t\treturn INSERT_BODY_AFTER_MAP.get(shader_name);\n\t}\n\n\tcreate_material() {\n\t\tconst template_shader = this._template_shader;\n\t\treturn new ShaderMaterial({\n\t\t\t// defines: {\n\t\t\t// \tDEPTH_PACKING: [RGBADepthPacking, BasicDepthPacking][0]\n\t\t\t// },\n\t\t\tdepthTest: true,\n\t\t\tdefines: {\n\t\t\t\tUSE_SIZEATTENUATION: 1,\n\t\t\t},\n\n\t\t\tuniforms: UniformsUtils.clone(template_shader.uniforms),\n\t\t\tvertexShader: template_shader.vertexShader,\n\t\t\tfragmentShader: template_shader.fragmentShader,\n\t\t});\n\t}\n}\n","import {UniformsUtils} from 'three/src/renderers/shaders/UniformsUtils';\nimport {ShaderMaterial} from 'three/src/materials/ShaderMaterial';\nimport {ShaderLib} from 'three/src/renderers/shaders/ShaderLib';\n\nimport {ShaderAssemblerMaterial, CustomAssemblerMap, CustomMaterialName} from './_BaseMaterial';\n\nimport {ShaderConfig} from '../../configs/ShaderConfig';\nimport {VariableConfig} from '../../configs/VariableConfig';\n\nimport {BaseGlShaderAssembler} from '../_Base';\nimport {ShaderAssemblerCustomPointsDepth} from './CustomPointsDepth';\nimport {ShaderAssemblerCustomPointsDistance} from './CustomPointsDistance';\nimport {ShaderAssemblerCustomPointsDepthDOF} from './CustomPointsDepthDOF';\nimport {OutputGlNode} from '../../../Output';\nimport {ParamType} from '../../../../../poly/ParamType';\nimport {TypedNamedConnectionPoint} from '../../../../utils/connections/NamedConnectionPoint';\nimport {ConnectionPointType} from '../../../../utils/connections/ConnectionPointType';\nimport {ShaderName} from '../../../../utils/shaders/ShaderName';\n\nconst LINES_TO_REMOVE_MAP: Map<ShaderName, string[]> = new Map([\n\t[ShaderName.VERTEX, ['#include <begin_vertex>', 'gl_PointSize = size;']],\n\t[ShaderName.FRAGMENT, []],\n]);\n\nconst CUSTOM_ASSEMBLER_MAP: CustomAssemblerMap = new Map();\nCUSTOM_ASSEMBLER_MAP.set(CustomMaterialName.DISTANCE, ShaderAssemblerCustomPointsDistance);\nCUSTOM_ASSEMBLER_MAP.set(CustomMaterialName.DEPTH, ShaderAssemblerCustomPointsDepth);\nCUSTOM_ASSEMBLER_MAP.set(CustomMaterialName.DEPTH_DOF, ShaderAssemblerCustomPointsDepthDOF);\n\nexport class ShaderAssemblerPoints extends ShaderAssemblerMaterial {\n\t// _color_declaration() { return 'diffuseColor' }\n\tcustom_assembler_class_by_custom_name(): CustomAssemblerMap {\n\t\treturn CUSTOM_ASSEMBLER_MAP;\n\t}\n\n\tget _template_shader() {\n\t\tconst template = ShaderLib.points;\n\t\treturn {\n\t\t\tvertexShader: template.vertexShader, //TemplateVertex,\n\t\t\tfragmentShader: template.fragmentShader, //TemplateFragment,\n\t\t\tuniforms: template.uniforms,\n\t\t};\n\t}\n\tcreate_material() {\n\t\tconst template_shader = this._template_shader;\n\n\t\t// const uniforms = UniformsUtils.clone( template_shader.uniforms )\n\t\t// uniforms.size.value = 10\n\n\t\tconst material = new ShaderMaterial({\n\t\t\ttransparent: true,\n\t\t\tfog: true,\n\n\t\t\t// size: 10,\n\t\t\t// //blending: AdditiveBlending\n\t\t\t// depthTest: true,\n\t\t\t// depthwrite: true,\n\t\t\t// alphaTest: 0.5,\n\t\t\tdefines: {\n\t\t\t\t// ALPHATEST: 0.5,\n\t\t\t\tUSE_SIZEATTENUATION: 1,\n\t\t\t},\n\n\t\t\tuniforms: UniformsUtils.clone(template_shader.uniforms),\n\t\t\tvertexShader: template_shader.vertexShader,\n\t\t\tfragmentShader: template_shader.fragmentShader,\n\t\t});\n\t\tthis._add_custom_materials(material);\n\t\treturn material;\n\t}\n\t// protected insert_body_after(shader_name){\n\t// \treturn {\n\t// \t\tvertex: 'gl_PointSize = size;',\n\t// \t\tfragment: 'vec4 diffuseColor = vec4( diffuse, opacity );'\n\t// \t}[shader_name]\n\t// }\n\t// those shadow shaders should ideally be overriden\n\t// to properly take into account point size\n\n\tadd_output_params(output_child: OutputGlNode) {\n\t\tBaseGlShaderAssembler.add_output_params(output_child);\n\t\toutput_child.add_param(ParamType.FLOAT, 'gl_PointSize', 1);\n\t}\n\tcreate_globals_node_output_connections() {\n\t\treturn BaseGlShaderAssembler.create_globals_node_output_connections().concat([\n\t\t\tnew TypedNamedConnectionPoint('gl_PointCoord', ConnectionPointType.VEC2),\n\t\t]);\n\t}\n\n\t// add_globals_params(globals_node){\n\t// \tBaseShaderAssembler.add_globals_params(globals_node)\n\t// \tglobals_node.set_named_outputs([\n\t// \t\tnew Connection.Vec3('position'),\n\t// \t\tnew Connection.Vec3('color'),\n\t// \t\tnew Connection.Vec3('normal'),\n\t// \t\tnew Connection.Vec4('gl_FragCoord'),\n\t// \t\tnew Connection.Vec2('gl_PointCoord'),\n\t// \t\t// new TypedConnectionVec2('uv'),\n\t// \t\tnew Connection.Float('frame')\n\t// \t])\n\t// }\n\tcreate_shader_configs() {\n\t\treturn [\n\t\t\tnew ShaderConfig(ShaderName.VERTEX, ['position', 'normal', 'uv', 'gl_PointSize'], []),\n\t\t\tnew ShaderConfig(ShaderName.FRAGMENT, ['color', 'alpha'], [ShaderName.VERTEX]),\n\t\t];\n\t}\n\tcreate_variable_configs() {\n\t\treturn BaseGlShaderAssembler.create_variable_configs().concat([\n\t\t\tnew VariableConfig('gl_PointSize', {\n\t\t\t\tdefault: '1.0',\n\t\t\t\tprefix: 'gl_PointSize = ',\n\t\t\t\tsuffix: ' * size * 10.0', // currently using 10 as 1 seems really small\n\t\t\t}),\n\t\t]);\n\t\t// \tnew VariableConfig('position', {\n\t\t// \t\tdefault_from_attribute: true,\n\t\t// \t\t// default: this.globals_handler().variable_config_default('position'),\n\t\t// \t\t// required_definitions: this.globals_handler().variable_config_required_definitions('position'),\n\t\t// \t\tprefix: 'vec3 transformed = '\n\t\t// \t}),\n\t\t// \tnew VariableConfig('normal', {\n\t\t// \t\tprefix: 'objectNormal = '\n\t\t// \t}),\n\t\t// \tnew VariableConfig('color', {\n\t\t// \t\tprefix: 'diffuseColor.xyz = '\n\t\t// \t}),\n\t\t// \tnew VariableConfig('alpha', {\n\t\t// \t\tprefix: 'diffuseColor.w = '\n\t\t// \t}),\n\t\t// \tnew VariableConfig('uv', {\n\t\t// \t\tdefault_from_attribute: true,\n\t\t// \t\tprefix: 'vUv = ',\n\t\t// \t\tif: 'defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )'\n\t\t// \t}),\n\t\t// \tnew VariableConfig('gl_PointSize', {\n\t\t// \t\tdefault: '1.0',\n\t\t// \t\tprefix: 'gl_PointSize = ',\n\t\t// \t\tsuffix: ' * size',\n\t\t// \t}),\n\t\t// ]\n\t}\n\tprotected lines_to_remove(shader_name: ShaderName) {\n\t\treturn LINES_TO_REMOVE_MAP.get(shader_name);\n\t}\n}\n","import {NodeParamsConfig} from '../utils/params/ParamsConfig';\nimport {ColorParamConfig, ColorsController} from './utils/UniformsColorsController';\nimport {SideParamConfig, SideController} from './utils/SideController';\nimport {SkinningParamConfig, SkinningController} from './utils/SkinningController';\nimport {TextureMapParamConfig} from './utils/TextureMapController';\nimport {TextureAlphaMapParamConfig} from './utils/TextureAlphaMapController';\nimport {ShaderAssemblerPoints} from '../gl/code/assemblers/materials/Points';\nimport {TypedBuilderMatNode} from './_BaseBuilder';\nimport {GlAssemblerController} from '../gl/code/Controller';\nclass PointsMatParamsConfig extends TextureAlphaMapParamConfig(\n\tTextureMapParamConfig(SkinningParamConfig(SideParamConfig(ColorParamConfig(NodeParamsConfig))))\n) {}\nconst ParamsConfig = new PointsMatParamsConfig();\n\nexport class PointsBuilderMatNode extends TypedBuilderMatNode<ShaderAssemblerPoints, PointsMatParamsConfig> {\n\tparams_config = ParamsConfig;\n\tstatic type() {\n\t\treturn 'points_builder';\n\t}\n\n\tinitialize_node() {}\n\n\tprotected _create_assembler_controller() {\n\t\treturn new GlAssemblerController<ShaderAssemblerPoints>(this, ShaderAssemblerPoints);\n\t}\n\n\tasync cook() {\n\t\tawait this.compile_if_required();\n\n\t\tColorsController.update(this);\n\t\tSideController.update(this);\n\t\tSkinningController.update(this);\n\n\t\tthis.set_material(this.material);\n\t}\n}\n","// import {VertexColors} from 'three/src/constants'\nimport {SkinnedMesh} from 'three/src/objects/SkinnedMesh';\nimport {Scene} from 'three/src/scenes/Scene';\nimport {Points} from 'three/src/objects/Points';\nimport {Object3D} from 'three/src/core/Object3D';\n// import {NoColors} from 'three/src/constants';\nimport {Mesh} from 'three/src/objects/Mesh';\nimport {LineSegments} from 'three/src/objects/LineSegments';\nimport {Group} from 'three/src/objects/Group';\nimport {FrontSide} from 'three/src/constants';\n// import {DoubleSide} from 'three/src/constants'\nimport {Color} from 'three/src/math/Color';\nimport {Bone} from 'three/src/objects/Bone';\n// import {AdditiveBlending} from 'three/src/constants'\nimport {Material} from 'three/src/materials/Material';\nimport {PointsMaterial} from 'three/src/materials/PointsMaterial';\nimport {MeshStandardMaterial} from 'three/src/materials/MeshStandardMaterial';\nimport {MeshLambertMaterial} from 'three/src/materials/MeshLambertMaterial';\nimport {LineBasicMaterial} from 'three/src/materials/LineBasicMaterial';\n// const THREE = {AdditiveBlending, Bone, Color, DoubleSide, FrontSide, Group, LineBasicMaterial, LineSegments, Mesh, MeshLambertMaterial, MeshStandardMaterial, NoColors, Object3D, Points, PointsMaterial, Scene, SkinnedMesh, VertexColors}\n\ninterface MaterialsByString {\n\t[propName: string]: Material;\n}\n\n// export enum AttribClass {\n// \tVERTEX = \"vertex\",\n// \tOBJECT = \"object\"\n// }\n// materials['MeshStandard'] = new MeshStandardMaterial({\n// \tcolor: 0xffffff,\n// \t//vertexColors: VertexColors\n// \tside: FrontSide, // DoubleSide\n// \tmetalness: 0.5,\n// \troughness: 0.9\n// })\n// materials[Mesh.name] = new MeshLambertMaterial({ // MeshStandardMaterial\n// \tcolor: new Color(0.5,0.5,1),\n// \tside: FrontSide,\n// \tvertexColors: NoColors,\n// \ttransparent: true,\n// \tdepthTest: true\n// })\n// materials[Points.name] = new PointsMaterial({\n// \tcolor: 0xffffff,\n// \tsize: 0.1,\n// \t//blending: AdditiveBlending\n// \tdepthTest: true\n// })\n// materials[LineSegments.name] = new LineBasicMaterial({\n// \tcolor: 0xffffff,\n// \tlinewidth: 1\n// })\nexport enum ObjectType {\n\tMESH = 'MESH',\n\tPOINTS = 'POINTS',\n\tLINE_SEGMENTS = 'LINE_SEGMENTS',\n}\nexport const ObjectTypes = [ObjectType.MESH, ObjectType.POINTS, ObjectType.LINE_SEGMENTS];\nexport const ObjectTypeMenuEntries = [\n\t{name: 'Mesh', value: ObjectTypes.indexOf(ObjectType.MESH)},\n\t{name: 'Points', value: ObjectTypes.indexOf(ObjectType.POINTS)},\n\t{name: 'LineSegments', value: ObjectTypes.indexOf(ObjectType.LINE_SEGMENTS)},\n];\n\nexport function ObjectTypeByObject(object: Object3D): ObjectType | undefined {\n\tif (object instanceof Mesh) {\n\t\treturn ObjectType.MESH;\n\t}\n\tif (object instanceof LineSegments) {\n\t\treturn ObjectType.LINE_SEGMENTS;\n\t}\n\tif (object instanceof Points) {\n\t\treturn ObjectType.POINTS;\n\t}\n\tconsole.warn('ObjectTypeByObject received an unknown object type', object);\n}\n\nconst materials: MaterialsByString = {\n\tMeshStandard: new MeshStandardMaterial({\n\t\tcolor: 0xffffff,\n\t\t//vertexColors: VertexColors\n\t\tside: FrontSide, // DoubleSide\n\t\tmetalness: 0.5,\n\t\troughness: 0.9,\n\t}),\n\t[ObjectType.MESH]: new MeshLambertMaterial({\n\t\t// MeshStandardMaterial\n\t\tcolor: new Color(0.5, 0.5, 1),\n\t\tside: FrontSide,\n\t\tvertexColors: false,\n\t\ttransparent: true,\n\t\tdepthTest: true,\n\t}),\n\t[ObjectType.POINTS]: new PointsMaterial({\n\t\tcolor: 0xffffff,\n\t\tsize: 0.1,\n\t\t//blending: AdditiveBlending\n\t\tdepthTest: true,\n\t}),\n\t[ObjectType.LINE_SEGMENTS]: new LineBasicMaterial({\n\t\tcolor: 0xffffff,\n\t\tlinewidth: 1,\n\t}),\n};\n\n// TODO: typescript: check that this works after using uglifier\n\nexport enum AttribClass {\n\tVERTEX = 0,\n\tOBJECT = 1,\n}\n\nexport const AttribClassMenuEntries = [\n\t{name: 'vertex', value: AttribClass.VERTEX},\n\t{name: 'object', value: AttribClass.OBJECT},\n];\n\nexport enum AttribType {\n\tNUMERIC = 0,\n\tSTRING = 1,\n}\nexport const AttribTypeMenuEntries = [\n\t{name: 'numeric', value: AttribType.NUMERIC},\n\t{name: 'string', value: AttribType.STRING},\n];\n\nexport const CoreConstant = {\n\tATTRIB_CLASS: {\n\t\tVERTEX: AttribClass.VERTEX,\n\t\tOBJECT: AttribClass.OBJECT,\n\t},\n\n\tATTRIB_TYPE: {\n\t\tNUMERIC: 0,\n\t\tSTRING: 1,\n\t},\n\n\tOBJECT_TYPE: {\n\t\t// TODO: typescript\n\t\tMESH: ObjectType.MESH,\n\t\tPOINTS: ObjectType.POINTS,\n\t\tLINE_SEGMENTS: ObjectType.LINE_SEGMENTS,\n\t},\n\tOBJECT_TYPES: ObjectTypes,\n\tCONSTRUCTOR_NAMES_BY_CONSTRUCTOR_NAME: {\n\t\t[Scene.name]: 'Scene',\n\t\t[Group.name]: 'Group',\n\t\t[Object3D.name]: 'Object3D',\n\t\t[Mesh.name]: 'Mesh',\n\t\t[Points.name]: 'Points',\n\t\t[LineSegments.name]: 'LineSegments',\n\t\t[Bone.name]: 'Bone',\n\t\t[SkinnedMesh.name]: 'SkinnedMesh',\n\t},\n\tCONSTRUCTORS_BY_NAME: {\n\t\t[ObjectType.MESH]: Mesh,\n\t\t[ObjectType.POINTS]: Points,\n\t\t[ObjectType.LINE_SEGMENTS]: LineSegments,\n\t},\n\t// CONSTRUCTORS_BY_TYPE: {\n\t// \t['MESH']: Mesh,\n\t// \t['POINTS']: Points,\n\t// \t['LINE_SEGMENTS']: LineSegments,\n\t// },\n\t// OBJECT_TYPE_BY_CONSTRUCTOR_NAME: {\n\t// \t[Mesh.name]: 'MESH',\n\t// \t[Points.name]: 'POINTS',\n\t// \t[LineSegments.name]: 'LINE_SEGMENTS',\n\t// },\n\tMATERIALS: materials,\n};\n\n// CoreConstant.CONSTRUCTOR_NAMES_BY_CONSTRUCTOR_NAME[Scene.name] = 'Scene'\n// CoreConstant.CONSTRUCTOR_NAMES_BY_CONSTRUCTOR_NAME[Group.name] = 'Group'\n// CoreConstant.CONSTRUCTOR_NAMES_BY_CONSTRUCTOR_NAME[Object3D.name] = 'Object3D'\n// CoreConstant.CONSTRUCTOR_NAMES_BY_CONSTRUCTOR_NAME[Mesh.name] = 'Mesh'\n// CoreConstant.CONSTRUCTOR_NAMES_BY_CONSTRUCTOR_NAME[Points.name] = 'Points'\n// CoreConstant.CONSTRUCTOR_NAMES_BY_CONSTRUCTOR_NAME[LineSegments.name] = 'LineSegments'\n// CoreConstant.CONSTRUCTOR_NAMES_BY_CONSTRUCTOR_NAME[Bone.name] = 'Bone'\n// CoreConstant.CONSTRUCTOR_NAMES_BY_CONSTRUCTOR_NAME[SkinnedMesh.name] = 'SkinnedMesh'\n\n// CoreConstant.CONSTRUCTORS_BY_NAME[Mesh.name] = Mesh\n// CoreConstant.CONSTRUCTORS_BY_NAME[Points.name] = Points\n// CoreConstant.CONSTRUCTORS_BY_NAME[LineSegments.name] = LineSegments\n\n// CoreConstant.CONSTRUCTORS_BY_TYPE['MESH'] = Mesh\n// CoreConstant.CONSTRUCTORS_BY_TYPE['POINTS'] = Points\n// CoreConstant.CONSTRUCTORS_BY_TYPE['LINE_SEGMENTS'] = LineSegments\n\n// CoreConstant.OBJECT_TYPE_BY_CONSTRUCTOR_NAME[Mesh.name] = 'MESH'\n// CoreConstant.OBJECT_TYPE_BY_CONSTRUCTOR_NAME[Points.name] = 'POINTS'\n// CoreConstant.OBJECT_TYPE_BY_CONSTRUCTOR_NAME[LineSegments.name] = 'LINE_SEGMENTS'\n","export class CoreEntity {\n\tconstructor(protected _index: number) {}\n\tget index() {\n\t\treturn this._index;\n\t}\n}\n","import {Vector4} from 'three/src/math/Vector4';\nimport {Vector3} from 'three/src/math/Vector3';\nimport {Vector2} from 'three/src/math/Vector2';\nimport {BufferGeometry} from 'three/src/core/BufferGeometry';\n// const THREE = {BufferGeometry, Vector2, Vector3, Vector4}\nimport {CoreAttribute} from './Attribute';\nimport {CoreGeometry} from './Geometry';\nimport {CoreEntity} from './Entity';\n// import Geometry from './Geometry';\n\nconst ATTRIB_NAMES = {\n\tPOSITION: 'position',\n\tNORMAL: 'normal',\n};\n\nenum ComponentName {\n\tx = 'x',\n\ty = 'y',\n\tz = 'z',\n\tw = 'w',\n\tr = 'r',\n\tg = 'g',\n\tb = 'b',\n}\nconst COMPONENT_INDICES = {\n\tx: 0,\n\ty: 1,\n\tz: 2,\n\tw: 3,\n\tr: 0,\n\tg: 1,\n\tb: 2,\n};\n\nconst PTNUM = 'ptnum';\nconst DOT = '.';\n\nexport class CorePoint extends CoreEntity {\n\t_geometry: BufferGeometry;\n\t_position: Vector3 | undefined;\n\t_normal: Vector3 | undefined;\n\n\tconstructor(private _core_geometry: CoreGeometry, index: number) {\n\t\tsuper(index);\n\t\tthis._geometry = this._core_geometry.geometry();\n\t}\n\n\tgeometry_wrapper() {\n\t\treturn this._core_geometry;\n\t}\n\tgeometry() {\n\t\treturn (this._geometry = this._geometry || this._core_geometry.geometry());\n\t}\n\n\t// add_attribute: (name, size, value)->\n\t// \t@_attributes[name] = new Attribute(size, value)\n\n\tattrib_size(name: string): number {\n\t\t//@_attributes[name].size()\n\t\tname = CoreAttribute.remap_name(name);\n\t\treturn this._geometry.getAttribute(name).itemSize;\n\t}\n\n\thas_attrib(name: string): boolean {\n\t\tconst remapped_name = CoreAttribute.remap_name(name);\n\t\treturn this._core_geometry.has_attrib(remapped_name);\n\t}\n\n\tattrib_value(name: string) {\n\t\t//, target){ // target could be used, but not entirely sure I am ready now\n\n\t\tif (name === PTNUM) {\n\t\t\treturn this.index;\n\t\t} else {\n\t\t\tlet component_name = null;\n\t\t\tlet component_index = null;\n\t\t\tif (name[name.length - 2] === DOT) {\n\t\t\t\tcomponent_name = name[name.length - 1] as ComponentName;\n\t\t\t\tcomponent_index = COMPONENT_INDICES[component_name];\n\t\t\t\tname = name.substring(0, name.length - 2);\n\t\t\t}\n\t\t\tconst remaped_name = CoreAttribute.remap_name(name);\n\n\t\t\t//if (attrib = @_attributes[name])?\n\t\t\tconst attrib = this._geometry.getAttribute(remaped_name);\n\t\t\tif (attrib) {\n\t\t\t\tconst {array} = attrib;\n\t\t\t\tif (this._core_geometry.is_attrib_indexed(remaped_name)) {\n\t\t\t\t\tconst value_index = this.attrib_value_index(remaped_name); //attrib.value()\n\t\t\t\t\treturn this._core_geometry.user_data_attrib(remaped_name)[value_index];\n\t\t\t\t} else {\n\t\t\t\t\tconst size = attrib.itemSize;\n\t\t\t\t\tconst start_index = this._index * size;\n\n\t\t\t\t\tif (component_index == null) {\n\t\t\t\t\t\tswitch (size) {\n\t\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\t\treturn array[start_index];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\t\treturn new Vector2(array[start_index + 0], array[start_index + 1]);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 3:\n\t\t\t\t\t\t\t\treturn new Vector3(\n\t\t\t\t\t\t\t\t\tarray[start_index + 0],\n\t\t\t\t\t\t\t\t\tarray[start_index + 1],\n\t\t\t\t\t\t\t\t\tarray[start_index + 2]\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t// target.fromArray(array, start_index)\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 4:\n\t\t\t\t\t\t\t\treturn new Vector4(\n\t\t\t\t\t\t\t\t\tarray[start_index + 0],\n\t\t\t\t\t\t\t\t\tarray[start_index + 1],\n\t\t\t\t\t\t\t\t\tarray[start_index + 2],\n\t\t\t\t\t\t\t\t\tarray[start_index + 3]\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\tthrow `size not valid (${size})`;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tswitch (size) {\n\t\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\t\treturn array[start_index];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\treturn array[start_index + component_index];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconst message = `attrib ${name} not found. availables are: ${Object.keys(\n\t\t\t\t\tthis._geometry.attributes || {}\n\t\t\t\t).join(',')}`;\n\t\t\t\tconsole.warn(message);\n\t\t\t\tthrow message;\n\t\t\t}\n\t\t}\n\t}\n\n\tattrib_value_index(name: string) {\n\t\tif (this._core_geometry.is_attrib_indexed(name)) {\n\t\t\t//@_attributes[name].value()\n\t\t\treturn this._geometry.getAttribute(name).array[this._index];\n\t\t} else {\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tposition(): Vector3 {\n\t\t//@_attributes['position'].value()\n\t\tconst {array} = this._geometry.getAttribute(ATTRIB_NAMES.POSITION);\n\t\tthis._position = this._position || new Vector3();\n\t\treturn this._position.fromArray(array, this._index * 3);\n\t}\n\tset_position(new_position: Vector3) {\n\t\tthis.set_attrib_value_vector3(ATTRIB_NAMES.POSITION, new_position);\n\t}\n\n\tnormal(): Vector3 {\n\t\tconst {array} = this._geometry.getAttribute(ATTRIB_NAMES.NORMAL);\n\t\tthis._normal = this._normal || new Vector3();\n\t\treturn this._normal.fromArray(array, this._index * 3);\n\t}\n\tset_normal(new_normal: Vector3) {\n\t\treturn this.set_attrib_value_vector3(ATTRIB_NAMES.NORMAL, new_normal);\n\t}\n\n\tset_attrib_value(name: string, value: NumericAttribValue | string) {\n\t\t// TODO: this fails if the value is null\n\t\tif (value == null) {\n\t\t\treturn;\n\t\t}\n\t\tif (name == null) {\n\t\t\tthrow 'Point.set_attrib_value requires a name';\n\t\t}\n\n\t\t// attrib = @_attributes[name]\n\t\t// attrib.set_value(value)\n\t\t//value = attrib.value()\n\t\t//value = this.attrib_value()\n\t\tconst attrib = this._geometry.getAttribute(name);\n\t\tconst array = attrib.array as number[];\n\t\tconst attrib_size = attrib.itemSize;\n\n\t\tswitch (attrib_size) {\n\t\t\tcase 1:\n\t\t\t\tarray[this._index] = value as number;\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tconst v2 = value as Vector2Like;\n\t\t\t\tarray[this._index * 2 + 0] = v2.x;\n\t\t\t\tarray[this._index * 2 + 1] = v2.y;\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tconst is_color = (value as ColorLike).r != null;\n\t\t\t\tif (is_color) {\n\t\t\t\t\tconst col = value as ColorLike;\n\t\t\t\t\tarray[this._index * 3 + 0] = col.r;\n\t\t\t\t\tarray[this._index * 3 + 1] = col.g;\n\t\t\t\t\tarray[this._index * 3 + 2] = col.b;\n\t\t\t\t} else {\n\t\t\t\t\tconst v3 = value as Vector3Like;\n\t\t\t\t\tarray[this._index * 3 + 0] = v3.x;\n\t\t\t\t\tarray[this._index * 3 + 1] = v3.y;\n\t\t\t\t\tarray[this._index * 3 + 2] = v3.z;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tconsole.warn(`Point.set_attrib_value does not yet allow attrib size ${attrib_size}`);\n\t\t\t\tthrow `attrib size ${attrib_size} not implemented`;\n\t\t}\n\t}\n\tset_attrib_value_vector3(name: string, value: Vector3) {\n\t\t// TODO: this fails if the value is null\n\t\tif (value == null) {\n\t\t\treturn;\n\t\t}\n\t\tif (name == null) {\n\t\t\tthrow 'Point.set_attrib_value requires a name';\n\t\t}\n\n\t\tconst attrib = this._geometry.getAttribute(name);\n\t\tconst array = attrib.array as number[];\n\t\tconst i = this._index * 3;\n\n\t\tarray[i] = value.x;\n\t\tarray[i + 1] = value.y;\n\t\tarray[i + 2] = value.z;\n\t}\n\n\tset_attrib_index(name: string, new_value_index: number) {\n\t\t// attrib = @_attributes[name]\n\t\t// attrib.set_value(new_value_index)\n\t\t//value = attrib.value()\n\t\tconst array = this._geometry.getAttribute(name).array as number[];\n\t\treturn (array[this._index] = new_value_index);\n\t}\n}\n","import lodash_sum from 'lodash/sum';\n\nimport {Vector3} from 'three/src/math/Vector3';\nimport {Vector2} from 'three/src/math/Vector2';\nimport {Triangle} from 'three/src/math/Triangle';\nimport {BufferGeometry} from 'three/src/core/BufferGeometry';\nimport {BufferAttribute} from 'three/src/core/BufferAttribute';\n// const THREE = {BufferGeometry, Triangle, Vector2, Vector3}\nimport {CorePoint} from './Point';\nimport {CoreGeometry} from './Geometry';\nimport {CoreMath} from '../math/_Module';\n// import {CoreInterpolate} from '../Math/Interpolate'\n\ninterface FaceLike {\n\ta: number;\n\tb: number;\n\tc: number;\n}\n\ntype CorePointArray3 = [CorePoint, CorePoint, CorePoint];\ntype Vector3Array2 = [Vector3, Vector3];\ntype Vector3Array3 = [Vector3, Vector3, Vector3];\n\nexport class CoreFace {\n\t_geometry: BufferGeometry;\n\t_points: CorePointArray3 | undefined;\n\t_triangle: Triangle | undefined;\n\t_positions: Vector3Array3 | undefined;\n\t_deltas: Vector3Array2 | undefined;\n\n\tconstructor(private _core_geometry: CoreGeometry, private _index: number) {\n\t\tthis._geometry = this._core_geometry.geometry();\n\t}\n\tget index() {\n\t\treturn this._index;\n\t}\n\tget points() {\n\t\treturn (this._points = this._points || this._get_points());\n\t}\n\tprivate _get_points(): CorePointArray3 {\n\t\tconst index_array = this._geometry.index?.array || [];\n\t\tconst start = this._index * 3;\n\t\treturn [\n\t\t\tnew CorePoint(this._core_geometry, index_array[start + 0]),\n\t\t\tnew CorePoint(this._core_geometry, index_array[start + 1]),\n\t\t\tnew CorePoint(this._core_geometry, index_array[start + 2]),\n\t\t];\n\t}\n\tget positions() {\n\t\treturn (this._positions = this._positions || this._get_positions());\n\t}\n\tprivate _get_positions(): Vector3Array3 {\n\t\tconst points = this.points;\n\t\treturn [points[0].position(), points[1].position(), points[2].position()];\n\t}\n\tget triangle() {\n\t\treturn (this._triangle = this._triangle || this._get_triangle());\n\t}\n\tprivate _get_triangle(): Triangle {\n\t\tconst positions = this.positions;\n\t\treturn new Triangle(positions[0], positions[1], positions[2]);\n\t}\n\tget deltas() {\n\t\treturn (this._deltas = this._deltas || this._get_deltas());\n\t}\n\tprivate _get_deltas(): Vector3Array2 {\n\t\treturn [this.positions[1].clone().sub(this.positions[0]), this.positions[2].clone().sub(this.positions[0])];\n\t}\n\n\tget area(): number {\n\t\treturn this.triangle.getArea();\n\t}\n\tcenter(target: Vector3) {\n\t\tconst positions = this.positions;\n\t\ttarget.x = (positions[0].x + positions[1].x + positions[2].x) / 3;\n\t\ttarget.y = (positions[0].y + positions[1].y + positions[2].y) / 3;\n\t\ttarget.z = (positions[0].z + positions[1].z + positions[2].z) / 3;\n\n\t\treturn target;\n\t}\n\n\trandom_position(seed: number) {\n\t\tlet weights = [CoreMath.rand_float(seed), CoreMath.rand_float(seed * 6541)];\n\n\t\tif (weights[0] + weights[1] > 1) {\n\t\t\tweights[0] = 1 - weights[0];\n\t\t\tweights[1] = 1 - weights[1];\n\t\t}\n\n\t\treturn this.positions[0]\n\t\t\t.clone()\n\t\t\t.add(this.deltas[0].clone().multiplyScalar(weights[0]))\n\t\t\t.add(this.deltas[1].clone().multiplyScalar(weights[1]));\n\t}\n\t// random_position(seed: number){\n\t// \tlet weights = [\n\t// \t\tCoreMath.rand_float(seed),\n\t// \t\tCoreMath.rand_float(seed*524),\n\t// \t\tCoreMath.rand_float(seed*4631)\n\t// \t]\n\t// \tconst sum = lodash_sum(weights)\n\t// \tweights = weights.map(w=>w/sum)\n\t// \tconst pos = new Vector3()\n\t// \tlet positions = this.positions().map((p,i)=> p.multiplyScalar(weights[i]))\n\t// \tpositions.forEach(p=>{\n\t// \t\tpos.add(p)\n\t// \t})\n\t// \treturn pos\n\t// }\n\n\tattrib_value_at_position(attrib_name: string, position: Vector3) {\n\t\t// const weights = CoreInterpolate._weights_from_3(position, this._positions)\n\t\tconst barycentric_coordinates = new Vector3();\n\t\tthis.triangle.getBarycoord(position, barycentric_coordinates);\n\t\tconst weights = barycentric_coordinates.toArray();\n\n\t\tconst attrib = this._geometry.attributes[attrib_name];\n\t\tconst attrib_size = attrib.itemSize;\n\t\tconst point_values = this.points.map((point) => point.attrib_value(attrib_name));\n\n\t\tlet new_attrib_value;\n\t\tlet sum;\n\t\tlet index = 0;\n\t\tswitch (attrib_size) {\n\t\t\tcase 1: {\n\t\t\t\tsum = 0;\n\t\t\t\tfor (let point_value of point_values) {\n\t\t\t\t\tsum += point_value * weights[index];\n\t\t\t\t\tindex++;\n\t\t\t\t}\n\t\t\t\tnew_attrib_value = sum;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdefault: {\n\t\t\t\tfor (let point_value of point_values) {\n\t\t\t\t\tconst weighted_value = point_value.multiplyScalar(weights[index]);\n\t\t\t\t\tif (sum) {\n\t\t\t\t\t\tsum.add(weighted_value);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tsum = weighted_value;\n\t\t\t\t\t}\n\t\t\t\t\tindex++;\n\t\t\t\t}\n\t\t\t\tnew_attrib_value = sum;\n\t\t\t}\n\t\t}\n\t\treturn new_attrib_value;\n\t}\n\n\tstatic interpolated_value(\n\t\tgeometry: BufferGeometry,\n\t\tface: FaceLike,\n\t\tintersect_point: Vector3,\n\t\tattrib: BufferAttribute\n\t) {\n\t\t// let point_index, i, sum\n\t\tconst point_indices = [face.a, face.b, face.c];\n\t\tconst position_attrib = geometry.getAttribute('position');\n\t\tconst position_attrib_array = position_attrib.array;\n\t\tconst point_positions = point_indices.map(\n\t\t\t(point_index) =>\n\t\t\t\tnew Vector3(\n\t\t\t\t\tposition_attrib_array[point_index * 3 + 0],\n\t\t\t\t\tposition_attrib_array[point_index * 3 + 1],\n\t\t\t\t\tposition_attrib_array[point_index * 3 + 2]\n\t\t\t\t)\n\t\t);\n\n\t\tconst attrib_size = attrib.itemSize;\n\t\tconst attrib_array = attrib.array;\n\t\tlet attrib_values: NumericAttribValue[] = [];\n\t\tswitch (attrib_size) {\n\t\t\tcase 1:\n\t\t\t\tattrib_values = point_indices.map((point_index) => attrib_array[point_index]);\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tattrib_values = point_indices.map(\n\t\t\t\t\t(point_index) => new Vector2(attrib_array[point_index * 2 + 0], attrib_array[point_index * 2 + 1])\n\t\t\t\t);\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tattrib_values = point_indices.map(\n\t\t\t\t\t(point_index) =>\n\t\t\t\t\t\tnew Vector3(\n\t\t\t\t\t\t\tattrib_array[point_index * 3 + 0],\n\t\t\t\t\t\t\tattrib_array[point_index * 3 + 1],\n\t\t\t\t\t\t\tattrib_array[point_index * 3 + 2]\n\t\t\t\t\t\t)\n\t\t\t\t);\n\t\t\t\tbreak;\n\t\t}\n\n\t\tconst dist_to_points = point_indices.map((point_index, i) => intersect_point.distanceTo(point_positions[i]));\n\n\t\t// https://math.stackexchange.com/questions/1336386/weighted-average-distance-between-3-or-more-points\n\t\t// TODO: replace this with Core.Math.Interpolate\n\t\tconst distance_total = lodash_sum([\n\t\t\tdist_to_points[0] * dist_to_points[1],\n\t\t\tdist_to_points[0] * dist_to_points[2],\n\t\t\tdist_to_points[1] * dist_to_points[2],\n\t\t]);\n\n\t\tconst weights = [\n\t\t\t(dist_to_points[1] * dist_to_points[2]) / distance_total,\n\t\t\t(dist_to_points[0] * dist_to_points[2]) / distance_total,\n\t\t\t(dist_to_points[0] * dist_to_points[1]) / distance_total,\n\t\t];\n\n\t\tlet new_attrib_value;\n\t\tswitch (attrib_size) {\n\t\t\tcase 1:\n\t\t\t\tnew_attrib_value = lodash_sum(\n\t\t\t\t\tpoint_indices.map((point_indx, i) => weights[i] * (attrib_values[i] as number))\n\t\t\t\t);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tvar values = point_indices.map((point_index, i) =>\n\t\t\t\t\t(attrib_values[i] as Vector3).multiplyScalar(weights[i])\n\t\t\t\t);\n\t\t\t\tnew_attrib_value = null;\n\t\t\t\tfor (let value of values) {\n\t\t\t\t\tif (new_attrib_value) {\n\t\t\t\t\t\tnew_attrib_value.add(value);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnew_attrib_value = value;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t}\n\n\t\treturn new_attrib_value;\n\t}\n}\n","import {InterleavedBufferAttribute} from 'three/src/core/InterleavedBufferAttribute'\n\nexport class MonkeyPatcher {\n\t// this allows cloning of geometries containing InterleavedBufferAttribute such as soldier.glb\n\tstatic patch(attribute: InterleavedBufferAttribute) {\n\t\tObject.assign(attribute, {\n\t\t\tclone: function() {\n\t\t\t\treturn new InterleavedBufferAttribute(\n\t\t\t\t\tattribute.data.clone(),\n\t\t\t\t\tattribute.itemSize,\n\t\t\t\t\tattribute.offset,\n\t\t\t\t\tattribute.normalized\n\t\t\t\t)\n\t\t\t},\n\t\t})\n\t}\n}\n","import lodash_isArray from 'lodash/isArray';\n\nimport {ShaderMaterial} from 'three/src/materials/ShaderMaterial';\nimport {Object3D} from 'three/src/core/Object3D';\nimport {Mesh} from 'three/src/objects/Mesh';\nimport {Material} from 'three/src/materials/Material';\nimport {LineBasicMaterial} from 'three/src/materials/LineBasicMaterial';\nimport {PolyScene} from '../../engine/scene/PolyScene';\nimport {IUniform} from 'three/src/renderers/shaders/UniformsLib';\n\nexport interface IUniforms {\n\t[uniform: string]: IUniform;\n}\nexport interface MaterialWithUniforms extends Material {\n\tuniforms: IUniforms;\n}\n\nenum CustomMaterialName {\n\tcustomDistanceMaterial = 'customDistanceMaterial',\n\tcustomDepthMaterial = 'customDepthMaterial',\n\tcustomDepthDOFMaterial = 'customDepthDOFMaterial',\n}\nexport interface ObjectWithCustomMaterials extends Mesh {\n\t// customDistanceMaterial?: Material;\n\t// customDepthMaterial?: Material;\n\tcustomDepthDOFMaterial?: Material;\n}\nexport interface ShaderMaterialWithCustomMaterials extends ShaderMaterial {\n\tcustom_materials: {\n\t\t[key in CustomMaterialName]?: ShaderMaterial;\n\t};\n}\nexport interface MaterialWithSkinning extends Material {\n\tskinning: boolean;\n\tmorphTargets: boolean;\n}\n\nexport class CoreMaterial {\n\tstatic node(scene: PolyScene, material: Material) {\n\t\treturn scene.node(material.name);\n\t}\n\n\tstatic clone(src_material: Material | Material[]) {\n\t\tif (lodash_isArray(src_material)) {\n\t\t\treturn src_material.map((material) => {\n\t\t\t\treturn this.clone_single(material);\n\t\t\t});\n\t\t} else {\n\t\t\treturn this.clone_single(src_material);\n\t\t}\n\t}\n\n\tstatic clone_single(src_material: Material) {\n\t\tconst material = src_material.clone();\n\t\t// linewidth doesn't seem cloned correctly for ShaderMaterial\n\t\t(material as LineBasicMaterial).linewidth = (src_material as LineBasicMaterial).linewidth;\n\n\t\treturn material;\n\t}\n\n\tstatic apply_custom_materials(object: Object3D, material: Material) {\n\t\tconst material_with_custom = material as ShaderMaterialWithCustomMaterials;\n\t\tif (material_with_custom.custom_materials) {\n\t\t\tfor (let name of Object.keys(material_with_custom.custom_materials)) {\n\t\t\t\tconst mat_name = name as CustomMaterialName;\n\t\t\t\t// http://blog.edankwan.com/post/three-js-advanced-tips-shadow\n\t\t\t\tconst custom_material = material_with_custom.custom_materials[mat_name];\n\t\t\t\tif (custom_material) {\n\t\t\t\t\t(object as ObjectWithCustomMaterials)[mat_name] = custom_material;\n\t\t\t\t\tcustom_material.needsUpdate = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// object.material = material.custom_materials.customDepthDOFMaterial\n\t\t\t// object.material = material.custom_materials.customDepthMaterial\n\t\t\t// object.material = material.custom_materials.customDistanceMaterial\n\t\t}\n\t}\n\tstatic assign_custom_uniforms(mat: Material, uniform_name: string, uniform_value: any) {\n\t\tconst material = mat as ShaderMaterialWithCustomMaterials;\n\t\tif (material.custom_materials) {\n\t\t\tfor (let name of Object.keys(material.custom_materials)) {\n\t\t\t\tconst mat_name = name as CustomMaterialName;\n\t\t\t\tconst custom_material = material.custom_materials[mat_name];\n\t\t\t\tif (custom_material) {\n\t\t\t\t\tcustom_material.uniforms[uniform_name].value = uniform_value;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tstatic init_custom_material_uniforms(mat: Material, uniform_name: string, uniform_value: any) {\n\t\tconst material = mat as ShaderMaterialWithCustomMaterials;\n\t\tif (material.custom_materials) {\n\t\t\tfor (let name of Object.keys(material.custom_materials)) {\n\t\t\t\tconst mat_name = name as CustomMaterialName;\n\t\t\t\tconst custom_material = material.custom_materials[mat_name];\n\t\t\t\tif (custom_material) {\n\t\t\t\t\tcustom_material.uniforms[uniform_name] = custom_material.uniforms[uniform_name] || uniform_value;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n","import {BufferAttribute} from 'three/src/core/BufferAttribute';\nimport {BufferGeometry} from 'three/src/core/BufferGeometry';\nimport {InterleavedBuffer} from 'three/src/core/InterleavedBuffer';\nimport {InterleavedBufferAttribute} from 'three/src/core/InterleavedBufferAttribute';\nimport {TriangleFanDrawMode} from 'three/src/constants';\nimport {TriangleStripDrawMode} from 'three/src/constants';\nimport {TrianglesDrawMode} from 'three/src/constants';\nimport {Vector2} from 'three/src/math/Vector2';\nimport {Vector3} from 'three/src/math/Vector3';\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\n\nvar BufferGeometryUtils = {\n\n\tcomputeTangents: function ( geometry ) {\n\n\t\tvar index = geometry.index;\n\t\tvar attributes = geometry.attributes;\n\n\t\t// based on http://www.terathon.com/code/tangent.html\n\t\t// (per vertex tangents)\n\n\t\tif ( index === null ||\n\t\t\t attributes.position === undefined ||\n\t\t\t attributes.normal === undefined ||\n\t\t\t attributes.uv === undefined ) {\n\n\t\t\tconsole.warn( 'THREE.BufferGeometry: Missing required attributes (index, position, normal or uv) in BufferGeometry.computeTangents()' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tvar indices = index.array;\n\t\tvar positions = attributes.position.array;\n\t\tvar normals = attributes.normal.array;\n\t\tvar uvs = attributes.uv.array;\n\n\t\tvar nVertices = positions.length / 3;\n\n\t\tif ( attributes.tangent === undefined ) {\n\n\t\t\tgeometry.setAttribute( 'tangent', new BufferAttribute( new Float32Array( 4 * nVertices ), 4 ) );\n\n\t\t}\n\n\t\tvar tangents = attributes.tangent.array;\n\n\t\tvar tan1 = [], tan2 = [];\n\n\t\tfor ( var i = 0; i < nVertices; i ++ ) {\n\n\t\t\ttan1[ i ] = new Vector3();\n\t\t\ttan2[ i ] = new Vector3();\n\n\t\t}\n\n\t\tvar vA = new Vector3(),\n\t\t\tvB = new Vector3(),\n\t\t\tvC = new Vector3(),\n\n\t\t\tuvA = new Vector2(),\n\t\t\tuvB = new Vector2(),\n\t\t\tuvC = new Vector2(),\n\n\t\t\tsdir = new Vector3(),\n\t\t\ttdir = new Vector3();\n\n\t\tfunction handleTriangle( a, b, c ) {\n\n\t\t\tvA.fromArray( positions, a * 3 );\n\t\t\tvB.fromArray( positions, b * 3 );\n\t\t\tvC.fromArray( positions, c * 3 );\n\n\t\t\tuvA.fromArray( uvs, a * 2 );\n\t\t\tuvB.fromArray( uvs, b * 2 );\n\t\t\tuvC.fromArray( uvs, c * 2 );\n\n\t\t\tvB.sub( vA );\n\t\t\tvC.sub( vA );\n\n\t\t\tuvB.sub( uvA );\n\t\t\tuvC.sub( uvA );\n\n\t\t\tvar r = 1.0 / ( uvB.x * uvC.y - uvC.x * uvB.y );\n\n\t\t\t// silently ignore degenerate uv triangles having coincident or colinear vertices\n\n\t\t\tif ( ! isFinite( r ) ) return;\n\n\t\t\tsdir.copy( vB ).multiplyScalar( uvC.y ).addScaledVector( vC, - uvB.y ).multiplyScalar( r );\n\t\t\ttdir.copy( vC ).multiplyScalar( uvB.x ).addScaledVector( vB, - uvC.x ).multiplyScalar( r );\n\n\t\t\ttan1[ a ].add( sdir );\n\t\t\ttan1[ b ].add( sdir );\n\t\t\ttan1[ c ].add( sdir );\n\n\t\t\ttan2[ a ].add( tdir );\n\t\t\ttan2[ b ].add( tdir );\n\t\t\ttan2[ c ].add( tdir );\n\n\t\t}\n\n\t\tvar groups = geometry.groups;\n\n\t\tif ( groups.length === 0 ) {\n\n\t\t\tgroups = [ {\n\t\t\t\tstart: 0,\n\t\t\t\tcount: indices.length\n\t\t\t} ];\n\n\t\t}\n\n\t\tfor ( var i = 0, il = groups.length; i < il; ++ i ) {\n\n\t\t\tvar group = groups[ i ];\n\n\t\t\tvar start = group.start;\n\t\t\tvar count = group.count;\n\n\t\t\tfor ( var j = start, jl = start + count; j < jl; j += 3 ) {\n\n\t\t\t\thandleTriangle(\n\t\t\t\t\tindices[ j + 0 ],\n\t\t\t\t\tindices[ j + 1 ],\n\t\t\t\t\tindices[ j + 2 ]\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t}\n\n\t\tvar tmp = new Vector3(), tmp2 = new Vector3();\n\t\tvar n = new Vector3(), n2 = new Vector3();\n\t\tvar w, t, test;\n\n\t\tfunction handleVertex( v ) {\n\n\t\t\tn.fromArray( normals, v * 3 );\n\t\t\tn2.copy( n );\n\n\t\t\tt = tan1[ v ];\n\n\t\t\t// Gram-Schmidt orthogonalize\n\n\t\t\ttmp.copy( t );\n\t\t\ttmp.sub( n.multiplyScalar( n.dot( t ) ) ).normalize();\n\n\t\t\t// Calculate handedness\n\n\t\t\ttmp2.crossVectors( n2, t );\n\t\t\ttest = tmp2.dot( tan2[ v ] );\n\t\t\tw = ( test < 0.0 ) ? - 1.0 : 1.0;\n\n\t\t\ttangents[ v * 4 ] = tmp.x;\n\t\t\ttangents[ v * 4 + 1 ] = tmp.y;\n\t\t\ttangents[ v * 4 + 2 ] = tmp.z;\n\t\t\ttangents[ v * 4 + 3 ] = w;\n\n\t\t}\n\n\t\tfor ( var i = 0, il = groups.length; i < il; ++ i ) {\n\n\t\t\tvar group = groups[ i ];\n\n\t\t\tvar start = group.start;\n\t\t\tvar count = group.count;\n\n\t\t\tfor ( var j = start, jl = start + count; j < jl; j += 3 ) {\n\n\t\t\t\thandleVertex( indices[ j + 0 ] );\n\t\t\t\thandleVertex( indices[ j + 1 ] );\n\t\t\t\thandleVertex( indices[ j + 2 ] );\n\n\t\t\t}\n\n\t\t}\n\n\t},\n\n\t/**\n\t * @param  {Array<BufferGeometry>} geometries\n\t * @param  {Boolean} useGroups\n\t * @return {BufferGeometry}\n\t */\n\tmergeBufferGeometries: function ( geometries, useGroups ) {\n\n\t\tvar isIndexed = geometries[ 0 ].index !== null;\n\n\t\tvar attributesUsed = new Set( Object.keys( geometries[ 0 ].attributes ) );\n\t\tvar morphAttributesUsed = new Set( Object.keys( geometries[ 0 ].morphAttributes ) );\n\n\t\tvar attributes = {};\n\t\tvar morphAttributes = {};\n\n\t\tvar morphTargetsRelative = geometries[ 0 ].morphTargetsRelative;\n\n\t\tvar mergedGeometry = new BufferGeometry();\n\n\t\tvar offset = 0;\n\n\t\tfor ( var i = 0; i < geometries.length; ++ i ) {\n\n\t\t\tvar geometry = geometries[ i ];\n\n\t\t\t// ensure that all geometries are indexed, or none\n\n\t\t\tif ( isIndexed !== ( geometry.index !== null ) ) return null;\n\n\t\t\t// gather attributes, exit early if they're different\n\n\t\t\tfor ( var name in geometry.attributes ) {\n\n\t\t\t\tif ( ! attributesUsed.has( name ) ) return null;\n\n\t\t\t\tif ( attributes[ name ] === undefined ) attributes[ name ] = [];\n\n\t\t\t\tattributes[ name ].push( geometry.attributes[ name ] );\n\n\t\t\t}\n\n\t\t\t// gather morph attributes, exit early if they're different\n\n\t\t\tif ( morphTargetsRelative !== geometry.morphTargetsRelative ) return null;\n\n\t\t\tfor ( var name in geometry.morphAttributes ) {\n\n\t\t\t\tif ( ! morphAttributesUsed.has( name ) ) return null;\n\n\t\t\t\tif ( morphAttributes[ name ] === undefined ) morphAttributes[ name ] = [];\n\n\t\t\t\tmorphAttributes[ name ].push( geometry.morphAttributes[ name ] );\n\n\t\t\t}\n\n\t\t\t// gather .userData\n\n\t\t\tmergedGeometry.userData.mergedUserData = mergedGeometry.userData.mergedUserData || [];\n\t\t\tmergedGeometry.userData.mergedUserData.push( geometry.userData );\n\n\t\t\tif ( useGroups ) {\n\n\t\t\t\tvar count;\n\n\t\t\t\tif ( isIndexed ) {\n\n\t\t\t\t\tcount = geometry.index.count;\n\n\t\t\t\t} else if ( geometry.attributes.position !== undefined ) {\n\n\t\t\t\t\tcount = geometry.attributes.position.count;\n\n\t\t\t\t} else {\n\n\t\t\t\t\treturn null;\n\n\t\t\t\t}\n\n\t\t\t\tmergedGeometry.addGroup( offset, count, i );\n\n\t\t\t\toffset += count;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// merge indices\n\n\t\tif ( isIndexed ) {\n\n\t\t\tvar indexOffset = 0;\n\t\t\tvar mergedIndex = [];\n\n\t\t\tfor ( var i = 0; i < geometries.length; ++ i ) {\n\n\t\t\t\tvar index = geometries[ i ].index;\n\n\t\t\t\tfor ( var j = 0; j < index.count; ++ j ) {\n\n\t\t\t\t\tmergedIndex.push( index.getX( j ) + indexOffset );\n\n\t\t\t\t}\n\n\t\t\t\tindexOffset += geometries[ i ].attributes.position.count;\n\n\t\t\t}\n\n\t\t\tmergedGeometry.setIndex( mergedIndex );\n\n\t\t}\n\n\t\t// merge attributes\n\n\t\tfor ( var name in attributes ) {\n\n\t\t\tvar mergedAttribute = this.mergeBufferAttributes( attributes[ name ] );\n\n\t\t\tif ( ! mergedAttribute ) return null;\n\n\t\t\tmergedGeometry.setAttribute( name, mergedAttribute );\n\n\t\t}\n\n\t\t// merge morph attributes\n\n\t\tfor ( var name in morphAttributes ) {\n\n\t\t\tvar numMorphTargets = morphAttributes[ name ][ 0 ].length;\n\n\t\t\tif ( numMorphTargets === 0 ) break;\n\n\t\t\tmergedGeometry.morphAttributes = mergedGeometry.morphAttributes || {};\n\t\t\tmergedGeometry.morphAttributes[ name ] = [];\n\n\t\t\tfor ( var i = 0; i < numMorphTargets; ++ i ) {\n\n\t\t\t\tvar morphAttributesToMerge = [];\n\n\t\t\t\tfor ( var j = 0; j < morphAttributes[ name ].length; ++ j ) {\n\n\t\t\t\t\tmorphAttributesToMerge.push( morphAttributes[ name ][ j ][ i ] );\n\n\t\t\t\t}\n\n\t\t\t\tvar mergedMorphAttribute = this.mergeBufferAttributes( morphAttributesToMerge );\n\n\t\t\t\tif ( ! mergedMorphAttribute ) return null;\n\n\t\t\t\tmergedGeometry.morphAttributes[ name ].push( mergedMorphAttribute );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn mergedGeometry;\n\n\t},\n\n\t/**\n\t * @param {Array<BufferAttribute>} attributes\n\t * @return {BufferAttribute}\n\t */\n\tmergeBufferAttributes: function ( attributes ) {\n\n\t\tvar TypedArray;\n\t\tvar itemSize;\n\t\tvar normalized;\n\t\tvar arrayLength = 0;\n\n\t\tfor ( var i = 0; i < attributes.length; ++ i ) {\n\n\t\t\tvar attribute = attributes[ i ];\n\n\t\t\tif ( attribute.isInterleavedBufferAttribute ) return null;\n\n\t\t\tif ( TypedArray === undefined ) TypedArray = attribute.array.constructor;\n\t\t\tif ( TypedArray !== attribute.array.constructor ) return null;\n\n\t\t\tif ( itemSize === undefined ) itemSize = attribute.itemSize;\n\t\t\tif ( itemSize !== attribute.itemSize ) return null;\n\n\t\t\tif ( normalized === undefined ) normalized = attribute.normalized;\n\t\t\tif ( normalized !== attribute.normalized ) return null;\n\n\t\t\tarrayLength += attribute.array.length;\n\n\t\t}\n\n\t\tvar array = new TypedArray( arrayLength );\n\t\tvar offset = 0;\n\n\t\tfor ( var i = 0; i < attributes.length; ++ i ) {\n\n\t\t\tarray.set( attributes[ i ].array, offset );\n\n\t\t\toffset += attributes[ i ].array.length;\n\n\t\t}\n\n\t\treturn new BufferAttribute( array, itemSize, normalized );\n\n\t},\n\n\t/**\n\t * @param {Array<BufferAttribute>} attributes\n\t * @return {Array<InterleavedBufferAttribute>}\n\t */\n\tinterleaveAttributes: function ( attributes ) {\n\n\t\t// Interleaves the provided attributes into an InterleavedBuffer and returns\n\t\t// a set of InterleavedBufferAttributes for each attribute\n\t\tvar TypedArray;\n\t\tvar arrayLength = 0;\n\t\tvar stride = 0;\n\n\t\t// calculate the the length and type of the interleavedBuffer\n\t\tfor ( var i = 0, l = attributes.length; i < l; ++ i ) {\n\n\t\t\tvar attribute = attributes[ i ];\n\n\t\t\tif ( TypedArray === undefined ) TypedArray = attribute.array.constructor;\n\t\t\tif ( TypedArray !== attribute.array.constructor ) {\n\n\t\t\t\tconsole.warn( 'AttributeBuffers of different types cannot be interleaved' );\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tarrayLength += attribute.array.length;\n\t\t\tstride += attribute.itemSize;\n\n\t\t}\n\n\t\t// Create the set of buffer attributes\n\t\tvar interleavedBuffer = new InterleavedBuffer( new TypedArray( arrayLength ), stride );\n\t\tvar offset = 0;\n\t\tvar res = [];\n\t\tvar getters = [ 'getX', 'getY', 'getZ', 'getW' ];\n\t\tvar setters = [ 'setX', 'setY', 'setZ', 'setW' ];\n\n\t\tfor ( var j = 0, l = attributes.length; j < l; j ++ ) {\n\n\t\t\tvar attribute = attributes[ j ];\n\t\t\tvar itemSize = attribute.itemSize;\n\t\t\tvar count = attribute.count;\n\t\t\tvar iba = new InterleavedBufferAttribute( interleavedBuffer, itemSize, offset, attribute.normalized );\n\t\t\tres.push( iba );\n\n\t\t\toffset += itemSize;\n\n\t\t\t// Move the data for each attribute into the new interleavedBuffer\n\t\t\t// at the appropriate offset\n\t\t\tfor ( var c = 0; c < count; c ++ ) {\n\n\t\t\t\tfor ( var k = 0; k < itemSize; k ++ ) {\n\n\t\t\t\t\tiba[ setters[ k ] ]( c, attribute[ getters[ k ] ]( c ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn res;\n\n\t},\n\n\t/**\n\t * @param {Array<BufferGeometry>} geometry\n\t * @return {number}\n\t */\n\testimateBytesUsed: function ( geometry ) {\n\n\t\t// Return the estimated memory used by this geometry in bytes\n\t\t// Calculate using itemSize, count, and BYTES_PER_ELEMENT to account\n\t\t// for InterleavedBufferAttributes.\n\t\tvar mem = 0;\n\t\tfor ( var name in geometry.attributes ) {\n\n\t\t\tvar attr = geometry.getAttribute( name );\n\t\t\tmem += attr.count * attr.itemSize * attr.array.BYTES_PER_ELEMENT;\n\n\t\t}\n\n\t\tvar indices = geometry.getIndex();\n\t\tmem += indices ? indices.count * indices.itemSize * indices.array.BYTES_PER_ELEMENT : 0;\n\t\treturn mem;\n\n\t},\n\n\t/**\n\t * @param {BufferGeometry} geometry\n\t * @param {number} tolerance\n\t * @return {BufferGeometry>}\n\t */\n\tmergeVertices: function ( geometry, tolerance = 1e-4 ) {\n\n\t\ttolerance = Math.max( tolerance, Number.EPSILON );\n\n\t\t// Generate an index buffer if the geometry doesn't have one, or optimize it\n\t\t// if it's already available.\n\t\tvar hashToIndex = {};\n\t\tvar indices = geometry.getIndex();\n\t\tvar positions = geometry.getAttribute( 'position' );\n\t\tvar vertexCount = indices ? indices.count : positions.count;\n\n\t\t// next value for triangle indices\n\t\tvar nextIndex = 0;\n\n\t\t// attributes and new attribute arrays\n\t\tvar attributeNames = Object.keys( geometry.attributes );\n\t\tvar attrArrays = {};\n\t\tvar morphAttrsArrays = {};\n\t\tvar newIndices = [];\n\t\tvar getters = [ 'getX', 'getY', 'getZ', 'getW' ];\n\n\t\t// initialize the arrays\n\t\tfor ( var i = 0, l = attributeNames.length; i < l; i ++ ) {\n\n\t\t\tvar name = attributeNames[ i ];\n\n\t\t\tattrArrays[ name ] = [];\n\n\t\t\tvar morphAttr = geometry.morphAttributes[ name ];\n\t\t\tif ( morphAttr ) {\n\n\t\t\t\tmorphAttrsArrays[ name ] = new Array( morphAttr.length ).fill().map( () => [] );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// convert the error tolerance to an amount of decimal places to truncate to\n\t\tvar decimalShift = Math.log10( 1 / tolerance );\n\t\tvar shiftMultiplier = Math.pow( 10, decimalShift );\n\t\tfor ( var i = 0; i < vertexCount; i ++ ) {\n\n\t\t\tvar index = indices ? indices.getX( i ) : i;\n\n\t\t\t// Generate a hash for the vertex attributes at the current index 'i'\n\t\t\tvar hash = '';\n\t\t\tfor ( var j = 0, l = attributeNames.length; j < l; j ++ ) {\n\n\t\t\t\tvar name = attributeNames[ j ];\n\t\t\t\tvar attribute = geometry.getAttribute( name );\n\t\t\t\tvar itemSize = attribute.itemSize;\n\n\t\t\t\tfor ( var k = 0; k < itemSize; k ++ ) {\n\n\t\t\t\t\t// double tilde truncates the decimal value\n\t\t\t\t\thash += `${ ~ ~ ( attribute[ getters[ k ] ]( index ) * shiftMultiplier ) },`;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// Add another reference to the vertex if it's already\n\t\t\t// used by another index\n\t\t\tif ( hash in hashToIndex ) {\n\n\t\t\t\tnewIndices.push( hashToIndex[ hash ] );\n\n\t\t\t} else {\n\n\t\t\t\t// copy data to the new index in the attribute arrays\n\t\t\t\tfor ( var j = 0, l = attributeNames.length; j < l; j ++ ) {\n\n\t\t\t\t\tvar name = attributeNames[ j ];\n\t\t\t\t\tvar attribute = geometry.getAttribute( name );\n\t\t\t\t\tvar morphAttr = geometry.morphAttributes[ name ];\n\t\t\t\t\tvar itemSize = attribute.itemSize;\n\t\t\t\t\tvar newarray = attrArrays[ name ];\n\t\t\t\t\tvar newMorphArrays = morphAttrsArrays[ name ];\n\n\t\t\t\t\tfor ( var k = 0; k < itemSize; k ++ ) {\n\n\t\t\t\t\t\tvar getterFunc = getters[ k ];\n\t\t\t\t\t\tnewarray.push( attribute[ getterFunc ]( index ) );\n\n\t\t\t\t\t\tif ( morphAttr ) {\n\n\t\t\t\t\t\t\tfor ( var m = 0, ml = morphAttr.length; m < ml; m ++ ) {\n\n\t\t\t\t\t\t\t\tnewMorphArrays[ m ].push( morphAttr[ m ][ getterFunc ]( index ) );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\thashToIndex[ hash ] = nextIndex;\n\t\t\t\tnewIndices.push( nextIndex );\n\t\t\t\tnextIndex ++;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Generate typed arrays from new attribute arrays and update\n\t\t// the attributeBuffers\n\t\tconst result = geometry.clone();\n\t\tfor ( var i = 0, l = attributeNames.length; i < l; i ++ ) {\n\n\t\t\tvar name = attributeNames[ i ];\n\t\t\tvar oldAttribute = geometry.getAttribute( name );\n\n\t\t\tvar buffer = new oldAttribute.array.constructor( attrArrays[ name ] );\n\t\t\tvar attribute = new BufferAttribute( buffer, oldAttribute.itemSize, oldAttribute.normalized );\n\n\t\t\tresult.setAttribute( name, attribute );\n\n\t\t\t// Update the attribute arrays\n\t\t\tif ( name in morphAttrsArrays ) {\n\n\t\t\t\tfor ( var j = 0; j < morphAttrsArrays[ name ].length; j ++ ) {\n\n\t\t\t\t\tvar oldMorphAttribute = geometry.morphAttributes[ name ][ j ];\n\n\t\t\t\t\tvar buffer = new oldMorphAttribute.array.constructor( morphAttrsArrays[ name ][ j ] );\n\t\t\t\t\tvar morphAttribute = new BufferAttribute( buffer, oldMorphAttribute.itemSize, oldMorphAttribute.normalized );\n\t\t\t\t\tresult.morphAttributes[ name ][ j ] = morphAttribute;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// indices\n\n\t\tresult.setIndex( newIndices );\n\n\t\treturn result;\n\n\t},\n\n\t/**\n\t * @param {BufferGeometry} geometry\n\t * @param {number} drawMode\n\t * @return {BufferGeometry>}\n\t */\n\ttoTrianglesDrawMode: function ( geometry, drawMode ) {\n\n\t\tif ( drawMode === TrianglesDrawMode ) {\n\n\t\t\tconsole.warn( 'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles.' );\n\t\t\treturn geometry;\n\n\t\t}\n\n\t\tif ( drawMode === TriangleFanDrawMode || drawMode === TriangleStripDrawMode ) {\n\n\t\t\tvar index = geometry.getIndex();\n\n\t\t\t// generate index if not present\n\n\t\t\tif ( index === null ) {\n\n\t\t\t\tvar indices = [];\n\n\t\t\t\tvar position = geometry.getAttribute( 'position' );\n\n\t\t\t\tif ( position !== undefined ) {\n\n\t\t\t\t\tfor ( var i = 0; i < position.count; i ++ ) {\n\n\t\t\t\t\t\tindices.push( i );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tgeometry.setIndex( indices );\n\t\t\t\t\tindex = geometry.getIndex();\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.' );\n\t\t\t\t\treturn geometry;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tvar numberOfTriangles = index.count - 2;\n\t\t\tvar newIndices = [];\n\n\t\t\tif ( drawMode === TriangleFanDrawMode ) {\n\n\t\t\t\t// gl.TRIANGLE_FAN\n\n\t\t\t\tfor ( var i = 1; i <= numberOfTriangles; i ++ ) {\n\n\t\t\t\t\tnewIndices.push( index.getX( 0 ) );\n\t\t\t\t\tnewIndices.push( index.getX( i ) );\n\t\t\t\t\tnewIndices.push( index.getX( i + 1 ) );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// gl.TRIANGLE_STRIP\n\n\t\t\t\tfor ( var i = 0; i < numberOfTriangles; i ++ ) {\n\n\t\t\t\t\tif ( i % 2 === 0 ) {\n\n\t\t\t\t\t\tnewIndices.push( index.getX( i ) );\n\t\t\t\t\t\tnewIndices.push( index.getX( i + 1 ) );\n\t\t\t\t\t\tnewIndices.push( index.getX( i + 2 ) );\n\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tnewIndices.push( index.getX( i + 2 ) );\n\t\t\t\t\t\tnewIndices.push( index.getX( i + 1 ) );\n\t\t\t\t\t\tnewIndices.push( index.getX( i ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( ( newIndices.length / 3 ) !== numberOfTriangles ) {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.' );\n\n\t\t\t}\n\n\t\t\t// build final geometry\n\n\t\t\tvar newGeometry = geometry.clone();\n\t\t\tnewGeometry.setIndex( newIndices );\n\t\t\tnewGeometry.clearGroups();\n\n\t\t\treturn newGeometry;\n\n\t\t} else {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:', drawMode );\n\t\t\treturn geometry;\n\n\t\t}\n\n\t}\n\n};\n\nexport { BufferGeometryUtils };\n","import {Vector3} from 'three/src/math/Vector3';\n// import {Vector2} from 'three/src/math/Vector2'\nimport {Int32BufferAttribute} from 'three/src/core/BufferAttribute';\nimport {Float32BufferAttribute} from 'three/src/core/BufferAttribute';\nimport {BufferGeometry} from 'three/src/core/BufferGeometry';\nimport {Box3} from 'three/src/math/Box3';\nimport {InterleavedBufferAttribute} from 'three/src/core/InterleavedBufferAttribute';\n\n// const THREE = {\n// \tBox3,\n// \tBufferGeometry,\n// \tFloat32BufferAttribute,\n// \tInt32BufferAttribute,\n// \tInterleavedBufferAttribute,\n// \tVector2,\n// \tVector3,\n// }\nimport lodash_range from 'lodash/range';\nimport lodash_uniq from 'lodash/uniq';\nimport lodash_each from 'lodash/each';\nimport lodash_chunk from 'lodash/chunk';\nimport lodash_cloneDeep from 'lodash/cloneDeep';\nimport lodash_clone from 'lodash/clone';\nimport lodash_isArray from 'lodash/isArray';\nimport lodash_isNumber from 'lodash/isNumber';\nimport {CorePoint} from './Point';\nimport {CoreFace} from './Face';\nimport {CoreConstant, ObjectType} from './Constant';\nimport {CoreAttribute} from './Attribute';\nimport {MonkeyPatcher} from './MonkeyPatcher';\n\nimport {BufferGeometryUtils} from '../../../modules/three/examples/jsm/utils/BufferGeometryUtils';\nimport {CoreAttributeData} from './AttributeData';\n\nexport class CoreGeometry {\n\t_bounding_box: Box3 | undefined;\n\tprivate _points: CorePoint[] | undefined;\n\n\t// @INDEX_MODE_POINTS = 'INDEX_MODE_POINTS'\n\t// @INDEX_MODE_FACES = 'INDEX_MODE_FACES'\n\t// @INDEX_MODE_LINES = 'INDEX_MODE_LINES'\n\n\tconstructor(private _geometry: BufferGeometry) {}\n\t//\n\n\tgeometry() {\n\t\treturn this._geometry;\n\t}\n\tuuid() {\n\t\treturn this._geometry.uuid;\n\t}\n\n\tbounding_box() {\n\t\treturn (this._bounding_box = this._bounding_box || this._create_bounding_box());\n\t}\n\t_create_bounding_box() {\n\t\tthis._geometry.computeBoundingBox();\n\t\tif (this._geometry.boundingBox) {\n\t\t\treturn this._geometry.boundingBox;\n\t\t}\n\t}\n\n\tmark_as_instance() {\n\t\tthis._geometry.userData['is_instance'] = true;\n\t}\n\tstatic marked_as_instance(geometry: BufferGeometry): boolean {\n\t\treturn geometry.userData['is_instance'] === true;\n\t}\n\tmarked_as_instance(): boolean {\n\t\treturn CoreGeometry.marked_as_instance(this._geometry);\n\t}\n\tposition_attrib_name() {\n\t\tlet name = 'position';\n\t\tif (this.marked_as_instance()) {\n\t\t\tname = 'instancePosition';\n\t\t}\n\t\treturn name;\n\t}\n\n\tcompute_vertex_normals() {\n\t\tthis._geometry.computeVertexNormals();\n\t}\n\n\tuser_data_attribs() {\n\t\tconst key = 'indexed_attrib_values';\n\t\treturn (this._geometry.userData[key] = this._geometry.userData[key] || {});\n\t}\n\tindexed_attribute_names() {\n\t\treturn Object.keys(this.user_data_attribs() || {});\n\t}\n\tuser_data_attrib(name: string) {\n\t\tname = CoreAttribute.remap_name(name);\n\t\treturn this.user_data_attribs()[name];\n\t}\n\tis_attrib_indexed(name: string): boolean {\n\t\tname = CoreAttribute.remap_name(name);\n\t\treturn this.user_data_attrib(name) != null;\n\t}\n\n\thas_attrib(name: string): boolean {\n\t\tif (name === 'ptnum') {\n\t\t\treturn true;\n\t\t}\n\t\tname = CoreAttribute.remap_name(name);\n\t\treturn this._geometry.attributes[name] != null;\n\t}\n\tattrib_type(name: string) {\n\t\tif (this.is_attrib_indexed(name)) {\n\t\t\treturn CoreConstant.ATTRIB_TYPE.STRING;\n\t\t} else {\n\t\t\treturn CoreConstant.ATTRIB_TYPE.NUMERIC;\n\t\t}\n\t}\n\n\tattrib_names(): string[] {\n\t\treturn Object.keys(this._geometry.attributes);\n\t}\n\tattrib_sizes() {\n\t\tconst h: Dictionary<number> = {};\n\t\tfor (let attrib_name of this.attrib_names()) {\n\t\t\th[attrib_name] = this._geometry.attributes[attrib_name].itemSize;\n\t\t}\n\t\treturn h;\n\t}\n\tattrib_size(name: string): number {\n\t\tlet attrib;\n\t\tname = CoreAttribute.remap_name(name);\n\t\tif ((attrib = this._geometry.attributes[name]) != null) {\n\t\t\treturn attrib.itemSize;\n\t\t} else {\n\t\t\tif (name === 'ptnum') {\n\t\t\t\t// to ensure attrib copy with ptnum as source works\n\t\t\t\treturn 1;\n\t\t\t} else {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tset_indexed_attribute_values(name: string, values: string[]) {\n\t\tthis.user_data_attribs()[name] = values;\n\t}\n\n\tset_indexed_attribute(name: string, values: string[], indices: number[]) {\n\t\tthis.set_indexed_attribute_values(name, values);\n\t\tthis._geometry.setAttribute(name, new Int32BufferAttribute(indices, 1));\n\t}\n\n\tadd_numeric_attrib(name: string, size: number = 1, default_value: NumericAttribValue = 0) {\n\t\tconst values = [];\n\n\t\tlet attribute_added = false;\n\t\tif (lodash_isNumber(default_value)) {\n\t\t\t// adding number\n\t\t\tfor (let i = 0; i < this.points_count(); i++) {\n\t\t\t\tfor (let j = 0; j < size; j++) {\n\t\t\t\t\tvalues.push(default_value);\n\t\t\t\t}\n\t\t\t}\n\t\t\tattribute_added = true;\n\t\t} else {\n\t\t\tif (size > 1) {\n\t\t\t\tif (lodash_isArray(default_value)) {\n\t\t\t\t\t// adding array\n\t\t\t\t\tfor (let i = 0; i < this.points_count(); i++) {\n\t\t\t\t\t\tfor (let j = 0; j < size; j++) {\n\t\t\t\t\t\t\tvalues.push(default_value[j]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tattribute_added = true;\n\t\t\t\t} else {\n\t\t\t\t\t// adding Vector2\n\t\t\t\t\tconst vec2 = default_value as Vector2Like;\n\t\t\t\t\tif (size == 2 && vec2.x != null && vec2.y != null) {\n\t\t\t\t\t\tfor (let i = 0; i < this.points_count(); i++) {\n\t\t\t\t\t\t\tvalues.push(vec2.x);\n\t\t\t\t\t\t\tvalues.push(vec2.y);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tattribute_added = true;\n\t\t\t\t\t}\n\t\t\t\t\t// adding Vector3\n\t\t\t\t\tconst vec3 = default_value as Vector3Like;\n\t\t\t\t\tif (size == 3 && vec3.x != null && vec3.y != null && vec3.z != null) {\n\t\t\t\t\t\tfor (let i = 0; i < this.points_count(); i++) {\n\t\t\t\t\t\t\tvalues.push(vec3.x);\n\t\t\t\t\t\t\tvalues.push(vec3.y);\n\t\t\t\t\t\t\tvalues.push(vec3.z);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tattribute_added = true;\n\t\t\t\t\t}\n\t\t\t\t\t// adding Color\n\t\t\t\t\tconst col = default_value as ColorLike;\n\t\t\t\t\tif (size == 3 && col.r != null && col.g != null && col.b != null) {\n\t\t\t\t\t\tfor (let i = 0; i < this.points_count(); i++) {\n\t\t\t\t\t\t\tvalues.push(col.r);\n\t\t\t\t\t\t\tvalues.push(col.g);\n\t\t\t\t\t\t\tvalues.push(col.b);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tattribute_added = true;\n\t\t\t\t\t}\n\t\t\t\t\t// adding Vector4\n\t\t\t\t\tconst vec4 = default_value as Vector4Like;\n\t\t\t\t\tif (size == 4 && vec4.x != null && vec4.y != null && vec4.z != null && vec4.w != null) {\n\t\t\t\t\t\tfor (let i = 0; i < this.points_count(); i++) {\n\t\t\t\t\t\t\tvalues.push(vec4.x);\n\t\t\t\t\t\t\tvalues.push(vec4.y);\n\t\t\t\t\t\t\tvalues.push(vec4.z);\n\t\t\t\t\t\t\tvalues.push(vec4.w);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tattribute_added = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (attribute_added) {\n\t\t\tthis._geometry.setAttribute(name, new Float32BufferAttribute(values, size));\n\t\t} else {\n\t\t\tthrow 'no other default value allowed for now in add_numeric_attrib';\n\t\t}\n\t}\n\n\tinit_position_attribute(points_count: number, default_value?: Vector3) {\n\t\tconst values = [];\n\t\tif (default_value == null) {\n\t\t\tdefault_value = new Vector3();\n\t\t}\n\n\t\tfor (let i = 0; i < points_count; i++) {\n\t\t\tvalues.push(default_value.x);\n\t\t\tvalues.push(default_value.y);\n\t\t\tvalues.push(default_value.z);\n\t\t}\n\n\t\treturn this._geometry.setAttribute('position', new Float32BufferAttribute(values, 3));\n\t}\n\n\tadd_attribute(name: string, attrib_data: CoreAttributeData) {\n\t\tswitch (attrib_data.type()) {\n\t\t\tcase CoreConstant.ATTRIB_TYPE.STRING:\n\t\t\t\treturn console.log('TODO: to implement');\n\t\t\tcase CoreConstant.ATTRIB_TYPE.NUMERIC:\n\t\t\t\treturn this.add_numeric_attrib(name, attrib_data.size());\n\t\t}\n\t}\n\n\trename_attribute(old_name: string, new_name: string) {\n\t\tif (this.is_attrib_indexed(old_name)) {\n\t\t\tthis.user_data_attribs()[new_name] = lodash_clone(this.user_data_attribs()[old_name]);\n\t\t\tdelete this.user_data_attribs()[old_name];\n\t\t}\n\n\t\tconst old_attrib = this._geometry.getAttribute(old_name);\n\t\tthis._geometry.setAttribute(new_name, new Float32BufferAttribute(old_attrib.array, old_attrib.itemSize));\n\t\treturn this._geometry.deleteAttribute(old_name);\n\t}\n\n\tdelete_attribute(name: string) {\n\t\tif (this.is_attrib_indexed(name)) {\n\t\t\tdelete this.user_data_attribs()[name];\n\t\t}\n\n\t\treturn this._geometry.deleteAttribute(name);\n\t}\n\n\tclone(): BufferGeometry {\n\t\treturn CoreGeometry.clone(this._geometry);\n\t}\n\n\tstatic clone(src_geometry: BufferGeometry): BufferGeometry {\n\t\tlet src_userData;\n\n\t\t// monkey path\n\t\tfor (let attribute_name of Object.keys(src_geometry.attributes)) {\n\t\t\tconst attribute = src_geometry.getAttribute(attribute_name);\n\t\t\tif (attribute.constructor.name == InterleavedBufferAttribute.name) {\n\t\t\t\tMonkeyPatcher.patch(attribute as InterleavedBufferAttribute);\n\t\t\t}\n\t\t}\n\n\t\tconst new_geometry = src_geometry.clone();\n\t\tif ((src_userData = src_geometry.userData) != null) {\n\t\t\tnew_geometry.userData = lodash_cloneDeep(src_userData);\n\t\t}\n\t\treturn new_geometry;\n\t}\n\n\tpoints_count(): number {\n\t\treturn CoreGeometry.points_count(this._geometry);\n\t}\n\n\tstatic points_count(geometry: BufferGeometry): number {\n\t\tlet position;\n\t\tlet count = 0;\n\t\tconst core_geometry = new this(geometry);\n\t\tlet position_attrib_name = 'position';\n\t\tif (core_geometry.marked_as_instance()) {\n\t\t\tposition_attrib_name = 'instancePosition';\n\t\t}\n\n\t\tif ((position = geometry.getAttribute(position_attrib_name)) != null) {\n\t\t\tlet array;\n\t\t\tif ((array = position.array) != null) {\n\t\t\t\tcount = array.length / 3;\n\t\t\t}\n\t\t}\n\n\t\treturn count;\n\t}\n\n\t// TODO: use lodash_chunk\n\t// like: lodash_chunk(template_geometry.getAttribute('position').array, 3)\n\tpoints(): CorePoint[] {\n\t\treturn (this._points = this._points || this.points_from_geometry());\n\t}\n\treset_points() {\n\t\tthis._points = undefined;\n\t}\n\tpoints_from_geometry(): CorePoint[] {\n\t\tconst points = [];\n\t\tconst position_attrib = this._geometry.getAttribute(this.position_attrib_name());\n\n\t\tif (position_attrib != null) {\n\t\t\tconst points_count = position_attrib.array.length / 3;\n\t\t\tfor (let point_index = 0; point_index < points_count; point_index++) {\n\t\t\t\tconst point = new CorePoint(this, point_index);\n\n\t\t\t\t// lodash_each lodash_keys(@_geometry.attributes), (attrib_name) =>\n\n\t\t\t\t// \tattribute = @_geometry.getAttribute(attrib_name)\n\t\t\t\t// \titem_size = attribute.itemSize\n\t\t\t\t// \tcurrent_index = point_index  *item_size\n\n\t\t\t\t// \tattrib_value = switch item_size\n\t\t\t\t// \t\twhen 1\n\t\t\t\t// \t\t\tattribute.array[current_index]\n\t\t\t\t// \t\twhen 2\n\t\t\t\t// \t\t\tnew Vector2(\n\t\t\t\t// \t\t\t\tattribute.array[current_index + 0]\n\t\t\t\t// \t\t\t\tattribute.array[current_index + 1]\n\t\t\t\t// \t\t\t\t)\n\t\t\t\t// \t\twhen 3\n\t\t\t\t// \t\t\tnew Vector3(\n\t\t\t\t// \t\t\t\tattribute.array[current_index + 0]\n\t\t\t\t// \t\t\t\tattribute.array[current_index + 1]\n\t\t\t\t// \t\t\t\tattribute.array[current_index + 2]\n\t\t\t\t// \t\t\t\t)\n\n\t\t\t\t// \tpoint.add_attribute(attrib_name, item_size, attrib_value)\n\n\t\t\t\tpoints.push(point);\n\t\t\t}\n\t\t}\n\n\t\treturn points;\n\t}\n\n\tstatic geometry_from_points(points: CorePoint[], object_type: ObjectType): BufferGeometry {\n\t\tconst geometry = new BufferGeometry();\n\t\tconst geometry_wrapper = new this(geometry);\n\n\t\tconst first_point = points[0];\n\t\tif (first_point != null) {\n\t\t\tconst old_geometry = first_point.geometry();\n\t\t\tconst old_geometry_wrapper = first_point.geometry_wrapper();\n\n\t\t\t// index\n\t\t\tconst new_index_by_old_index: Dictionary<number> = {};\n\t\t\tlodash_each(points, (point, i) => (new_index_by_old_index[point.index] = i));\n\n\t\t\tconst indices = this._indices_from_points(new_index_by_old_index, old_geometry, object_type);\n\t\t\tif (indices != null && indices.length !== 0) {\n\t\t\t\tgeometry.setIndex(indices);\n\t\t\t}\n\n\t\t\t// attributes\n\t\t\tconst {attributes} = old_geometry;\n\t\t\t// const new_attributes = {}\n\t\t\tfor (let attribute_name of Object.keys(attributes)) {\n\t\t\t\tconst attrib_values = old_geometry_wrapper.user_data_attribs()[attribute_name];\n\t\t\t\tconst is_attrib_indexed = attrib_values != null;\n\n\t\t\t\tif (is_attrib_indexed) {\n\t\t\t\t\tconst new_values = lodash_uniq(points.map((point) => point.attrib_value(attribute_name)));\n\t\t\t\t\tconst new_index_by_value: Dictionary<number> = {};\n\t\t\t\t\tlodash_each(new_values, (new_value, i) => (new_index_by_value[new_value] = i));\n\n\t\t\t\t\tgeometry_wrapper.user_data_attribs()[attribute_name] = new_values;\n\n\t\t\t\t\t// const old_attrib = old_geometry.getAttribute(attribute_name)\n\t\t\t\t\t// const old_attrib_array = old_attrib.array\n\t\t\t\t\tconst new_attrib_indices = [];\n\t\t\t\t\tfor (let point of points) {\n\t\t\t\t\t\t// const old_index = old_attrib_array[point.index()]\n\t\t\t\t\t\tconst new_index = new_index_by_value[point.attrib_value(attribute_name)];\n\t\t\t\t\t\tnew_attrib_indices.push(new_index);\n\t\t\t\t\t}\n\n\t\t\t\t\tgeometry.setAttribute(attribute_name, new Float32BufferAttribute(new_attrib_indices, 1));\n\t\t\t\t} else {\n\t\t\t\t\tconst values = [];\n\t\t\t\t\tconst attrib_size = attributes[attribute_name].itemSize;\n\t\t\t\t\tfor (let point of points) {\n\t\t\t\t\t\tconst value = point.attrib_value(attribute_name);\n\t\t\t\t\t\tswitch (attrib_size) {\n\t\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\t\tvalues.push(value);\n\t\t\t\t\t\t\tcase 3:\n\t\t\t\t\t\t\t\tvalues.push(value.x);\n\t\t\t\t\t\t\t\tvalues.push(value.y);\n\t\t\t\t\t\t\t\tvalues.push(value.z);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tgeometry.setAttribute(attribute_name, new Float32BufferAttribute(values, attrib_size));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn geometry;\n\t}\n\n\tstatic _indices_from_points(\n\t\tnew_index_by_old_index: Dictionary<number>,\n\t\told_geometry: BufferGeometry,\n\t\tobject_type: ObjectType\n\t) {\n\t\tconst index_attrib = old_geometry.index;\n\t\tif (index_attrib != null) {\n\t\t\tconst old_indices = index_attrib.array;\n\n\t\t\tconst new_indices: number[] = [];\n\n\t\t\tswitch (object_type) {\n\t\t\t\tcase CoreConstant.OBJECT_TYPE.POINTS:\n\t\t\t\t\tlodash_each(old_indices, function (old_index, i: number) {\n\t\t\t\t\t\tconst new_index = new_index_by_old_index[old_index];\n\t\t\t\t\t\tif (new_index != null) {\n\t\t\t\t\t\t\tnew_indices.push(new_index);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase CoreConstant.OBJECT_TYPE.MESH:\n\t\t\t\t\tlodash_each(old_indices, function (old_index, i: number) {\n\t\t\t\t\t\tif (i % 3 === 0) {\n\t\t\t\t\t\t\tconst old_index0 = old_indices[i];\n\t\t\t\t\t\t\tconst old_index1 = old_indices[i + 1];\n\t\t\t\t\t\t\tconst old_index2 = old_indices[i + 2];\n\t\t\t\t\t\t\tconst new_index0 = new_index_by_old_index[old_index0];\n\t\t\t\t\t\t\tconst new_index1 = new_index_by_old_index[old_index1];\n\t\t\t\t\t\t\tconst new_index2 = new_index_by_old_index[old_index2];\n\t\t\t\t\t\t\tif (new_index0 != null && new_index1 != null && new_index2 != null) {\n\t\t\t\t\t\t\t\tnew_indices.push(new_index0);\n\t\t\t\t\t\t\t\tnew_indices.push(new_index1);\n\t\t\t\t\t\t\t\tnew_indices.push(new_index2);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase CoreConstant.OBJECT_TYPE.LINE_SEGMENTS:\n\t\t\t\t\tlodash_each(old_indices, function (old_index, i: number) {\n\t\t\t\t\t\tif (i % 2 === 0) {\n\t\t\t\t\t\t\tconst old_index0 = old_indices[i];\n\t\t\t\t\t\t\tconst old_index1 = old_indices[i + 1];\n\t\t\t\t\t\t\tconst new_index0 = new_index_by_old_index[old_index0];\n\t\t\t\t\t\t\tconst new_index1 = new_index_by_old_index[old_index1];\n\t\t\t\t\t\t\tif (new_index0 != null && new_index1 != null) {\n\t\t\t\t\t\t\t\tnew_indices.push(new_index0);\n\t\t\t\t\t\t\t\tnew_indices.push(new_index1);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\treturn new_indices;\n\t\t}\n\t}\n\n\tstatic merge_geometries(geometries: BufferGeometry[]) {\n\t\tif (geometries.length === 0) {\n\t\t\treturn;\n\t\t}\n\n\t\t//\n\t\t// 1/3. set the new attrib indices for the indexed attributes\n\t\t//\n\t\tconst core_geometries = geometries.map((geometry) => new CoreGeometry(geometry));\n\t\tconst indexed_attribute_names = core_geometries[0].indexed_attribute_names();\n\n\t\tconst new_values_by_attribute_name: Dictionary<string[]> = {};\n\t\tfor (let indexed_attribute_name of indexed_attribute_names) {\n\t\t\tconst index_by_values: Dictionary<number> = {};\n\t\t\tconst all_geometries_points = [];\n\t\t\tfor (let core_geometry of core_geometries) {\n\t\t\t\tconst geometry_points = core_geometry.points();\n\t\t\t\tfor (let point of geometry_points) {\n\t\t\t\t\tall_geometries_points.push(point);\n\t\t\t\t\tconst value = point.attrib_value(indexed_attribute_name);\n\t\t\t\t\t//value_index = point.attrib_value_index(indexed_attribute_name)\n\t\t\t\t\t// TODO: typescript: that doesn't seem right\n\t\t\t\t\tindex_by_values[value] != null\n\t\t\t\t\t\t? index_by_values[value]\n\t\t\t\t\t\t: (index_by_values[value] = Object.keys(index_by_values).length);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst values = Object.keys(index_by_values);\n\t\t\tfor (let point of all_geometries_points) {\n\t\t\t\tconst value = point.attrib_value(indexed_attribute_name);\n\t\t\t\tconst new_index = index_by_values[value];\n\t\t\t\tpoint.set_attrib_index(indexed_attribute_name, new_index);\n\t\t\t}\n\n\t\t\tnew_values_by_attribute_name[indexed_attribute_name] = values;\n\t\t}\n\n\t\t//\n\t\t// 2/3. merge the geos\n\t\t//\n\t\tconst merged_geometry = BufferGeometryUtils.mergeBufferGeometries(geometries);\n\n\t\t//\n\t\t// 3/3. add the index attrib values\n\t\t//\n\n\t\tconst merged_geometry_wrapper = new this(merged_geometry);\n\t\tObject.keys(new_values_by_attribute_name).forEach((indexed_attribute_name) => {\n\t\t\tconst values = new_values_by_attribute_name[indexed_attribute_name];\n\t\t\tmerged_geometry_wrapper.set_indexed_attribute_values(indexed_attribute_name, values);\n\t\t});\n\n\t\tif (merged_geometry) {\n\t\t\tdelete merged_geometry.userData.mergedUserData;\n\t\t}\n\n\t\treturn merged_geometry;\n\t}\n\n\tsegments() {\n\t\t// const points = this.points();\n\t\tconst index = this.geometry().index?.array || [];\n\t\treturn lodash_chunk(index, 2);\n\t}\n\n\tfaces(): CoreFace[] {\n\t\treturn this.faces_from_geometry();\n\t}\n\tfaces_from_geometry(): CoreFace[] {\n\t\tconst index_array = this.geometry().index?.array || [];\n\t\tconst faces_count = index_array.length / 3;\n\t\treturn lodash_range(faces_count).map((i) => new CoreFace(this, i));\n\t}\n}\n\n// segments_count = 0.5*index.length\n// segments = []\n// lodash_times segments_count, (i)->\n// \tindices = [i, i+1]\n// \tsegments.push(indices) #lodash_map(indices, (index)->points[index])\n\n// segments\n","import {Vector3} from 'three/src/math/Vector3';\nimport {Vector2} from 'three/src/math/Vector2';\nimport {Object3D} from 'three/src/core/Object3D';\nimport {Mesh} from 'three/src/objects/Mesh';\nimport {Color} from 'three/src/math/Color';\nimport {BufferGeometry} from 'three/src/core/BufferGeometry';\nimport {AnimationClip} from 'three/src/animation/AnimationClip';\nimport {Material} from 'three/src/materials/Material';\nimport {SkinnedMesh} from 'three/src/objects/SkinnedMesh';\nimport {Bone} from 'three/src/objects/Bone';\n\n// import {CoreConstant} from './Constant'\nimport {CoreGeometry} from './Geometry';\nimport {GroupString} from './Group';\nimport {CoreAttribute} from './Attribute';\nimport {CoreConstant} from './Constant';\nimport {CorePoint} from './Point';\nimport {CoreMaterial, ShaderMaterialWithCustomMaterials} from './Material';\nimport {CoreString} from '../String';\n\nimport lodash_cloneDeep from 'lodash/cloneDeep';\nimport lodash_isString from 'lodash/isString';\nimport lodash_isArray from 'lodash/isArray';\nimport lodash_isNumber from 'lodash/isNumber';\nimport {CoreEntity} from './Entity';\nconst PTNUM = 'ptnum';\nconst NAME_ATTR = 'name';\nconst ATTRIBUTES = 'attributes';\n\ninterface Object3DWithAnimations extends Object3D {\n\tanimations: AnimationClip[];\n}\ninterface MaterialWithColor extends Material {\n\tcolor: Color;\n}\n// interface SkinnedMeshWithisSkinnedMesh extends SkinnedMesh {\n// \treadonly isSkinnedMesh: boolean;\n// }\n\nexport class CoreObject extends CoreEntity {\n\tconstructor(private _object: Object3D, index: number) {\n\t\tsuper(index);\n\t\tif (this._object.userData[ATTRIBUTES] == null) {\n\t\t\tthis._object.userData[ATTRIBUTES] = {};\n\t\t}\n\t}\n\n\t// set_index(i: number) {\n\t// \tthis._index = i;\n\t// }\n\n\tobject() {\n\t\treturn this._object;\n\t}\n\tgeometry(): BufferGeometry | null {\n\t\treturn (this._object as Mesh).geometry as BufferGeometry | null;\n\t}\n\tcore_geometry(): CoreGeometry | null {\n\t\tconst geo = this.geometry();\n\t\tif (geo) {\n\t\t\treturn new CoreGeometry(geo);\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t\t// const geo = this.geometry()\n\t\t// if (geo) {\n\t\t// \treturn new CoreGeometry(geo)\n\t\t// } else {\n\t\t// \treturn null\n\t\t// }\n\t}\n\tpoints() {\n\t\treturn this.core_geometry()?.points() || [];\n\t}\n\tpoints_from_group(group: GroupString): CorePoint[] {\n\t\tif (group) {\n\t\t\tconst indices = CoreString.indices(group);\n\t\t\tif (indices) {\n\t\t\t\tconst points = this.points();\n\t\t\t\treturn indices.map((i) => points[i]);\n\t\t\t} else {\n\t\t\t\treturn [];\n\t\t\t}\n\t\t} else {\n\t\t\treturn this.points();\n\t\t}\n\t}\n\n\tcompute_vertex_normals() {\n\t\tthis.core_geometry()?.compute_vertex_normals();\n\t}\n\n\tadd_attribute(name: string, value: AttribValue) {\n\t\tlet data;\n\t\tif (!lodash_isNumber(value) && !lodash_isArray(value) && !lodash_isString(value)) {\n\t\t\tdata = (value as Vector3).toArray();\n\t\t} else {\n\t\t\tdata = value;\n\t\t}\n\t\tthis._object.userData[ATTRIBUTES][name] = data;\n\t}\n\tadd_numeric_attrib(name: string, value: NumericAttribValue) {\n\t\tthis.add_attribute(name, value);\n\t}\n\tset_attrib_value(name: string, value: AttribValue) {\n\t\tthis.add_attribute(name, value);\n\t}\n\tadd_numeric_vertex_attrib(name: string, size: number, default_value: NumericAttribValue) {\n\t\tif (default_value == null) {\n\t\t\tdefault_value = CoreAttribute.default_value(size);\n\t\t}\n\t\tthis.core_geometry()?.add_numeric_attrib(name, size, default_value);\n\t}\n\n\tattribute_names(): string[] {\n\t\t// TODO: to remove\n\t\treturn Object.keys(this._object.userData[ATTRIBUTES]);\n\t}\n\tattrib_names(): string[] {\n\t\treturn this.attribute_names();\n\t}\n\n\thas_attrib(name: string): boolean {\n\t\treturn this.attribute_names().includes(name);\n\t}\n\n\trename_attribute(old_name: string, new_name: string) {\n\t\tthis.add_attribute(new_name, this.attrib_value(old_name));\n\t\tthis.delete_attribute(old_name);\n\t}\n\n\tdelete_attribute(name: string) {\n\t\tdelete this._object.userData[ATTRIBUTES][name];\n\t}\n\n\tattrib_value(name: string): AttribValue {\n\t\tif (name === PTNUM) {\n\t\t\treturn this.index;\n\t\t} else {\n\t\t\tlet val = this._object.userData[ATTRIBUTES][name];\n\t\t\tif (val == null) {\n\t\t\t\tif (name == NAME_ATTR) {\n\t\t\t\t\tval = this._object.name;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn val;\n\t\t}\n\t}\n\tname(): string {\n\t\treturn this.attrib_value(NAME_ATTR) as string;\n\t}\n\thuman_type(): string {\n\t\treturn CoreConstant.CONSTRUCTOR_NAMES_BY_CONSTRUCTOR_NAME[this._object.constructor.name];\n\t}\n\n\tattrib_type(name: string) {\n\t\tconst val = this.attrib_value(name);\n\t\tif (lodash_isString(val)) {\n\t\t\treturn CoreConstant.ATTRIB_TYPE.STRING;\n\t\t} else {\n\t\t\treturn CoreConstant.ATTRIB_TYPE.NUMERIC;\n\t\t}\n\t}\n\n\tattrib_size(name: string) {\n\t\tconst val = this.attrib_value(name);\n\t\tif (val == null) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (lodash_isString(val) || lodash_isNumber(val)) {\n\t\t\treturn 1;\n\t\t} else {\n\t\t\tswitch (val.constructor) {\n\t\t\t\tcase Vector2:\n\t\t\t\t\treturn 2;\n\t\t\t\tcase Vector3:\n\t\t\t\t\treturn 3;\n\t\t\t\tdefault:\n\t\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tclone() {\n\t\treturn CoreObject.clone(this._object);\n\t}\n\n\tstatic clone(src_object: Object3D) {\n\t\tconst new_object = src_object.clone();\n\n\t\tvar sourceLookup = new Map<Object3D, Object3D>();\n\t\tvar cloneLookup = new Map<Object3D, Object3D>();\n\t\tCoreObject.parallelTraverse(src_object, new_object, function (sourceNode: Object3D, clonedNode: Object3D) {\n\t\t\tsourceLookup.set(clonedNode, sourceNode);\n\t\t\tcloneLookup.set(sourceNode, clonedNode);\n\t\t});\n\t\tnew_object.traverse(function (node) {\n\t\t\tconst src_node = sourceLookup.get(node) as SkinnedMesh;\n\t\t\tconst mesh_node = node as Mesh;\n\n\t\t\tif (mesh_node.geometry) {\n\t\t\t\tconst src_node_geometry = src_node.geometry as BufferGeometry;\n\t\t\t\tmesh_node.geometry = CoreGeometry.clone(src_node_geometry);\n\t\t\t\tconst mesh_node_geometry = mesh_node.geometry as BufferGeometry;\n\t\t\t\tif (mesh_node_geometry.userData) {\n\t\t\t\t\tmesh_node_geometry.userData = lodash_cloneDeep(src_node_geometry.userData);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (mesh_node.material) {\n\t\t\t\tmesh_node.material = src_node.material;\n\t\t\t\tCoreMaterial.apply_custom_materials(node, mesh_node.material as ShaderMaterialWithCustomMaterials);\n\n\t\t\t\t// prevents crashes for linesegments with shader material such as the line dashed instance\n\t\t\t\t// TODO: test\n\t\t\t\tconst material_with_color = mesh_node.material as MaterialWithColor;\n\t\t\t\tif (material_with_color.color == null) {\n\t\t\t\t\tmaterial_with_color.color = new Color(1, 1, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (src_object.userData) {\n\t\t\t\tnode.userData = lodash_cloneDeep(src_node.userData);\n\t\t\t}\n\n\t\t\tconst src_node_with_animations = (<unknown>src_node) as Object3DWithAnimations;\n\t\t\tif (src_node_with_animations.animations) {\n\t\t\t\t(node as Object3DWithAnimations).animations = src_node_with_animations.animations.map((animation) =>\n\t\t\t\t\tanimation.clone()\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tconst skinned_node = node as SkinnedMesh;\n\t\t\tif (skinned_node.isSkinnedMesh) {\n\t\t\t\tvar clonedMesh = skinned_node;\n\t\t\t\tvar sourceMesh = src_node;\n\t\t\t\tvar sourceBones = sourceMesh.skeleton.bones;\n\n\t\t\t\tclonedMesh.skeleton = sourceMesh.skeleton.clone();\n\t\t\t\tclonedMesh.bindMatrix.copy(sourceMesh.bindMatrix);\n\n\t\t\t\tconst new_bones = sourceBones.map(function (bone) {\n\t\t\t\t\treturn cloneLookup.get(bone);\n\t\t\t\t}) as Bone[];\n\n\t\t\t\tclonedMesh.skeleton.bones = new_bones;\n\n\t\t\t\tclonedMesh.bind(clonedMesh.skeleton, clonedMesh.bindMatrix);\n\t\t\t}\n\t\t});\n\n\t\treturn new_object;\n\t}\n\n\tstatic parallelTraverse(a: Object3D, b: Object3D, callback: (a: Object3D, b: Object3D) => void) {\n\t\tcallback(a, b);\n\t\tfor (var i = 0; i < a.children.length; i++) {\n\t\t\tthis.parallelTraverse(a.children[i], b.children[i], callback);\n\t\t}\n\t}\n}\n","import lodash_uniq from 'lodash/uniq';\nimport lodash_compact from 'lodash/compact';\nimport lodash_isNaN from 'lodash/isNaN';\nimport lodash_trim from 'lodash/trim';\nimport lodash_flatten from 'lodash/flatten';\nimport lodash_sum from 'lodash/sum';\nimport {Vector3} from 'three/src/math/Vector3';\nimport {Points} from 'three/src/objects/Points';\nimport {Object3D} from 'three/src/core/Object3D';\nimport {Mesh} from 'three/src/objects/Mesh';\nimport {LineSegments} from 'three/src/objects/LineSegments';\nimport {Group} from 'three/src/objects/Group';\nimport {BufferGeometry} from 'three/src/core/BufferGeometry';\nimport {Box3} from 'three/src/math/Box3';\n// const THREE = {Box3, BufferGeometry, Group, LineSegments, Mesh, Object3D, Points, Vector3}\nimport {CoreObject} from './Object';\nimport {CoreGeometry} from './Geometry';\nimport {CoreAttribute} from './Attribute';\n// import {Core} from '../_Module'\nimport {CoreString} from '../String';\nimport {CoreConstant, AttribClass} from './Constant';\n\n// import './MonkeyPatch'\n\nexport type GroupString = string;\n\nexport interface Object3DWithGeometry extends Object3D {\n\tgeometry: BufferGeometry;\n}\n\nexport class CoreGroup {\n\t// _group: Group\n\tprivate _timestamp: number | undefined;\n\t// _core_objects:\n\tprivate _objects: Object3D[] | undefined;\n\tprivate _core_objects: CoreObject[] | undefined;\n\n\t// _geometries: BufferGeometry[];\n\tprivate _core_geometries: CoreGeometry[] | undefined;\n\n\tprivate _bounding_box: Box3 | undefined;\n\t// private _bounding_sphere: Sphere | undefined;\n\n\tconstructor() {\n\t\t//_group: Group){\n\t\t// this._group = _group;\n\t\tthis.touch();\n\t}\n\n\t//\n\t//\n\t// TIMESTAMP\n\t//\n\t//\n\ttimestamp() {\n\t\treturn this._timestamp;\n\t}\n\ttouch() {\n\t\tthis._timestamp = performance.now();\n\t\tthis.reset();\n\t}\n\treset() {\n\t\tthis._bounding_box = undefined;\n\t\t// this._bounding_sphere = undefined;\n\t\tthis._core_geometries = undefined;\n\t\tthis._core_objects = undefined;\n\t}\n\n\t//\n\t//\n\t// CLONE\n\t//\n\t//\n\tclone() {\n\t\tconst core_group = new CoreGroup();\n\t\tif (this._objects) {\n\t\t\tconst objects = [];\n\t\t\tfor (let object of this._objects) {\n\t\t\t\tobjects.push(CoreObject.clone(object));\n\t\t\t}\n\t\t\tcore_group.set_objects(objects);\n\t\t}\n\t\treturn core_group;\n\t}\n\t//\n\t//\n\t// OBJECTS\n\t//\n\t//\n\tset_objects(objects: Object3D[]) {\n\t\tthis._objects = objects;\n\t\tthis.touch();\n\t}\n\tobjects() {\n\t\treturn this._objects as Object3DWithGeometry[];\n\t}\n\tcore_objects() {\n\t\treturn (this._core_objects = this._core_objects || this._create_core_objects());\n\t}\n\tprivate _create_core_objects(): CoreObject[] {\n\t\tconst list: CoreObject[] = [];\n\t\tif (this._objects) {\n\t\t\tfor (let i = 0; i < this._objects.length; i++) {\n\t\t\t\tthis._objects[i].traverse((object) => {\n\t\t\t\t\tconst core_object = new CoreObject(object, i);\n\t\t\t\t\tlist.push(core_object);\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t\treturn list;\n\t}\n\n\t// group() {\n\t// \treturn this._group;\n\t// }\n\t// uuid() {\n\t// \treturn this._group.uuid;\n\t// }\n\n\tgeometries(): BufferGeometry[] {\n\t\t// this._geometries = [];\n\t\t// for (let object of this._objects) {\n\t\t// \tobject.traverse((object) => this.__geometry_from_object.bind(this)(this._geometries, object));\n\t\t// \t// \tconst geometry = this.geometry_from_object(object)\n\t\t// \t// \tif (geometry != null) {\n\t\t// \t// \t\treturn list.push(new CoreGeometry(geometry));\n\t\t// \t// \t}\n\t\t// \t// });\n\t\t// }\n\t\t// return this._geometries;\n\t\tconst list: BufferGeometry[] = [];\n\t\tfor (let core_object of this.core_objects()) {\n\t\t\tconst geometry = (core_object.object() as Mesh).geometry as BufferGeometry;\n\t\t\tif (geometry) {\n\t\t\t\tlist.push(geometry);\n\t\t\t}\n\t\t}\n\t\treturn list;\n\t}\n\tcore_geometries(): CoreGeometry[] {\n\t\treturn (this._core_geometries = this._core_geometries || this.create_core_geometries());\n\t}\n\tprivate create_core_geometries() {\n\t\tconst list: CoreGeometry[] = [];\n\t\tfor (let geometry of this.geometries()) {\n\t\t\tlist.push(new CoreGeometry(geometry));\n\t\t\t// object.traverse(object=> this.__core_geometry_from_object.bind(this)(this._core_geometries, object))\n\t\t\t// \tconst geometry = this.geometry_from_object(object)\n\t\t\t// \tif (geometry != null) {\n\t\t\t// \t\treturn list.push(new CoreGeometry(geometry));\n\t\t\t// \t}\n\t\t\t// });\n\t\t}\n\t\treturn list;\n\t}\n\t__geometry_from_object(list: BufferGeometry[], object: Mesh) {\n\t\tif (object.geometry) {\n\t\t\treturn list.push(object.geometry as BufferGeometry);\n\t\t}\n\t}\n\t// __core_geometry_from_object(list, object){\n\t// \tconst geometry = CoreGroup.geometry_from_object(object)\n\t// \tif (geometry != null) {\n\t// \t\treturn list.push(new CoreGeometry(geometry));\n\t// \t}\n\t// }\n\tstatic geometry_from_object(object: Object3D): BufferGeometry | null {\n\t\tif ((object as Mesh).isMesh || (object as LineSegments).isLine || (object as Points).isPoints) {\n\t\t\treturn (object as Mesh).geometry as BufferGeometry;\n\t\t}\n\t\treturn null;\n\t}\n\tfaces() {\n\t\treturn lodash_flatten(this.core_geometries().map((g) => g.faces()));\n\t}\n\tpoints() {\n\t\treturn lodash_flatten(this.core_geometries().map((g) => g.points()));\n\t}\n\tpoints_count() {\n\t\treturn lodash_sum(this.core_geometries().map((g) => g.points_count()));\n\t}\n\tpoints_from_group(group: GroupString) {\n\t\tif (group) {\n\t\t\tconst indices = CoreString.indices(group);\n\t\t\tconst points = this.points();\n\t\t\treturn lodash_compact(indices.map((i) => points[i]));\n\t\t} else {\n\t\t\treturn this.points();\n\t\t}\n\t}\n\n\tstatic from_objects(objects: Object3D[]): CoreGroup {\n\t\tconst core_group = new CoreGroup();\n\t\tcore_group.set_objects(objects);\n\t\treturn core_group;\n\t}\n\n\t// objects() {\n\t// \treturn this._objects = lodash_map(this._group.children, (object, i)=> {\n\t// \t\tconst object_wrapper = new CoreObject(object);\n\t// \t\tobject_wrapper.set_index(i);\n\t// \t\treturn object_wrapper;\n\t// \t});\n\t// }\n\tobjects_from_group(group_name: string): Object3D[] {\n\t\treturn this.core_objects_from_group(group_name).map((co) => co.object());\n\t}\n\tcore_objects_from_group(group_name: string): CoreObject[] {\n\t\tgroup_name = lodash_trim(group_name);\n\n\t\tif (group_name !== '') {\n\t\t\tconst index = parseInt(group_name);\n\t\t\tif (!lodash_isNaN(index)) {\n\t\t\t\treturn lodash_compact([this.core_objects()[index]]);\n\t\t\t} else {\n\t\t\t\treturn this.core_objects().filter((core_object) => {\n\t\t\t\t\treturn CoreString.match_mask(group_name, core_object.name());\n\t\t\t\t});\n\t\t\t}\n\t\t} else {\n\t\t\treturn this.core_objects();\n\t\t}\n\t}\n\n\t// reset: ->\n\t// \t@_geometries = []\n\t// \t@_points = []\n\n\t// _find_geometries: ->\n\t// \tlist = []\n\t// \t@_group.traverse (object)=>\n\t// \t\tif (geometry = object.geometry)?\n\t// \t\t\tlist.push new Geometry(geometry)\n\t// \tlist\n\n\t// _find_points: ->\n\t// \tlodash_flatten( lodash_map(this.objects(), (g)->g.points()) )\n\n\t// bounding_box() {\n\t// \treturn new Box3().setFromObject(this._group);\n\t// }\n\tbounding_box(): Box3 {\n\t\treturn (this._bounding_box = this._bounding_box || this._compute_bounding_box());\n\t}\n\t// bounding_sphere(): Sphere {\n\t// \treturn (this._bounding_sphere = this._bounding_sphere || this._compute_bounding_sphere());\n\t// }\n\tcenter(): Vector3 {\n\t\tconst center = new Vector3();\n\t\tthis.bounding_box().getCenter(center);\n\t\treturn center;\n\t}\n\tsize(): Vector3 {\n\t\tconst size = new Vector3();\n\t\tthis.bounding_box().getSize(size);\n\t\treturn size;\n\t}\n\n\tprivate _compute_bounding_box() {\n\t\tlet bbox: Box3 | undefined; // = new Box3();\n\t\tif (this._objects) {\n\t\t\tfor (let object of this._objects) {\n\t\t\t\tconst geometry = (object as Object3DWithGeometry).geometry;\n\t\t\t\tif (geometry) {\n\t\t\t\t\tgeometry.computeBoundingBox();\n\t\t\t\t\tif (bbox) {\n\t\t\t\t\t\tbbox.expandByObject(object);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (geometry.boundingBox) {\n\t\t\t\t\t\t\tbbox = geometry.boundingBox.clone();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbbox = bbox || new Box3(new Vector3(-1, -1, -1), new Vector3(+1, +1, +1));\n\t\treturn bbox;\n\t}\n\t// private _compute_bounding_sphere() {\n\t// \tlet sphere: Sphere | undefined; // = new Box3();\n\t// \tif (this._objects) {\n\t// \t\tfor (let object of this._objects) {\n\t// \t\t\tconst geometry = (object as Object3DWithGeometry).geometry;\n\t// \t\t\tgeometry.computeBoundingSphere();\n\t// \t\t\tif (sphere) {\n\t// \t\t\t\tsphere.expandByObject(object);\n\t// \t\t\t} else {\n\t// \t\t\t\tsphere = geometry.boundingBox.clone();\n\t// \t\t\t}\n\t// \t\t}\n\t// \t}\n\t// \tsphere = sphere || new Sphere(new Vector3(0, 0, 0), 1);\n\t// \treturn sphere;\n\t// }\n\tcompute_vertex_normals() {\n\t\tfor (let object of this.core_objects()) {\n\t\t\tobject.compute_vertex_normals();\n\t\t}\n\t}\n\n\thas_attrib(name: string) {\n\t\tlet first_geometry;\n\t\tif ((first_geometry = this.core_geometries()[0]) != null) {\n\t\t\treturn first_geometry.has_attrib(name);\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\tattrib_type(name: string) {\n\t\tconst first_geometry = this.core_geometries()[0];\n\t\tif (first_geometry != null) {\n\t\t\treturn first_geometry.attrib_type(name);\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\trename_attrib(old_name: string, new_name: string, attrib_class: AttribClass) {\n\t\tswitch (attrib_class) {\n\t\t\tcase CoreConstant.ATTRIB_CLASS.VERTEX:\n\t\t\t\tif (this.has_attrib(old_name)) {\n\t\t\t\t\tif (this._objects) {\n\t\t\t\t\t\tfor (let object of this._objects) {\n\t\t\t\t\t\t\tobject.traverse((child) => {\n\t\t\t\t\t\t\t\tconst geometry = CoreGroup.geometry_from_object(child);\n\t\t\t\t\t\t\t\tif (geometry) {\n\t\t\t\t\t\t\t\t\tconst core_geometry = new CoreGeometry(geometry);\n\t\t\t\t\t\t\t\t\tcore_geometry.rename_attribute(old_name, new_name);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase CoreConstant.ATTRIB_CLASS.OBJECT:\n\t\t\t\tif (this.has_attrib(old_name)) {\n\t\t\t\t\tif (this._objects) {\n\t\t\t\t\t\tfor (let object of this._objects) {\n\t\t\t\t\t\t\tobject.traverse((child) => {\n\t\t\t\t\t\t\t\tconst core_object = new CoreObject(child, 0);\n\t\t\t\t\t\t\t\tcore_object.rename_attribute(old_name, new_name);\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tattrib_names() {\n\t\tlet first_geometry;\n\t\tif ((first_geometry = this.core_geometries()[0]) != null) {\n\t\t\treturn first_geometry.attrib_names();\n\t\t} else {\n\t\t\treturn [];\n\t\t}\n\t}\n\tobject_attrib_names() {\n\t\tlet first_object;\n\t\tif ((first_object = this.core_objects()[0]) != null) {\n\t\t\treturn first_object.attrib_names();\n\t\t} else {\n\t\t\treturn [];\n\t\t}\n\t}\n\n\tattrib_names_matching_mask(masks_string: GroupString) {\n\t\tconst masks = CoreString.attrib_names(masks_string);\n\n\t\tconst matching_attrib_names = [];\n\t\tfor (let attrib_name of this.attrib_names()) {\n\t\t\tfor (let mask of masks) {\n\t\t\t\tif (CoreString.match_mask(attrib_name, mask)) {\n\t\t\t\t\tmatching_attrib_names.push(attrib_name);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn lodash_uniq(matching_attrib_names);\n\t}\n\n\tattrib_sizes() {\n\t\tlet first_geometry;\n\t\tif ((first_geometry = this.core_geometries()[0]) != null) {\n\t\t\treturn first_geometry.attrib_sizes();\n\t\t} else {\n\t\t\treturn {};\n\t\t}\n\t}\n\tattrib_size(attrib_name: string) {\n\t\tlet first_geometry;\n\t\tif ((first_geometry = this.core_geometries()[0]) != null) {\n\t\t\treturn first_geometry.attrib_size(attrib_name);\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tadd_numeric_vertex_attrib(name: string, size: number, default_value: NumericAttribValue) {\n\t\tif (default_value == null) {\n\t\t\tdefault_value = CoreAttribute.default_value(size);\n\t\t}\n\n\t\tfor (let core_geometry of this.core_geometries()) {\n\t\t\tcore_geometry.add_numeric_attrib(name, size, default_value);\n\t\t}\n\t}\n\n\tadd_numeric_object_attrib(name: string, size: number, default_value: NumericAttribValue) {\n\t\tif (default_value == null) {\n\t\t\tdefault_value = CoreAttribute.default_value(size);\n\t\t}\n\n\t\tfor (let core_object of this.core_objects()) {\n\t\t\tcore_object.add_numeric_attrib(name, default_value);\n\t\t}\n\t}\n\n\tstatic clone(src_group: Group) {\n\t\tconst new_group = new Group();\n\n\t\tsrc_group.children.forEach((src_object) => {\n\t\t\tconst new_object = CoreObject.clone(src_object);\n\t\t\tnew_group.add(new_object);\n\t\t});\n\n\t\treturn new_group;\n\t}\n}\n","import {Vector3} from 'three/src/math/Vector3';\n// import {Object3D} from 'three/src/core/Object3D'\n// import {Group} from 'three/src/objects/Group'\nimport {Mesh} from 'three/src/objects/Mesh';\nimport {Box3} from 'three/src/math/Box3';\nimport {TypedContainer} from './_Base';\nimport {CoreGroup} from '../../core/geometry/Group';\n// import {CoreObject} from '../../core/geometry/Object'\nimport {CoreGeometry} from '../../core/geometry/Geometry';\nimport {BufferGeometry} from 'three/src/core/BufferGeometry';\nimport {Object3D} from 'three/src/core/Object3D';\nimport {ContainableMap} from './utils/ContainableMap';\n// import {CoreConstant} from '../../core/geometry/Constant'\n\n// const CoreGeometryGroup = CoreGroup\n\n// export type RequestContainerGeometryCallback = (container: Geometry)=>void\n\n// interface GroupOptions {\n// \tclone?: boolean\n// }\n// interface BooleanByString {\n// \t[propName: string]: boolean\n// }\nexport class GeometryContainer extends TypedContainer<ContainableMap['GEOMETRY']> {\n\t// protected _group: Group = new Group()\n\t// private _objects_by_uuid: BooleanByString = {}\n\t// protected _content: Object3D[] = []\n\t// protected _core_group: CoreGroup | null;\n\n\t// _points_count: number | null;\n\t// _bounding_box: Box3 | null;\n\n\t// constructor() {\n\t// \tsuper();\n\t// \t// this._materials = [];\n\t// }\n\n\t// _post_set_content() {\n\t// \tthis._core_group = this._core_group || new CoreGroup();\n\t// \tthis._core_group.touch();\n\t// \tthis._core_group.set_objects(this._content);\n\t// }\n\tset_objects(objects: Object3D[]) {}\n\n\t// clone_content(){\n\t// \treturn this._content.map(object=>CoreObject.clone(object))\n\t// }\n\t// core_content(): CoreGroup | null {\n\t// \treturn this._core_group; //= this._core_group || this._create_core_group()\n\t// }\n\tcore_content_cloned(): CoreGroup | undefined {\n\t\tif (this._content) {\n\t\t\treturn this._content.clone();\n\t\t}\n\t}\n\t// private _create_core_group(){\n\t// \tif(this._content){\n\t// \t\tconst core_group = new CoreGroup()\n\t// \t\tcore_group.set_objects(this._content)\n\t// \t\treturn core_group\n\t// \t}\n\t// }\n\t// reset_caches() {\n\t// \tconsole.log('reset cache');\n\t// \t// this._content = null;\n\t// \t// this._points_count = null;\n\t// \t// this._bounding_box = null;\n\t// }\n\t// _default_content() {\n\t// \treturn new CoreGroup();\n\t// }\n\n\t// set_geometry: (geometry)->\n\t// \tif @_content?\n\t// \t\t@_content.dispose()\n\t// \tthis.set_content(geometry)\n\t// has_group: ->\n\t// \tthis.has_content()\n\t// group(options?: GroupOptions): Group | null{\n\t// \tlet src_group;\n\t// \tif (options == null) { options = {}; }\n\t// \tif ((options['clone'] == null)) {\n\t// \t\toptions['clone'] = true;\n\t// \t}\n\n\t// \tlet new_group = null;\n\t// \tif ((src_group = this.content()) != null) {\n\t// \t\tif (options['clone'] === true) {\n\t// \t\t\tnew_group = CoreGroup.clone(src_group);\n\t// \t\t} else {\n\t// \t\t\tnew_group = src_group;\n\t// \t\t}\n\t// \t}\n\n\t// \treturn new_group;\n\t// }\n\n\t// group_wrapper(options){\n\t// \t// if (options == null) { options = {}; }\n\t// \t// return new CoreGroup(this.group(options));\n\t// }\n\t// core_group() {\n\t// \treturn this._core_group; //this.group_wrapper(options)\n\t// }\n\tset_content(content: ContainableMap['GEOMETRY']) {\n\t\tsuper.set_content(content);\n\t}\n\t// object(options){\n\t// \tif (options == null) { options = {}; }\n\t// \treturn this.group(options);\n\t// }\n\t// _post_set_content(){\n\t// \t// const objects_to_remove = []\n\t// \t// const objects_to_add = []\n\t// \t// const new_objects_by_uuid = {}\n\t// \t// for(let object of this._content){\n\t// \t// \tif(!this._objects_by_uuid[object.uuid]){\n\t// \t// \t\tobjects_to_add.push(object)\n\t// \t// \t}\n\t// \t// \tnew_objects_by_uuid[object.uuid] = true\n\t// \t// }\n\t// \t// for(let uuid of Object.keys(this._objects_by_uuid)){\n\n\t// \t// }\n\t// \tlet child\n\t// \twhile(child = this._group.children[0]){\n\t// \t\tthis._group.remove(child)\n\t// \t}\n\t// \tfor(let object of this._content){\n\t// \t\tthis._group.add(object)\n\t// \t}\n\t// }\n\n\t//\n\t//\n\t// INFOS\n\t//\n\t//\n\t// infos() {\n\t// \tif (this._content != null) {\n\t// \t\tconst bbox = this.bounding_box();\n\t// \t\tconst center = this.center(); //bbox.min.clone().add(bbox.max).multiplyScalar(0.5)\n\t// \t\tconst size = this.size(); //bbox.max.clone().sub(bbox.min)\n\n\t// \t\tconst node = this.node();\n\t// \t\tconst part_1 = [\n\t// \t\t\t`time dependent: ${node.is_time_dependent()}`,\n\t// \t\t\t`${node.cooks_count()} cooks`,\n\t// \t\t\t`cook time: ${node.cook_time()}`,\n\t// \t\t\t`cook time with inputs: ${node.cook_time_with_inputs()}`,\n\t// \t\t\t`${this.points_count()} points`,\n\t// \t\t\t`${this.objects_count()} object(s)  (${this.objects_visible_count()} visible)`\n\t// \t\t];\n\n\t// \t\tconst part_2 = [];\n\t// \t\tconst count_by_type = this.objects_count_by_type();\n\t// \t\tObject.keys(count_by_type).forEach((type)=>{\n\n\t// \t\t\tconst count = count_by_type[type];\n\t// \t\t\treturn part_2.push(`${count} ${type}`);\n\t// \t\t});\n\n\t// \t\tconst vertex_attributes = this.vertex_attribute_names();\n\t// \t\tconst object_attributes = this.object_attribute_names();\n\t// \t\tpart_2.push(`vertex attributes (${vertex_attributes.length}): ${vertex_attributes.join(', ')}`);\n\t// \t\tpart_2.push(`object attributes (${object_attributes.length}): ${object_attributes.join(', ')}`);\n\n\t// \t\tconst part_3 = [\n\t// \t\t\t\"bbox:\",\n\t// \t\t\t[bbox.min.x, bbox.min.y, bbox.min.z],\n\t// \t\t\t[bbox.max.x, bbox.max.y, bbox.max.z],\n\t// \t\t\t\"center:\",\n\t// \t\t\t[center.x, center.y, center.z],\n\t// \t\t\t\"size:\",\n\t// \t\t\t[size.x, size.y, size.z],\n\t// \t\t\tthis._content\n\t// \t\t];\n\n\t// \t\treturn lodash_concat( part_1, part_2, part_3 );\n\t// \t}\n\t// }\n\n\tprivate first_object() {\n\t\tif (this._content) {\n\t\t\treturn this._content.objects()[0];\n\t\t}\n\t}\n\tprivate first_geometry(): BufferGeometry | null {\n\t\tconst object = this.first_object();\n\t\tif (object) {\n\t\t\treturn (object as Mesh).geometry as BufferGeometry;\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tobjects_count(): number {\n\t\t// let count = 0\n\t\t// if(this._content){\n\t\t// \tcount = this._content.children.length\n\t\t// }\n\t\t// return count\n\t\tif (this._content) {\n\t\t\treturn this._content.objects().length;\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t}\n\tobjects_visible_count(): number {\n\t\tlet count = 0;\n\t\tif (this._content) {\n\t\t\tcount = this._content.objects().filter((c) => c.visible).length; // lodash_filter(this._content, c=> c.visible).length;\n\t\t}\n\t\treturn count;\n\t}\n\tobjects_count_by_type() {\n\t\tconst count_by_type: Dictionary<number> = {};\n\t\tconst core_group = this._content;\n\t\tif (this._content && core_group) {\n\t\t\tfor (let core_object of core_group.core_objects()) {\n\t\t\t\tconst human_type = core_object.human_type();\n\t\t\t\tif (count_by_type[human_type] == null) {\n\t\t\t\t\tcount_by_type[human_type] = 0;\n\t\t\t\t}\n\t\t\t\tcount_by_type[human_type] += 1;\n\t\t\t}\n\t\t}\n\t\treturn count_by_type;\n\t}\n\tobjects_names_by_type() {\n\t\tconst names_by_type: Dictionary<string[]> = {};\n\t\tconst core_group = this._content;\n\t\tif (this._content && core_group) {\n\t\t\tfor (let core_object of core_group.core_objects()) {\n\t\t\t\tconst human_type = core_object.human_type();\n\t\t\t\tnames_by_type[human_type] = names_by_type[human_type] || [];\n\t\t\t\tnames_by_type[human_type].push(core_object.name());\n\t\t\t}\n\t\t}\n\t\treturn names_by_type;\n\t}\n\n\tvertex_attribute_names() {\n\t\tlet names: string[] = [];\n\t\tconst geometry = this.first_geometry();\n\t\tif (geometry) {\n\t\t\tnames = Object.keys(geometry.attributes);\n\t\t}\n\t\treturn names;\n\t}\n\tvertex_attribute_sizes_by_name() {\n\t\tlet sizes_by_name: Dictionary<number> = {};\n\t\tconst geometry = this.first_geometry();\n\t\tif (geometry) {\n\t\t\tObject.keys(geometry.attributes).forEach((attrib_name) => {\n\t\t\t\tconst attrib = geometry.attributes[attrib_name];\n\t\t\t\tsizes_by_name[attrib_name] = attrib.itemSize;\n\t\t\t});\n\t\t}\n\t\treturn sizes_by_name;\n\t}\n\tvertex_attribute_types_by_name() {\n\t\tlet types_by_name: Dictionary<number> = {};\n\t\tconst geometry = this.first_geometry();\n\t\tif (geometry) {\n\t\t\tconst core_geo = new CoreGeometry(geometry);\n\t\t\tObject.keys(geometry.attributes).forEach((attrib_name) => {\n\t\t\t\ttypes_by_name[attrib_name] = core_geo.attrib_type(attrib_name);\n\t\t\t});\n\t\t}\n\t\treturn types_by_name;\n\t}\n\tobject_attribute_names() {\n\t\tlet names: string[] = [];\n\t\tconst object = this.first_object();\n\t\tif (object) {\n\t\t\tnames = Object.keys(object.userData['attributes'] || {});\n\t\t}\n\t\treturn names;\n\t}\n\n\tpoints_count(): number {\n\t\tif (this._content) {\n\t\t\treturn this._content.points_count();\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\n\t\t// return this._points_count != null ? this._points_count : (this._points_count = this._compute_points_count());\n\t}\n\n\t// _compute_points_count() {\n\t// \tlet points_count = 0;\n\t// \tif (this._content) {\n\t// \t\tfor (let object of this._content.objects()) {\n\t// \t\t\tobject.traverse((object) => {\n\t// \t\t\t\tconst geometry = (object as Mesh).geometry as BufferGeometry;\n\t// \t\t\t\tif (geometry) {\n\t// \t\t\t\t\tpoints_count += CoreGeometry.points_count(geometry);\n\t// \t\t\t\t}\n\t// \t\t\t});\n\t// \t\t}\n\t// \t}\n\t// \treturn points_count;\n\t// }\n\t//@_content.userData['points_count']\n\t//Core.Geometry.Geometry.points_count(@_content)\n\t// count = 0\n\t// if (position = @_content.getAttribute('position'))?\n\t// \tif (array = position.array)?\n\t// \t\tcount = array.length / 3\n\n\t// count\n\n\t// points_for_geometry: (geometry)->\n\t// \tCore.Geometry.Geometry.points_from_geometry(geometry)\n\n\t// create_geometry_from_points: (points, index_mode)->\n\t// \tCore.Geometry.Geometry.geometry_from_points(points, index_mode)\n\n\t//\n\t//\n\t// BBOX\n\t//\n\t//\n\tbounding_box(): Box3 {\n\t\treturn this._content.bounding_box();\n\t\t// return this._bounding_box != null ? this._bounding_box : (this._bounding_box = this._compute_bounding_box());\n\t}\n\tcenter(): Vector3 {\n\t\treturn this._content.center();\n\t\t// const center = new Vector3();\n\t\t// this.bounding_box().getCenter(center);\n\t\t// return center;\n\t}\n\tsize(): Vector3 {\n\t\treturn this._content.size();\n\t\t// const size = new Vector3();\n\t\t// this.bounding_box().getSize(size);\n\t\t// return size;\n\t}\n\n\t// private _compute_bounding_box() {\n\t// \tconst bbox = new Box3();\n\t// \tif (this._content) {\n\t// \t\tfor (let object of this._content.objects()) {\n\t// \t\t\t// const box = new Box3()\n\t// \t\t\t// bbox.setFromObject(object);\n\t// \t\t\tbbox.expandByObject(object);\n\t// \t\t}\n\t// \t}\n\t// \treturn bbox;\n\t// }\n}\n","import {Object3D} from 'three/src/core/Object3D';\nimport {Mesh} from 'three/src/objects/Mesh';\nimport {Material} from 'three/src/materials/Material';\n// import {Group} from 'three/src/objects/Group';\nimport {BufferGeometry} from 'three/src/core/BufferGeometry';\n// import lodash_includes from 'lodash/includes';\nimport lodash_range from 'lodash/range';\nimport lodash_times from 'lodash/times';\nimport {TypedNode} from '../_Base';\nimport {CoreConstant} from '../../../core/geometry/Constant';\nimport {CoreGroup, Object3DWithGeometry} from '../../../core/geometry/Group';\nimport {CoreMaterial} from '../../../core/geometry/Material';\nimport {ObjectType} from '../../../core/geometry/Constant';\n\nimport {GeometryContainer} from '../../containers/Geometry';\nimport {TypedContainerController} from '../utils/ContainerController';\nimport {BaseMatNodeType} from '../mat/_Base';\nimport {NodeContext} from '../../poly/NodeContext';\n\nimport {NodeParamsConfig} from '../utils/params/ParamsConfig';\nimport {FlagsControllerDB} from '../utils/FlagsController';\n// import * as Container from '../../Container/Geometry';\n\n// import {AttribTypeParam} from './concerns/AttribTypeParam';\n// import {Bypass} from './Concerns/Bypass';\n// import {GroupParam} from './concerns/GroupParam';\n// import {Named} from './concerns/Named'; // TODO; typescript\n// import {ObjectTypeParam} from './concerns/ObjectTypeParam';\n\n// TODO: do I really need to add attributes in objects?\n// TODO: after setting a node dirty, it should clear its object\n\n// import {RequestContainerGeometryCallback} from '../../../Engine/Container/Geometry'\n// const CONTAINER_CLASS = 'Geometry';\n\nenum MESSAGE {\n\tFROM_SET_CORE_GROUP = 'from set_core_group',\n\tFROM_SET_GROUP = 'from set_group',\n\tFROM_SET_OBJECTS = 'from set_objects',\n\tFROM_SET_OBJECT = 'from set_object',\n\tFROM_SET_GEOMETRIES = 'from set_geometries',\n\tFROM_SET_GEOMETRY = 'from set_geometry',\n}\n\nconst INPUT_GEOMETRY_NAME = 'input geometry';\nconst DEFAULT_INPUT_NAMES = [INPUT_GEOMETRY_NAME, INPUT_GEOMETRY_NAME, INPUT_GEOMETRY_NAME, INPUT_GEOMETRY_NAME];\n\nexport class TypedSopNode<K extends NodeParamsConfig> extends TypedNode<'GEOMETRY', BaseSopNodeType, K> {\n\tcontainer_controller: TypedContainerController<GeometryContainer> = new TypedContainerController<GeometryContainer>(\n\t\tthis,\n\t\tGeometryContainer\n\t);\n\tpublic readonly flags: FlagsControllerDB = new FlagsControllerDB(this);\n\n\tstatic node_context(): NodeContext {\n\t\treturn NodeContext.SOP;\n\t}\n\n\tstatic displayed_input_names(): string[] {\n\t\treturn DEFAULT_INPUT_NAMES;\n\t}\n\n\t// _master_group: Group\n\t// _objects: Object3D[] = []\n\n\tinitialize_base_node() {\n\t\t// this.flags.add_bypass();\n\n\t\t// this.flags.add_display();\n\t\tif (this.flags.display) {\n\t\t\tthis.flags.display.set(false);\n\t\t\tthis.flags.display.add_hook(() => {\n\t\t\t\tif (this.flags.display.active) {\n\t\t\t\t\tconst parent = this.parent;\n\t\t\t\t\tif (parent && parent.display_node_controller) {\n\t\t\t\t\t\tparent.display_node_controller.set_display_node(this);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\tthis.io.outputs.set_has_one_output();\n\t\t// this.container_controller.init(CONTAINER_CLASS);\n\t}\n\n\t// request_container() {\n\t// \treturn super.request_container(); //as Promise<GeometryContainer>;\n\t// }\n\n\t//\n\t//\n\t// GEOMETRY\n\t//\n\t//\n\t// group(): Group {\n\t// \treturn this._master_group = this._master_group || this._create_group()\n\t// }\n\t// set_group(group: Group){\n\t// \tthis._clear_objectsI() //(MESSAGE.FROM_SET_GROUP);\n\t// \tthis._master_group.add(group)\n\t// \t// let child;\n\n\t// \t// const new_children = [];\n\t// \t// while (child = group.children[0]) {\n\t// \t// \tnew_children.push(child);\n\t// \t// \tgroup.remove(child);\n\t// \t// }\n\n\t// \t// new_children.forEach(child=> {\n\t// \t// \tthis._master_group.add( child );\n\t// \t// });\n\n\t// \t// // if (this.allow_add_object_attributes()) {\n\t// \t// \tthis._master_group.traverse(object=> {\n\t// \t// \t\tthis._set_object_attributes(object);\n\t// \t// \t});\n\t// \t// // }\n\t// \tthis.set_container(this._master_group, MESSAGE.FROM_SET_GROUP);\n\t// }\n\tset_core_group(core_group: CoreGroup) {\n\t\tconst objects = core_group.objects();\n\t\tfor (let object of objects) {\n\t\t\tthis._set_object_attributes(object);\n\t\t}\n\t\tthis.set_container(core_group, MESSAGE.FROM_SET_CORE_GROUP);\n\t}\n\n\tset_object(object: Object3D) {\n\t\t// this._clear_objects();\n\t\t// this.add_object(object);\n\t\t// this.set_container(this.group(), MESSAGE.FROM_SET_OBJECT);\n\t\tthis._set_object_attributes(object);\n\t\t// const core_group = new CoreGroup();\n\t\t// core_group.set_objects([object]);\n\t\tthis.set_container_objects([object], MESSAGE.FROM_SET_OBJECT);\n\t}\n\tset_objects(objects: Object3D[]) {\n\t\t// this._clear_objects();\n\t\t// const list = objects;\n\t\t// lodash_times(list.length, i=> {\n\t\t// \tconst object = list[i];\n\t\t// \tthis.add_object(object);\n\t\t// });\n\t\tfor (let object of objects) {\n\t\t\tthis._set_object_attributes(object);\n\t\t}\n\t\t// const core_group = new CoreGroup();\n\t\t// core_group.set_objects(objects);\n\t\tthis.set_container_objects(objects, MESSAGE.FROM_SET_OBJECTS);\n\t}\n\n\t// add_object(object: Object3D) {\n\t// \tif (object != null) {\n\t// \t\tthis.group().add(object);\n\t// \t\t// if (this.allow_add_object_attributes()) {\n\t// \t\tthis._set_object_attributes(object);\n\t// \t\t// }\n\t// \t\treturn object;\n\t// \t}\n\t// }\n\t// add_geometry(geometry: BufferGeometry, type: ObjectType) {\n\t// \tlet object;\n\t// \tif (geometry.index == null) {\n\t// \t\tthis._add_index(geometry);\n\t// \t}\n\n\t// \tif ((object = this.create_object(geometry, type)) != null) {\n\t// \t\tthis.add_object(object);\n\t// \t}\n\t// }\n\n\tset_geometry(geometry: BufferGeometry, type?: ObjectType) {\n\t\t// this._clear_objects();\n\t\t// this.add_geometry(geometry, type);\n\t\t// this.set_container(this.group(), MESSAGE.FROM_SET_GEOMETRY);\n\t\tconst object = this.create_object(geometry, type);\n\t\t// const core_group = new CoreGroup();\n\t\t// core_group.set_objects([object]);\n\t\tthis.set_container_objects([object], MESSAGE.FROM_SET_GEOMETRY);\n\t}\n\t//this.end_cook()\n\n\tset_geometries(geometries: BufferGeometry[], type?: ObjectType) {\n\t\t// this._clear_objects();\n\t\tconst objects: Object3D[] = [];\n\t\tlet object;\n\t\tgeometries.forEach((geometry) => {\n\t\t\tobject = this.create_object(geometry, type);\n\t\t\tthis._set_object_attributes(object);\n\t\t\tobjects.push(object);\n\t\t});\n\t\t// const core_group = new CoreGroup();\n\t\t// core_group.set_objects(objects);\n\t\tthis.set_container_objects(objects, MESSAGE.FROM_SET_GEOMETRIES);\n\t}\n\n\tset_container_objects(objects: Object3D[], message: MESSAGE) {\n\t\tconst core_group = this.container_controller.container.core_content() || new CoreGroup();\n\t\tcore_group.set_objects(objects);\n\t\tcore_group.touch();\n\t\tthis.set_container(core_group);\n\t}\n\n\t// do_clone_inputs() {\n\t// \tlet result = true;\n\t// \tif (this.has_param('do_not_clone_inputs')) {\n\t// \t\tresult = false;\n\t// \t}\n\t// \treturn result;\n\t// }\n\t// allow_add_object_attributes() {\n\t// \tif (!this.do_clone_inputs()) { return false; }\n\t// \tlet result = true;\n\t// \tif (this.has_param('do_not_add_object_attributes')) {\n\t// \t\tresult = false;\n\t// \t}\n\t// \treturn result;\n\t// }\n\n\t// _create_group() {\n\t// \tconst group = new Group();\n\t// \tgroup.name = this.full_path();\n\n\t// \tthis._init_sop_bypass_group(group)\n\n\t// \treturn group;\n\t// }\n\n\tcreate_object(geometry: BufferGeometry, type?: ObjectType): Object3DWithGeometry {\n\t\t// ensure it has an index\n\t\tif (!geometry.index) {\n\t\t\tconst position_array = geometry.getAttribute('position').array;\n\t\t\tgeometry.setIndex(lodash_range(position_array.length / 3));\n\t\t}\n\n\t\tif (type == null) {\n\t\t\ttype = CoreConstant.OBJECT_TYPE.MESH;\n\t\t}\n\t\t// if (!lodash_includes(CoreConstant.OBJECT_TYPES, type)) {\n\t\t// \tconst human_type = CoreConstant.CONSTRUCTOR_NAMES_BY_CONSTRUCTOR_NAME[type];\n\t\t// \tconst human_names = CoreConstant.OBJECT_TYPES.map(\n\t\t// \t\t(n) => CoreConstant.CONSTRUCTOR_NAMES_BY_CONSTRUCTOR_NAME[n]\n\t\t// \t);\n\t\t// \tthrow `type '${human_type}' not recognized. Available types are ${human_names.join(', ')}.`;\n\t\t// }\n\n\t\t// if (geometry != null) {\n\t\tconst object_constructor = CoreConstant.CONSTRUCTORS_BY_NAME[type]; //THREE[type];\n\t\tconst material = CoreConstant.MATERIALS[type].clone();\n\t\tconst object = new object_constructor(geometry, material) as Object3DWithGeometry;\n\t\tobject.castShadow = true;\n\t\tobject.receiveShadow = true;\n\t\tobject.frustumCulled = false;\n\n\t\treturn object;\n\t\t// }\n\t}\n\n\t_set_object_attributes(object: Object3D) {\n\t\t// if (!this.allow_add_object_attributes()) { return; }\n\t\t// TODO: the exception below are just to debug when a geo could be reused or not cloned properly\n\t\t// I could remove that when more sure it all refreshes fine, and this would allow the null or merge to\n\t\t// not have to clone the data\n\t\t// if ((object.name == null) && (object.name !== '')) {\n\t\t// \tif (this.do_clone_inputs()) {\n\t\t// \t\tthrow `object.name already set to ${object.node_name} (attempt to set by ${this.full_path()})`;\n\t\t// \t}\n\t\t// } else {\n\t\t// \tobject.name = this.full_path();\n\t\t// }\n\n\t\t// if ((geometry = object.geometry) != null) {\n\t\t// \tif ((geometry.name == null) && (geometry.name !== '')) {\n\t\t// \t\tif (this.do_clone_inputs()) {\n\t\t// \t\t\tthrow `geometry.node_name already set to ${geometry.node_name} (attempt to set by ${this.full_path()})`;\n\t\t// \t\t}\n\t\t// \t} else {\n\t\t// \t\tgeometry.name = this.full_path();\n\t\t// \t}\n\t\t// }\n\t\tconst material: Material = (object as Mesh).material as Material;\n\t\tif (material) {\n\t\t\tif (!this.scene) {\n\t\t\t\tconsole.log('no scene');\n\t\t\t\tthrow 'no scene';\n\t\t\t}\n\t\t\tconst material_node = CoreMaterial.node(this.scene, material) as BaseMatNodeType;\n\t\t\tif (material_node) {\n\t\t\t\tmaterial_node.add_render_hook(object);\n\t\t\t}\n\t\t}\n\t}\n\n\t// _clear_objects() {\n\t// \tconst group = this.group();\n\n\t// \tlet child\n\t// \twhile(child = group.children[0]) {\n\t// \t\tgroup.remove(child);\n\t// \t}\n\t// \t// const children = lodash_clone(group.children);\n\t// \t// let child;\n\t// \t// for(let i=0; i < children.length; i++){\n\t// \t// \tchild = children[i]\n\t// \t// \tgroup.remove(child);\n\t// \t// \tchild.traverse((object)=>{\n\t// \t// \t\tif (object.geometry != null) {\n\t// \t// \t\t\tobject.geometry.dispose();\n\t// \t// \t\t}\n\t// \t// \t\t// no more material dispose since each the materials are not cloned\n\t// \t// \t\t// if (object.material){\n\t// \t// \t\t// \tif (lodash_isArray(object.material)){\n\t// \t// \t\t// \t\tobject.material.forEach((mat)=>{mat.dispose()})\n\t// \t// \t\t// \t} else {\n\t// \t// \t\t// \t\tobject.material.dispose()\n\t// \t// \t\t// \t}\n\t// \t// \t\t// }\n\t// \t// \t});\n\t// \t// }\n\t// }\n\n\t_add_index(geometry: BufferGeometry) {\n\t\tconst position_attrib = geometry.getAttribute('position');\n\t\tconst position_array = position_attrib.array;\n\t\tconst points_count = position_array.length / 3;\n\t\tconst indices: number[] = [];\n\t\tlodash_times(points_count, (i) => indices.push(i));\n\n\t\tgeometry.setIndex(indices);\n\t}\n}\n\nexport type BaseSopNodeType = TypedSopNode<NodeParamsConfig>;\nexport class BaseSopNodeClass extends TypedSopNode<NodeParamsConfig> {}\n","// import lodash_flatten from 'lodash/flatten';\n// import lodash_last from 'lodash/last';\nimport lodash_times from 'lodash/times';\nimport {Object3D} from 'three/src/core/Object3D';\n// import {Float32BufferAttribute} from 'three/src/core/BufferAttribute';\nimport {BufferGeometry} from 'three/src/core/BufferGeometry';\nimport {BufferAttribute} from 'three/src/core/BufferAttribute';\nimport {TypedSopNode} from './_Base';\n// import {Core} from '../../../Core/_Module';\nimport {CoreConstant} from '../../../core/geometry/Constant';\nimport {CoreGroup} from '../../../core/geometry/Group';\n// import {CoreGeometryUtilShape} from '../../../core/geometry/util/Shape';\n\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nclass AddSopParamsConfig extends NodeParamsConfig {\n\tcreate_point = ParamConfig.BOOLEAN(1);\n\tpoints_count = ParamConfig.INTEGER(1, {\n\t\trange: [1, 100],\n\t\trange_locked: [true, false],\n\t\tvisible_if: {create_point: true},\n\t});\n\tposition = ParamConfig.VECTOR3([0, 0, 0], {visible_if: {create_point: true}});\n\t// create_polygon = ParamConfig.BOOLEAN(0);\n\topen = ParamConfig.BOOLEAN(0);\n\tconnect_to_last_point = ParamConfig.BOOLEAN(0);\n}\nconst ParamsConfig = new AddSopParamsConfig();\n\nexport class AddSopNode extends TypedSopNode<AddSopParamsConfig> {\n\tparams_config = ParamsConfig;\n\tstatic type() {\n\t\treturn 'add';\n\t}\n\t_objects: Object3D[] | undefined;\n\n\tstatic displayed_input_names(): string[] {\n\t\treturn ['geometry to create polygons from (optional)'];\n\t}\n\n\tinitialize_node() {\n\t\tthis.io.inputs.set_count(0, 1);\n\t}\n\n\tcook(input_contents: CoreGroup[]) {\n\t\tthis._objects = [];\n\t\tthis._create_point();\n\t\t// if (this.pv.create_polygon) {\n\t\t// \tthis._create_polygon(input_contents[0]);\n\t\t// }\n\n\t\tthis.set_objects(this._objects);\n\t}\n\n\tprivate _create_point() {\n\t\tif (this.pv.create_point) {\n\t\t\tconst geometry = new BufferGeometry();\n\t\t\tconst positions: number[] = [];\n\t\t\tlodash_times(this.pv.points_count, (i) => {\n\t\t\t\tthis.pv.position.toArray(positions, i * 3);\n\t\t\t});\n\t\t\tgeometry.setAttribute('position', new BufferAttribute(new Float32Array(positions), 3));\n\t\t\tconst object = this.create_object(geometry, CoreConstant.OBJECT_TYPE.POINTS);\n\n\t\t\tif (this._objects) {\n\t\t\t\tthis._objects.push(object);\n\t\t\t}\n\t\t}\n\t}\n\n\t// private _create_polygon(core_group: CoreGroup) {\n\t// \tconst points = core_group.points();\n\t// \tconst is_polygon_closed = !this.pv.open && points.length >= 3;\n\t// \tif (points.length > 0) {\n\t// \t\tif (is_polygon_closed) {\n\t// \t\t\tthis._create_polygon_closed(core_group);\n\t// \t\t} else {\n\t// \t\t\tthis._create_polygon_open(core_group);\n\t// \t\t}\n\t// \t}\n\t// }\n\n\t// _create_polygon_closed(core_group: CoreGroup) {\n\t// \tconst points = core_group.points();\n\n\t// \tconst geometry = CoreGeometryUtilShape.geometry_from_points(points);\n\t// \tconst object = this.create_object(geometry);\n\t// \tthis._objects.push(object);\n\t// }\n\n\t// _create_polygon_open(core_group:CoreGroup) {\n\t// \tconst points = core_group.points();\n\n\t// \tlet positions:number[][] = [];\n\t// \tconst indices:number[] = [];\n\t// \tpoints.forEach((point, i) => {\n\t// \t\tpoint.position().toArray(positions, i * 3);\n\t// \t\t// positions.push(point.position().toArray());\n\n\t// \t\tif (i > 0) {\n\t// \t\t\tindices.push(i - 1);\n\t// \t\t\tindices.push(i);\n\t// \t\t}\n\t// \t});\n\n\t// \tif (points.length > 2 && this.pv.connect_to_last_point) {\n\t// \t\tpositions.push(points[0].position().toArray());\n\t// \t\tindices.push(lodash_last(indices));\n\t// \t\tindices.push(0);\n\t// \t}\n\n\t// \tpositions = lodash_flatten(positions);\n\t// \tconst geometry = new BufferGeometry();\n\t// \tgeometry.setAttribute('position', new Float32BufferAttribute(positions, 3));\n\t// \tgeometry.setIndex(indices);\n\t// \tconst object = this.create_object(geometry, CoreConstant.OBJECT_TYPE.LINE_SEGMENTS);\n\t// \tthis._objects.push(object);\n\t// }\n}\n","import {TypedSopNode} from './_Base';\n// import {CoreTransform} from '../../../Core/Transform';\n// import {ParamType} from '../../../Engine/Param/_Module'\n\n// interface ActionsByName {\n// \t[propName: string]: THREE.AnimationClip;\n// }\n\nimport {NodeParamsConfig} from '../utils/params/ParamsConfig';\nimport {InputCloneMode} from '../../poly/InputCloneMode';\nimport {CoreGroup} from '../../../core/geometry/Group';\nimport {Object3DWithAnimation} from '../../../core/geometry/Animation';\nclass AnimationCopySopParamsConfig extends NodeParamsConfig {}\nconst ParamsConfig = new AnimationCopySopParamsConfig();\n\nexport class AnimationCopySopNode extends TypedSopNode<AnimationCopySopParamsConfig> {\n\tparams_config = ParamsConfig;\n\tstatic type() {\n\t\treturn 'animation_copy';\n\t}\n\n\tstatic displayed_input_names(): string[] {\n\t\treturn ['geometry to copy animation to', 'geometry to copy animation from'];\n\t}\n\n\tinitialize_node() {\n\t\tthis.io.inputs.set_count(2);\n\t\tthis.io.inputs.init_inputs_clonable_state([InputCloneMode.FROM_NODE, InputCloneMode.NEVER]);\n\t}\n\n\tcook(input_contents: CoreGroup[]) {\n\t\tconst core_group_target = input_contents[0];\n\t\tconst core_group_src = input_contents[1];\n\n\t\tconst src_object = core_group_src.objects()[0] as Object3DWithAnimation;\n\t\tconst target_object = core_group_target.objects()[0] as Object3DWithAnimation;\n\n\t\tconst src_animations = src_object.animations;\n\t\tif (src_animations) {\n\t\t\ttarget_object.animations = src_animations.map((a) => a.clone());\n\t\t\tthis.set_core_group(core_group_target);\n\t\t} else {\n\t\t\tthis.states.error.set('no animation found');\n\t\t}\n\t}\n}\n","import {TypedSopNode} from './_Base';\nimport lodash_isArray from 'lodash/isArray';\n// import {Object3D} from 'three/src/core/Object3D';\nimport {AnimationMixer} from 'three/src/animation/AnimationMixer';\n// import {AnimationClip} from 'three/src/animation/AnimationClip';\nimport {InputCloneMode} from '../../poly/InputCloneMode';\nimport {CoreGroup} from '../../../core/geometry/Group';\nimport {Object3DWithAnimation} from '../../../core/geometry/Animation';\nimport {ParamType} from '../../poly/ParamType';\nimport {AnimationAction} from 'three/src/animation/AnimationAction';\nimport {Mesh} from 'three/src/objects/Mesh';\n\nimport {Material} from 'three/src/materials/Materials';\nimport {MaterialWithSkinning} from '../../../core/geometry/Material';\nimport {NodeEvent} from '../../poly/NodeEvent';\nimport {BaseParamType} from '../../params/_Base';\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nimport {Object3D} from 'three/src/core/Object3D';\nimport {BaseNodeType} from '../_Base';\nclass AnimationMixerSopParamsConfig extends NodeParamsConfig {\n\ttime = ParamConfig.FLOAT('$T', {range: [0, 10]});\n\tprepare = ParamConfig.BUTTON(null, {\n\t\tcallback: (node: BaseNodeType, param: BaseParamType) => {\n\t\t\tAnimationMixerSopNode.PARAM_CALLBACK_prepare(node as AnimationMixerSopNode, param);\n\t\t},\n\t});\n}\nconst ParamsConfig = new AnimationMixerSopParamsConfig();\n\nexport class AnimationMixerSopNode extends TypedSopNode<AnimationMixerSopParamsConfig> {\n\tparams_config = ParamsConfig;\n\tstatic type() {\n\t\treturn 'animation_mixer';\n\t}\n\n\t_previous_time: number | null = null;\n\t_mixer: AnimationMixer | null = null;\n\t_actions_by_name: Dictionary<AnimationAction> = {};\n\t_values_by_param_name: Dictionary<number> = {};\n\t// _mixer_used_once: boolean = false\n\t_animation_target: Object3DWithAnimation | undefined;\n\n\tstatic displayed_input_names(): string[] {\n\t\treturn ['geometry to be animated'];\n\t}\n\n\tinitialize_node() {\n\t\tthis.io.inputs.set_count(1);\n\t\tthis.io.inputs.init_inputs_clonable_state([InputCloneMode.FROM_NODE]);\n\t}\n\n\tcook(input_contents: CoreGroup[]) {\n\t\tif (!this._mixer) {\n\t\t\tthis.create_mixer(input_contents[0]);\n\t\t} else {\n\t\t\tthis._update_mixer();\n\t\t\tthis.cook_controller.end_cook();\n\t\t}\n\t}\n\n\tprivate create_mixer(core_group: CoreGroup) {\n\t\tthis._animation_target = core_group.objects()[0] as Object3DWithAnimation;\n\t\tthis._mixer = new AnimationMixer(this._animation_target);\n\n\t\tthis._remove_spare_params();\n\t\tthis._actions_by_name = {};\n\n\t\tif (this._animation_target.animations) {\n\t\t\tthis._animation_target.animations.forEach((animation, i) => {\n\t\t\t\tconst param_name = animation.name;\n\t\t\t\tconst previous_value = this._values_by_param_name[param_name];\n\t\t\t\tlet default_value = previous_value;\n\t\t\t\tif (default_value == null) {\n\t\t\t\t\tdefault_value = i == 0 ? 1 : 0;\n\t\t\t\t}\n\t\t\t\tconst param = this.add_param(ParamType.FLOAT, param_name, default_value, {spare: true});\n\t\t\t\tif (param) {\n\t\t\t\t\tconst prev_value = this._values_by_param_name[param_name];\n\t\t\t\t\tif (prev_value) {\n\t\t\t\t\t\tparam.set(prev_value);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (this._mixer) {\n\t\t\t\t\tconst action = this._mixer.clipAction(animation);\n\t\t\t\t\tthis._actions_by_name[animation.name] = action;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\tthis.emit(NodeEvent.PARAMS_UPDATED);\n\n\t\tObject.keys(this._actions_by_name).forEach((name) => {\n\t\t\tthis._actions_by_name[name].play();\n\t\t});\n\n\t\t// set material skinning\n\t\tconst materials_by_id: Dictionary<Material> = {};\n\t\tthis._animation_target.traverse((object3d: Object3D) => {\n\t\t\tconst child = object3d as Mesh;\n\t\t\tif (child.material) {\n\t\t\t\tif (!lodash_isArray(child.material)) {\n\t\t\t\t\tmaterials_by_id[child.material.uuid] = child.material;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\tObject.keys(materials_by_id).forEach((uuid) => {\n\t\t\tconst material = materials_by_id[uuid] as MaterialWithSkinning;\n\t\t\tmaterial.skinning = true;\n\t\t\tmaterial.morphTargets = true;\n\t\t});\n\t\tthis._previous_time = null;\n\t\tthis._update_mixer();\n\t\tthis._update_mixer_weights(); // might be redundant with _update_mixer, but ensures this is done on load\n\t\tthis.set_object(this._animation_target);\n\t}\n\n\tprivate _remove_spare_params() {\n\t\tthis._values_by_param_name = {};\n\t\tconst current_param_names: string[] = this.params.spare_names;\n\t\tconst names_to_delete: string[] = [];\n\t\tcurrent_param_names.forEach((param_name) => {\n\t\t\tconst param = this.params.get_float(param_name);\n\t\t\tif (param) {\n\t\t\t\tthis._values_by_param_name[param_name] = param.value;\n\t\t\t\tnames_to_delete.push(param_name);\n\t\t\t}\n\t\t});\n\t\tif (names_to_delete.length > 0) {\n\t\t\tthis.params.update_params({names_to_delete: names_to_delete});\n\t\t}\n\t}\n\n\tprivate _update_mixer() {\n\t\tif (this.pv.time != this._previous_time) {\n\t\t\tthis._update_mixer_time();\n\t\t} else {\n\t\t\tthis._update_mixer_weights();\n\t\t}\n\t}\n\tprivate _update_mixer_time() {\n\t\tconst delta = this.pv.time - (this._previous_time || 0);\n\t\tif (this._mixer) {\n\t\t\tthis._mixer.update(delta);\n\t\t}\n\t\tthis._previous_time = this.pv.time;\n\t}\n\n\tprivate _update_mixer_weights() {\n\t\tfor (let name of Object.keys(this._actions_by_name)) {\n\t\t\tconst action = this._actions_by_name[name];\n\t\t\tconst cache_value = this.params.get_float(name).value;\n\t\t\tif (cache_value != null) {\n\t\t\t\taction.setEffectiveWeight(cache_value);\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic PARAM_CALLBACK_prepare(node: AnimationMixerSopNode, param: BaseParamType) {\n\t\tnode.prepare_animation_mixer();\n\t}\n\tasync prepare_animation_mixer() {\n\t\tthis._mixer = null;\n\t\tconst container = await this.io.inputs.eval_required_input(0);\n\t\tthis.create_mixer(container.core_content_cloned());\n\t\tthis.set_dirty();\n\t}\n}\n","import {TypedSopNode} from './_Base';\n// import {Core} from '../../../Core/_Module';\nimport {CoreGroup} from '../../../core/geometry/Group';\n\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nimport {BufferAttribute} from 'three/src/core/BufferAttribute';\nimport {BufferGeometry} from 'three/src/core/BufferGeometry';\nimport {InputCloneMode} from '../../poly/InputCloneMode';\nclass AttribAddMultSopParamsConfig extends NodeParamsConfig {\n\tname = ParamConfig.STRING('');\n\tpre_add = ParamConfig.FLOAT(0, {range: [0, 1]});\n\tmult = ParamConfig.FLOAT(1, {range: [0, 1]});\n\tpost_add = ParamConfig.FLOAT(0, {range: [0, 1]});\n}\nconst ParamsConfig = new AttribAddMultSopParamsConfig();\n\nexport class AttribAddMultSopNode extends TypedSopNode<AttribAddMultSopParamsConfig> {\n\tparams_config = ParamsConfig;\n\tstatic type() {\n\t\treturn 'attrib_add_mult';\n\t}\n\n\tinitialize_node() {\n\t\tthis.io.inputs.set_count(1);\n\t\tthis.io.inputs.init_inputs_clonable_state([InputCloneMode.FROM_NODE]);\n\t}\n\n\tcook(input_contents: CoreGroup[]) {\n\t\tconst core_group = input_contents[0];\n\t\tconst attrib_names = core_group.attrib_names_matching_mask(this.pv.name);\n\n\t\tfor (let attrib_name of attrib_names) {\n\t\t\tconst geometries = core_group.geometries();\n\t\t\tfor (let geometry of geometries) {\n\t\t\t\tthis._update_attrib(attrib_name, geometry);\n\t\t\t}\n\t\t}\n\n\t\tthis.set_core_group(core_group);\n\t}\n\n\tprivate _update_attrib(attrib_name: string, geometry: BufferGeometry) {\n\t\tconst attribute = geometry.getAttribute(attrib_name) as BufferAttribute;\n\t\tif (attribute) {\n\t\t\tconst values = attribute.array as number[];\n\n\t\t\tconst pre_add = this.pv.pre_add;\n\t\t\tconst mult = this.pv.mult;\n\t\t\tconst post_add = this.pv.post_add;\n\t\t\tfor (let i = 0; i < values.length; i++) {\n\t\t\t\tconst value = values[i];\n\t\t\t\tvalues[i] = (value + pre_add) * mult + post_add;\n\t\t\t}\n\t\t\tif (!this.io.inputs.input_cloned(0)) {\n\t\t\t\tattribute.needsUpdate = true;\n\t\t\t}\n\t\t}\n\t}\n}\n","import {TypedSopNode} from './_Base';\n\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nimport {InputCloneMode} from '../../poly/InputCloneMode';\nimport {CoreGroup} from '../../../core/geometry/Group';\nimport {BufferGeometry} from 'three/src/core/BufferGeometry';\nimport {Float32BufferAttribute} from 'three/src/core/BufferAttribute';\nclass AttribCopySopParamsConfig extends NodeParamsConfig {\n\t// class = ParamConfig.INTEGER(CoreConstant.ATTRIB_CLASS.VERTEX, {\n\t// \tmenu: {\n\t// \t\tentries: [\n\t// \t\t\t{name: 'vertex', value: CoreConstant.ATTRIB_CLASS.VERTEX},\n\t// \t\t\t{name: 'object', value: CoreConstant.ATTRIB_CLASS.OBJECT},\n\t// \t\t],\n\t// \t},\n\t// })\n\tname = ParamConfig.STRING('');\n\ttnew_name = ParamConfig.BOOLEAN(0);\n\tnew_name = ParamConfig.STRING('', {visible_if: {tnew_name: 1}});\n\t// to_all_components = ParamConfig.BOOLEAN(1)\n\t// src_component = ParamConfig.INTEGER(0, {\n\t// \trange: [0, 2],\n\t// \trange_locked: [true, true],\n\t// \tvisible_if: {to_all_components: 0},\n\t// })\n\t// dest_component = ParamConfig.INTEGER(0, {\n\t// \trange: [0, 2],\n\t// \trange_locked: [true, true],\n\t// \tvisible_if: {to_all_components: 0},\n\t// })\n}\nconst ParamsConfig = new AttribCopySopParamsConfig();\n\n// TODO: attrib copy should handle string attributes\nexport class AttribCopySopNode extends TypedSopNode<AttribCopySopParamsConfig> {\n\tparams_config = ParamsConfig;\n\tstatic type() {\n\t\treturn 'attrib_copy';\n\t}\n\n\tstatic displayed_input_names(): string[] {\n\t\treturn ['geometry to copy attributes to', 'geometry to copy attributes from'];\n\t}\n\n\tinitialize_node() {\n\t\tthis.io.inputs.set_count(2);\n\t\tthis.io.inputs.init_inputs_clonable_state([InputCloneMode.FROM_NODE, InputCloneMode.NEVER]);\n\t}\n\n\tcreate_params() {}\n\n\tcook(input_contents: CoreGroup[]) {\n\t\tconst core_group_dest = input_contents[0];\n\t\tconst core_group_src = input_contents[1];\n\n\t\tconst attrib_names = core_group_src.attrib_names_matching_mask(this.pv.name);\n\t\tfor (let attrib_name of attrib_names) {\n\t\t\tthis.copy_vertex_attribute_between_core_groups(core_group_dest, core_group_src, attrib_name);\n\t\t}\n\n\t\t// switch (this.pv.class) {\n\t\t// \tcase CoreConstant.ATTRIB_CLASS.VERTEX:\n\t\t// \t\tthis.copy_vertex_attribute(core_group_dest, core_group_src);\n\t\t// \t\tbreak;\n\t\t// \tcase CoreConstant.ATTRIB_CLASS.OBJECT:\n\t\t// \t\tthis.copy_object_attribute(core_group_dest, core_group_src);\n\t\t// \t\tbreak;\n\t\t// }\n\n\t\treturn this.set_core_group(core_group_dest);\n\t}\n\n\tprivate copy_vertex_attribute_between_core_groups(\n\t\tcore_group_dest: CoreGroup,\n\t\tcore_group_src: CoreGroup,\n\t\tattrib_name: string\n\t) {\n\t\tconst src_objects = core_group_src.objects();\n\t\tconst dest_objects = core_group_dest.objects();\n\n\t\tif (dest_objects.length > src_objects.length) {\n\t\t\tthis.states.error.set('second input does not have enough objects to copy attributes from');\n\t\t} else {\n\t\t\tfor (let i = 0; i < dest_objects.length; i++) {\n\t\t\t\tconst dest_geometry = dest_objects[i].geometry;\n\t\t\t\tconst src_geometry = dest_objects[i].geometry;\n\t\t\t\tthis.copy_vertex_attribute_between_geometries(dest_geometry, src_geometry, attrib_name);\n\t\t\t}\n\t\t}\n\t}\n\tprivate copy_vertex_attribute_between_geometries(\n\t\tdest_geometry: BufferGeometry,\n\t\tsrc_geometry: BufferGeometry,\n\t\tattrib_name: string\n\t) {\n\t\tconst src_attrib = src_geometry.getAttribute(attrib_name);\n\t\tif (src_attrib) {\n\t\t\tconst size = src_attrib.itemSize;\n\t\t\tconst src_points_count = src_geometry.getAttribute('position').array.length / 3;\n\t\t\tconst dest_points_count = dest_geometry.getAttribute('position').array.length / 3;\n\t\t\tif (dest_points_count > src_points_count) {\n\t\t\t\tthis.states.error.set('not enough points in second input');\n\t\t\t}\n\t\t\tconst src_array = src_attrib.array as number[];\n\t\t\tconst sub_array = src_array.slice(0, dest_points_count * size);\n\t\t\tconst dest_name = this.pv.tnew_name ? this.pv.new_name : attrib_name;\n\t\t\tdest_geometry.setAttribute(dest_name, new Float32BufferAttribute(sub_array, size));\n\t\t} else {\n\t\t\tthis.states.error.set(`attribute '${attrib_name}' does not exist on second input`);\n\t\t}\n\t}\n\n\t// _src_value_to_all_components(src_attrib_value: NumericAttribValue, dest_attrib_size) {\n\t// \tif (lodash_isNumber(src_attrib_value)) {\n\t// \t\tswitch (dest_attrib_size) {\n\t// \t\t\tcase 1:\n\t// \t\t\t\treturn src_attrib_value;\n\t// \t\t\tcase 2:\n\t// \t\t\t\treturn new THREE.Vector2(src_attrib_value, src_attrib_value);\n\t// \t\t\tcase 3:\n\t// \t\t\t\treturn new THREE.Vector3(src_attrib_value, src_attrib_value, src_attrib_value);\n\t// \t\t}\n\t// \t} else {\n\t// \t\tswitch (dest_attrib_size) {\n\t// \t\t\tcase 1:\n\t// \t\t\t\treturn src_attrib_value.x;\n\t// \t\t\tcase 2:\n\t// \t\t\t\treturn new THREE.Vector2(src_attrib_value.x, src_attrib_value.y);\n\t// \t\t\tcase 3:\n\t// \t\t\t\treturn new THREE.Vector3(\n\t// \t\t\t\t\tsrc_attrib_value.x,\n\t// \t\t\t\t\tsrc_attrib_value.y,\n\t// \t\t\t\t\tsrc_attrib_value.z || src_attrib_value.y\n\t// \t\t\t\t);\n\t// \t\t}\n\t// \t}\n\t// }\n\n\t// _src_value_to_component(src_attrib_value, current_dest_value, src_component, dest_component) {\n\t// \tconst src_component_value = (() => {\n\t// \t\tswitch (src_component) {\n\t// \t\t\tcase 0:\n\t// \t\t\t\treturn src_attrib_value.x || src_attrib_value;\n\t// \t\t\tcase 1:\n\t// \t\t\t\treturn src_attrib_value.y;\n\t// \t\t\tcase 2:\n\t// \t\t\t\treturn src_attrib_value.z;\n\t// \t\t}\n\t// \t})();\n\n\t// \tconst dest_component_name = ['x', 'y', 'z'][dest_component];\n\t// \tif (current_dest_value[dest_component_name] != null) {\n\t// \t\tcurrent_dest_value[dest_component_name] = src_component_value;\n\t// \t\treturn current_dest_value;\n\t// \t} else {\n\t// \t\tconst src_component_name = ['x', 'y', 'z'][src_component];\n\t// \t\treturn src_attrib_value[src_component_name];\n\t// \t}\n\t// }\n\n\t// TODO: find a way to use the point method, but have the group api allow easy switch\n\t// private  copy_object_attribute(core_group_dest: CoreGroup, core_group_src:CoreGroup) {\n\t// \t// const objects_dest = core_group_dest.objects();\n\t// \t// const objects_src = core_group_src.objects();\n\n\t// \t//attribute_names = core_group_src.attrib_names_matching_mask(@_param_name)\n\n\t// \t//lodash_each attribute_names, (attrib_name) =>\n\t// \tconst attrib_name = this.pv.name;\n\n\t// \tif (!core_group_dest.has_attrib(attrib_name)) {\n\t// \t\tconst attrib_size = core_group_src.attrib_size(attrib_name);\n\t// \t\tcore_group_dest.add_numeric_vertex_attrib(attrib_name, attrib_size, 0);\n\t// \t}\n\n\t// \tlodash_each(points_dest, (point_dest, i) => {\n\t// \t\tlet point_src;\n\t// \t\tif ((point_src = points_src[i]) != null) {\n\t// \t\t\tconst attrib_value = point_src.attrib_value(attrib_name);\n\t// \t\t\tpoint_dest.set_attrib_value(attrib_name, attrib_value);\n\t// \t\t}\n\t// \t});\n\t// }\n}\n","import lodash_trim from 'lodash/trim';\n\nimport {TypedSopNode} from './_Base';\nimport {\n\tCoreConstant,\n\tAttribClassMenuEntries,\n\tAttribTypeMenuEntries,\n\tAttribClass,\n\tAttribType,\n} from '../../../core/geometry/Constant';\nimport {CoreAttribute} from '../../../core/geometry/Attribute';\n// import {CoreGeometry} from '../../../core/geometry/Geometry'\nimport {CoreObject} from '../../../core/geometry/Object';\nimport {CoreGroup} from '../../../core/geometry/Group';\n\n// import {Vector3} from 'three/src/math/Vector3';\n// import {Vector2} from 'three/src/math/Vector2';\n\nimport {InputCloneMode} from '../../poly/InputCloneMode';\nimport {BufferGeometry} from 'three/src/core/BufferGeometry';\n\n// const VALUE_PARAM = {\n// \tVALUEX: 'valuex',\n// \tVALUE: 'value',\n// \tSTRING: 'string',\n// };\n// const DEFAULT_VALUE = {\n// \tvaluex: 0,\n// \tvalue: [0, 0, 0],\n// \tstring: '',\n// };\n// type COMPONENT_INDEX = keyof Vector4Like;\n// const COMPONENT_INDEX: Array<COMPONENT_INDEX> = ['x', 'y', 'z', 'w'];\ntype ValueArrayByName = Dictionary<number[]>;\n\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nclass AttribCreateSopParamsConfig extends NodeParamsConfig {\n\tgroup = ParamConfig.STRING('');\n\tclass = ParamConfig.INTEGER(AttribClass.VERTEX, {\n\t\tmenu: {\n\t\t\tentries: AttribClassMenuEntries,\n\t\t},\n\t});\n\ttype = ParamConfig.INTEGER(AttribType.NUMERIC, {\n\t\tmenu: {\n\t\t\tentries: AttribTypeMenuEntries,\n\t\t},\n\t});\n\tname = ParamConfig.STRING('new_attrib');\n\tsize = ParamConfig.INTEGER(1, {\n\t\trange: [1, 4],\n\t\trange_locked: [true, true],\n\t\tvisible_if: {type: CoreConstant.ATTRIB_TYPE.NUMERIC},\n\t});\n\tvalue1 = ParamConfig.FLOAT(0, {\n\t\tvisible_if: {type: CoreConstant.ATTRIB_TYPE.NUMERIC, size: 1},\n\t\texpression: {for_entities: true},\n\t});\n\tvalue2 = ParamConfig.VECTOR2([0, 0], {\n\t\tvisible_if: {type: CoreConstant.ATTRIB_TYPE.NUMERIC, size: 2},\n\t\texpression: {for_entities: true},\n\t});\n\tvalue3 = ParamConfig.VECTOR3([0, 0, 0], {\n\t\tvisible_if: {type: CoreConstant.ATTRIB_TYPE.NUMERIC, size: 3},\n\t\texpression: {for_entities: true},\n\t});\n\tvalue4 = ParamConfig.VECTOR4([0, 0, 0, 0], {\n\t\tvisible_if: {type: CoreConstant.ATTRIB_TYPE.NUMERIC, size: 4},\n\t\texpression: {for_entities: true},\n\t});\n\tstring = ParamConfig.STRING('', {\n\t\tvisible_if: {type: CoreConstant.ATTRIB_TYPE.STRING},\n\t\texpression: {for_entities: true},\n\t});\n}\nconst ParamsConfig = new AttribCreateSopParamsConfig();\nexport class AttribCreateSopNode extends TypedSopNode<AttribCreateSopParamsConfig> {\n\tparams_config = ParamsConfig;\n\tstatic type() {\n\t\treturn 'attrib_create';\n\t}\n\n\tprivate _x_arrays_by_geometry_uuid: ValueArrayByName = {};\n\tprivate _y_arrays_by_geometry_uuid: ValueArrayByName = {};\n\tprivate _z_arrays_by_geometry_uuid: ValueArrayByName = {};\n\tprivate _w_arrays_by_geometry_uuid: ValueArrayByName = {};\n\n\tinitialize_node() {\n\t\tthis.io.inputs.set_count(1);\n\t\tthis.io.inputs.init_inputs_clonable_state([InputCloneMode.FROM_NODE]);\n\t}\n\n\tcook(input_contents: CoreGroup[]) {\n\t\tconst core_group = input_contents[0];\n\n\t\tif (this.pv.name && lodash_trim(this.pv.name) != '') {\n\t\t\tswitch (this.pv.class) {\n\t\t\t\tcase AttribClass.VERTEX:\n\t\t\t\t\tthis.add_point_attribute(core_group);\n\t\t\t\t\tbreak;\n\t\t\t\tcase AttribClass.OBJECT:\n\t\t\t\t\tthis.add_object_attribute(core_group);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tthis.states.error.set('attribute name is not valid');\n\t\t}\n\t}\n\n\tasync add_point_attribute(core_group: CoreGroup) {\n\t\tconst core_objects = core_group.core_objects();\n\t\tfor (let i = 0; i < core_objects.length; i++) {\n\t\t\tconst core_object = core_objects[i];\n\t\t\tswitch (this.pv.type) {\n\t\t\t\tcase CoreConstant.ATTRIB_TYPE.NUMERIC:\n\t\t\t\t\tawait this.add_numeric_attribute_to_points(core_object);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CoreConstant.ATTRIB_TYPE.STRING:\n\t\t\t\t\tawait this.add_string_attribute_to_points(core_object);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tthis.set_core_group(core_group);\n\t}\n\tasync add_object_attribute(core_group: CoreGroup) {\n\t\tconst core_objects = core_group.core_objects_from_group(this.pv.group);\n\t\tswitch (this.pv.type) {\n\t\t\tcase CoreConstant.ATTRIB_TYPE.NUMERIC:\n\t\t\t\tawait this.add_numeric_attribute_to_object(core_objects);\n\t\t\t\tbreak;\n\t\t\tcase CoreConstant.ATTRIB_TYPE.STRING:\n\t\t\t\tawait this.add_string_attribute_to_object(core_objects);\n\t\t\t\tbreak;\n\t\t}\n\t\tthis.set_core_group(core_group);\n\t}\n\n\tasync add_numeric_attribute_to_points(core_object: CoreObject) {\n\t\tconst core_geometry = core_object.core_geometry();\n\t\tif (!core_geometry) {\n\t\t\treturn;\n\t\t}\n\t\tconst points = core_object.points_from_group(this.pv.group);\n\n\t\tconst param = [this.p.value1, this.p.value2, this.p.value3, this.p.value4][this.pv.size - 1];\n\n\t\tif (param.has_expression()) {\n\t\t\tif (!core_geometry.has_attrib(this.pv.name)) {\n\t\t\t\tcore_geometry.add_numeric_attrib(this.pv.name, this.pv.size, param.value);\n\t\t\t}\n\n\t\t\tconst geometry = core_geometry.geometry();\n\t\t\tconst array = geometry.getAttribute(this.pv.name).array as number[];\n\t\t\tif (this.pv.size == 1) {\n\t\t\t\tif (this.p.value1.expression_controller) {\n\t\t\t\t\tawait this.p.value1.expression_controller.compute_expression_for_points(points, (point, value) => {\n\t\t\t\t\t\tarray[point.index * this.pv.size + 0] = value;\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconst vparam = [this.p.value2, this.p.value3, this.p.value4][this.pv.size - 2];\n\t\t\t\tlet params = vparam.components;\n\t\t\t\tconst tmp_arrays = new Array(params.length);\n\t\t\t\tlet component_param;\n\n\t\t\t\tconst arrays_by_geometry_uuid = [\n\t\t\t\t\tthis._x_arrays_by_geometry_uuid,\n\t\t\t\t\tthis._y_arrays_by_geometry_uuid,\n\t\t\t\t\tthis._z_arrays_by_geometry_uuid,\n\t\t\t\t\tthis._w_arrays_by_geometry_uuid,\n\t\t\t\t];\n\n\t\t\t\tfor (let i = 0; i < params.length; i++) {\n\t\t\t\t\tcomponent_param = params[i];\n\t\t\t\t\tif (component_param.has_expression() && component_param.expression_controller) {\n\t\t\t\t\t\ttmp_arrays[i] = this._init_array_if_required(\n\t\t\t\t\t\t\tgeometry,\n\t\t\t\t\t\t\tarrays_by_geometry_uuid[i],\n\t\t\t\t\t\t\tpoints.length\n\t\t\t\t\t\t);\n\t\t\t\t\t\tawait component_param.expression_controller.compute_expression_for_points(\n\t\t\t\t\t\t\tpoints,\n\t\t\t\t\t\t\t(point, value) => {\n\t\t\t\t\t\t\t\t// array[point.index()*this.pv.size+i] = value\n\t\t\t\t\t\t\t\ttmp_arrays[i][point.index] = value;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconst value = component_param.value;\n\t\t\t\t\t\tfor (let point of points) {\n\t\t\t\t\t\t\tarray[point.index * this.pv.size + i] = value;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// commit the tmp values\n\t\t\t\tfor (let j = 0; j < tmp_arrays.length; j++) {\n\t\t\t\t\tconst tmp_array = tmp_arrays[j];\n\t\t\t\t\tif (tmp_array) {\n\t\t\t\t\t\tfor (let i = 0; i < tmp_array.length; i++) {\n\t\t\t\t\t\t\tarray[i * this.pv.size + j] = tmp_array[i];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\t// const value = await param.eval_p();\n\t\t\tcore_object.add_numeric_vertex_attrib(this.pv.name, this.pv.size, param.value);\n\t\t}\n\t}\n\n\tasync add_numeric_attribute_to_object(core_objects: CoreObject[]) {\n\t\tconst param = [this.p.value1, this.p.value2, this.p.value3, this.p.value4][this.pv.size - 1];\n\t\tif (param.has_expression()) {\n\t\t\tif (this.pv.size == 1) {\n\t\t\t\tif (this.p.value1.expression_controller) {\n\t\t\t\t\tawait this.p.value1.expression_controller.compute_expression_for_objects(\n\t\t\t\t\t\tcore_objects,\n\t\t\t\t\t\t(core_object, value) => {\n\t\t\t\t\t\t\tcore_object.set_attrib_value(this.pv.name, value);\n\t\t\t\t\t\t}\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconst vparam = [this.p.value2, this.p.value3, this.p.value4][this.pv.size - 2];\n\t\t\t\tlet params = vparam.components;\n\t\t\t\tlet values_by_core_object_index: Dictionary<NumericAttribValueAsArray> = {};\n\t\t\t\t// for (let component_param of params) {\n\t\t\t\t// \tvalues.push(component_param.value);\n\t\t\t\t// }\n\t\t\t\tfor (let core_object of core_objects) {\n\t\t\t\t\tvalues_by_core_object_index[core_object.index] = (<unknown>[]) as NumericAttribValueAsArray;\n\t\t\t\t}\n\t\t\t\tfor (let component_index = 0; component_index < params.length; component_index++) {\n\t\t\t\t\tconst component_param = params[component_index];\n\t\t\t\t\tif (component_param.has_expression() && component_param.expression_controller) {\n\t\t\t\t\t\tawait component_param.expression_controller.compute_expression_for_objects(\n\t\t\t\t\t\t\tcore_objects,\n\t\t\t\t\t\t\t(core_object, value) => {\n\t\t\t\t\t\t\t\tvalues_by_core_object_index[core_object.index][component_index] = value;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfor (let core_object of core_objects) {\n\t\t\t\t\t\t\tvalues_by_core_object_index[core_object.index][component_index] = component_param.value;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (let i = 0; i < core_objects.length; i++) {\n\t\t\t\t\tconst core_object = core_objects[i];\n\t\t\t\t\tconst value = values_by_core_object_index[core_object.index];\n\t\t\t\t\tcore_object.set_attrib_value(this.pv.name, value);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\t// let value = await param.eval_p();\n\t\t\t// if (this.pv.size > 1) {\n\t\t\t// \tvalue = this._convert_object_numeric_value(value);\n\t\t\t// }\n\t\t\tfor (let core_object of core_objects) {\n\t\t\t\tcore_object.set_attrib_value(this.pv.name, param.value);\n\t\t\t}\n\t\t}\n\t}\n\n\t// private _convert_object_numeric_value(value: Vector4) {\n\t// \tlet converted_value;\n\t// \tswitch (this.pv.size) {\n\t// \t\tcase 1: {\n\t// \t\t\tconverted_value = value.x;\n\t// \t\t\tbreak;\n\t// \t\t}\n\t// \t\tcase 2: {\n\t// \t\t\tconverted_value = new Vector2(value.x, value.y);\n\t// \t\t\tbreak;\n\t// \t\t}\n\t// \t\tcase 3: {\n\t// \t\t\tconverted_value = new Vector3(value.x, value.y, value.z);\n\t// \t\t\tbreak;\n\t// \t\t}\n\t// \t\tcase 4: {\n\t// \t\t\tconverted_value = new Vector4(value.x, value.y, value.z, value.w);\n\t// \t\t\tbreak;\n\t// \t\t}\n\t// \t}\n\t// \treturn converted_value;\n\t// }\n\n\tasync add_string_attribute_to_points(core_object: CoreObject) {\n\t\tconst points = core_object.points_from_group(this.pv.group);\n\t\tconst param = this.p.string;\n\n\t\tconst string_values: string[] = [];\n\t\tif (param.has_expression() && param.expression_controller) {\n\t\t\tawait param.expression_controller.compute_expression_for_points(points, (point, value) => {\n\t\t\t\tstring_values[point.index] = value;\n\t\t\t});\n\t\t} else {\n\t\t\tstring_values.push(param.value);\n\t\t}\n\n\t\tconst index_data = CoreAttribute.array_to_indexed_arrays(string_values);\n\t\tcore_object.core_geometry()?.set_indexed_attribute(this.pv.name, index_data['values'], index_data['indices']);\n\t}\n\n\tasync add_string_attribute_to_object(core_objects: CoreObject[]) {\n\t\tconst param = this.p.string;\n\t\tif (param.has_expression() && param.expression_controller) {\n\t\t\tawait param.expression_controller.compute_expression_for_objects(core_objects, (core_object, value) => {\n\t\t\t\tcore_object.set_attrib_value(this.pv.name, value);\n\t\t\t});\n\t\t} else {\n\t\t\tfor (let core_object of core_objects) {\n\t\t\t\tcore_object.set_attrib_value(this.pv.name, param.value);\n\t\t\t}\n\t\t}\n\t\t// this.context().set_entity(object);\n\n\t\t// const core_object = new CoreObject(object);\n\n\t\t// this.param('string').eval(val => {\n\t\t// \tcore_object.add_attribute(this.pv.name, val);\n\t\t// });\n\t}\n\n\t//\n\t//\n\t// PRIVATE\n\t//\n\t//\n\n\t// https://stackoverflow.com/questions/24586110/resolve-promises-one-after-another-i-e-in-sequence\n\t// async _eval_params_for_entities(entities){\n\t// \t// let p = Promise.resolve(); // Q() in q\n\n\t// \tconst param = this._value_param();\n\n\t// \tif (param.has_expression()) {\n\t// \t\t// const iterator = new CoreIterator()\n\t// \t\t// await iterator.start_with_array(entities, (element, index)=>{\n\n\t// \t\t// })\n\t// \t\tfor(let entity of entities){\n\t// \t\t\tawait this._eval_param_for_entity(param, entity);\n\t// \t\t}\n\n\t// \t\t// entities.forEach((entity, index)=> {\n\t// \t\t// \tp = p.then(() => {\n\t// \t\t// \t\treturn this._eval_param_for_entity(param, entity);\n\t// \t\t// \t});\n\t// \t\t// });\n\t// \t} else {\n\t// \t\tconst val = await param.eval_p();\n\t// \t\tfor(let entity of entities){\n\t// \t\t\tthis._values.push(val);\n\t// \t\t}\n\t// \t\t// entities.forEach(entity=> {\n\t// \t\t// \treturn this._values.push(val);\n\t// \t\t// });\n\t// \t}\n\n\t// \t// return p;\n\t// }\n\n\t// async _eval_param_for_entity(value_param, entity){\n\t// \tthis.context().set_entity(entity);\n\n\t// \tlet val = await value_param.eval_p()\n\n\t// \t // TODO: optimize. pass directly to the entity instead\n\t// \tif(val.clone){\n\t// \t\tval = val.clone()\n\t// \t}\n\t// \tthis._values.push(val);\n\t// }\n\n\t// private _default_attrib_value() {\n\t// \treturn DEFAULT_VALUE[this._value_param_name()];\n\t// }\n\n\t// private _value_param_name() {\n\t// \tif (this.pv.type == CoreConstant.ATTRIB_TYPE.NUMERIC) {\n\t// \t\tif (this.pv.size == 1) {\n\t// \t\t\treturn VALUE_PARAM.VALUEX;\n\t// \t\t} else {\n\t// \t\t\treturn VALUE_PARAM.VALUE;\n\t// \t\t}\n\t// \t} else {\n\t// \t\treturn VALUE_PARAM.STRING;\n\t// \t}\n\t// }\n\t// private _value_param() {\n\t// \treturn this.params.get(this._value_param_name());\n\t// }\n\n\tprivate _init_array_if_required(\n\t\tgeometry: BufferGeometry,\n\t\tarrays_by_geometry_uuid: ValueArrayByName,\n\t\tpoints_count: number\n\t) {\n\t\tconst uuid = geometry.uuid;\n\t\tconst current_array = arrays_by_geometry_uuid[uuid];\n\t\tif (current_array) {\n\t\t\t// only create new array if we need more point, or as soon as the length is different?\n\t\t\tif (current_array.length < points_count) {\n\t\t\t\tarrays_by_geometry_uuid[uuid] = new Array(points_count);\n\t\t\t}\n\t\t} else {\n\t\t\tarrays_by_geometry_uuid[uuid] = new Array(points_count);\n\t\t}\n\t\treturn arrays_by_geometry_uuid[uuid];\n\t}\n\n\t// private _commit_tmp_values(tmp_array: number[], target_array: number[], offset: number) {\n\t// \tfor (let i = 0; i < tmp_array.length; i++) {\n\t// \t\ttarget_array[i * 3 + offset] = tmp_array[i];\n\t// \t}\n\t// }\n}\n","import {TypedSopNode} from './_Base';\nimport {CoreGroup} from '../../../core/geometry/Group';\nimport {CoreObject} from '../../../core/geometry/Object';\nimport {CoreGeometry} from '../../../core/geometry/Geometry';\nimport {AttribClassMenuEntries, AttribClass} from '../../../core/geometry/Constant';\n\nimport {InputCloneMode} from '../../poly/InputCloneMode';\nimport {Object3D} from 'three/src/core/Object3D';\nimport {BufferGeometry} from 'three/src/core/BufferGeometry';\nimport {Mesh} from 'three/src/objects/Mesh';\n\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nclass AttribDeleteSopParamsConfig extends NodeParamsConfig {\n\tclass = ParamConfig.INTEGER(AttribClass.VERTEX, {\n\t\tmenu: {\n\t\t\tentries: AttribClassMenuEntries,\n\t\t},\n\t});\n\tname = ParamConfig.STRING('');\n}\nconst ParamsConfig = new AttribDeleteSopParamsConfig();\n\nexport class AttribDeleteSopNode extends TypedSopNode<AttribDeleteSopParamsConfig> {\n\tparams_config = ParamsConfig;\n\tstatic type() {\n\t\treturn 'attrib_delete';\n\t}\n\n\tstatic displayed_input_names(): string[] {\n\t\treturn ['geometry to delete attributes from'];\n\t}\n\n\tinitialize_node() {\n\t\tthis.io.inputs.set_count(1);\n\t\tthis.io.inputs.init_inputs_clonable_state([InputCloneMode.FROM_NODE]);\n\t}\n\n\tcook(input_contents: CoreGroup[]) {\n\t\tconst core_group = input_contents[0];\n\t\tconst attrib_names = core_group.attrib_names_matching_mask(this.pv.name);\n\n\t\tfor (let attrib_name of attrib_names) {\n\t\t\tswitch (this.pv.class) {\n\t\t\t\tcase AttribClass.VERTEX:\n\t\t\t\t\tthis.delete_vertex_attribute(core_group, attrib_name);\n\t\t\t\tcase AttribClass.OBJECT:\n\t\t\t\t\tthis.delete_object_attribute(core_group, attrib_name);\n\t\t\t}\n\t\t}\n\n\t\tthis.set_core_group(core_group);\n\t}\n\n\tdelete_vertex_attribute(core_group: CoreGroup, attrib_name: string) {\n\t\tfor (let object of core_group.objects()) {\n\t\t\tobject.traverse((object3d: Object3D) => {\n\t\t\t\tconst child = object3d as Mesh;\n\t\t\t\tif (child.geometry) {\n\t\t\t\t\tconst core_geometry = new CoreGeometry(child.geometry as BufferGeometry);\n\t\t\t\t\tcore_geometry.delete_attribute(attrib_name);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n\tdelete_object_attribute(core_group: CoreGroup, attrib_name: string) {\n\t\tfor (let object of core_group.objects()) {\n\t\t\tlet index = 0;\n\t\t\tobject.traverse((object3d: Object3D) => {\n\t\t\t\tconst child = object3d as Mesh;\n\t\t\t\tconst core_object = new CoreObject(child, index);\n\t\t\t\tcore_object.delete_attribute(attrib_name);\n\t\t\t\tindex++;\n\t\t\t});\n\t\t}\n\t}\n}\n","import {TypedSopNode} from './_Base';\nimport {Vector3} from 'three/src/math/Vector3';\nimport lodash_max from 'lodash/max';\nimport lodash_min from 'lodash/min';\nimport lodash_isNumber from 'lodash/isNumber';\nimport {CoreGroup} from '../../../core/geometry/Group';\nimport {InputCloneMode} from '../../poly/InputCloneMode';\n\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nclass AttribNormalizeSopParamsConfig extends NodeParamsConfig {\n\tname = ParamConfig.STRING('');\n\tchange_name = ParamConfig.BOOLEAN(false);\n\tnew_name = ParamConfig.STRING('', {visible_if: {change_name: 1}});\n}\nconst ParamsConfig = new AttribNormalizeSopParamsConfig();\n\nexport class AttribNormalizeSopNode extends TypedSopNode<AttribNormalizeSopParamsConfig> {\n\tparams_config = ParamsConfig;\n\tstatic type() {\n\t\treturn 'attrib_normalize';\n\t}\n\n\tinitialize_node() {\n\t\tthis.io.inputs.set_count(1);\n\t\tthis.io.inputs.init_inputs_clonable_state([InputCloneMode.FROM_NODE]);\n\t}\n\n\tcook(input_contents: CoreGroup[]) {\n\t\tconst core_group = input_contents[0];\n\t\tthis._normalize_attribute(core_group);\n\t\tthis.set_core_group(core_group);\n\t}\n\n\t_normalize_attribute(core_group: CoreGroup) {\n\t\tconst points = core_group.points();\n\t\tif (points.length === 0) {\n\t\t\treturn;\n\t\t}\n\t\tif (this.pv.name === '') {\n\t\t\treturn;\n\t\t}\n\n\t\tconst attrib_size = points[0].attrib_size(this.pv.name);\n\t\tconst values = points.map((point) => point.attrib_value(this.pv.name));\n\t\tlet normalized_values: NumericAttribValue[] = [];\n\t\tlet min: NumericAttribValue, max: NumericAttribValue;\n\t\tswitch (attrib_size) {\n\t\t\tcase 1:\n\t\t\t\t// if (this._param_only_integer_values) {\n\t\t\t\t// \tconst sorted_values = lodash_uniq(lodash_sortBy(values));\n\t\t\t\t// \tconst index_by_value = {};\n\t\t\t\t// \tlodash_each(sorted_values, (sorted_value, i)=> index_by_value[sorted_value] = i);\n\t\t\t\t// \tnormalized_values = lodash_map(values, value=> index_by_value[value]);\n\n\t\t\t\t// } else {\n\t\t\t\tmin = lodash_min(values);\n\t\t\t\tmax = lodash_max(values);\n\t\t\t\t//this._save_min_max(group, min, max)\n\t\t\t\tif (lodash_isNumber(min) && lodash_isNumber(max)) {\n\t\t\t\t\tfor (let value of values) {\n\t\t\t\t\t\tconst normalized_value = max > min ? (value - min) / (max - min) : 1;\n\t\t\t\t\t\tnormalized_values.push(normalized_value);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase 3:\n\t\t\t\tmin = new Vector3(\n\t\t\t\t\tlodash_min(values.map((v) => v.x)),\n\t\t\t\t\tlodash_min(values.map((v) => v.y)),\n\t\t\t\t\tlodash_min(values.map((v) => v.z))\n\t\t\t\t);\n\t\t\t\tmax = new Vector3(\n\t\t\t\t\tlodash_max(values.map((v) => v.x)),\n\t\t\t\t\tlodash_max(values.map((v) => v.y)),\n\t\t\t\t\tlodash_max(values.map((v) => v.z))\n\t\t\t\t);\n\t\t\t\t//this._save_min_max(group, min, max)\n\t\t\t\tif (min instanceof Vector3 && max instanceof Vector3) {\n\t\t\t\t\tfor (let value of values) {\n\t\t\t\t\t\tconst normalized_value = new Vector3(\n\t\t\t\t\t\t\t(value.x - min.x) / (max.x - min.x),\n\t\t\t\t\t\t\t(value.y - min.y) / (max.y - min.y),\n\t\t\t\t\t\t\t(value.z - min.z) / (max.z - min.z)\n\t\t\t\t\t\t);\n\t\t\t\t\t\tnormalized_values.push(normalized_value);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\n\t\tlet target_name = this.pv.name;\n\t\tif (this.pv.change_name) {\n\t\t\ttarget_name = this.pv.new_name;\n\t\t\tif (!core_group.has_attrib(target_name)) {\n\t\t\t\tcore_group.add_numeric_vertex_attrib(target_name, attrib_size, 0);\n\t\t\t}\n\t\t}\n\n\t\tnormalized_values.forEach((normalized_value, i) => {\n\t\t\tconst point = points[i];\n\t\t\tpoint.set_attrib_value(target_name, normalized_value);\n\t\t});\n\t}\n}\n\n// TODO: they should be saved as a detail, not per object\n// _save_min_max: (group, min, max)->\n// \tgroup.traverse (object)=>\n// \t\tobject_wrapper = new Core.Geometry.Object(object)\n// \t\tobject_wrapper.add_attribute(\"#{@pv.name}_min\", min)\n// \t\tobject_wrapper.add_attribute(\"#{@pv.name}_max\", max)\n","import lodash_max from 'lodash/max';\nimport lodash_min from 'lodash/min';\n\nimport {InputCloneMode} from '../../poly/InputCloneMode';\nimport {TypedSopNode} from './_Base';\nimport {AttribClass, AttribClassMenuEntries} from '../../../core/geometry/Constant';\nimport {CoreObject} from '../../../core/geometry/Object';\nimport {CoreGroup} from '../../../core/geometry/Group';\nimport {CoreString} from '../../../core/String';\n\nexport enum AttribPromoteMode {\n\tMIN = 0,\n\tMAX = 1,\n\tFIRST_FOUND = 2,\n}\n// const PROMOTE_MODE:PROMOTE_MODE = {\n// \tMIN: 0,\n// \tMAX: 1,\n// \t// AVERAGE: 2,\n// \tFIRST_FOUND: 3,\n// };\nconst PromoteModeMenuEntries = [\n\t{name: 'min', value: AttribPromoteMode.MIN},\n\t{name: 'max', value: AttribPromoteMode.MAX},\n\t{name: 'first_found', value: AttribPromoteMode.FIRST_FOUND},\n];\n\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nclass AttribPromoteSopParamsConfig extends NodeParamsConfig {\n\tclass_from = ParamConfig.INTEGER(AttribClass.VERTEX, {\n\t\tmenu: {\n\t\t\tentries: AttribClassMenuEntries,\n\t\t},\n\t});\n\tclass_to = ParamConfig.INTEGER(AttribClass.OBJECT, {\n\t\tmenu: {\n\t\t\tentries: AttribClassMenuEntries,\n\t\t},\n\t});\n\tmode = ParamConfig.INTEGER(AttribPromoteMode.FIRST_FOUND, {\n\t\tmenu: {\n\t\t\tentries: PromoteModeMenuEntries,\n\t\t},\n\t});\n\tname = ParamConfig.STRING('');\n}\nconst ParamsConfig = new AttribPromoteSopParamsConfig();\n\nexport class AttribPromoteSopNode extends TypedSopNode<AttribPromoteSopParamsConfig> {\n\tparams_config = ParamsConfig;\n\tstatic type() {\n\t\treturn 'attrib_promote';\n\t}\n\n\tinitialize_node() {\n\t\tthis.io.inputs.set_count(1);\n\t\tthis.io.inputs.init_inputs_clonable_state([InputCloneMode.FROM_NODE]);\n\t\t// this.ui_data.set_icon('sort-amount-up');\n\t}\n\n\tcreate_params() {}\n\n\tprivate _core_group: CoreGroup | undefined;\n\tprivate _core_object: CoreObject | undefined;\n\tprivate _values_per_attrib_name: Dictionary<number[]> = {};\n\tprivate _filtered_values_per_attrib_name: Dictionary<number | undefined> = {};\n\tcook(input_contents: CoreGroup[]) {\n\t\tthis._core_group = input_contents[0];\n\n\t\tthis._values_per_attrib_name = {};\n\t\tthis._filtered_values_per_attrib_name = {};\n\n\t\tfor (let core_object of this._core_group.core_objects()) {\n\t\t\tthis._core_object = core_object;\n\t\t\tthis.find_values();\n\t\t\tthis.filter_values();\n\t\t\tthis.set_values();\n\t\t}\n\n\t\t// switch @_param_class_from\n\t\t// \twhen Core.Geometry.ATTRIB_CLASS.VERTEX then this.promote_attribute_from_vertex()\n\t\t// \twhen Core.Geometry.ATTRIB_CLASS.OBJECT then this.promote_attribute_from_object()\n\t\tthis.set_core_group(this._core_group);\n\t}\n\n\t// private promote_attribute_from_vertex() {\n\t// \t// switch (this.pv.class_to) {\n\t// \t// \tcase AttribClass.VERTEX:\n\t// \t\t\treturn this.promote_attribute_from_vertex_to_vertex();\n\t// \t\t// case AttribClass.OBJECT:\n\t// \t\t// return this.promote_attribute_from_vertex_to_object();\n\t// \t// }\n\t// }\n\n\t// private promote_attribute_from_object() {\n\t// \tswitch (this.pv.class_to) {\n\t// \t\tcase AttribClass.VERTEX:\n\t// \t\t// return this.promote_attribute_from_object_to_vertex();\n\t// \t\tcase AttribClass.OBJECT:\n\t// \t\t// return this.promote_attribute_from_object_to_object();\n\t// \t}\n\t// }\n\n\t// private promote_attribute_from_vertex_to_vertex() {\n\t// \tif (this._core_group) {\n\t// \t\tconst attrib_names = CoreString.attrib_names(this.pv.name);\n\t// \t\tconst points = this._core_group.points();\n\t// \t\tfor (let attrib_name of attrib_names) {\n\t// \t\t\tconst values = lodash_map(points, (point) => point.attrib_value(attrib_name));\n\t// \t\t\tconst new_value = (() => {\n\t// \t\t\t\tswitch (this.pv.mode) {\n\t// \t\t\t\t\tcase PromoteMode.MIN:\n\t// \t\t\t\t\t\treturn lodash_min(values);\n\t// \t\t\t\t\tcase PromoteMode.MAX:\n\t// \t\t\t\t\t\treturn lodash_max(values);\n\t// \t\t\t\t\t// case PROMOTE_MODE.AVERAGE: return lodash_average(values);\n\t// \t\t\t\t\tdefault:\n\t// \t\t\t\t\t\treturn null;\n\t// \t\t\t\t}\n\t// \t\t\t})();\n\n\t// \t\t\tif (new_value != null) {\n\t// \t\t\t\tlodash_each(points, (point) => point.set_attrib_value(attrib_name, new_value));\n\t// \t\t\t}\n\t// \t\t}\n\t// \t}\n\t// }\n\n\tprivate find_values() {\n\t\tconst attrib_names = CoreString.attrib_names(this.pv.name);\n\t\tfor (let attrib_name of attrib_names) {\n\t\t\tswitch (this.pv.class_from) {\n\t\t\t\tcase AttribClass.VERTEX:\n\t\t\t\t\treturn this.find_values_from_points(attrib_name);\n\t\t\t\tcase AttribClass.OBJECT:\n\t\t\t\t\treturn this.find_values_from_object(attrib_name);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate find_values_from_points(attrib_name: string) {\n\t\tif (this._core_object) {\n\t\t\tconst points = this._core_object.points();\n\t\t\tthis._values_per_attrib_name[attrib_name] = points.map((point) => point.attrib_value(attrib_name));\n\t\t}\n\t}\n\n\tprivate find_values_from_object(attrib_name: string) {\n\t\tthis._values_per_attrib_name[attrib_name] = [];\n\t\tif (this._core_object) {\n\t\t\tthis._values_per_attrib_name[attrib_name].push(this._core_object.attrib_value(attrib_name) as number);\n\t\t}\n\t}\n\n\tprivate filter_values() {\n\t\tconst attrib_names = Object.keys(this._values_per_attrib_name);\n\t\tfor (let attrib_name of attrib_names) {\n\t\t\tconst values = this._values_per_attrib_name[attrib_name];\n\t\t\tswitch (this.pv.mode) {\n\t\t\t\tcase AttribPromoteMode.MIN:\n\t\t\t\t\tthis._filtered_values_per_attrib_name[attrib_name] = lodash_min(values);\n\t\t\t\t\tbreak;\n\t\t\t\tcase AttribPromoteMode.MAX:\n\t\t\t\t\tthis._filtered_values_per_attrib_name[attrib_name] = lodash_max(values);\n\t\t\t\t\tbreak;\n\t\t\t\t// case PROMOTE_MODE.AVERAGE: return lodash_average(values);\n\t\t\t\tcase AttribPromoteMode.FIRST_FOUND:\n\t\t\t\t\tthis._filtered_values_per_attrib_name[attrib_name] = values[0];\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate set_values() {\n\t\tconst attrib_names = Object.keys(this._filtered_values_per_attrib_name);\n\t\tfor (let attrib_name of attrib_names) {\n\t\t\tconst new_value = this._filtered_values_per_attrib_name[attrib_name];\n\t\t\tif (new_value != null) {\n\t\t\t\tswitch (this.pv.class_to) {\n\t\t\t\t\tcase AttribClass.VERTEX:\n\t\t\t\t\t\tthis.set_values_to_points(attrib_name, new_value);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase AttribClass.OBJECT:\n\t\t\t\t\t\tthis.set_values_to_object(attrib_name, new_value);\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate set_values_to_points(attrib_name: string, new_value: NumericAttribValue) {\n\t\tif (this._core_group && this._core_object) {\n\t\t\tconst attribute_exists = this._core_group.has_attrib(attrib_name);\n\t\t\tif (!attribute_exists) {\n\t\t\t\tconst param_size = 1; // TODO: allow size with larger params\n\t\t\t\tthis._core_group.add_numeric_vertex_attrib(attrib_name, param_size, new_value);\n\t\t\t}\n\n\t\t\tconst points = this._core_object.points();\n\t\t\tpoints.forEach((point) => point.set_attrib_value(attrib_name, new_value));\n\t\t}\n\t}\n\n\tprivate set_values_to_object(attrib_name: string, new_value: NumericAttribValue) {\n\t\tthis._core_object?.set_attrib_value(attrib_name, new_value);\n\t}\n}\n","import lodash_max from 'lodash/max';\nimport lodash_min from 'lodash/min';\nimport lodash_sortBy from 'lodash/sortBy';\nimport lodash_uniq from 'lodash/uniq';\nimport lodash_isNumber from 'lodash/isNumber';\nimport {Vector3} from 'three/src/math/Vector3';\nimport {TypedSopNode} from './_Base';\nimport {CoreGroup} from '../../../core/geometry/Group';\n\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nclass AttribRemapSopParamsConfig extends NodeParamsConfig {\n\tname = ParamConfig.STRING();\n\tramp = ParamConfig.RAMP();\n\tchange_name = ParamConfig.BOOLEAN(0);\n\tnew_name = ParamConfig.STRING('', {visible_if: {change_name: 1}});\n}\nconst ParamsConfig = new AttribRemapSopParamsConfig();\n\nexport class AttribRemapSopNode extends TypedSopNode<AttribRemapSopParamsConfig> {\n\tparams_config = ParamsConfig;\n\tstatic type() {\n\t\treturn 'attrib_remap';\n\t}\n\n\tinitialize_node() {\n\t\tthis.io.inputs.set_count(1);\n\t}\n\n\tcook(input_contents: CoreGroup[]) {\n\t\tconst core_group = input_contents[0];\n\t\tthis._remap_attribute(core_group);\n\t\tthis.set_core_group(core_group);\n\t}\n\n\t_remap_attribute(core_group: CoreGroup) {\n\t\tconst points = core_group.points();\n\t\tif (points.length === 0) {\n\t\t\treturn;\n\t\t}\n\t\tif (this.pv.name === '') {\n\t\t\treturn;\n\t\t}\n\n\t\tconst attrib_size = points[0].attrib_size(this.pv.name);\n\t\tconst values = points.map((point) => point.attrib_value(this.pv.name));\n\t\tlet min: NumericAttribValue, max: NumericAttribValue;\n\t\tlet normalized_values: NumericAttribValue[] = new Array(points.length);\n\t\tswitch (attrib_size) {\n\t\t\tcase 1:\n\t\t\t\tif (this.pv.only_integer_values) {\n\t\t\t\t\tconst sorted_values = lodash_uniq(lodash_sortBy(values));\n\t\t\t\t\tconst index_by_value: Dictionary<number> = {};\n\t\t\t\t\tsorted_values.forEach((sorted_value, i) => (index_by_value[sorted_value] = i));\n\t\t\t\t\tnormalized_values = values.map((value) => index_by_value[value]);\n\t\t\t\t} else {\n\t\t\t\t\tmin = lodash_min(values);\n\t\t\t\t\tmax = lodash_max(values);\n\t\t\t\t\t//this._save_min_max(group, min, max)\n\t\t\t\t\tif (lodash_isNumber(min) && lodash_isNumber(max)) {\n\t\t\t\t\t\tfor (let i = 0; i < values.length; i++) {\n\t\t\t\t\t\t\tconst value = values[i];\n\t\t\t\t\t\t\tconst normalized_value = max > min ? (value - min) / (max - min) : 1;\n\t\t\t\t\t\t\tnormalized_values[i] = normalized_value;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase 3:\n\t\t\t\tmin = new Vector3(\n\t\t\t\t\tlodash_min(values.map((v) => v.x)),\n\t\t\t\t\tlodash_min(values.map((v) => v.y)),\n\t\t\t\t\tlodash_min(values.map((v) => v.z))\n\t\t\t\t);\n\t\t\t\tmax = new Vector3(\n\t\t\t\t\tlodash_max(values.map((v) => v.x)),\n\t\t\t\t\tlodash_max(values.map((v) => v.y)),\n\t\t\t\t\tlodash_max(values.map((v) => v.z))\n\t\t\t\t);\n\t\t\t\t//this._save_min_max(group, min, max)\n\t\t\t\tif (min instanceof Vector3 && max instanceof Vector3) {\n\t\t\t\t\tfor (let i = 0; i < values.length; i++) {\n\t\t\t\t\t\tconst value = values[i];\n\t\t\t\t\t\tconst normalized_value = new Vector3(\n\t\t\t\t\t\t\t(value.x - min.x) / (max.x - min.x),\n\t\t\t\t\t\t\t(value.y - min.y) / (max.y - min.y),\n\t\t\t\t\t\t\t(value.z - min.z) / (max.z - min.z)\n\t\t\t\t\t\t);\n\t\t\t\t\t\tnormalized_values[i] = normalized_value;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\n\t\tlet target_name = this.pv.name;\n\t\tif (this.pv.change_name) {\n\t\t\ttarget_name = this.pv.new_name;\n\t\t\tif (!core_group.has_attrib(target_name)) {\n\t\t\t\tcore_group.add_numeric_vertex_attrib(target_name, attrib_size, 0);\n\t\t\t}\n\t\t}\n\n\t\tnormalized_values.forEach((normalized_value, i) => {\n\t\t\tconst point = points[i];\n\t\t\tpoint.set_attrib_value(target_name, normalized_value);\n\t\t});\n\t}\n}\n\n// TODO: they should be saved as a detail, not per object\n// _save_min_max: (group, min, max)->\n// \tgroup.traverse (object)=>\n// \t\tobject_wrapper = new Core.Geometry.Object(object)\n// \t\tobject_wrapper.add_attribute(\"#{@_param_name}_min\", min)\n// \t\tobject_wrapper.add_attribute(\"#{@_param_name}_max\", max)\n","import {TypedSopNode} from './_Base';\nimport {CoreGroup} from '../../../core/geometry/Group';\n\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nimport {AttribClassMenuEntries, AttribClass} from '../../../core/geometry/Constant';\nimport {InputCloneMode} from '../../poly/InputCloneMode';\nclass AttribRenameSopParamsConfig extends NodeParamsConfig {\n\tclass = ParamConfig.INTEGER(AttribClass.VERTEX, {\n\t\tmenu: {\n\t\t\tentries: AttribClassMenuEntries,\n\t\t},\n\t});\n\told_name = ParamConfig.STRING();\n\tnew_name = ParamConfig.STRING();\n}\nconst ParamsConfig = new AttribRenameSopParamsConfig();\n\nexport class AttribRenameSopNode extends TypedSopNode<AttribRenameSopParamsConfig> {\n\tparams_config = ParamsConfig;\n\tstatic type() {\n\t\treturn 'attrib_rename';\n\t}\n\n\tinitialize_node() {\n\t\tthis.io.inputs.set_count(1);\n\t\tthis.io.inputs.init_inputs_clonable_state([InputCloneMode.FROM_NODE]);\n\t}\n\n\tcook(input_contents: CoreGroup[]) {\n\t\t// const group = input_containers[0].group();\n\t\tconst core_group = input_contents[0];\n\n\t\tcore_group.rename_attrib(this.pv.old_name, this.pv.new_name, this.pv.class);\n\n\t\tthis.set_core_group(core_group);\n\t}\n}\n","import {Vector3} from 'three/src/math/Vector3';\nimport {Sphere} from 'three/src/math/Sphere';\nimport {Box3} from 'three/src/math/Box3';\nimport lodash_flatten from 'lodash/flatten';\nimport {CorePoint} from '../../geometry/Point';\n\nexport type OctreeNodeTraverseCallback = (node: OctreeNode) => void;\n\nexport class OctreeNode {\n\t_leaves_by_octant: Dictionary<OctreeNode> = {};\n\t_points_by_octant_id: Dictionary<CorePoint[]> = {};\n\t_leaves: OctreeNode[] = [];\n\t// _bbox: Box3 | undefined;\n\t_center: Vector3;\n\t_bounding_boxes_by_octant: Dictionary<Box3> = {};\n\t_bounding_boxes_by_octant_prepared: boolean = false;\n\n\tconstructor(private _bbox: Box3, private _level: number = 0) {\n\t\tthis._center = this._bbox.max\n\t\t\t.clone()\n\t\t\t.add(this._bbox.min)\n\t\t\t.multiplyScalar(0.5);\n\t}\n\t// set_bounding_box(bbox: Box3) {\n\t// \tthis._bbox = bbox;\n\t// }\n\n\tlevel() {\n\t\treturn this._level;\n\t}\n\n\ttraverse(callback: OctreeNodeTraverseCallback) {\n\t\tcallback(this);\n\t\tconst octants = Object.values(this._leaves_by_octant);\n\t\toctants.forEach((node) => {\n\t\t\tnode.traverse(callback);\n\t\t});\n\t}\n\n\tintersects_sphere(sphere: Sphere): boolean {\n\t\tif (this._bbox) {\n\t\t\treturn this._bbox.intersectsSphere(sphere);\n\t\t}\n\t\treturn false;\n\t}\n\n\t//@PERF = 0\n\tpoints_in_sphere(sphere: Sphere, accumulated_points: CorePoint[]): void {\n\t\tif (this._leaves.length == 0) {\n\t\t\tconst found_points = lodash_flatten(Object.values(this._points_by_octant_id));\n\t\t\tconst selected_points = found_points.filter((point) => sphere.containsPoint(point.position()));\n\t\t\tselected_points.forEach((point) => {\n\t\t\t\taccumulated_points.push(point);\n\t\t\t});\n\t\t} else {\n\t\t\t//start_time = performance.now()\n\t\t\tconst leaves_intersecting_with_sphere = this._leaves.filter((leaf) => leaf.intersects_sphere(sphere));\n\n\t\t\t//console.log(\"level: #{@_level}, found #{leaves_intersecting_with_sphere.length} leaves \")\n\t\t\tleaves_intersecting_with_sphere.forEach((leaf) => leaf.points_in_sphere(sphere, accumulated_points));\n\t\t}\n\t}\n\t//this.constructor.PERF += performance.now()-start_time\n\n\tbounding_box(): Box3 | undefined {\n\t\treturn this._bbox;\n\t}\n\n\t// points_count: ->\n\t// \t@_points_count\n\n\tset_points(points: CorePoint[]) {\n\t\t//@_points_count = points.length\n\n\t\tthis._points_by_octant_id = {};\n\t\tfor (let point of points) {\n\t\t\tthis.add_point(point);\n\t\t}\n\n\t\tconst octant_ids = Object.keys(this._points_by_octant_id);\n\t\tif (octant_ids.length > 1) {\n\t\t\toctant_ids.forEach((octant_id) => {\n\t\t\t\tthis.create_leaf(octant_id);\n\t\t\t});\n\t\t}\n\t}\n\n\tcreate_leaf(octant_id: string) {\n\t\tconst box = this._leaf_bbox(octant_id);\n\t\tconst leaf = new OctreeNode(box, this._level + 1);\n\t\tthis._leaves_by_octant[octant_id] = leaf;\n\t\tthis._leaves.push(leaf);\n\t\t//throw \"test #{@_level}\"\n\n\t\tleaf.set_points(this._points_by_octant_id[octant_id]);\n\t}\n\n\tadd_point(point: CorePoint) {\n\t\tconst octant_id = this._octant_id(point.position());\n\t\tif (this._points_by_octant_id[octant_id] == null) {\n\t\t\tthis._points_by_octant_id[octant_id] = [];\n\t\t}\n\t\tthis._points_by_octant_id[octant_id].push(point);\n\t}\n\n\tprivate _octant_id(position: Vector3): string {\n\t\tconst x_pos = position.x > this._center.x ? 1 : 0;\n\t\tconst y_pos = position.y > this._center.y ? 1 : 0;\n\t\tconst z_pos = position.z > this._center.z ? 1 : 0;\n\t\treturn `${x_pos}${y_pos}${z_pos}`;\n\t}\n\n\t_leaf_bbox(octant_id: string): Box3 {\n\t\tif (!this._bounding_boxes_by_octant_prepared) {\n\t\t\tthis._prepare_leaves_bboxes();\n\t\t\tthis._bounding_boxes_by_octant_prepared = true;\n\t\t}\n\t\treturn this._bounding_boxes_by_octant[octant_id];\n\t}\n\n\tprivate _bbox_center(x_pos: number, y_pos: number, z_pos: number) {\n\t\tconst corner = this._bbox.min.clone();\n\t\tif (x_pos) {\n\t\t\tcorner.x = this._bbox.max.x;\n\t\t}\n\t\tif (y_pos) {\n\t\t\tcorner.y = this._bbox.max.y;\n\t\t}\n\t\tif (z_pos) {\n\t\t\tcorner.z = this._bbox.max.z;\n\t\t}\n\n\t\treturn corner\n\t\t\t.clone()\n\t\t\t.add(this._center)\n\t\t\t.multiplyScalar(0.5);\n\t}\n\n\tprivate _prepare_leaves_bboxes() {\n\t\tconst bbox_centers = [];\n\t\tbbox_centers.push(this._bbox_center(0, 0, 0));\n\t\tbbox_centers.push(this._bbox_center(0, 0, 1));\n\t\tbbox_centers.push(this._bbox_center(0, 1, 0));\n\t\tbbox_centers.push(this._bbox_center(0, 1, 1));\n\t\tbbox_centers.push(this._bbox_center(1, 0, 0));\n\t\tbbox_centers.push(this._bbox_center(1, 0, 1));\n\t\tbbox_centers.push(this._bbox_center(1, 1, 0));\n\t\tbbox_centers.push(this._bbox_center(1, 1, 1));\n\n\t\tconst bbox_size_quarter = this._bbox.max\n\t\t\t.clone()\n\t\t\t.sub(this._bbox.min)\n\t\t\t.multiplyScalar(0.25);\n\t\tfor (let bbox_center of bbox_centers) {\n\t\t\tconst octant_id = this._octant_id(bbox_center);\n\t\t\tconst bbox = new Box3(\n\t\t\t\tbbox_center.clone().sub(bbox_size_quarter),\n\t\t\t\tbbox_center.clone().add(bbox_size_quarter)\n\t\t\t);\n\t\t\tthis._bounding_boxes_by_octant[octant_id] = bbox;\n\t\t}\n\t\t// this._bounding_boxes_by_octant;\n\t}\n}\n","import {Vector3} from 'three/src/math/Vector3';\nimport {Sphere} from 'three/src/math/Sphere';\nimport {Box3} from 'three/src/math/Box3';\nimport lodash_sortBy from 'lodash/sortBy';\nimport {CorePoint} from '../../geometry/Point';\n// import {CoreMath} from './_Module'\n// import OctreeModule from './Octree/_Module';\nimport {OctreeNode, OctreeNodeTraverseCallback} from './Node';\n\nexport class CoreOctree {\n\tprivate _root: OctreeNode;\n\n\tconstructor(bbox: Box3) {\n\t\tthis._root = new OctreeNode(bbox);\n\t}\n\n\t// set_bounding_box(bbox: Box3) {\n\t// \tthis._root.set_bounding_box(bbox)\n\t// }\n\n\tset_points(points: CorePoint[]) {\n\t\tthis._root.set_points(points);\n\t}\n\n\ttraverse(callback: OctreeNodeTraverseCallback) {\n\t\tthis._root.traverse(callback);\n\t}\n\n\t// TODO: I am tempted to stop going through the leaves if\n\t// the ones currently seen already have the required number of points.\n\t// but that probably doesn't work as those points may end up being further\n\t// than the ones from the following leaf\n\tfind_points(position: Vector3, distance: number, max_points_count?: number): CorePoint[] {\n\t\tconst sphere = new Sphere(position, distance);\n\t\tlet found_points: CorePoint[] = [];\n\n\t\tif (this._root.intersects_sphere(sphere)) {\n\t\t\tthis._root.points_in_sphere(sphere, found_points);\n\t\t}\n\n\t\tif (max_points_count == null) {\n\t\t\treturn found_points;\n\t\t} else {\n\t\t\tif (found_points.length > max_points_count) {\n\t\t\t\tfound_points = lodash_sortBy(found_points, (point) => {\n\t\t\t\t\treturn point.position().distanceTo(position);\n\t\t\t\t});\n\t\t\t\t// const lng_lat = {lng: position.x, lat: position.z}\n\t\t\t\t// found_points = lodash_sortBy(found_points, (point)=>{\n\t\t\t\t// \tconst src_position = point.position()\n\t\t\t\t// \tconst src_lng_lat = {lng: src_position.x, lat: src_position.z}\n\t\t\t\t// \treturn CoreMath.geodesic_distance(src_lng_lat, lng_lat)\n\t\t\t\t// });\n\n\t\t\t\tfound_points = found_points.slice(0, max_points_count);\n\t\t\t}\n\n\t\t\treturn found_points;\n\t\t}\n\t}\n}\n\n// Octree.Node = OctreeNode;\n","type IterateeMethod = (element: any, index?: number) => void;\ntype IterateeMethodArray = IterateeMethod; // TODO: check this, as the element may be an array\ntype IterateeMethodCount = (index: number) => void;\n\ninterface CoreIteratorOptions {\n\tmax_time_per_chunk?: number;\n\tcheck_every_interations?: number;\n}\n\nexport class CoreIterator {\n\t// array\n\tprivate _array: any[] | undefined;\n\tprivate _iteratee_method_array: IterateeMethodArray | undefined;\n\tprivate _bound_next_with_array: (() => void) | undefined;\n\tprivate _current_array_element: any;\n\tprivate _array_index: number = 0;\n\n\t// count\n\tprivate _count: number = 0;\n\tprivate _iteratee_method_count: IterateeMethodCount | undefined;\n\tprivate _bound_next_with_count: (() => void) | undefined;\n\tprivate _current_count_index: number = 0;\n\n\tprivate _max_time_per_chunk: number;\n\tprivate _check_every_interations: number;\n\n\tprivate _resolve: null | (() => void) = null;\n\n\tconstructor(options: CoreIteratorOptions = {}) {\n\t\tthis._max_time_per_chunk = options.max_time_per_chunk || 10;\n\t\tthis._check_every_interations = options.check_every_interations || 100;\n\t}\n\n\tasync start_with_count(count: number, iteratee_method: IterateeMethodCount) {\n\t\tthis._count = count;\n\t\tthis._current_count_index = 0;\n\t\tthis._iteratee_method_count = iteratee_method;\n\t\tthis._bound_next_with_count = this.next_with_count.bind(this);\n\n\t\tif (this._resolve) {\n\t\t\tthrow 'an iterator cannot be started twice';\n\t\t}\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tthis._resolve = resolve;\n\t\t\tthis.next_with_count();\n\t\t});\n\t}\n\tnext_with_count() {\n\t\tconst start_time = performance.now();\n\n\t\tif (this._iteratee_method_count && this._bound_next_with_count) {\n\t\t\twhile (this._current_count_index < this._count) {\n\t\t\t\tthis._iteratee_method_count(this._current_count_index);\n\n\t\t\t\tthis._current_count_index++;\n\n\t\t\t\tif (this._current_count_index % this._check_every_interations == 0) {\n\t\t\t\t\tif (performance.now() - start_time > this._max_time_per_chunk) {\n\t\t\t\t\t\tsetTimeout(this._bound_next_with_count, 1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (this._current_count_index >= this._count) {\n\t\t\tif (this._resolve) {\n\t\t\t\tthis._resolve();\n\t\t\t}\n\t\t}\n\t}\n\n\t//\n\t//\n\t// ARRAY\n\t//\n\t//\n\tasync start_with_array(array: any[], iteratee_method: IterateeMethod) {\n\t\tthis._array = array;\n\t\tthis._array_index = 0;\n\t\tthis._iteratee_method_array = iteratee_method;\n\t\tthis._bound_next_with_array = this.next_with_array.bind(this);\n\n\t\tif (this._resolve) {\n\t\t\tthrow 'an iterator cannot be started twice';\n\t\t}\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tthis._resolve = resolve;\n\t\t\tthis.next_with_array();\n\t\t});\n\t}\n\tnext_with_array() {\n\t\tconst start_time = performance.now();\n\n\t\tif (this._iteratee_method_array && this._bound_next_with_array && this._array) {\n\t\t\twhile ((this._current_array_element = this._array[this._array_index])) {\n\t\t\t\tthis._iteratee_method_array(this._current_array_element, this._array_index);\n\n\t\t\t\tthis._array_index++;\n\n\t\t\t\tif (this._array_index % this._check_every_interations == 0) {\n\t\t\t\t\tif (performance.now() - start_time > this._max_time_per_chunk) {\n\t\t\t\t\t\tsetTimeout(this._bound_next_with_array, 1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (this._current_array_element === undefined) {\n\t\t\tif (this._resolve) {\n\t\t\t\tthis._resolve();\n\t\t\t}\n\t\t}\n\t}\n}\n","import {TypedSopNode} from './_Base';\nimport {CorePoint} from '../../../core/geometry/Point';\nimport {CoreGroup} from '../../../core/geometry/Group';\n// import {CoreMath} from '../../../core/math/_Module';\nimport {CoreInterpolate} from '../../../core/math/Interpolate';\nimport {CoreOctree} from '../../../core/math/octree/Octree';\nimport {CoreIterator} from '../../../core/Iterator';\n// import lodash_sum from 'lodash/sum';\n\n// enum TransferMethod {\n// \tAUTO = 0,\n// \tARTISTIC = 1,\n// }\n// const TransferMethodMenuEntries = [\n// \t{name: 'auto', value: TransferMethod.AUTO},\n// \t{name: 'artistic', value: TransferMethod.ARTISTIC},\n// ];\n\n// const LATITUDE = 'Latitude'\n// const LONGITUDE = 'Longitude'\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nimport {InputCloneMode} from '../../poly/InputCloneMode';\nclass AttribTransferSopParamsConfig extends NodeParamsConfig {\n\tsrc_group = ParamConfig.STRING();\n\tdest_group = ParamConfig.STRING();\n\tname = ParamConfig.STRING();\n\tmax_samples_count = ParamConfig.INTEGER(1, {\n\t\trange: [1, 10],\n\t\trange_locked: [true, false],\n\t});\n\t// method = ParamConfig.INTEGER(TransferMethod.AUTO, {\n\t// \tmenu: {\n\t// \t\tentries: TransferMethodMenuEntries,\n\t// \t},\n\t// });\n\tdistance_threshold = ParamConfig.FLOAT(1);\n\tblend_width = ParamConfig.FLOAT(0);\n}\nconst ParamsConfig = new AttribTransferSopParamsConfig();\n\nexport class AttribTransferSopNode extends TypedSopNode<AttribTransferSopParamsConfig> {\n\tparams_config = ParamsConfig;\n\tstatic type() {\n\t\treturn 'attrib_transfer';\n\t}\n\n\t_core_group_dest!: CoreGroup;\n\t_core_group_src!: CoreGroup;\n\n\t// utils\n\t_attrib_names!: string[];\n\t_octree_timestamp: number | undefined;\n\t_prev_param_src_group: string | undefined;\n\t_octree: CoreOctree | undefined;\n\n\tstatic displayed_input_names(): string[] {\n\t\treturn ['geometry to transfer attributes to', 'geometry to transfer attributes from'];\n\t}\n\n\tinitialize_node() {\n\t\tthis.io.inputs.set_count(2);\n\t\tthis.io.inputs.init_inputs_clonable_state([InputCloneMode.FROM_NODE, InputCloneMode.NEVER]);\n\t}\n\n\tasync cook(input_contents: CoreGroup[]) {\n\t\t// this._group_dest = input_containers[0].group();\n\t\t// const container1 = input_containers[1];\n\n\t\tthis._core_group_dest = input_contents[0]; //new CoreGroup(this._group_dest);\n\t\tconst dest_points = this._core_group_dest.points_from_group(this.pv.dest_group);\n\n\t\t// this._group_src = input_containers[1] //container1.group({ clone: false });\n\t\tthis._core_group_src = input_contents[1]; //new CoreGroup(this._group_src);\n\n\t\tthis._attrib_names = this._core_group_src.attrib_names_matching_mask(this.pv.name);\n\t\tthis._error_if_attribute_not_found_on_second_input();\n\t\tthis._build_octree_if_required(this._core_group_src);\n\t\tthis._add_attribute_if_required();\n\n\t\tawait this._transfer_attributes(dest_points);\n\t\tthis.set_core_group(this._core_group_dest);\n\t}\n\n\t_error_if_attribute_not_found_on_second_input() {\n\t\tfor (let attrib_name of this._attrib_names) {\n\t\t\tif (!this._core_group_src.has_attrib(attrib_name)) {\n\t\t\t\tthis.states.error.set(`attribute '${attrib_name}' not found on second input`);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate _build_octree_if_required(core_group: CoreGroup) {\n\t\tconst second_input_changed =\n\t\t\tthis._octree_timestamp == null || this._octree_timestamp !== core_group.timestamp();\n\t\tconst src_group_changed = this._prev_param_src_group !== this.pv.src_group;\n\n\t\tif (src_group_changed || second_input_changed) {\n\t\t\tthis._octree_timestamp = core_group.timestamp();\n\t\t\tthis._prev_param_src_group = this.pv.src_group;\n\n\t\t\tconst points_src = this._core_group_src.points_from_group(this.pv.src_group);\n\n\t\t\tthis._octree = new CoreOctree(this._core_group_src.bounding_box());\n\t\t\tthis._octree.set_points(points_src);\n\t\t}\n\t}\n\n\tprivate _add_attribute_if_required() {\n\t\tthis._attrib_names.forEach((attrib_name) => {\n\t\t\tif (!this._core_group_dest.has_attrib(attrib_name)) {\n\t\t\t\tconst attrib_size = this._core_group_src.attrib_size(attrib_name);\n\t\t\t\tthis._core_group_dest.add_numeric_vertex_attrib(attrib_name, attrib_size, 0);\n\t\t\t}\n\t\t});\n\t}\n\n\tprivate async _transfer_attributes(dest_points: CorePoint[]) {\n\t\t// const start_time = performance.now()\n\t\tconst iterator = new CoreIterator();\n\t\tawait iterator.start_with_array(dest_points, this._transfer_attributes_for_point.bind(this));\n\t\t// for(let dest_point of dest_points){\n\n\t\t// \tthis._transfer_attributes_for_point(dest_point)\n\n\t\t// }\n\t}\n\tprivate _transfer_attributes_for_point(dest_point: CorePoint) {\n\t\tconst total_dist = this.pv.distance_threshold + this.pv.blend_width;\n\t\tconst nearest_points: CorePoint[] =\n\t\t\tthis._octree?.find_points(dest_point.position(), total_dist, this.pv.max_samples_count) || [];\n\n\t\t// test[nearest_points.length] = test[nearest_points.length] || 0\n\t\t// test[nearest_points.length] += 1\n\n\t\tfor (let attrib_name of this._attrib_names) {\n\t\t\tthis._interpolate_points(dest_point, nearest_points, attrib_name);\n\t\t}\n\t}\n\n\t// if @_param_draw_connections\n\t// \tlodash_each nearest_points, (nearest_point)=>\n\t// \t\t@_connection_point_pairs.push([ nearest_point.position(), dest_point.position() ])\n\n\t// if @_param_draw_connections\n\t// \tthis._draw_connections()\n\n\tprivate _interpolate_points(point_dest: CorePoint, src_points: CorePoint[], attrib_name: string) {\n\t\tlet new_value: number;\n\t\t// if (this.pv.method == TransferMethod.ARTISTIC) {\n\n\t\tnew_value = CoreInterpolate.perform(\n\t\t\tpoint_dest,\n\t\t\tsrc_points,\n\t\t\tattrib_name,\n\t\t\tthis.pv.distance_threshold,\n\t\t\tthis.pv.blend_width\n\t\t);\n\t\t// } else {\n\t\t// \tnew_value = this._select(point_dest, src_points, attrib_name);\n\t\t// \tconsole.log('B new_value', new_value);\n\t\t// }\n\n\t\tif (new_value != null) {\n\t\t\tpoint_dest.set_attrib_value(attrib_name, new_value);\n\t\t}\n\t}\n\n\t// private _select(point_dest: CorePoint, src_points: CorePoint[], attrib_name: string) {\n\t// \tconst src_values = [];\n\t// \tconst inverse_distances = [];\n\t// \tconst dest_position = point_dest.position();\n\t// \tconst dest_lng_lat = {lng: dest_position.x, lat: dest_position.z};\n\t// \tfor (let src_point of src_points) {\n\t// \t\t// const dist = dest_position.distanceTo(src_point.position()) //* 0.1\n\t// \t\tconst src_position = src_point.position();\n\t// \t\tconst src_lng_lat = {lng: src_position.x, lat: src_position.z};\n\t// \t\tconst dist = CoreMath.geodesic_distance(src_lng_lat, dest_lng_lat);\n\t// \t\tconst dist_squared = dist * dist;\n\t// \t\tconst attrib_value = src_point.attrib_value(attrib_name);\n\n\t// \t\tsrc_values.push(attrib_value / dist_squared);\n\t// \t\tinverse_distances.push(1 / dist_squared);\n\t// \t}\n\n\t// \tconst sum = lodash_sum(src_values) / lodash_sum(inverse_distances);\n\t// \treturn sum;\n\t// }\n\n\t// ROUND(\n\n\t// \tSUM(\n\t// \t\tValue\n\t// \t\t/\n\t// \t\t(dist_meters*dist_meters)\n\t// \t\t)\n\t// \t/\n\t// \tSUM(\n\t// \t\t1\n\t// \t\t/\n\t// \t\t(dist_meters*dist_meters)\n\t// \t\t)\n\n\t// \t,1\n\n\t// )\n\n\t// _draw_connections() {\n\t// \tlet positions = [];\n\t// \tconst indices = [];\n\n\t// \tlodash_each(this._connection_point_pairs, function(current_positions, i) {\n\n\t// \t\tpositions.push(current_positions[0].toArray());\n\t// \t\tpositions.push(current_positions[1].toArray());\n\n\t// \t\tindices.push((2 * i) + 0);\n\t// \t\treturn indices.push((2 * i) + 1);\n\t// \t});\n\n\t// \tpositions = lodash_flatten(positions);\n\t// \tconst geometry = new THREE.BufferGeometry();\n\t// \tgeometry.setAttribute( 'position', new THREE.Float32BufferAttribute( positions, 3 ) );\n\t// \tgeometry.setIndex(indices);\n\t// \tconst object = this.create_object(geometry, Core.Geometry.Constant.OBJECT_TYPE.LINE_SEGMENTS);\n\t// \treturn this._group_dest.add(object);\n\t// }\n}\n","import lodash_max from 'lodash/max';\n// import lodash_last from 'lodash/last'\nimport lodash_sum from 'lodash/sum';\n\nimport {Vector3} from 'three/src/math/Vector3';\n// import {Vector2} from 'three/src/math/Vector2';\n// import {_Math} from 'three/src/math/MathU';\n// const THREE = {Math: _Math, Vector2, Vector3}\nimport {CorePoint} from '../geometry/Point';\n\nexport class CoreInterpolate {\n\tstatic perform(\n\t\tpoint_dest: CorePoint,\n\t\tpoints_src: CorePoint[],\n\t\tattrib_name: string,\n\t\tdistance_threshold: number,\n\t\tblend_with: number\n\t): number {\n\t\tswitch (points_src.length) {\n\t\t\tcase 0:\n\t\t\t\treturn 0;\n\t\t\tcase 1:\n\t\t\t\treturn this._interpolate_with_1_point(\n\t\t\t\t\tpoint_dest,\n\t\t\t\t\tpoints_src[0],\n\t\t\t\t\tattrib_name,\n\t\t\t\t\tdistance_threshold,\n\t\t\t\t\tblend_with\n\t\t\t\t);\n\t\t\tdefault:\n\t\t\t\t// positions_src = lodash_map(points_src, (point) -> point.position())\n\t\t\t\t// values_src = lodash_map(points_src, (point) -> point.attrib_value(attrib_name))\n\t\t\t\t// position_dest = point_dest.position()\n\t\t\t\t//if positions_src.length > 3\n\t\t\t\t//\tpositions_src = positions_src.slice(0,3)\n\t\t\t\t//this._interpolate_with_3_points_max(positions_src, values_src, position_dest, dest_value)\n\t\t\t\treturn this._interpolate_with_multiple_points(\n\t\t\t\t\tpoint_dest,\n\t\t\t\t\tpoints_src,\n\t\t\t\t\tattrib_name,\n\t\t\t\t\tdistance_threshold,\n\t\t\t\t\tblend_with\n\t\t\t\t);\n\t\t}\n\t}\n\n\tstatic _interpolate_with_1_point(\n\t\tpoint_dest: CorePoint,\n\t\tpoint_src: CorePoint,\n\t\tattrib_name: string,\n\t\tdistance_threshold: number,\n\t\tblend_with: number\n\t): number {\n\t\tconst position_dest = point_dest.position();\n\t\tconst position_src = point_src.position();\n\t\tconst distance = position_dest.distanceTo(position_src);\n\n\t\tconst value_src = point_src.attrib_value(attrib_name);\n\t\treturn this._weighted_value_from_distance(\n\t\t\tpoint_dest,\n\t\t\tvalue_src,\n\t\t\tattrib_name,\n\t\t\tdistance,\n\t\t\tdistance_threshold,\n\t\t\tblend_with\n\t\t);\n\t}\n\n\tstatic _weight_from_distance(distance: number, distance_threshold: number, blend_with: number) {\n\t\treturn (distance - distance_threshold) / blend_with;\n\t}\n\n\tstatic _weighted_value_from_distance(\n\t\tpoint_dest: CorePoint,\n\t\tvalue_src: number,\n\t\tattrib_name: string,\n\t\tdistance: number,\n\t\tdistance_threshold: number,\n\t\tblend_with: number\n\t): number {\n\t\tif (distance <= distance_threshold) {\n\t\t\treturn value_src;\n\t\t} else {\n\t\t\tconst value_dest = point_dest.attrib_value(attrib_name);\n\t\t\tconst blend = this._weight_from_distance(distance, distance_threshold, blend_with);\n\t\t\treturn blend * value_dest + (1 - blend) * value_src;\n\t\t\t// switch (point_dest.attrib_size(attrib_name)) {\n\t\t\t// \tcase 1:\n\t\t\t// \t\t// const value_src_as_number = value_src as number;\n\t\t\t// \t\treturn blend * value_dest + (1 - blend) * value_src;\n\t\t\t// \tcase 2:\n\t\t\t// \t\tconst value_src_as_vec2 = value_src as Vector2Like;\n\t\t\t// \t\treturn new Vector2(\n\t\t\t// \t\t\tblend * value_dest.x + (1 - blend) * value_src_as_vec2.x,\n\t\t\t// \t\t\tblend * value_dest.y + (1 - blend) * value_src_as_vec2.y\n\t\t\t// \t\t);\n\t\t\t// \tcase 3:\n\t\t\t// \t\tconst value_src_as_vec3 = value_src as Vector3Like;\n\t\t\t// \t\treturn new Vector3(\n\t\t\t// \t\t\tblend * value_dest.x + (1 - blend) * value_src_as_vec3.x,\n\t\t\t// \t\t\tblend * value_dest.y + (1 - blend) * value_src_as_vec3.y,\n\t\t\t// \t\t\tblend * value_dest.z + (1 - blend) * value_src_as_vec3.z\n\t\t\t// \t\t);\n\t\t\t// \tdefault:\n\t\t\t// \t\treturn 0;\n\t\t\t// }\n\t\t}\n\t}\n\n\t// @_interpolate_with_3_points_max: (positions_src, values_src, position_dest, dest_value)->\n\t// \tweights = this.weights( position_dest, positions_src )\n\t// \tinterpolated_value = lodash_sum lodash_map values_src, (src_value, i)=>\n\t// \t\tweights[i] * src_value\n\n\t// \tif dest_value?\n\t// \t\t0.5 * (dest_value + src_value)\n\t// \telse\n\t// \t\tinterpolated_value\n\n\t// weights: http://www.sidefx.com/docs/houdini/nodes/vop/pcfilter.html\n\t// w_i = 1-smooth(0, maxd*1.1, d_i);\n\t// maxd is the farthest point, and w_i is the weight for a given point at distance (d_i). Points that are closer to the center will be weighted higher with that formula, rather than it being an average.\n\tstatic _interpolate_with_multiple_points(\n\t\tpoint_dest: CorePoint,\n\t\tpoints_src: CorePoint[],\n\t\tattrib_name: string,\n\t\tdistance_threshold: number,\n\t\tblend_with: number\n\t): number {\n\t\t// let new_value\n\t\t// const positions_src = lodash_map(points_src, (point) =>\n\t\t// \tpoint.position()\n\t\t// )\n\t\t// const values_src = lodash_map(points_src, (point) =>\n\t\t// \tpoint.attrib_value(attrib_name)\n\t\t// )\n\t\t// const position_dest = point_dest.position()\n\t\t// const attrib_size = point_dest.attrib_size(attrib_name);\n\n\t\t// const distances = lodash_map(positions_src, (src_position) =>\n\t\t// \tsrc_position.distanceTo(position_dest)\n\t\t// )\n\t\t// distances = distances.sort()\n\t\t// max_dist = lodash_last(distances)\n\t\t// const max_dist = distance_threshold + blend_with\n\n\t\t// const weights = lodash_map(positions_src, (src_position, i) => {\n\t\t// \tconst distance = distances[i]\n\t\t// \t//1 - Math.smootherstep(distance, 0, max_dist*1.1)\n\t\t// \treturn this._weight_from_distance(\n\t\t// \t\tdistance,\n\t\t// \t\tdistance_threshold,\n\t\t// \t\tblend_with\n\t\t// \t)\n\t\t// })\n\n\t\t// const total_weight = lodash_sum(weights)\n\n\t\t// weighted_values = lodash_map values_src, (src_value, i)->\n\t\t// \tswitch attrib_size\n\t\t// \t\twhen 1 then src_value * weights[i]\n\t\t// \t\telse\n\t\t// \t\t\tsrc_value.clone().multiplyScalar(weights[i])\n\t\tconst weighted_values_src = points_src.map((point_src) => {\n\t\t\treturn this._interpolate_with_1_point(point_dest, point_src, attrib_name, distance_threshold, blend_with);\n\t\t});\n\t\treturn lodash_max(weighted_values_src) || 0;\n\n\t\t// // TODO: we could have 2 modes of interpolation?\n\t\t// // return (new_value = (() => {\n\t\t// switch (attrib_size) {\n\t\t// \t// when 1 then lodash_sum(weighted_values_src) / values_src.length # mode 1\n\t\t// \tcase 1:\n\t\t// \t\treturn lodash_max(weighted_values_src); // mode 2\n\t\t// \tdefault:\n\t\t// \t\tthrow 'interpolation with multiple vectors not implemented yet';\n\t\t// \t// var new_vector = weighted_values_src[0].clone();\n\t\t// \t// new_vector.x = lodash_sum(lodash_map(weighted_values, 'x')) / total_weight;\n\t\t// \t// new_vector.y = lodash_sum(lodash_map(weighted_values, 'y')) / total_weight;\n\t\t// \t// if (new_vector.z != null) {\n\t\t// \t// \tnew_vector.z = lodash_sum(lodash_map(weighted_values, 'z')) / total_weight;\n\t\t// \t// }\n\t\t// \t// return new_vector;\n\t\t// }\n\t\t// })())\n\t}\n\n\t// https://math.stackexchange.com/questions/1336386/weighted-average-distance-between-3-or-more-positions\n\tstatic weights(current_position: Vector3, other_positions: Vector3[]) {\n\t\tswitch (other_positions.length) {\n\t\t\tcase 1:\n\t\t\t\treturn 1;\n\t\t\tcase 2:\n\t\t\t\treturn this._weights_from_2(current_position, other_positions);\n\t\t\tdefault:\n\t\t\t\tother_positions = other_positions.slice(0, 3);\n\t\t\t\treturn this._weights_from_3(current_position, other_positions);\n\t\t}\n\t}\n\n\tstatic _weights_from_2(current_position: Vector3, other_positions: Vector3[]) {\n\t\tconst dist_to_positions = other_positions.map((other_position) => current_position.distanceTo(other_position));\n\n\t\tconst distance_total = lodash_sum(dist_to_positions);\n\n\t\treturn [dist_to_positions[1] / distance_total, dist_to_positions[0] / distance_total];\n\t}\n\n\tstatic _weights_from_3(current_position: Vector3, other_positions: Vector3[]) {\n\t\tconst dist_to_positions = other_positions.map((other_position) => current_position.distanceTo(other_position));\n\n\t\tconst distance_total = lodash_sum([\n\t\t\tdist_to_positions[0] * dist_to_positions[1],\n\t\t\tdist_to_positions[0] * dist_to_positions[2],\n\t\t\tdist_to_positions[1] * dist_to_positions[2],\n\t\t]);\n\n\t\treturn [\n\t\t\t(dist_to_positions[1] * dist_to_positions[2]) / distance_total,\n\t\t\t(dist_to_positions[0] * dist_to_positions[2]) / distance_total,\n\t\t\t(dist_to_positions[0] * dist_to_positions[1]) / distance_total,\n\t\t];\n\t}\n}\n","import {BufferGeometry} from 'three/src/core/BufferGeometry';\nimport {BufferAttribute} from 'three/src/core/BufferAttribute';\nimport lodash_range from 'lodash/range';\nimport {TypedSopNode} from './_Base';\nimport {CoreConstant} from '../../../core/geometry/Constant';\n\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nimport {CoreGroup} from '../../../core/geometry/Group';\nclass BboxScatterSopParamsConfig extends NodeParamsConfig {\n\tstep_size = ParamConfig.FLOAT(0.1);\n}\nconst ParamsConfig = new BboxScatterSopParamsConfig();\n\nexport class BboxScatterSopNode extends TypedSopNode<BboxScatterSopParamsConfig> {\n\tparams_config = ParamsConfig;\n\tstatic type() {\n\t\treturn 'bbox_scatter';\n\t}\n\n\tstatic displayed_input_names(): string[] {\n\t\treturn ['geometry to create points from'];\n\t}\n\n\tinitialize_node() {\n\t\tthis.io.inputs.set_count(1);\n\t}\n\n\tcook(input_contents: CoreGroup[]) {\n\t\tconst container = input_contents[0];\n\t\t// const group = container.group();\n\n\t\tconst step_size = this.pv.step_size;\n\t\t// jitter = @_param_jitter\n\n\t\tconst bbox = container.bounding_box();\n\n\t\tconst range = {\n\t\t\tx: lodash_range(bbox.min.x, bbox.max.x, step_size),\n\t\t\ty: lodash_range(bbox.min.y, bbox.max.y, step_size),\n\t\t\tz: lodash_range(bbox.min.z, bbox.max.z, step_size),\n\t\t};\n\n\t\t// create buffer geometry\n\t\t// const vertices_count = range.x * range.y * range.z;\n\t\tconst positions: number[] = [];\n\t\trange.x.forEach((x) => {\n\t\t\trange.y.forEach((y) => {\n\t\t\t\trange.z.forEach((z) => {\n\t\t\t\t\tpositions.push(x);\n\t\t\t\t\tpositions.push(y);\n\t\t\t\t\tpositions.push(z);\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\n\t\tconst geometry = new BufferGeometry();\n\t\tgeometry.setAttribute('position', new BufferAttribute(new Float32Array(positions), 3));\n\n\t\tthis.set_geometry(geometry, CoreConstant.OBJECT_TYPE.POINTS);\n\t}\n}\n","import {TypedSopNode} from './_Base';\n\nimport {Object3D} from 'three/src/core/Object3D';\n\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nimport {InputCloneMode} from '../../poly/InputCloneMode';\nimport {CoreGroup} from '../../../core/geometry/Group';\nimport {BufferGeometry} from 'three/src/core/BufferGeometry';\nimport {Mesh} from 'three/src/objects/Mesh';\n\nclass BlendSopParamsConfig extends NodeParamsConfig {\n\tattrib_name = ParamConfig.STRING();\n\tblend = ParamConfig.FLOAT(0.5, {\n\t\trange: [0, 1],\n\t\trange_locked: [true, true],\n\t});\n}\nconst ParamsConfig = new BlendSopParamsConfig();\n\nexport class BlendSopNode extends TypedSopNode<BlendSopParamsConfig> {\n\tparams_config = ParamsConfig;\n\tstatic type() {\n\t\treturn 'blend';\n\t}\n\n\tstatic displayed_input_names(): string[] {\n\t\treturn ['geometry to blend from', 'geometry to blend to'];\n\t}\n\tinitialize_node() {\n\t\tthis.io.inputs.set_count(2);\n\t\tthis.io.inputs.init_inputs_clonable_state([InputCloneMode.FROM_NODE, InputCloneMode.NEVER]);\n\t}\n\n\tcook(input_contents: CoreGroup[]) {\n\t\t// this.request_input_container 0, (container0)=>\n\t\t// \tif container0? && (group0 = container0.group())?\n\t\t// \t\tthis.request_input_container 1, (container1)=>\n\t\t// \t\t\tif container1? && (group1 = container1.group({clone: false}))?\n\n\t\t//this.eval_all_params =>\n\t\t// const container0 = input_containers[0];\n\t\t// const container1 = input_containers[1];\n\n\t\t// const group0 = container0.group();\n\t\t// const group1 = container1.group();\n\t\tconst core_group0 = input_contents[0];\n\t\tconst core_group1 = input_contents[1];\n\n\t\tconst objects0 = core_group0.objects();\n\t\tconst objects1 = core_group1.objects();\n\n\t\tlet object0, object1;\n\t\tfor (let i = 0; i < objects0.length; i++) {\n\t\t\tobject0 = objects0[i];\n\t\t\tobject1 = objects1[i];\n\t\t\tthis.blend(object0, object1, this.pv.blend);\n\t\t}\n\t\tthis.set_core_group(core_group0);\n\t}\n\n\t// \t\telse\n\t// \t\t\tthis.set_error(\"input 1 required\")\n\n\t// else\n\t// \tthis.set_error(\"input 0 required\")\n\tprivate blend(object0: Object3D, object1: Object3D, blend: number) {\n\t\tconst geometry0 = (object0 as Mesh).geometry as BufferGeometry;\n\t\tconst geometry1 = (object1 as Mesh).geometry as BufferGeometry;\n\t\tif (geometry0 == null || geometry1 == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst attrib0 = geometry0.getAttribute(this.pv.attrib_name);\n\t\tconst attrib1 = geometry1.getAttribute(this.pv.attrib_name);\n\t\tif (attrib0 == null || attrib1 == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst attrib0_array = attrib0.array as number[];\n\t\tconst attrib1_array = attrib1.array as number[];\n\n\t\tlet c0, c1;\n\t\tfor (let i = 0; i < attrib0_array.length; i++) {\n\t\t\tc0 = attrib0_array[i];\n\t\t\tc1 = attrib1_array[i];\n\t\t\tif (c1 != null) {\n\t\t\t\tattrib0_array[i] = (1 - blend) * c0 + blend * c1;\n\t\t\t}\n\t\t}\n\n\t\tgeometry0.computeVertexNormals();\n\t}\n}\n","import {TypedSopNode} from './_Base';\nimport {CoreTransform} from '../../../core/Transform';\nimport {CoreGroup} from '../../../core/geometry/Group';\n\n// import {Vector3} from 'three/src/math/Vector3';\nimport {BoxBufferGeometry} from 'three/src/geometries/BoxGeometry';\n// import {CoreGeometry} from '../../../core/geometry/Geometry'\n// import {ParamType} from '../../poly/ParamType';\nimport {InputCloneMode} from '../../poly/InputCloneMode';\n\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nclass BoxSopParamsConfig extends NodeParamsConfig {\n\tsize = ParamConfig.FLOAT(1);\n\tdivisions = ParamConfig.INTEGER(1, {\n\t\trange: [1, 10],\n\t\trange_locked: [true, false],\n\t});\n\tcenter = ParamConfig.VECTOR3([0, 0, 0]);\n}\nconst ParamsConfig = new BoxSopParamsConfig();\n\nexport class BoxSopNode extends TypedSopNode<BoxSopParamsConfig> {\n\tparams_config = ParamsConfig;\n\tstatic type() {\n\t\treturn 'box';\n\t}\n\n\tstatic displayed_input_names(): string[] {\n\t\treturn ['geometry to create bounding box from (optional)'];\n\t}\n\n\tprivate _core_transform = new CoreTransform();\n\t// constructor(scene: PolyScene) {\n\t// \tsuper(scene);\n\t// }\n\tinitialize_node() {\n\t\tthis.io.inputs.set_count(0, 1);\n\t\tthis.io.inputs.init_inputs_clonable_state([InputCloneMode.NEVER]);\n\t}\n\t// create_params() {\n\t// \tthis.add_param(ParamType.FLOAT, 'size', 1);\n\t// \tthis.add_param(ParamType.INTEGER, 'divisions', 1, {\n\t// \t\trange: [1, 10],\n\t// \t\trange_locked: [true, false],\n\t// \t});\n\t// \tthis.add_param(ParamType.VECTOR3, 'center', [0, 0, 0]);\n\t// }\n\n\tcook(input_contents: CoreGroup[]) {\n\t\tconst core_group = input_contents[0];\n\t\tif (core_group) {\n\t\t\tthis._cook_with_input(core_group);\n\t\t} else {\n\t\t\tthis._cook_without_input();\n\t\t}\n\t}\n\n\tprivate _cook_without_input() {\n\t\t//\t\tthis.eval_all_params =>\n\t\tconst divisions = this.pv.divisions;\n\t\tconst size = this.pv.size;\n\t\tconst geometry = new BoxBufferGeometry(size, size, size, divisions, divisions, divisions);\n\n\t\tgeometry.translate(this.pv.center.x, this.pv.center.y, this.pv.center.z);\n\n\t\tgeometry.computeVertexNormals();\n\n\t\t// const buffer_geometry = CoreGeometry.clone(geometry);\n\t\tthis.set_geometry(geometry);\n\t}\n\n\tprivate _cook_with_input(core_group: CoreGroup) {\n\t\tconst divisions = this.pv.divisions;\n\n\t\tconst bbox = core_group.bounding_box();\n\t\tconst size = bbox.max.clone().sub(bbox.min);\n\t\tconst center = bbox.max.clone().add(bbox.min).multiplyScalar(0.5);\n\n\t\tconst geometry = new BoxBufferGeometry(size.x, size.y, size.z, divisions, divisions, divisions);\n\t\tconst matrix = this._core_transform.translation_matrix(center);\n\t\tgeometry.applyMatrix4(matrix);\n\n\t\t// const buffer_geometry = CoreGeometry.clone(geometry);\n\t\tthis.set_geometry(geometry);\n\t}\n\n\t// else\n\t// \tthis.set_error(\"first input is invalid\")\n\n\t// _divisions() {\n\t// \treturn Math.max(1, this.pv.divisions);\n\t// }\n}\n","import {ObjectLoader} from 'three/src/loaders/ObjectLoader';\nimport {TypedSopNode} from './_Base';\n\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nimport {BaseNodeType} from '../_Base';\nimport {BaseParamType} from '../../params/_Base';\nimport {CoreGroup} from '../../../core/geometry/Group';\nclass CacheSopParamsConfig extends NodeParamsConfig {\n\tcache = ParamConfig.STRING('', {hidden: true});\n\treset = ParamConfig.BUTTON(null, {\n\t\tcallback: (node: BaseNodeType, param: BaseParamType) => {\n\t\t\tCacheSopNode.PARAM_CALLBACK_reset(node as CacheSopNode, param);\n\t\t},\n\t});\n}\nconst ParamsConfig = new CacheSopParamsConfig();\n\nexport class CacheSopNode extends TypedSopNode<CacheSopParamsConfig> {\n\tparams_config = ParamsConfig;\n\tstatic type() {\n\t\treturn 'cache';\n\t}\n\n\tstatic displayed_input_names(): string[] {\n\t\treturn ['geometry to cache'];\n\t}\n\n\tinitialize_node() {\n\t\tthis.io.inputs.set_count(0, 1);\n\t}\n\n\tcook(input_contents: CoreGroup[]) {\n\t\tconst is_cache_empty = this.pv.cache == '' || this.pv.cache == null;\n\t\tconst core_group = input_contents[0];\n\t\tif (is_cache_empty && core_group) {\n\t\t\tconst json = [];\n\t\t\tfor (let object of core_group.objects()) {\n\t\t\t\tjson.push(object.toJSON());\n\t\t\t}\n\t\t\tthis.set_core_group(core_group);\n\t\t\tthis.p.cache.set(JSON.stringify(json));\n\t\t} else {\n\t\t\tif (this.pv.cache) {\n\t\t\t\tconst obj_loader = new ObjectLoader();\n\t\t\t\tconst jsons = JSON.parse(this.pv.cache);\n\t\t\t\tconst all_objects = [];\n\t\t\t\tfor (let json of jsons) {\n\t\t\t\t\tconst parent = obj_loader.parse(json);\n\t\t\t\t\t// for(let child of parent.children){\n\t\t\t\t\tall_objects.push(parent);\n\t\t\t\t\t// }\n\t\t\t\t}\n\t\t\t\tthis.set_objects(all_objects);\n\t\t\t} else {\n\t\t\t\tthis.set_objects([]);\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic PARAM_CALLBACK_reset(node: CacheSopNode, param: BaseParamType) {\n\t\tnode.param_callback_PARAM_CALLBACK_reset();\n\t}\n\tasync param_callback_PARAM_CALLBACK_reset() {\n\t\tthis.p.cache.set('');\n\t\tthis.request_container();\n\t}\n}\n","import {CoreMath} from '../../math/_Module'\nimport {Vector2} from 'three/src/math/Vector2'\nimport {Float32BufferAttribute} from 'three/src/core/BufferAttribute'\nimport {BufferGeometry} from 'three/src/core/BufferGeometry'\n\nexport class CoreGeometryUtilCircle {\n\tstatic positions(\n\t\tradius: number,\n\t\tsegments_count: number,\n\t\tarc_angle: number = 360\n\t) {\n\t\tconst radian_per_segment =\n\t\t\tCoreMath.degrees_to_radians(arc_angle) / segments_count\n\n\t\tconst positions = []\n\t\tfor (let i = 0; i < segments_count; i++) {\n\t\t\tconst point_radian = radian_per_segment * i\n\t\t\tconst x = radius * Math.cos(point_radian)\n\t\t\tconst y = radius * Math.sin(point_radian)\n\n\t\t\tpositions.push(new Vector2(x, y))\n\t\t}\n\n\t\treturn positions\n\t}\n\n\tstatic create(\n\t\tradius: number,\n\t\tsegments_count: number,\n\t\tarc_angle: number = 360\n\t) {\n\t\tconst positions_2d = this.positions(radius, segments_count, arc_angle)\n\n\t\tconst positions = []\n\t\tconst indices = []\n\t\tlet position_2d\n\t\tfor (let i = 0; i < positions_2d.length; i++) {\n\t\t\tposition_2d = positions_2d[i]\n\n\t\t\tpositions.push(position_2d.x)\n\t\t\tpositions.push(position_2d.y)\n\t\t\tpositions.push(0)\n\n\t\t\tif (i > 0) {\n\t\t\t\tindices.push(i - 1)\n\t\t\t\tindices.push(i)\n\t\t\t}\n\t\t}\n\n\t\t// also add the last segment\n\t\tindices.push(segments_count - 1)\n\t\tindices.push(0)\n\n\t\tconst geometry = new BufferGeometry()\n\t\tgeometry.setAttribute(\n\t\t\t'position',\n\t\t\tnew Float32BufferAttribute(positions, 3)\n\t\t)\n\t\tgeometry.setIndex(indices)\n\n\t\treturn geometry\n\t}\n}\n","import {Vector3} from 'three/src/math/Vector3';\nimport {CircleBufferGeometry} from 'three/src/geometries/CircleGeometry';\nimport {TypedSopNode} from './_Base';\nimport {CoreGeometryUtilCircle} from '../../../core/geometry/util/Circle';\nimport {ObjectType} from '../../../core/geometry/Constant';\nimport {CoreTransform} from '../../../core/Transform';\n\nconst DEFAULT_UP = new Vector3(0, 0, 1);\n\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nclass CircleSopParamsConfig extends NodeParamsConfig {\n\tradius = ParamConfig.FLOAT(1);\n\tsegments = ParamConfig.INTEGER(12, {\n\t\trange: [1, 50],\n\t\trange_locked: [true, false],\n\t});\n\topen = ParamConfig.BOOLEAN(1);\n\tarc_angle = ParamConfig.FLOAT(360, {\n\t\trange: [0, 360],\n\t\trange_locked: [false, false],\n\t\tvisible_if: {open: 1},\n\t});\n\tdirection = ParamConfig.VECTOR3([0, 1, 0]);\n}\nconst ParamsConfig = new CircleSopParamsConfig();\n\nexport class CircleSopNode extends TypedSopNode<CircleSopParamsConfig> {\n\tparams_config = ParamsConfig;\n\tstatic type() {\n\t\treturn 'circle';\n\t}\n\n\tprivate _core_transform = new CoreTransform();\n\n\tinitialize_node() {\n\t\t// this.io.inputs.set_count(0);\n\t\t// this.io.inputs.init_inputs_clonable_state([InputCloneMode.FROM_NODE]);\n\t}\n\n\tcook() {\n\t\tif (this.pv.open) {\n\t\t\tthis._create_circle();\n\t\t} else {\n\t\t\tthis._create_disk();\n\t\t}\n\t}\n\n\t_create_circle() {\n\t\tconst geometry = CoreGeometryUtilCircle.create(this.pv.radius, this.pv.segments, this.pv.arc_angle);\n\n\t\tthis._core_transform.rotate_geometry(geometry, DEFAULT_UP, this.pv.direction);\n\n\t\tthis.set_geometry(geometry, ObjectType.LINE_SEGMENTS);\n\t}\n\n\t_create_disk() {\n\t\tconst geometry = new CircleBufferGeometry(this.pv.radius, this.pv.segments);\n\n\t\tthis._core_transform.rotate_geometry(geometry, DEFAULT_UP, this.pv.direction);\n\n\t\tthis.set_geometry(geometry);\n\t}\n}\n","import {TypedSopNode} from './_Base';\nimport {InputCloneMode} from '../../poly/InputCloneMode';\nimport {CoreGroup} from '../../../core/geometry/Group';\nimport {StringParamLanguage} from '../../params/utils/OptionsController';\nimport {AsyncFunction} from '../../../core/AsyncFunction';\n\nconst DEFAULT_FUNCTION_CODE = `import {BaseCodeSopProcessor, CoreGroup} from 'polygonjs-engine'\nexport class CodeSopProcessor extends BaseCodeSopProcessor {\n\tconstructor(){\n\t\tsuper();\n\t}\n\tcook(core_groups: CoreGroup[]){\n\t\tconst core_group = core_groups[0];\n\t\tconst object = core_group.objects()[0];\n\t\tobject.position.y = 1;\n\t\tthis.set_core_group(core_groups[0]);\n\t}\n}\n\n\n`;\n\nexport class BaseCodeSopProcessor {\n\tprotected node!: CodeSopNode;\n\tconstructor() {}\n\tset_node(node: CodeSopNode) {\n\t\tthis.node = node;\n\t}\n\tcook(core_groups: CoreGroup[]) {}\n\tprotected set_core_group(core_group: CoreGroup) {\n\t\tthis.node.set_core_group(core_group);\n\t}\n}\n\ntype EvaluatedFunction = (base_processor_class: typeof BaseCodeSopProcessor) => typeof BaseCodeSopProcessor | undefined;\n\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nimport {TranspiledFilter} from '../utils/code/controllers/TranspiledFilter';\nclass CodeSopParamsConfig extends NodeParamsConfig {\n\tcode_typescript = ParamConfig.STRING(DEFAULT_FUNCTION_CODE, {\n\t\tlabel: false,\n\t\tlanguage: StringParamLanguage.TYPESCRIPT,\n\t});\n\tcode_javascript = ParamConfig.STRING('', {hidden: true});\n}\nconst ParamsConfig = new CodeSopParamsConfig();\nexport class CodeSopNode extends TypedSopNode<CodeSopParamsConfig> {\n\tparams_config = ParamsConfig;\n\n\tprivate _last_compiled_code: string | undefined;\n\tprivate _processor: BaseCodeSopProcessor | undefined;\n\n\tstatic type() {\n\t\treturn 'code';\n\t}\n\n\tinitialize_node() {\n\t\tthis.io.inputs.set_count(0, 4);\n\t\tthis.ui_data.set_width(100);\n\t\tthis.io.inputs.init_inputs_clonable_state([InputCloneMode.FROM_NODE]);\n\t}\n\n\tcook(core_groups: CoreGroup[]) {\n\t\tthis._compile_if_required();\n\n\t\tif (this._processor) {\n\t\t\tthis._processor.cook(core_groups);\n\t\t} else {\n\t\t\tthis.set_core_group(core_groups[0]);\n\t\t}\n\t}\n\n\tprivate _compile_if_required() {\n\t\tif (!this._processor || this._last_compiled_code != this.pv.code_javascript) {\n\t\t\tthis._compile();\n\t\t}\n\t}\n\n\tprivate _compile() {\n\t\ttry {\n\t\t\tconst function_body = `try {\n\t\t\t\t${TranspiledFilter.filter(this.pv.code_javascript)}\n\t\t\t} catch(e) {\n\t\t\t\tthis.states.error.set(e)\n\t\t\t}`;\n\t\t\tconsole.log('function_body');\n\t\t\tconsole.log(function_body);\n\t\t\tconst processor_creator_function: EvaluatedFunction = new AsyncFunction(\n\t\t\t\t'BaseCodeSopProcessor',\n\t\t\t\tfunction_body\n\t\t\t);\n\t\t\tconst processor_class = processor_creator_function(BaseCodeSopProcessor);\n\t\t\tif (processor_class) {\n\t\t\t\tthis._processor = new processor_class();\n\t\t\t\tthis._processor.set_node(this);\n\t\t\t\tthis._last_compiled_code = this.pv.code_javascript;\n\t\t\t} else {\n\t\t\t\tthis.states.error.set(`cannot generate function`);\n\t\t\t\tthis._processor = undefined;\n\t\t\t}\n\t\t} catch (e) {\n\t\t\tconsole.warn(e);\n\t\t\tthis.states.error.set(`cannot generate function (${e})`);\n\t\t\tthis._processor = undefined;\n\t\t}\n\t}\n}\n","import {MathUtils} from 'three/src/math/MathUtils';\nimport {Color} from 'three/src/math/Color';\n\nexport class CoreColor {\n\t// use color.toStyle() if needed\n\t// static to_css(color: Color): string {\n\t// \tconst color_elements = color.toArray().map((e) => e * 255)\n\t// \treturn `rgb(${color_elements.join(', ')})`\n\t// }\n\n\t// from THREE.js examples ColorConverter.js\n\tstatic set_hsv(h: number, s: number, v: number, target: Color) {\n\t\th = MathUtils.euclideanModulo(h, 1);\n\t\ts = MathUtils.clamp(s, 0, 1);\n\t\tv = MathUtils.clamp(v, 0, 1);\n\n\t\ttarget.setHSL(h, (s * v) / ((h = (2 - s) * v) < 1 ? h : 2 - h), h * 0.5);\n\t}\n}\n","import {Color} from 'three/src/math/Color';\nimport {BufferAttribute} from 'three/src/core/BufferAttribute';\nimport {CoreColor} from '../../../core/Color';\n// import lodash_times from 'lodash/times'\n// import lodash_each from 'lodash/each'\n// import {CoreGroup} from '../../../core/geometry/Group';\nimport {TypedSopNode} from './_Base';\n\nimport {CoreObject} from '../../../core/geometry/Object';\nimport {CoreGeometry} from '../../../core/geometry/Geometry';\nimport {CorePoint} from '../../../core/geometry/Point';\n\nimport {CoreGroup} from '../../../core/geometry/Group';\nimport {InputCloneMode} from '../../poly/InputCloneMode';\nimport {BufferGeometry} from 'three/src/core/BufferGeometry';\nimport {Mesh} from 'three/src/objects/Mesh';\n\nconst DEFAULT_COLOR = new Color(1, 1, 1);\nconst COLOR_ATTRIB_NAME = 'color';\n\ntype ValueArrayByName = Dictionary<number[]>;\n\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nclass ColorSopParamsConfig extends NodeParamsConfig {\n\tfrom_attribute = ParamConfig.BOOLEAN(0);\n\tattrib_name = ParamConfig.STRING('', {\n\t\tvisible_if: {from_attribute: 1},\n\t});\n\tcolor = ParamConfig.COLOR([1, 1, 1], {\n\t\tvisible_if: {from_attribute: 0},\n\t\texpression: {for_entities: true},\n\t});\n\tas_hsv = ParamConfig.BOOLEAN(0, {\n\t\tvisible_if: {from_attribute: 0},\n\t});\n}\nconst ParamsConfig = new ColorSopParamsConfig();\n\nexport class ColorSopNode extends TypedSopNode<ColorSopParamsConfig> {\n\tparams_config = ParamsConfig;\n\tstatic type() {\n\t\treturn 'color';\n\t}\n\n\tprivate _r_arrays_by_geometry_uuid: ValueArrayByName = {};\n\tprivate _g_arrays_by_geometry_uuid: ValueArrayByName = {};\n\tprivate _b_arrays_by_geometry_uuid: ValueArrayByName = {};\n\n\tstatic displayed_input_names(): string[] {\n\t\treturn ['geometry to update color of'];\n\t}\n\n\tinitialize_node() {\n\t\tthis.io.inputs.set_count(1);\n\t\tthis.io.inputs.init_inputs_clonable_state([InputCloneMode.FROM_NODE]);\n\t\t// this.ui_data.set_icon('palette');\n\t}\n\n\tasync cook(input_contents: CoreGroup[]) {\n\t\tconst core_group = input_contents[0];\n\t\tconst core_objects = core_group.core_objects();\n\n\t\tfor (let core_object of core_objects) {\n\t\t\tif (this.pv.from_attribute) {\n\t\t\t\tthis._set_from_attribute(core_object);\n\t\t\t} else {\n\t\t\t\tconst has_expression = this.p.color.has_expression();\n\t\t\t\tif (has_expression) {\n\t\t\t\t\tawait this._eval_expressions(core_object);\n\t\t\t\t} else {\n\t\t\t\t\tthis._eval_simple_values(core_object);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// needs update required for when no cloning\n\t\tif (!this.io.inputs.input_cloned(0)) {\n\t\t\tconst geometries = core_group.geometries();\n\t\t\tfor (let geometry of geometries) {\n\t\t\t\t(geometry.getAttribute(COLOR_ATTRIB_NAME) as BufferAttribute).needsUpdate = true;\n\t\t\t}\n\t\t}\n\n\t\tthis.set_core_group(core_group);\n\t}\n\n\t_set_from_attribute(core_object: CoreObject) {\n\t\tconst core_geometry = core_object.core_geometry();\n\t\tif (!core_geometry) {\n\t\t\treturn;\n\t\t}\n\t\tthis._create_init_color(core_geometry, DEFAULT_COLOR);\n\t\tconst points = core_geometry.points();\n\n\t\tconst src_attrib_size = core_geometry.attrib_size(this.pv.attrib_name);\n\t\tconst geometry = core_geometry.geometry();\n\t\tconst src_array = geometry.getAttribute(this.pv.attrib_name).array;\n\t\tconst dest_array = geometry.getAttribute(COLOR_ATTRIB_NAME).array as number[];\n\n\t\tswitch (src_attrib_size) {\n\t\t\tcase 1: {\n\t\t\t\tfor (let i = 0; i < points.length; i++) {\n\t\t\t\t\tconst dest_i = i * 3;\n\t\t\t\t\tdest_array[dest_i + 0] = src_array[i];\n\t\t\t\t\tdest_array[dest_i + 1] = 1 - src_array[i];\n\t\t\t\t\tdest_array[dest_i + 2] = 0;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 2: {\n\t\t\t\tfor (let i = 0; i < points.length; i++) {\n\t\t\t\t\tconst dest_i = i * 3;\n\t\t\t\t\tconst src_i = i * 2;\n\t\t\t\t\tdest_array[dest_i + 0] = src_array[src_i + 0];\n\t\t\t\t\tdest_array[dest_i + 1] = src_array[src_i + 1];\n\t\t\t\t\tdest_array[dest_i + 2] = 0;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 3: {\n\t\t\t\tfor (let i = 0; i < src_array.length; i++) {\n\t\t\t\t\tdest_array[i] = src_array[i];\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 4: {\n\t\t\t\tfor (let i = 0; i < points.length; i++) {\n\t\t\t\t\tconst dest_i = i * 3;\n\t\t\t\t\tconst src_i = i * 4;\n\t\t\t\t\tdest_array[dest_i + 0] = src_array[src_i + 0];\n\t\t\t\t\tdest_array[dest_i + 1] = src_array[src_i + 1];\n\t\t\t\t\tdest_array[dest_i + 2] = src_array[src_i + 2];\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate _create_init_color(core_geometry: CoreGeometry, color: Color) {\n\t\tif (!core_geometry.has_attrib(COLOR_ATTRIB_NAME)) {\n\t\t\tcore_geometry.add_numeric_attrib(COLOR_ATTRIB_NAME, 3, DEFAULT_COLOR);\n\t\t}\n\t}\n\n\t_eval_simple_values(core_object: CoreObject) {\n\t\tconst core_geometry = core_object.core_geometry();\n\t\tif (!core_geometry) {\n\t\t\treturn;\n\t\t}\n\t\tthis._create_init_color(core_geometry, DEFAULT_COLOR);\n\n\t\tlet new_color: Color;\n\t\tif (this.pv.as_hsv) {\n\t\t\tnew_color = new Color();\n\t\t\tCoreColor.set_hsv(this.pv.color.r, this.pv.color.g, this.pv.color.b, new_color);\n\t\t} else {\n\t\t\tnew_color = this.pv.color; //.clone();\n\t\t}\n\t\tcore_geometry.add_numeric_attrib(COLOR_ATTRIB_NAME, 3, new_color);\n\t}\n\n\tasync _eval_expressions(core_object: CoreObject) {\n\t\tconst points = core_object.points();\n\t\tconst object = core_object.object();\n\t\tconst core_geometry = core_object.core_geometry();\n\t\tif (core_geometry) {\n\t\t\tthis._create_init_color(core_geometry, DEFAULT_COLOR);\n\t\t}\n\t\tconst geometry = (object as Mesh).geometry as BufferGeometry;\n\t\tif (geometry) {\n\t\t\tconst array = geometry.getAttribute(COLOR_ATTRIB_NAME).array as number[];\n\n\t\t\tconst tmp_array_r = await this._update_from_param(geometry, array, points, 0);\n\t\t\tconst tmp_array_g = await this._update_from_param(geometry, array, points, 1);\n\t\t\tconst tmp_array_b = await this._update_from_param(geometry, array, points, 2);\n\n\t\t\tif (tmp_array_r) {\n\t\t\t\tthis._commit_tmp_values(tmp_array_r, array, 0);\n\t\t\t}\n\t\t\tif (tmp_array_g) {\n\t\t\t\tthis._commit_tmp_values(tmp_array_g, array, 1);\n\t\t\t}\n\t\t\tif (tmp_array_b) {\n\t\t\t\tthis._commit_tmp_values(tmp_array_b, array, 2);\n\t\t\t}\n\n\t\t\t// to hsv\n\t\t\tif (this.pv.as_hsv) {\n\t\t\t\tlet current = new Color();\n\t\t\t\tlet target = new Color();\n\t\t\t\tlet index;\n\t\t\t\tfor (let point of points) {\n\t\t\t\t\tindex = point.index * 3;\n\t\t\t\t\tcurrent.fromArray(array, index);\n\t\t\t\t\tCoreColor.set_hsv(current.r, current.g, current.b, target);\n\t\t\t\t\ttarget.toArray(array, index);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// const colorr_param = this.param('colorr');\n\t\t// const colorg_param = this.param('colorg');\n\t\t// const colorb_param = this.param('colorb');\n\n\t\t// r\n\t\t// if(colorr_param.has_expression()){\n\t\t// \tawait colorr_param.eval_expression_for_entities(points, (point, value)=>{\n\t\t// \t\tarray[point.index()*3+0] = value\n\t\t// \t})\n\t\t// } else {\n\t\t// \tfor(let point of points){\n\t\t// \t\tarray[point.index()*3+0] = this.pv.color.r\n\t\t// \t}\n\t\t// }\n\t\t// g\n\t\t// if(colorg_param.has_expression()){\n\t\t// \tawait colorg_param.eval_expression_for_entities(points, (point, value)=>{\n\t\t// \t\tarray[point.index()*3+1] = value\n\t\t// \t})\n\t\t// } else {\n\t\t// \tfor(let point of points){\n\t\t// \t\tarray[point.index()*3+1] = this.pv.color.g\n\t\t// \t}\n\t\t// }\n\t\t// b\n\t\t// if(colorb_param.has_expression()){\n\t\t// \tawait colorb_param.eval_expression_for_entities(points, (point, value)=>{\n\t\t// \t\tarray[point.index()*3+2] = value\n\t\t// \t})\n\t\t// } else {\n\t\t// \tfor(let point of points){\n\t\t// \t\tarray[point.index()*3+2] = this.pv.color.b\n\t\t// \t}\n\t\t// }\n\t}\n\n\tprivate async _update_from_param(\n\t\tgeometry: BufferGeometry,\n\t\tarray: number[],\n\t\tpoints: CorePoint[],\n\t\toffset: number\n\t): Promise<number[] | undefined> {\n\t\t// const component_name = ['r', 'g', 'b'][offset];\n\t\tconst param = this.p.color.components[offset];\n\t\tconst param_value = [this.pv.color.r, this.pv.color.g, this.pv.color.b][offset];\n\t\tconst arrays_by_geometry_uuid = [\n\t\t\tthis._r_arrays_by_geometry_uuid,\n\t\t\tthis._g_arrays_by_geometry_uuid,\n\t\t\tthis._b_arrays_by_geometry_uuid,\n\t\t][offset];\n\n\t\tlet tmp_array: number[] | undefined;\n\t\tif (param.has_expression() && param.expression_controller) {\n\t\t\ttmp_array = this._init_array_if_required(geometry, arrays_by_geometry_uuid, points.length);\n\t\t\tawait param.expression_controller.compute_expression_for_points(points, (point, value) => {\n\t\t\t\t// array[point.index()*3+2] = value\n\t\t\t\t(tmp_array as number[])[point.index] = value;\n\t\t\t});\n\t\t} else {\n\t\t\tfor (let point of points) {\n\t\t\t\tarray[point.index * 3 + offset] = param_value;\n\t\t\t}\n\t\t}\n\t\treturn tmp_array;\n\t}\n\n\tprivate _init_array_if_required(\n\t\tgeometry: BufferGeometry,\n\t\tarrays_by_geometry_uuid: ValueArrayByName,\n\t\tpoints_count: number\n\t) {\n\t\tconst uuid = geometry.uuid;\n\t\tconst current_array = arrays_by_geometry_uuid[uuid];\n\t\tif (current_array) {\n\t\t\t// only create new array if we need more point, or as soon as the length is different?\n\t\t\tif (current_array.length < points_count) {\n\t\t\t\tarrays_by_geometry_uuid[uuid] = new Array(points_count);\n\t\t\t}\n\t\t} else {\n\t\t\tarrays_by_geometry_uuid[uuid] = new Array(points_count);\n\t\t}\n\t\treturn arrays_by_geometry_uuid[uuid];\n\t}\n\n\tprivate _commit_tmp_values(tmp_array: number[], target_array: number[], offset: number) {\n\t\tfor (let i = 0; i < tmp_array.length; i++) {\n\t\t\ttarget_array[i * 3 + offset] = tmp_array[i];\n\t\t}\n\t}\n}\n","import {TypedSopNode} from './_Base';\n\nimport {Vector3} from 'three/src/math/Vector3';\nimport {ConeBufferGeometry} from 'three/src/geometries/ConeGeometry';\nimport {CoreTransform} from '../../../core/Transform';\n\nconst DEFAULT_UP = new Vector3(0, 1, 0);\n\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nclass ConeSopParamsConfig extends NodeParamsConfig {\n\tradius = ParamConfig.FLOAT(1, {range: [0, 1]});\n\theight = ParamConfig.FLOAT(1, {range: [0, 1]});\n\tsegments_radial = ParamConfig.INTEGER(12, {range: [3, 20], range_locked: [true, false]});\n\tsegments_height = ParamConfig.INTEGER(1, {range: [1, 20], range_locked: [true, false]});\n\tcap = ParamConfig.BOOLEAN(1);\n\ttheta_start = ParamConfig.FLOAT(1, {range: [0, 1]});\n\ttheta_length = ParamConfig.FLOAT('2*$PI', {range: [0, 1]});\n\tcenter = ParamConfig.VECTOR3([0, 0, 0]);\n\tdirection = ParamConfig.VECTOR3([0, 0, 1]);\n}\nconst ParamsConfig = new ConeSopParamsConfig();\n\nexport class ConeSopNode extends TypedSopNode<ConeSopParamsConfig> {\n\tparams_config = ParamsConfig;\n\tstatic type() {\n\t\treturn 'cone';\n\t}\n\n\tprivate _core_transform = new CoreTransform();\n\n\tcook() {\n\t\tconst geometry = new ConeBufferGeometry(\n\t\t\tthis.pv.radius,\n\t\t\tthis.pv.height,\n\t\t\tthis.pv.segments_radial,\n\t\t\tthis.pv.segments_height,\n\t\t\t!this.pv.cap,\n\t\t\tthis.pv.theta_start,\n\t\t\tthis.pv.theta_length\n\t\t);\n\n\t\tthis._core_transform.rotate_geometry(geometry, DEFAULT_UP, this.pv.direction);\n\t\tgeometry.translate(this.pv.center.x, this.pv.center.y, this.pv.center.z);\n\n\t\tthis.set_geometry(geometry);\n\t}\n}\n","import lodash_isNumber from 'lodash/isNumber';\n\nimport {Vector3} from 'three/src/math/Vector3';\nimport {Vector2} from 'three/src/math/Vector2';\nimport {Quaternion} from 'three/src/math/Quaternion';\nimport {Matrix4} from 'three/src/math/Matrix4';\nimport {InstancedBufferGeometry} from 'three/src/core/InstancedBufferGeometry';\nimport {InstancedBufferAttribute} from 'three/src/core/InstancedBufferAttribute';\n// import {BoxBufferGeometry} from 'three/src/geometries/BoxGeometry'\n// const THREE = {BoxBufferGeometry, InstancedBufferAttribute, InstancedBufferGeometry, Matrix4, Quaternion, Vector2, Vector3}\n\nimport {CorePoint} from './Point';\n// import {Core} from '../_Module';\nimport {CoreGroup} from './Group';\nimport {CoreGeometry} from './Geometry';\nimport {BufferGeometry} from 'three/src/core/BufferGeometry';\n\nconst DEFAULT = {\n\tSCALE: new Vector3(1, 1, 1),\n\tPSCALE: 1,\n\tEYE: new Vector3(0, 0, 0),\n\tUP: new Vector3(0, 1, 0),\n};\nconst SCALE_ATTRIB_NAME = 'scale';\nconst PSCALE_ATTRIB_NAME = 'pscale';\nconst NORMAL_ATTRIB_NAME = 'normal';\nconst UP_ATTRIB_NAME = 'up';\nconst MATRIX_T = 'translate';\nconst MATRIX_R = 'rotate';\nconst MATRIX_S = 'scale';\n\nconst DEFAULT_COLOR = new Vector3(1, 1, 1);\nconst DEFAULT_UV = new Vector2(0, 0);\nconst ATTRIB_NAME_UV = 'uv';\nconst ATTRIB_NAME_COLOR = 'color';\n\nexport class CoreInstancer {\n\tprivate _is_pscale_present: boolean;\n\tprivate _is_scale_present: boolean;\n\tprivate _is_normal_present: boolean;\n\tprivate _is_up_present: boolean;\n\tprivate _do_rotate_matrices: boolean;\n\tprivate _matrices: Dictionary<Matrix4> = {};\n\n\tconstructor(private _group_wrapper: CoreGroup) {\n\t\tthis._is_pscale_present = this._group_wrapper.has_attrib('pscale');\n\t\tthis._is_scale_present = this._group_wrapper.has_attrib('scale');\n\n\t\tthis._is_normal_present = this._group_wrapper.has_attrib('normal');\n\t\tthis._is_up_present = this._group_wrapper.has_attrib('up');\n\n\t\tthis._do_rotate_matrices = this._is_normal_present; //&& this._is_up_present;\n\t}\n\n\tmatrices(): Matrix4[] {\n\t\tthis._matrices = {};\n\t\tthis._matrices[MATRIX_T] = new Matrix4();\n\t\tthis._matrices[MATRIX_R] = new Matrix4();\n\t\tthis._matrices[MATRIX_S] = new Matrix4();\n\n\t\treturn this._group_wrapper.points().map((point) => {\n\t\t\treturn this._matrix_from_point(point);\n\t\t});\n\t}\n\n\t_matrix_from_point(point: CorePoint): Matrix4 {\n\t\tconst t = point.position();\n\t\t//r = new Vector3(0,0,0)\n\t\tlet scale = this._is_scale_present ? point.attrib_value(SCALE_ATTRIB_NAME) : DEFAULT.SCALE;\n\t\tconst pscale = this._is_pscale_present ? point.attrib_value(PSCALE_ATTRIB_NAME) : DEFAULT.PSCALE;\n\t\tscale = scale.clone().multiplyScalar(pscale);\n\n\t\t//matrix = #Core.Transform.matrix(t, r, s, scale)\n\t\tconst matrix = new Matrix4();\n\t\tmatrix.identity();\n\n\t\tconst scale_matrix = this._matrices[MATRIX_S];\n\t\tscale_matrix.makeScale(scale.x, scale.y, scale.z);\n\n\t\tconst translate_matrix = this._matrices[MATRIX_T];\n\t\ttranslate_matrix.makeTranslation(t.x, t.y, t.z);\n\n\t\tmatrix.multiply(translate_matrix);\n\n\t\tif (this._do_rotate_matrices) {\n\t\t\tconst rotate_matrix = this._matrices[MATRIX_R];\n\t\t\tconst eye = DEFAULT.EYE;\n\t\t\tconst center = point.attrib_value(NORMAL_ATTRIB_NAME).multiplyScalar(-1);\n\t\t\tconst up = this._is_up_present ? point.attrib_value(UP_ATTRIB_NAME) : DEFAULT.UP;\n\t\t\tup.normalize();\n\t\t\trotate_matrix.lookAt(eye, center, up);\n\n\t\t\tmatrix.multiply(rotate_matrix);\n\t\t}\n\n\t\tmatrix.multiply(scale_matrix);\n\n\t\treturn matrix;\n\t}\n\n\tstatic create_instance_buffer_geo(\n\t\tgeometry_to_instance: BufferGeometry,\n\t\ttemplate_core_group: CoreGroup,\n\t\tattributes_to_copy: string\n\t) {\n\t\tconst instance_pts = template_core_group.points();\n\t\t// geometry_to_instance = new BoxBufferGeometry( 2, 2, 2 )\n\t\t// geometry = new InstancedBufferGeometry()\n\t\t// geometry.index = geometry_to_instance.index\n\t\t// geometry.attributes.position = geometry_to_instance.attributes.position\n\t\t// geometry.attributes.uv = geometry_to_instance.attributes.uv\n\n\t\tconst geometry = new InstancedBufferGeometry();\n\t\tgeometry.copy(geometry_to_instance);\n\n\t\tconst instances_count = instance_pts.length;\n\t\tconst positions = new Float32Array(instances_count * 3);\n\t\tconst colors = new Float32Array(instances_count * 3);\n\t\tconst scales = new Float32Array(instances_count * 3);\n\t\tconst orients = new Float32Array(instances_count * 4);\n\n\t\tconst has_color = template_core_group.has_attrib(ATTRIB_NAME_COLOR);\n\n\t\tconst position = new Vector3(0, 0, 0);\n\t\tconst quaternion = new Quaternion();\n\t\tconst scale = new Vector3(1, 1, 1);\n\n\t\tconst instancer = new CoreInstancer(template_core_group);\n\t\tconst instance_matrices = instancer.matrices();\n\n\t\tinstance_pts.forEach((instance_pt, i) => {\n\t\t\tconst index3 = i * 3;\n\t\t\tconst index4 = i * 4;\n\n\t\t\tconst matrix = instance_matrices[i];\n\t\t\tmatrix.decompose(position, quaternion, scale);\n\n\t\t\tposition.toArray(positions, index3);\n\t\t\tquaternion.toArray(orients, index4);\n\t\t\tscale.toArray(scales, index3);\n\n\t\t\tconst color = has_color ? instance_pt.attrib_value(ATTRIB_NAME_COLOR) : DEFAULT_COLOR;\n\t\t\tcolor.toArray(colors, index3);\n\t\t});\n\n\t\t// if(this._param_add_uv_offset){\n\t\tconst has_uv = template_core_group.has_attrib(ATTRIB_NAME_UV);\n\t\tif (has_uv) {\n\t\t\tconst uvs = new Float32Array(instances_count * 2);\n\t\t\tinstance_pts.forEach((instance_pt, i) => {\n\t\t\t\tconst index2 = i * 2;\n\t\t\t\tconst uv = has_uv ? instance_pt.attrib_value(ATTRIB_NAME_UV) : DEFAULT_UV;\n\t\t\t\tuv.toArray(uvs, index2);\n\t\t\t});\n\t\t\tgeometry.setAttribute('instanceUv', new InstancedBufferAttribute(uvs, 2));\n\t\t}\n\t\t// }\n\n\t\tgeometry.setAttribute('instancePosition', new InstancedBufferAttribute(positions, 3));\n\t\tgeometry.setAttribute('instanceScale', new InstancedBufferAttribute(scales, 3));\n\t\tgeometry.setAttribute('instanceOrientation', new InstancedBufferAttribute(orients, 4));\n\t\tgeometry.setAttribute('instanceColor', new InstancedBufferAttribute(colors, 3));\n\n\t\tconst attrib_names = template_core_group.attrib_names_matching_mask(attributes_to_copy);\n\n\t\tattrib_names.forEach((attrib_name) => {\n\t\t\tconst attrib_size = template_core_group.attrib_size(attrib_name);\n\t\t\tconst values = new Float32Array(instances_count * attrib_size);\n\t\t\tinstance_pts.forEach((pt, i) => {\n\t\t\t\tconst value = pt.attrib_value(attrib_name);\n\t\t\t\tif (lodash_isNumber(value)) {\n\t\t\t\t\tvalues[i] = value;\n\t\t\t\t} else {\n\t\t\t\t\tvalue.toArray(values, i * attrib_size);\n\t\t\t\t}\n\t\t\t});\n\t\t\tgeometry.setAttribute(attrib_name, new InstancedBufferAttribute(values, attrib_size));\n\t\t});\n\n\t\tconst geometry_wrapper = new CoreGeometry(geometry);\n\t\tgeometry_wrapper.mark_as_instance();\n\n\t\treturn geometry;\n\t}\n}\n","import {CorePoint} from '../../../../core/geometry/Point';\nimport {CoreGraphNode} from '../../../../core/graph/CoreGraphNode';\nimport {PolyScene} from '../../../scene/PolyScene';\n\nexport class CopyStamp extends CoreGraphNode {\n\tprivate _global_index: number = 0;\n\tprivate _point: CorePoint | undefined;\n\n\tconstructor(scene: PolyScene) {\n\t\tsuper(scene, 'CopyStamp');\n\t}\n\n\tset_point(point: CorePoint) {\n\t\tthis._point = point;\n\t\tthis.set_dirty();\n\t\tthis.remove_dirty_state();\n\t}\n\tset_global_index(index: number) {\n\t\tthis._global_index = index;\n\t\tthis.set_dirty();\n\t\tthis.remove_dirty_state();\n\t}\n\n\tvalue(attrib_name?: string) {\n\t\tif (this._point) {\n\t\t\tif (attrib_name) {\n\t\t\t\treturn this._point.attrib_value(attrib_name);\n\t\t\t} else {\n\t\t\t\treturn this._point.index;\n\t\t\t}\n\t\t} else {\n\t\t\treturn this._global_index;\n\t\t}\n\t}\n}\n","import lodash_compact from 'lodash/compact';\nimport {TypedSopNode} from './_Base';\nimport {CoreGroup, Object3DWithGeometry} from '../../../core/geometry/Group';\nimport {CoreObject} from '../../../core/geometry/Object';\n// import {CoreGeometry} from '../../../core/geometry/Geometry'\nimport {CoreInstancer} from '../../../core/geometry/Instancer';\nimport {CoreString} from '../../../core/String';\n// import {NodeSimple} from '../../../Core/Graph/NodeSimple'\nimport {CopyStamp} from './utils/CopyStamp';\nimport {Matrix4} from 'three/src/math/Matrix4';\nimport {CorePoint} from '../../../core/geometry/Point';\n\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nimport {InputCloneMode} from '../../poly/InputCloneMode';\nimport {Object3D} from 'three/src/core/Object3D';\nclass CopySopParamsConfig extends NodeParamsConfig {\n\tcount = ParamConfig.INTEGER(1, {\n\t\trange: [1, 20],\n\t\trange_locked: [true, false],\n\t});\n\ttransform_only = ParamConfig.BOOLEAN(0);\n\tcopy_attributes = ParamConfig.BOOLEAN(0);\n\tattributes_to_copy = ParamConfig.STRING('', {\n\t\tvisible_if: {copy_attributes: true},\n\t});\n\tuse_copy_expr = ParamConfig.BOOLEAN(0);\n}\nconst ParamsConfig = new CopySopParamsConfig();\n\nexport class CopySopNode extends TypedSopNode<CopySopParamsConfig> {\n\tparams_config = ParamsConfig;\n\tstatic type() {\n\t\treturn 'copy';\n\t}\n\n\tprivate _attribute_names_to_copy: string[] = [];\n\t// private _group: Group|undefined;\n\tprivate _objects: Object3D[] = [];\n\tprivate _stamp_node!: CopyStamp;\n\n\tstatic displayed_input_names(): string[] {\n\t\treturn ['geometry to be copied', 'points to copy to'];\n\t}\n\n\tinitialize_node() {\n\t\tthis.io.inputs.set_count(1, 2);\n\t\tthis.io.inputs.init_inputs_clonable_state([InputCloneMode.ALWAYS, InputCloneMode.NEVER]);\n\t}\n\n\t// async evaluate_inputs_and_params() {\n\t// \tawait this.eval_all_params()\n\t// }\n\n\tasync cook() {\n\t\tlet core_group0;\n\t\tconst container0 = await this.container_controller.request_input_container(0);\n\t\tif (container0 != null && (core_group0 = container0.core_content()) != null) {\n\t\t\tif (this.io.inputs.has_input(1)) {\n\t\t\t\tlet core_group1;\n\t\t\t\tconst container1 = await this.container_controller.request_input_container(1);\n\t\t\t\tif (container1 != null && (core_group1 = container1.core_content()) != null) {\n\t\t\t\t\tawait this.cook_with_template(core_group0, core_group1);\n\t\t\t\t} else {\n\t\t\t\t\tthis.states.error.set('second input required');\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis.cook_without_template(core_group0);\n\t\t\t}\n\t\t} else {\n\t\t\tthis.states.error.set('first input required');\n\t\t}\n\t}\n\n\tprivate async cook_with_template(instance_core_group: CoreGroup, template_core_group: CoreGroup) {\n\t\tthis._objects = [];\n\n\t\tconst template_points = template_core_group.points();\n\n\t\tconst instancer = new CoreInstancer(template_core_group);\n\t\tlet instance_matrices = instancer.matrices();\n\n\t\tthis._attribute_names_to_copy = CoreString.attrib_names(this.pv.attributes_to_copy).filter((attrib_name) =>\n\t\t\ttemplate_core_group.has_attrib(attrib_name)\n\t\t);\n\t\tawait this._copy_moved_objects_on_template_points(instance_core_group, instance_matrices, template_points);\n\t\tthis.set_objects(this._objects);\n\t}\n\n\t// https://stackoverflow.com/questions/24586110/resolve-promises-one-after-another-i-e-in-sequence\n\tprivate async _copy_moved_objects_on_template_points(\n\t\tinstance_core_group: CoreGroup,\n\t\tinstance_matrices: Matrix4[],\n\t\ttemplate_points: CorePoint[]\n\t) {\n\t\tfor (let point_index = 0; point_index < template_points.length; point_index++) {\n\t\t\tawait this._copy_moved_object_on_template_point(\n\t\t\t\tinstance_core_group,\n\t\t\t\tinstance_matrices,\n\t\t\t\ttemplate_points,\n\t\t\t\tpoint_index\n\t\t\t);\n\t\t}\n\t\t// template_points.forEach((template_point, point_index) => {\n\t\t// \tp = p.then(() => {\n\t\t// \t\treturn this._copy_moved_object_on_template_point(\n\t\t// \t\t\tinstance_core_group,\n\t\t// \t\t\tinstance_matrices,\n\t\t// \t\t\ttemplate_points,\n\t\t// \t\t\tpoint_index\n\t\t// \t\t);\n\t\t// \t});\n\t\t// });\n\t}\n\n\tprivate _copy_moved_object_on_template_point(\n\t\tinstance_core_group: CoreGroup,\n\t\tinstance_matrices: Matrix4[],\n\t\ttemplate_points: CorePoint[],\n\t\tpoint_index: number\n\t) {\n\t\treturn new Promise(async (resolve, reject) => {\n\t\t\tconst matrix = instance_matrices[point_index];\n\t\t\tconst template_point = template_points[point_index];\n\t\t\tthis.stamp_node.set_point(template_point);\n\n\t\t\tconst moved_objects = await this._get_moved_objects_for_template_point(instance_core_group, point_index);\n\n\t\t\tmoved_objects.forEach((moved_object) => {\n\t\t\t\tif (this.pv.copy_attributes) {\n\t\t\t\t\tthis._copy_attributes_from_template(moved_object, template_point);\n\t\t\t\t}\n\n\t\t\t\t// TODO: that node is getting inconsistent...\n\t\t\t\t// should I always only move the object?\n\t\t\t\t// and have a toggle to bake back to the geo?\n\t\t\t\t// or just enfore the use of a merge?\n\t\t\t\tif (this.pv.transform_only) {\n\t\t\t\t\tmoved_object.applyMatrix4(matrix);\n\t\t\t\t} else {\n\t\t\t\t\tconst geometry = moved_object.geometry;\n\t\t\t\t\tif (geometry) {\n\t\t\t\t\t\tmoved_object.geometry.applyMatrix4(matrix);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tmoved_object.applyMatrix4(matrix);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn this._objects.push(moved_object);\n\t\t\t});\n\n\t\t\treturn resolve();\n\t\t});\n\t}\n\n\tprivate _get_moved_objects_for_template_point(\n\t\tinstance_core_group: CoreGroup,\n\t\tpoint_index: number\n\t): Promise<Object3DWithGeometry[]> {\n\t\treturn new Promise(async (resolve, reject) => {\n\t\t\tconst stamped_instance_core_group = await this._stamp_instance_group_if_required(instance_core_group);\n\t\t\tif (stamped_instance_core_group) {\n\t\t\t\t// duplicate or select from instance children\n\t\t\t\tconst moved_objects = this.pv.transform_only\n\t\t\t\t\t? // TODO: why is doing a transform slower than cloning the input??\n\t\t\t\t\t  lodash_compact([instance_core_group.objects()[point_index]])\n\t\t\t\t\t: instance_core_group.clone().objects();\n\n\t\t\t\tresolve(moved_objects);\n\t\t\t} else {\n\t\t\t\tresolve([]);\n\t\t\t}\n\t\t});\n\t}\n\n\tprivate _stamp_instance_group_if_required(instance_core_group: CoreGroup): Promise<CoreGroup | undefined> {\n\t\treturn new Promise(async (resolve, reject) => {\n\t\t\tif (this.pv.use_copy_expr) {\n\t\t\t\tconst container0 = await this.container_controller.request_input_container(0);\n\t\t\t\tlet core_group0: CoreGroup;\n\t\t\t\tif (container0 && (core_group0 = container0.core_content()) != null) {\n\t\t\t\t\t// this.stamp_node.increment_global_value()\n\t\t\t\t\tresolve(core_group0);\n\t\t\t\t} else {\n\t\t\t\t\tthis.states.error.set(`input failed for index ${this.stamp_value()}`);\n\t\t\t\t\tresolve();\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tresolve(instance_core_group);\n\t\t\t}\n\t\t});\n\t}\n\n\t// https://stackoverflow.com/questions/24586110/resolve-promises-one-after-another-i-e-in-sequence\n\tprivate async _copy_moved_objects_for_each_instance(instance_core_group: CoreGroup) {\n\t\t// let p = Promise.resolve(); // Q() in q\n\n\t\tfor (let i = 0; i < this.pv.count; i++) {\n\t\t\tawait this._copy_moved_objects_for_instance(instance_core_group, i);\n\t\t}\n\t\t// lodash_times(this.pv.count, (i) => {\n\t\t// \tp = p.then(() => {\n\t\t// \t\treturn this._copy_moved_objects_for_instance(instance_core_group, i);\n\t\t// \t});\n\t\t// });\n\n\t\t// return p;\n\t}\n\n\tprivate _copy_moved_objects_for_instance(instance_core_group: CoreGroup, i: number) {\n\t\treturn new Promise(async (resolve, reject) => {\n\t\t\tthis.stamp_node.set_global_index(i);\n\n\t\t\tconst stamped_instance_core_group = await this._stamp_instance_group_if_required(instance_core_group);\n\t\t\tif (stamped_instance_core_group) {\n\t\t\t\tstamped_instance_core_group.objects().forEach((object) => {\n\t\t\t\t\t// TODO: I should use the Group wrapper, to ensure that material.linewidth is properly cloned\n\t\t\t\t\tconst new_object = CoreObject.clone(object);\n\t\t\t\t\tthis._objects.push(new_object);\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tresolve();\n\t\t});\n\t}\n\n\t// TODO: what if I combine both @_param_count and stamping?!\n\tprivate cook_without_template(instance_core_group: CoreGroup) {\n\t\tthis._objects = [];\n\t\tthis._copy_moved_objects_for_each_instance(instance_core_group).then(() => {\n\t\t\tthis.set_objects(this._objects);\n\t\t});\n\t}\n\n\tprivate _copy_attributes_from_template(object: Object3D, template_point: CorePoint) {\n\t\tthis._attribute_names_to_copy.forEach((attrib_name, i) => {\n\t\t\tconst attrib_value = template_point.attrib_value(attrib_name);\n\t\t\tconst object_wrapper = new CoreObject(object, i);\n\t\t\tobject_wrapper.add_attribute(attrib_name, attrib_value);\n\t\t});\n\t}\n\n\t//\n\t//\n\t// STAMP\n\t//\n\t//\n\tstamp_value(attrib_name?: string) {\n\t\treturn this.stamp_node.value(attrib_name);\n\t}\n\tget stamp_node() {\n\t\treturn (this._stamp_node = this._stamp_node || this.create_stamp_node());\n\t}\n\tprivate create_stamp_node() {\n\t\tconst stamp_node = new CopyStamp(this.scene);\n\t\tthis.dirty_controller.set_forbidden_trigger_nodes([stamp_node]);\n\t\treturn stamp_node;\n\t}\n\n\t// private set_dirty_allowed(original_trigger_graph_node: CoreGraphNode): boolean {\n\t// \treturn original_trigger_graph_node.graph_node_id !== this.stamp_node.graph_node_id;\n\t// }\n}\n","import lodash_isArray from 'lodash/isArray'\nimport lodash_isString from 'lodash/isString'\nimport {CoreConstant} from './Constant'\n\nexport class CoreAttributeData {\n\tconstructor(private _size: number, private _type: number) {}\n\n\tsize() {\n\t\treturn this._size\n\t}\n\ttype() {\n\t\treturn this._type\n\t}\n\n\tstatic from_value(attrib_value: any) {\n\t\tconst type = lodash_isString(attrib_value)\n\t\t\t? CoreConstant.ATTRIB_TYPE.STRING\n\t\t\t: CoreConstant.ATTRIB_TYPE.NUMERIC\n\t\tconst size = lodash_isArray(attrib_value) ? attrib_value.length : 1\n\n\t\treturn new this(size, type)\n\t}\n}\n","// import {Core} from '../../_Module';\nimport lodash_isArray from 'lodash/isArray';\nimport lodash_isObject from 'lodash/isObject';\nimport lodash_isString from 'lodash/isString';\nimport lodash_flatten from 'lodash/flatten';\nimport {Points} from 'three/src/objects/Points';\nimport {Float32BufferAttribute} from 'three/src/core/BufferAttribute';\nimport {BufferGeometry} from 'three/src/core/BufferGeometry';\nconst THREE = {BufferGeometry, Float32BufferAttribute, Points};\n\n// import UrlLoader from '../UrlLoader';\nimport {CoreString} from '../../String';\nimport {CoreGeometry} from '../../geometry/Geometry';\nimport {CoreConstant} from '../../geometry/Constant';\nimport {CoreAttributeData} from '../../geometry/AttributeData';\nimport {CoreAttribute} from '../../geometry/Attribute';\n// import {BaseNodeType} from '../../../engine/nodes/_Base';\nimport {Object3D} from 'three/src/core/Object3D';\n\nconst DEEP_ATTRIB_SEPARATOR = ':';\n\nexport interface JsonDataLoaderOptions {\n\tdata_keys_prefix?: string;\n\tskip_entries?: string;\n\tdo_convert?: boolean;\n\tconvert_to_numeric?: string;\n}\n\nexport class JsonDataLoader {\n\t_json: any[] | undefined;\n\t_attribute_datas_by_name: Dictionary<CoreAttributeData> = {};\n\tprivate _options: JsonDataLoaderOptions = {};\n\n\tconstructor(options: JsonDataLoaderOptions = {}) {\n\t\tthis._options.data_keys_prefix = options.data_keys_prefix;\n\t\tthis._options.skip_entries = options.skip_entries;\n\t\tthis._options.do_convert = options.do_convert || false;\n\t\tthis._options.convert_to_numeric = options.convert_to_numeric;\n\t}\n\t//\n\n\tload(\n\t\turl: string,\n\t\tsuccess_callback: (object: Object3D) => void,\n\t\tprogress_callback: (() => void) | undefined,\n\t\terror_callback: (error: ErrorEvent) => void | undefined\n\t) {\n\t\t// const url_loader = new UrlLoader();\n\t\t// const start_time = performance.now();\n\t\t// const config = {\n\t\t// \tcrossdomain: true\n\t\t// }\n\t\tfetch(url)\n\t\t\t.then(async (response) => {\n\t\t\t\t// const end_time = performance.now();\n\n\t\t\t\tthis._json = await response.json();\n\t\t\t\tif (this._options.data_keys_prefix != null && this._options.data_keys_prefix != '') {\n\t\t\t\t\tthis._json = this.get_prefixed_json(this._json, this._options.data_keys_prefix.split('.'));\n\t\t\t\t}\n\t\t\t\tconst object = this.create_object();\n\t\t\t\tsuccess_callback(object);\n\t\t\t})\n\t\t\t.catch((error: ErrorEvent) => {\n\t\t\t\tconsole.log('error', error);\n\t\t\t\terror_callback(error);\n\t\t\t});\n\t}\n\n\tget_prefixed_json(json: any, prefixes: string[]): any[] {\n\t\tif (prefixes.length == 0) {\n\t\t\treturn json;\n\t\t} else {\n\t\t\tconst first_prefix = prefixes.shift();\n\t\t\tif (first_prefix) {\n\t\t\t\treturn this.get_prefixed_json(json[first_prefix], prefixes);\n\t\t\t}\n\t\t}\n\t\treturn [];\n\t}\n\n\tset_json(json: any) {\n\t\treturn (this._json = json);\n\t}\n\n\tcreate_object() {\n\t\tconst geometry = new THREE.BufferGeometry();\n\t\tconst core_geo = new CoreGeometry(geometry);\n\n\t\tif (this._json != null) {\n\t\t\tconst points_count = this._json.length;\n\t\t\tcore_geo.init_position_attribute(points_count);\n\n\t\t\tthis._find_attributes();\n\t\t\t// for(let attrib_name of Object.keys(this._attribute_names)){\n\t\t\t// \tconst attrib_data = this._attribute_datas_by_name[attrib_name];\n\t\t\t// \treturn core_geo.add_attribute(attrib_name, attrib_data);\n\t\t\t// }\n\n\t\t\tconst convert_to_numeric_masks = CoreString.attrib_names(this._options.convert_to_numeric || '');\n\n\t\t\t// set values\n\t\t\tfor (let attrib_name of Object.keys(this._attribute_datas_by_name)) {\n\t\t\t\tlet attrib_values = lodash_flatten(this._attribute_values_for_name(attrib_name));\n\n\t\t\t\tconst data = this._attribute_datas_by_name[attrib_name];\n\t\t\t\tconst size = data.size();\n\n\t\t\t\tif (data.type() === CoreConstant.ATTRIB_TYPE.STRING) {\n\t\t\t\t\t// const index_data = CoreAttribute.array_to_indexed_arrays(\n\t\t\t\t\t// \tattrib_values as string[]\n\t\t\t\t\t// )\n\n\t\t\t\t\tif (\n\t\t\t\t\t\tthis._options.do_convert &&\n\t\t\t\t\t\tCoreString.matches_one_mask(attrib_name, convert_to_numeric_masks)\n\t\t\t\t\t) {\n\t\t\t\t\t\tconst numerical_attrib_values: number[] = attrib_values.map((v) => {\n\t\t\t\t\t\t\tif (lodash_isString(v)) {\n\t\t\t\t\t\t\t\treturn parseFloat(v) || 0;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\treturn v;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t\tgeometry.setAttribute(\n\t\t\t\t\t\t\tattrib_name,\n\t\t\t\t\t\t\tnew THREE.Float32BufferAttribute(numerical_attrib_values, size)\n\t\t\t\t\t\t);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconst index_data = CoreAttribute.array_to_indexed_arrays(attrib_values as string[]);\n\t\t\t\t\t\tcore_geo.set_indexed_attribute(attrib_name, index_data['values'], index_data['indices']);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tconst numerical_attrib_values = attrib_values as number[];\n\t\t\t\t\tgeometry.setAttribute(attrib_name, new THREE.Float32BufferAttribute(numerical_attrib_values, size));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn new THREE.Points(geometry, CoreConstant.MATERIALS[THREE.Points.name]);\n\t}\n\n\tprivate _find_attributes() {\n\t\tlet first_pt;\n\n\t\tconst masks = CoreString.attrib_names(this._options.skip_entries || '');\n\n\t\tif (this._json) {\n\t\t\tif ((first_pt = this._json[0]) != null) {\n\t\t\t\tfor (let attrib_name of Object.keys(first_pt)) {\n\t\t\t\t\tconst attrib_value = first_pt[attrib_name];\n\n\t\t\t\t\tif (this._value_has_subentries(attrib_value)) {\n\t\t\t\t\t\tfor (let key of Object.keys(attrib_value)) {\n\t\t\t\t\t\t\tconst deep_attrib_name = [attrib_name, key].join(DEEP_ATTRIB_SEPARATOR);\n\t\t\t\t\t\t\tconst deep_attrib_value = attrib_value[attrib_name];\n\n\t\t\t\t\t\t\tif (!CoreString.matches_one_mask(deep_attrib_name, masks)) {\n\t\t\t\t\t\t\t\tthis._attribute_datas_by_name[deep_attrib_name] = CoreAttributeData.from_value(\n\t\t\t\t\t\t\t\t\tdeep_attrib_value\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (!CoreString.matches_one_mask(attrib_name, masks)) {\n\t\t\t\t\t\t\tthis._attribute_datas_by_name[attrib_name] = CoreAttributeData.from_value(attrib_value);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate _attribute_values_for_name(attrib_name: string): StringOrNumber[] {\n\t\tif (this._json) {\n\t\t\treturn this._json.map((json_element: Dictionary<any>) => {\n\t\t\t\tconst prefix = attrib_name.split(DEEP_ATTRIB_SEPARATOR)[0];\n\t\t\t\tconst value = json_element[prefix];\n\t\t\t\tif (this._value_has_subentries(value)) {\n\t\t\t\t\tconst deep_attrib_name = attrib_name.substring(prefix.length + 1);\n\t\t\t\t\treturn value[deep_attrib_name] || 0;\n\t\t\t\t} else {\n\t\t\t\t\treturn value || 0;\n\t\t\t\t}\n\t\t\t});\n\t\t} else {\n\t\t\treturn [];\n\t\t}\n\t}\n\n\t_value_has_subentries(value: any): boolean {\n\t\treturn lodash_isObject(value) && !lodash_isArray(value);\n\t}\n}\n","// import {Core} from '../../../Core/_Module';\nimport {TypedSopNode} from './_Base';\nimport {JsonDataLoader} from '../../../core/loader/geometry/JsonData';\n\nconst DEFAULT_DATA = [\n\t{value: -40},\n\t{value: -30},\n\t{value: -20},\n\t{value: -10},\n\t{value: 0},\n\t{value: 10},\n\t{value: 20},\n\t{value: 30},\n\t{value: 40},\n\t{value: 50},\n\t{value: 60},\n\t{value: 70},\n\t{value: 80},\n];\nconst DEFAULT_DATA_STR = JSON.stringify(DEFAULT_DATA);\n\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nclass DataSopParamsConfig extends NodeParamsConfig {\n\tdata = ParamConfig.STRING(DEFAULT_DATA_STR);\n}\nconst ParamsConfig = new DataSopParamsConfig();\n\nexport class DataSopNode extends TypedSopNode<DataSopParamsConfig> {\n\tparams_config = ParamsConfig;\n\tstatic type() {\n\t\treturn 'data';\n\t}\n\n\tcook() {\n\t\tlet json = null;\n\t\ttry {\n\t\t\tjson = JSON.parse(this.pv.data);\n\t\t} catch (e) {\n\t\t\tthis.states.error.set('could not parse json');\n\t\t}\n\n\t\tif (json) {\n\t\t\tconst loader = new JsonDataLoader();\n\t\t\tloader.set_json(json);\n\t\t\tconst object = loader.create_object();\n\t\t\tthis.set_object(object);\n\t\t} else {\n\t\t\tthis.cook_controller.end_cook();\n\t\t}\n\t}\n}\n","import {Object3D} from 'three/src/core/Object3D';\n// import lodash_flatten from 'lodash/flatten';\nimport {TypedSopNode} from './_Base';\n\n// import {CoreLoaderGeometry, LoaderType, LOADER_TYPES} from '../../../Core/Loader/Geometry';\nimport {JsonDataLoader} from '../../../core/loader/geometry/JsonData';\n\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nimport {BaseParamType} from '../../params/_Base';\nimport {BaseNodeType} from '../_Base';\nclass DataUrlSopParamsConfig extends NodeParamsConfig {\n\turl = ParamConfig.STRING('/examples/sop/data_url/basic.json');\n\tjson_data_keys_prefix = ParamConfig.STRING('');\n\tskip_entries = ParamConfig.STRING('');\n\tconvert = ParamConfig.BOOLEAN(0);\n\tconvert_to_numeric = ParamConfig.STRING('', {\n\t\tvisible_if: {convert: 1},\n\t});\n\treload = ParamConfig.BUTTON(null, {\n\t\tcallback: (node: BaseNodeType, param: BaseParamType) => {\n\t\t\tDataUrlSopNode.PARAM_CALLBACK_reload(node as DataUrlSopNode, param);\n\t\t},\n\t});\n}\nconst ParamsConfig = new DataUrlSopParamsConfig();\n\nexport class DataUrlSopNode extends TypedSopNode<DataUrlSopParamsConfig> {\n\tparams_config = ParamsConfig;\n\tstatic type() {\n\t\treturn 'data_url';\n\t}\n\n\t// TODO: no error when trying to load a non existing zip file??\n\tasync cook() {\n\t\tconst loader = new JsonDataLoader({\n\t\t\tdata_keys_prefix: this.pv.json_data_keys_prefix,\n\t\t\tskip_entries: this.pv.skip_entries,\n\t\t\tdo_convert: this.pv.convert,\n\t\t\tconvert_to_numeric: this.pv.convert_to_numeric,\n\t\t});\n\t\tloader.load(this.pv.url, this._on_load.bind(this), undefined, this._on_error.bind(this));\n\t}\n\n\t_on_load(objects: Object3D) {\n\t\t// objects = lodash_flatten(objects);\n\t\tthis.set_objects([objects]);\n\t}\n\t_on_error(error: ErrorEvent) {\n\t\tthis.states.error.set(`could not load geometry from ${this.pv.url} (${error})`);\n\t\tthis.cook_controller.end_cook();\n\t}\n\n\t// async _on_open_url(){\n\t// \tconst url = await this.param('url').eval_p()\n\t// \tconst a = document.createElement('a')\n\t// \ta.href = url\n\t// \ta.setAttribute('target', '_blank')\n\t// \ta.click()\n\t// }\n\n\tstatic PARAM_CALLBACK_reload(node: DataUrlSopNode, param: BaseParamType) {\n\t\tnode.param_callback_reload();\n\t}\n\tparam_callback_reload() {\n\t\t// this._previous_param_url = null\n\n\t\t// set the param dirty is preferable, in case this is used to refresh a local asset\n\t\tthis.p.url.set_dirty();\n\t\t// this.set_dirty()\n\t}\n}\n","import {TypedSopNode} from './_Base';\n\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nimport {InputCloneMode} from '../../poly/InputCloneMode';\nimport {CoreGroup} from '../../../core/geometry/Group';\nclass DelaySopParamsConfig extends NodeParamsConfig {\n\tduration = ParamConfig.INTEGER(1000);\n}\nconst ParamsConfig = new DelaySopParamsConfig();\n\nexport class DelaySopNode extends TypedSopNode<DelaySopParamsConfig> {\n\tparams_config = ParamsConfig;\n\tstatic type() {\n\t\treturn 'delay';\n\t}\n\n\tinitialize_node() {\n\t\tthis.io.inputs.set_count(1);\n\t\tthis.io.inputs.init_inputs_clonable_state([InputCloneMode.ALWAYS]);\n\t}\n\n\tcook(inputs_contents: CoreGroup[]) {\n\t\tconst core_group = inputs_contents[0];\n\t\tconst c = () => {\n\t\t\tthis.set_core_group(core_group);\n\t\t};\n\t\tsetTimeout(c, this.pv.duration);\n\t}\n}\n","import {Box3} from 'three/src/math/Box3';\nimport lodash_isString from 'lodash/isString';\nimport lodash_each from 'lodash/each';\nimport {TypedSopNode} from './_Base';\nimport {CoreString} from '../../../core/String';\nimport {\n\tAttribClass,\n\tAttribClassMenuEntries,\n\tObjectType,\n\tObjectTypeMenuEntries,\n\tObjectTypes,\n} from '../../../core/geometry/Constant';\nimport {CoreGroup, Object3DWithGeometry} from '../../../core/geometry/Group';\nimport {CoreGeometry} from '../../../core/geometry/Geometry';\nimport {InputCloneMode} from '../../poly/InputCloneMode';\nimport {CorePoint} from '../../../core/geometry/Point';\nimport {CoreObject} from '../../../core/geometry/Object';\n\nenum ComparisonOperator {\n\t'==' = 0,\n\t'<' = 1,\n\t'<=' = 2,\n\t'>=' = 3,\n\t'>' = 4,\n\t'!=' = 5,\n}\nconst ComparisonOperatorMenuEntries = [\n\t{name: '==', value: ComparisonOperator['==']},\n\t{name: '<', value: ComparisonOperator['<']},\n\t{name: '<=', value: ComparisonOperator['<=']},\n\t{name: '>=', value: ComparisonOperator['>=']},\n\t{name: '>', value: ComparisonOperator['>']},\n\t{name: '!=', value: ComparisonOperator['!=']},\n];\n\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nclass DeleteSopParamsConfig extends NodeParamsConfig {\n\tclass = ParamConfig.INTEGER(AttribClass.VERTEX, {\n\t\tmenu: {\n\t\t\tentries: AttribClassMenuEntries,\n\t\t},\n\t});\n\tinvert = ParamConfig.BOOLEAN(0);\n\thide_objects = ParamConfig.BOOLEAN(0);\n\n\t// by_object_type\n\tby_object_type = ParamConfig.BOOLEAN(0);\n\tobject_type = ParamConfig.INTEGER(ObjectTypes.indexOf(ObjectType.MESH), {\n\t\tmenu: {\n\t\t\tentries: ObjectTypeMenuEntries,\n\t\t},\n\t\tvisible_if: {by_object_type: true},\n\t});\n\n\t// by_expression\n\tby_expression = ParamConfig.BOOLEAN(0);\n\texpression = ParamConfig.BOOLEAN('@ptnum==0', {\n\t\tvisible_if: {by_expression: true},\n\t\texpression: {for_entities: true},\n\t});\n\n\t// by_attrib\n\tby_attrib = ParamConfig.BOOLEAN(0);\n\tattrib_name = ParamConfig.STRING('', {\n\t\tvisible_if: {by_attrib: true},\n\t});\n\tattrib_string = ParamConfig.STRING('', {\n\t\tvisible_if: {by_attrib: true},\n\t});\n\t// attrib_float = ParamConfig.FLOAT(0, {\n\t// \tvisible_if: {by_attrib: true},\n\t// })\n\tattrib_numeric = ParamConfig.VECTOR4([0, 0, 0, 0], {\n\t\tvisible_if: {by_attrib: true},\n\t});\n\tattrib_comparison_operator = ParamConfig.INTEGER(ComparisonOperator['=='], {\n\t\tmenu: {\n\t\t\tentries: ComparisonOperatorMenuEntries,\n\t\t},\n\t\tvisible_if: {by_attrib: true},\n\t});\n\n\t// by_bbox\n\tby_bbox = ParamConfig.BOOLEAN(0);\n\tbbox_size = ParamConfig.VECTOR3([1, 1, 1], {\n\t\tvisible_if: {by_bbox: true},\n\t});\n\tbbox_center = ParamConfig.VECTOR3([0, 0, 0], {\n\t\tvisible_if: {by_bbox: true},\n\t});\n\t//this.add_param( ParamType.STRING, 'index_mode', Core.Geometry.Geometry.INDEX_MODE_FACES )\n\n\t// by_visible\n\tby_visible = ParamConfig.BOOLEAN(0);\n\tkeep_points = ParamConfig.BOOLEAN(1, {\n\t\tvisible_if: {\n\t\t\tclass: AttribClass.OBJECT,\n\t\t},\n\t});\n}\nconst ParamsConfig = new DeleteSopParamsConfig();\n\nexport class DeleteSopNode extends TypedSopNode<DeleteSopParamsConfig> {\n\tparams_config = ParamsConfig;\n\tstatic type() {\n\t\treturn 'delete';\n\t}\n\n\t// _param_attrib_class: number;\n\t// _param_invert: boolean;\n\t// _param_hide_objects: boolean;\n\t// _param_by_object_type: boolean;\n\t// _param_object_type: number;\n\t// _param_by_attrib: boolean;\n\t// _param_attrib_name: string;\n\t// _param_attrib_float: number;\n\t// _param_attrib_string: string;\n\t// _param_attrib_vector: Vector3;\n\t// _param_attrib_ComparisonOperator: number;\n\t// _param_by_expression: boolean;\n\t// _param_expression: string;\n\t// _param_by_bbox: boolean;\n\t// _param_bbox_size: Vector3;\n\t// _param_bbox_center: Vector3;\n\t// _param_by_visible: boolean;\n\n\tprivate _bbox_cache: Box3 | undefined;\n\n\tprivate _marked_for_deletion_per_object_index: Map<number, boolean> = new Map();\n\n\tstatic displayed_input_names(): string[] {\n\t\treturn ['geometry to delete from'];\n\t}\n\n\tinitialize_node() {\n\t\tthis.io.inputs.set_count(1);\n\t\tthis.io.inputs.init_inputs_clonable_state([InputCloneMode.FROM_NODE]);\n\t}\n\n\tasync cook(input_contents: CoreGroup[]) {\n\t\tconst core_group = input_contents[0];\n\n\t\tthis._bbox_cache = undefined;\n\t\tswitch (this.pv.class) {\n\t\t\tcase AttribClass.VERTEX:\n\t\t\t\tawait this._eval_for_points(core_group);\n\t\t\t\tbreak;\n\t\t\tcase AttribClass.OBJECT:\n\t\t\t\tawait this._eval_for_objects(core_group);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tprivate async _eval_for_objects(core_group: CoreGroup) {\n\t\t// const objects_to_delete = [];\n\t\tconst objects_to_keep = [];\n\t\tconst core_objects = core_group.core_objects();\n\n\t\tthis._marked_for_deletion_per_object_index = new Map();\n\t\tfor (let core_object of core_objects) {\n\t\t\tthis._marked_for_deletion_per_object_index.set(core_object.index, false);\n\t\t}\n\n\t\tif (this.pv.by_expression) {\n\t\t\tawait this._eval_expressions_for_objects(core_objects);\n\t\t}\n\n\t\tif (this.pv.by_object_type) {\n\t\t\tthis._eval_type_for_objects(core_objects);\n\t\t}\n\n\t\tif (this.pv.by_attrib && this.pv.attrib_name !== '') {\n\t\t\tthis._eval_attrib_for_objects(core_objects);\n\n\t\t\t// \tif !is_deleted && @_param_by_bbox\n\t\t\t// \t\tis_deleted = this._eval_bbox_for_object(object)\n\n\t\t\t// \tif !is_deleted && @_param_by_visible\n\t\t\t// \t\tis_deleted = !object.visible\n\n\t\t\t// \tif @_param_invert\n\t\t\t// \t\tis_deleted = !is_deleted\n\n\t\t\t// \tif @_param_hide_objects\n\t\t\t// \t\tobject.visible = !is_deleted\n\t\t\t// \telse\n\t\t\t// \t\tif is_deleted\n\t\t\t// \t\t\tobjects_to_delete.push(object)\n\n\t\t\t// true; // to ensure the loop isn't breaking, which is what happens when setting the object.visible to false...\n\t\t}\n\n\t\tif (this.pv.invert) {\n\t\t\tthis._marked_for_deletion_per_object_index.forEach((marked_for_deletion, object_index) => {\n\t\t\t\tthis._marked_for_deletion_per_object_index.set(object_index, !marked_for_deletion);\n\t\t\t});\n\t\t}\n\n\t\tlet core_object, object;\n\t\tconst point_objects_from_deleted_objects: Object3DWithGeometry[] = [];\n\t\t// for (let object_index of Object.keys(this._marked_for_deletion_per_object_index)) {\n\t\tthis._marked_for_deletion_per_object_index.forEach((marked_for_deletion, object_index) => {\n\t\t\tcore_object = core_objects[object_index];\n\t\t\tobject = core_object.object();\n\n\t\t\tif (this.pv.hide_objects) {\n\t\t\t\tobjects_to_keep.push(object);\n\t\t\t\tif (marked_for_deletion) {\n\t\t\t\t\tobject.visible = false;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (!marked_for_deletion) {\n\t\t\t\t\tobjects_to_keep.push(object);\n\t\t\t\t}\n\t\t\t\tif (marked_for_deletion) {\n\t\t\t\t\tpoint_objects_from_deleted_objects.push(this._point_object(core_object));\n\t\t\t\t}\n\t\t\t}\n\t\t\t// if (marked_for_deletion) {\n\t\t\t// \tcmptr += 1;\n\t\t\t// \tif (this.pv.hide_objects) {\n\t\t\t// \t\tobject.visible = true;\n\n\t\t\t// \t} else {\n\t\t\t// \t\t// object.parent.remove(object);\n\t\t\t// \t\t// const c = () =>\n\t\t\t// \t\t// \tobject.traverse(function(object_child) {\n\t\t\t// \t\t// \t\tif (object_child.geometry != null) {\n\t\t\t// \t\t// \t\t\tobject_child.geometry.dispose();\n\t\t\t// \t\t// \t\t}\n\t\t\t// \t\t// \t\t// const material = object_child.material\n\t\t\t// \t\t// \t\t// if(material){ material.dispose() }\n\t\t\t// \t\t// \t})\n\t\t\t// \t\t// ;\n\t\t\t// \t\t// setTimeout(c, 25);\n\t\t\t// \t}\n\t\t\t// }\n\t\t});\n\n\t\tfor (let object of point_objects_from_deleted_objects) {\n\t\t\tobjects_to_keep.push(object);\n\t\t}\n\n\t\tthis.set_objects(objects_to_keep);\n\t}\n\n\t//console.log(\"#{cmptr} marked for deletion\")\n\n\t// TODO: ensure that geometries with no remaining points are removed from the group\n\tprivate async _eval_for_points(core_group: CoreGroup) {\n\t\tconst core_objects = core_group.core_objects();\n\t\tlet core_object;\n\t\tfor (let i = 0; i < core_objects.length; i++) {\n\t\t\tcore_object = core_objects[i];\n\t\t\tlet core_geometry = core_object.core_geometry();\n\t\t\tif (core_geometry) {\n\t\t\t\tlet points = core_geometry.points_from_geometry();\n\t\t\t\tconst init_points_count = points.length;\n\t\t\t\tif (this.pv.by_expression) {\n\t\t\t\t\tpoints = await this._eval_expressions_for_points(points);\n\t\t\t\t}\n\n\t\t\t\tif (this.pv.by_attrib && this.pv.attrib_name !== '') {\n\t\t\t\t\tpoints = this._eval_attrib_for_points(points);\n\t\t\t\t}\n\t\t\t\tif (this.pv.by_bbox) {\n\t\t\t\t\tpoints = this._eval_bbox_for_points(points);\n\t\t\t\t}\n\n\t\t\t\tif (points.length != init_points_count) {\n\t\t\t\t\tconst object = core_object.object() as Object3DWithGeometry;\n\t\t\t\t\tcore_geometry.geometry().dispose();\n\t\t\t\t\tif (points.length > 0) {\n\t\t\t\t\t\t// TODO: if the new geo only has unconnected points, how do I know it and how do I change the material if it was previously a mesh?\n\t\t\t\t\t\tobject.geometry = CoreGeometry.geometry_from_points(\n\t\t\t\t\t\t\tpoints,\n\t\t\t\t\t\t\t(<unknown>object.constructor) as ObjectType\n\t\t\t\t\t\t);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// TODO: do not dispose material if not cloned\n\t\t\t\t\t\t// if (object.material != null) {\n\t\t\t\t\t\t// \tobject.material.dispose();\n\t\t\t\t\t\t// }\n\t\t\t\t\t\tobject.parent != null ? object.parent.remove(object) : undefined;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthis.set_core_group(core_group);\n\t}\n\n\tprivate async _eval_expressions_for_points(points: CorePoint[]) {\n\t\tconst kept_points = [];\n\n\t\t// const promises = points.map((point, i)=> {\n\t\t// \treturn new Promise( async (resolve, reject)=> {\n\t\t// \t\tthis.context().set_entity(point);\n\t\t// \t\tconst val = await(this.param('expression').eval_p());\n\t\t// \t\tconst keep_point = this.pv.invert ?\n\t\t// \t\t\tval === true\n\t\t// \t\t:\n\t\t// \t\t\tval === false;\n\n\t\t// \t\tif (keep_point) {\n\t\t// \t\t\tkept_points.push(point);\n\t\t// \t\t}\n\t\t// \t\tresolve();\n\t\t// \t});\n\t\t// });\n\n\t\t// await(Promise.all(promises));\n\t\tconst param = this.p.expression;\n\t\tif (this.p.expression.has_expression() && param.expression_controller) {\n\t\t\tawait param.expression_controller.compute_expression_for_points(points, (point, value) => {\n\t\t\t\tlet keep_point = !value;\n\t\t\t\tif (this.pv.invert) {\n\t\t\t\t\tkeep_point = !keep_point;\n\t\t\t\t}\n\t\t\t\tif (keep_point) {\n\t\t\t\t\tkept_points.push(point);\n\t\t\t\t}\n\t\t\t});\n\t\t} else {\n\t\t\tconst value = this.pv.expression;\n\t\t\tlet keep_point = !value;\n\t\t\tif (this.pv.invert) {\n\t\t\t\tkeep_point = !keep_point;\n\t\t\t}\n\t\t\tfor (let i = 0; i < points.length; i++) {\n\t\t\t\tif (keep_point) {\n\t\t\t\t\tkept_points.push(points[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tconsole.log(kept_points);\n\t\treturn kept_points;\n\t}\n\n\tprivate async _eval_expressions_for_objects(core_objects: CoreObject[]) {\n\t\tconst param = this.p.expression;\n\n\t\tif (param.has_expression() && param.expression_controller) {\n\t\t\tawait param.expression_controller.compute_expression_for_objects(core_objects, (core_object, value) => {\n\t\t\t\tconst is_marked_for_deletion = this._marked_for_deletion_per_object_index.get(core_object.index);\n\t\t\t\tif (!is_marked_for_deletion) {\n\t\t\t\t\tthis._marked_for_deletion_per_object_index.set(core_object.index, value);\n\t\t\t\t}\n\t\t\t});\n\t\t} else {\n\t\t\tfor (let core_object of core_objects) {\n\t\t\t\tthis._marked_for_deletion_per_object_index.set(core_object.index, param.value);\n\t\t\t}\n\t\t}\n\n\t\t// for (let core_object of core_objects) {\n\t\t// \tconst is_marked_for_deletion = this._marked_for_deletion_per_object_index.get(core_object.index);\n\n\t\t// \tif (!is_marked_for_deletion) {\n\t\t// \t\tthis.processing_context.set_entity(core_object);\n\t\t// \t\t// param.set_dirty();\n\t\t// \t\tawait param.compute();\n\t\t// \t\tthis._marked_for_deletion_per_object_index.set(core_object.index, param.value);\n\t\t// \t}\n\t\t// }\n\t}\n\n\tprivate _eval_attrib_for_points(points: CorePoint[]) {\n\t\tconst kept_points: CorePoint[] = [];\n\n\t\tif (points.length > 0) {\n\t\t\tconst first_attrib_value = points[0].attrib_value(this.pv.attrib_name);\n\t\t\t// TODO: should I just have @_param_attrib_string?\n\t\t\t// although I may need a vector one... maybe a multiple string?\n\t\t\tconst comparison_attrib_values = lodash_isString(first_attrib_value)\n\t\t\t\t? //@_param_attrib_string\n\t\t\t\t  CoreString.attrib_names(this.pv.attrib_string)\n\t\t\t\t: [this.pv.attrib_numeric.x];\n\n\t\t\tcomparison_attrib_values.forEach((comparison_attrib_value: string | number) => {\n\t\t\t\treturn points.forEach((point) => {\n\t\t\t\t\tconst attrib_value = point.attrib_value(this.pv.attrib_name);\n\n\t\t\t\t\t// TODO: and for vectors? should I have a point.attrib(name).is_equal(value)\n\t\t\t\t\t// or point.is_attrib_equal(name, value) ?\n\t\t\t\t\t//keep_point = (attrib_value != comparison_attrib_value)\n\t\t\t\t\tlet keep_point = !this._comparison(attrib_value, comparison_attrib_value);\n\n\t\t\t\t\tif (this.pv.invert) {\n\t\t\t\t\t\tkeep_point = !keep_point;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (keep_point) {\n\t\t\t\t\t\treturn kept_points.push(point);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t});\n\t\t}\n\n\t\treturn kept_points;\n\t}\n\n\tprivate _comparison(attrib_value: number | string, comparison_attrib_value: number | string) {\n\t\tswitch (this.pv.attrib_ComparisonOperator) {\n\t\t\tcase ComparisonOperator['==']:\n\t\t\t\treturn attrib_value === comparison_attrib_value;\n\t\t\tcase ComparisonOperator['<=']:\n\t\t\t\treturn attrib_value <= comparison_attrib_value;\n\t\t\tcase ComparisonOperator['<']:\n\t\t\t\treturn attrib_value < comparison_attrib_value;\n\t\t\tcase ComparisonOperator['>']:\n\t\t\t\treturn attrib_value > comparison_attrib_value;\n\t\t\tcase ComparisonOperator['>=']:\n\t\t\t\treturn attrib_value >= comparison_attrib_value;\n\t\t\tcase ComparisonOperator['!=']:\n\t\t\t\treturn attrib_value !== comparison_attrib_value;\n\t\t}\n\t}\n\n\tprivate _eval_type_for_objects(core_objects: CoreObject[]) {\n\t\tconst object_type_name = ObjectTypes[this.pv.object_type];\n\n\t\tfor (let core_object of core_objects) {\n\t\t\tconst is_marked_for_deletion = this._marked_for_deletion_per_object_index.get(core_object.index);\n\n\t\t\tif (!is_marked_for_deletion) {\n\t\t\t\tconst object = core_object.object();\n\n\t\t\t\tif (object.constructor.name === object_type_name) {\n\t\t\t\t\tthis._marked_for_deletion_per_object_index.set(core_object.index, true);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate _eval_attrib_for_objects(core_objects: CoreObject[]) {\n\t\tfor (let core_object of core_objects) {\n\t\t\tconst is_marked_for_deletion = this._marked_for_deletion_per_object_index.get(core_object.index);\n\n\t\t\tif (!is_marked_for_deletion) {\n\t\t\t\t// const object = core_object.object();\n\t\t\t\tconst attrib_value = core_object.attrib_value(this.pv.attrib_name);\n\n\t\t\t\tconst comparison_attrib_value = lodash_isString(attrib_value)\n\t\t\t\t\t? this.pv.attrib_string\n\t\t\t\t\t: this.pv.attrib_float;\n\n\t\t\t\tif (attrib_value === comparison_attrib_value) {\n\t\t\t\t\tthis._marked_for_deletion_per_object_index.set(core_object.index, true);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate _eval_bbox_for_points(points: CorePoint[]) {\n\t\tconst kept_points: CorePoint[] = [];\n\n\t\tlodash_each(points, (point, i) => {\n\t\t\tconst in_bbox = this._bbox.containsPoint(point.position());\n\n\t\t\tconst keep_point = this.pv.invert ? in_bbox : !in_bbox;\n\n\t\t\tif (keep_point) {\n\t\t\t\treturn kept_points.push(point);\n\t\t\t}\n\t\t});\n\n\t\treturn kept_points;\n\t}\n\n\t// private _eval_bbox_for_object(object: Object3D): boolean {\n\t// \tconst object_bbox = new Box3().setFromObject(object);\n\t// \tconst center = new Vector3();\n\t// \tobject_bbox.getCenter(center);\n\n\t// \treturn this.pv.bbox().containsPoint(center);\n\t// }\n\n\tprivate get _bbox() {\n\t\treturn this._bbox_cache != null\n\t\t\t? this._bbox_cache\n\t\t\t: (this._bbox_cache = new Box3(\n\t\t\t\t\tthis.pv.bbox_center.clone().sub(this.pv.bbox_size.clone().multiplyScalar(0.5)),\n\t\t\t\t\tthis.pv.bbox_center.clone().add(this.pv.bbox_size.clone().multiplyScalar(0.5))\n\t\t\t  ));\n\t}\n\n\tprivate _point_object(core_object: CoreObject) {\n\t\tconst core_points = core_object.points();\n\t\tconst geometry = CoreGeometry.geometry_from_points(\n\t\t\tcore_points,\n\t\t\t(<unknown>core_object.object().constructor) as ObjectType\n\t\t);\n\t\treturn this.create_object(geometry, ObjectType.POINTS);\n\t}\n}\n","import {Vector3} from 'three/src/math/Vector3';\nimport {BufferGeometry} from 'three/src/core/BufferGeometry';\nimport {BufferAttribute} from 'three/src/core/BufferAttribute';\nimport {Mesh} from 'three/src/objects/Mesh';\nimport lodash_range from 'lodash/range';\nimport lodash_times from 'lodash/times';\nimport lodash_chunk from 'lodash/chunk';\nimport {TypedSopNode} from './_Base';\nimport {CoreGroup} from '../../../core/geometry/Group';\nimport {InputCloneMode} from '../../poly/InputCloneMode';\n\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nimport {CorePoint} from '../../../core/geometry/Point';\nimport {CoreFace} from '../../../core/geometry/Face';\nclass FaceSopParamsConfig extends NodeParamsConfig {\n\tmake_faces_unique = ParamConfig.BOOLEAN(0);\n\tadd_face_center_attribute = ParamConfig.BOOLEAN(0, {\n\t\tvisible_if: {make_faces_unique: 1},\n\t});\n\tadd_face_id = ParamConfig.BOOLEAN(0, {\n\t\tvisible_if: {make_faces_unique: 1},\n\t});\n\ttransform = ParamConfig.BOOLEAN(0, {\n\t\tvisible_if: {make_faces_unique: 1},\n\t});\n\tscale = ParamConfig.FLOAT(1, {\n\t\tvisible_if: {make_faces_unique: 1, transform: 1},\n\t});\n}\nconst ParamsConfig = new FaceSopParamsConfig();\n\nexport class FaceSopNode extends TypedSopNode<FaceSopParamsConfig> {\n\tparams_config = ParamsConfig;\n\tstatic type() {\n\t\treturn 'face';\n\t}\n\n\tinitialize_node() {\n\t\tthis.io.inputs.set_count(1);\n\t\tthis.io.inputs.init_inputs_clonable_state([InputCloneMode.FROM_NODE]);\n\t}\n\n\tcook(input_contents: CoreGroup[]) {\n\t\tconst core_group = input_contents[0];\n\n\t\tif (this.pv.make_faces_unique) {\n\t\t\tthis._make_faces_unique(core_group);\n\n\t\t\t// we can only add face_center attrib\n\t\t\t// if the faces have been split\n\t\t\t// otherwise a point may belong to multiple faces\n\t\t\tif (this.pv.add_face_center_attribute) {\n\t\t\t\tthis._add_face_center_attribute(core_group);\n\t\t\t}\n\t\t\tif (this.pv.add_face_id) {\n\t\t\t\tthis._add_face_id(core_group);\n\t\t\t}\n\t\t\tif (this.pv.transform) {\n\t\t\t\tthis._transform_faces(core_group);\n\t\t\t}\n\t\t}\n\n\t\tthis.set_core_group(core_group);\n\t}\n\n\tprivate _make_faces_unique(core_group: CoreGroup) {\n\t\tfor (let object of core_group.objects()) {\n\t\t\tif ((object as Mesh).isMesh) {\n\t\t\t\tconst geometry = (object as Mesh).geometry as BufferGeometry;\n\t\t\t\tconst faces = lodash_chunk(geometry.index?.array || [], 3);\n\t\t\t\tconst points_count = faces.length * 3;\n\t\t\t\tfor (let attrib_name of Object.keys(geometry.attributes)) {\n\t\t\t\t\tconst attrib = geometry.attributes[attrib_name];\n\t\t\t\t\tconst attrib_size = attrib.itemSize;\n\t\t\t\t\tconst new_values = new Float32Array(points_count * attrib_size);\n\t\t\t\t\tlet new_value_index = 0;\n\t\t\t\t\tfaces.forEach((face) => {\n\t\t\t\t\t\tface.forEach((index) => {\n\t\t\t\t\t\t\tlodash_times(attrib_size, (i) => {\n\t\t\t\t\t\t\t\tconst current_value = attrib.array[index * attrib_size + i];\n\t\t\t\t\t\t\t\tnew_values[new_value_index] = current_value;\n\t\t\t\t\t\t\t\tnew_value_index += 1;\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t});\n\t\t\t\t\t});\n\t\t\t\t\tgeometry.setAttribute(attrib_name, new BufferAttribute(new_values, attrib_size));\n\t\t\t\t}\n\t\t\t\tconst new_indices = lodash_range(points_count);\n\t\t\t\tgeometry.setIndex(new_indices);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate _add_face_center_attribute(core_group: CoreGroup) {\n\t\tconst attrib_name = 'face_center';\n\t\tconst face_center = new Vector3();\n\t\tlet faces: CoreFace[], face: CoreFace, points: CorePoint[], point: CorePoint;\n\n\t\tcore_group.core_objects().forEach((core_object) => {\n\t\t\tconst object = core_object.object();\n\t\t\tconst core_geometry = core_object.core_geometry();\n\t\t\tif ((object as Mesh).isMesh && core_geometry) {\n\t\t\t\tfaces = core_geometry.faces();\n\t\t\t\tif (!core_geometry.has_attrib(attrib_name)) {\n\t\t\t\t\tcore_geometry.add_numeric_attrib(attrib_name, 3, -1);\n\t\t\t\t}\n\n\t\t\t\tfor (let fi = 0; fi < faces.length; fi++) {\n\t\t\t\t\tface = faces[fi];\n\t\t\t\t\tface.center(face_center);\n\n\t\t\t\t\tpoints = face.points;\n\t\t\t\t\tfor (let pi = 0; pi < points.length; pi++) {\n\t\t\t\t\t\tpoint = points[pi];\n\t\t\t\t\t\tpoint.set_attrib_value(attrib_name, face_center);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\tprivate _add_face_id(core_group: CoreGroup) {\n\t\tconst attrib_name = 'face_id';\n\n\t\tcore_group.core_objects().forEach((core_object) => {\n\t\t\tconst object = core_object.object();\n\t\t\tconst core_geometry = core_object.core_geometry();\n\t\t\tif ((object as Mesh).isMesh && core_geometry) {\n\t\t\t\tconst faces = core_geometry.faces();\n\t\t\t\t// const points_count = core_geometry.points_count();\n\n\t\t\t\tif (!core_geometry.has_attrib(attrib_name)) {\n\t\t\t\t\tcore_geometry.add_numeric_attrib(attrib_name, 1, -1);\n\t\t\t\t}\n\n\t\t\t\tfor (let i = 0; i < faces.length; i++) {\n\t\t\t\t\tconst face = faces[i];\n\t\t\t\t\tconst points = face.points;\n\t\t\t\t\tfor (let j = 0; j < points.length; j++) {\n\t\t\t\t\t\tconst point = points[j];\n\t\t\t\t\t\tpoint.set_attrib_value(attrib_name, i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\tprivate _transform_faces(core_group: CoreGroup) {\n\t\tconst attrib_name = 'position';\n\t\tconst face_center = new Vector3();\n\t\tconst new_position = new Vector3();\n\t\tconst scale = this.pv.scale;\n\t\tlet faces: CoreFace[], face: CoreFace, points: CorePoint[], point: CorePoint;\n\n\t\tcore_group.core_objects().forEach((core_object) => {\n\t\t\tconst object = core_object.object();\n\t\t\tconst core_geometry = core_object.core_geometry();\n\t\t\tif ((object as Mesh).isMesh && core_geometry) {\n\t\t\t\tfaces = core_geometry.faces();\n\t\t\t\tif (!core_geometry.has_attrib(attrib_name)) {\n\t\t\t\t\tcore_geometry.add_numeric_attrib(attrib_name, 3, -1);\n\t\t\t\t}\n\n\t\t\t\tfor (let fi = 0; fi < faces.length; fi++) {\n\t\t\t\t\tface = faces[fi];\n\t\t\t\t\tface.center(face_center);\n\n\t\t\t\t\tpoints = face.points;\n\t\t\t\t\tfor (let pi = 0; pi < points.length; pi++) {\n\t\t\t\t\t\tpoint = points[pi];\n\t\t\t\t\t\tconst position = point.position();\n\t\t\t\t\t\tnew_position.x = position.x * scale + face_center.x * (1 - scale);\n\t\t\t\t\t\tnew_position.y = position.y * scale + face_center.y * (1 - scale);\n\t\t\t\t\t\tnew_position.z = position.z * scale + face_center.z * (1 - scale);\n\t\t\t\t\t\tpoint.set_attrib_value(attrib_name, new_position);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n}\n","import {ObjectLoader} from 'three/src/loaders/ObjectLoader';\nimport {Object3D} from 'three/src/core/Object3D';\n// import lodash_isArray from 'lodash/isArray';\n// import {CoreString} from '../String';\n\n// import {GeometryLoaderModule} from './Geometry/_Module';\n// import {DRACOLoader} from './Geometry/DRACOLoader';\n// import {JsonData} from './Geometry/JsonData'\n// import {CoreScriptLoader} from './Script';\nimport {BufferGeometry} from 'three/src/core/BufferGeometry';\nimport {Mesh} from 'three/src/objects/Mesh';\nimport {MeshLambertMaterial} from 'three/src/materials/MeshLambertMaterial';\n\n// import {DDSLoader} from '../../../modules/three/examples/jsm/loaders/DDSLoader';\n// import {DRACOLoader} from '../../../modules/three/examples/jsm/loaders/DRACOLoader';\n// import {GLTFLoader} from '../../../modules/three/examples/jsm/loaders/GLTFLoader';\n// import {OBJLoader} from '../../../modules/three/examples/jsm/loaders/OBJLoader';\n\n// const GLTFLoaders = ['DDSLoader', 'DRACOLoader', 'GLTFLoader'];\n// const SCRIPT_URLS_BY_EXT = {\n// \tgltf: GLTFLoaders,\n// \tglb: GLTFLoaders,\n// \tobj: 'OBJLoader',\n// };\n// const THREE_LOADER_BY_EXT = {\n// \tgltf: 'GLTFLoader',\n// \tglb: 'GLTFLoader',\n// \tobj: 'OBJLoader',\n// };\n// const DRACO_EXTENSIONS = ['gltf', 'glb']\n// const DRACO_EXTENSIONS = ['drc'];\n\n// export enum LoaderType {\n// \tAUTO = 'auto',\n// \tJSON_DATA = 'json_data',\n// \t// THREEJS_JSON = 'threejs_json',\n// }\n// export const LOADER_TYPES = [\n// \tLoaderType.AUTO,\n// \tLoaderType.JSON_DATA,\n// \t// LoaderType.THREEJS_JSON,\n// ];\n\nexport class CoreLoaderGeometry {\n\tprivate ext: string;\n\n\tconstructor(\n\t\tprivate url: string // private type: LoaderType, // private requester: any\n\t) {\n\t\tconst elements = this.url.split('.');\n\t\tthis.ext = elements[elements.length - 1].toLowerCase();\n\t\tif (this.ext === 'zip') {\n\t\t\tthis.ext = elements[elements.length - 2];\n\t\t}\n\t\t// if(!this.type){\n\t\t// \tconsole.error(\"CoreLoaderGeometry type is not valid\", this.type)\n\t\t// }\n\t}\n\n\tload(on_success: (objects: Object3D[]) => void, on_error: (error: string) => void) {\n\t\tthis.load_auto()\n\t\t\t.then((object) => {\n\t\t\t\ton_success(object);\n\t\t\t})\n\t\t\t.catch((error) => {\n\t\t\t\ton_error(error);\n\t\t\t});\n\t}\n\n\tprivate load_auto(): Promise<any> {\n\t\treturn new Promise(async (resolve, reject) => {\n\t\t\tconst url = this.url; //.includes('?') ? this.url : `${this.url}?${Date.now()}`;\n\n\t\t\tif (this.ext == 'json') {\n\t\t\t\tfetch(url)\n\t\t\t\t\t.then(async (response) => {\n\t\t\t\t\t\tconst data = await response.json();\n\t\t\t\t\t\tconst obj_loader = new ObjectLoader();\n\t\t\t\t\t\tobj_loader.parse(data, (obj) => {\n\t\t\t\t\t\t\tresolve(this.on_load_success(obj.children[0]));\n\t\t\t\t\t\t});\n\t\t\t\t\t})\n\t\t\t\t\t.catch((error) => {\n\t\t\t\t\t\treject(error);\n\t\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tconst loader = await this.loader_for_ext();\n\t\t\t\tif (loader) {\n\t\t\t\t\tloader.load(\n\t\t\t\t\t\turl,\n\t\t\t\t\t\t(object: any) => {\n\t\t\t\t\t\t\tconsole.log(object);\n\t\t\t\t\t\t\tthis.on_load_success(object).then((object2) => {\n\t\t\t\t\t\t\t\tresolve(object2);\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t},\n\t\t\t\t\t\tundefined,\n\t\t\t\t\t\t(error_message: ErrorEvent) => {\n\t\t\t\t\t\t\treject(error_message);\n\t\t\t\t\t\t}\n\t\t\t\t\t);\n\t\t\t\t} else {\n\t\t\t\t\tconst error_message = `format not supported (${this.ext})`;\n\t\t\t\t\treject(error_message);\n\t\t\t\t}\n\t\t\t\t// CoreLoaderGeometry.loader_for_ext().then((loader) => {\n\t\t\t\t// \tif (loader) {\n\t\t\t\t// \t\tloader.load(\n\t\t\t\t// \t\t\turl,\n\t\t\t\t// \t\t\t(object: Object3D) => {\n\t\t\t\t// \t\t\t\tthis.on_load_success(object).then((object2) => {\n\t\t\t\t// \t\t\t\t\tresolve(object2);\n\t\t\t\t// \t\t\t\t});\n\t\t\t\t// \t\t\t},\n\t\t\t\t// \t\t\tnull,\n\t\t\t\t// \t\t\t(error_message: string) => {\n\t\t\t\t// \t\t\t\treject(error_message);\n\t\t\t\t// \t\t\t}\n\t\t\t\t// \t\t);\n\t\t\t\t// \t} else {\n\t\t\t\t// \t\tconst error_message = `format not supported (${this.ext})`;\n\t\t\t\t// \t\tconsole.warn(error_message);\n\t\t\t\t// \t\treject(error_message);\n\t\t\t\t// \t}\n\t\t\t\t// });\n\t\t\t}\n\t\t});\n\t}\n\n\tprivate async on_load_success(object: Object3D | BufferGeometry | object): Promise<Object3D[]> {\n\t\t// console.log(\"animation?\", object.animations)\n\t\t// if(object.animations){\n\t\t// \tawait CoreScriptLoader.load('/three/js/utils/SkeletonUtils')\n\t\t// }\n\t\tif (object instanceof Object3D) {\n\t\t\tswitch (this.ext) {\n\t\t\t\tcase 'gltf':\n\t\t\t\t\treturn this.on_load_succes_gltf(object);\n\t\t\t\tcase 'glb':\n\t\t\t\t\treturn this.on_load_succes_gltf(object);\n\t\t\t\t// case 'drc':\n\t\t\t\t// \treturn this.on_load_succes_drc(object);\n\t\t\t\tcase 'obj':\n\t\t\t\t\treturn [object]; // [object] //.children\n\t\t\t\tcase 'json':\n\t\t\t\t\treturn [object]; // [object] //.children\n\t\t\t\tdefault:\n\t\t\t\t\treturn [object];\n\t\t\t}\n\t\t}\n\t\tif (object instanceof BufferGeometry) {\n\t\t\tswitch (this.ext) {\n\t\t\t\tcase 'drc':\n\t\t\t\t\treturn this.on_load_succes_drc(object);\n\t\t\t\tdefault:\n\t\t\t\t\treturn [new Mesh(object)];\n\t\t\t}\n\t\t}\n\n\t\t// if it's an object, such as returned by glb\n\t\tswitch (this.ext) {\n\t\t\tcase 'gltf':\n\t\t\t\treturn this.on_load_succes_gltf(object);\n\t\t\tcase 'glb':\n\t\t\t\treturn this.on_load_succes_gltf(object);\n\t\t\tdefault:\n\t\t\t\treturn [];\n\t\t}\n\t\treturn [];\n\t}\n\n\tprivate on_load_succes_gltf(gltf: any): Object3D[] {\n\t\tconst scene = gltf['scene'];\n\t\tscene.animations = gltf.animations;\n\n\t\tconsole.log('[scene]', [scene]);\n\t\treturn [scene]; //.children\n\t}\n\tprivate on_load_succes_drc(geometry: BufferGeometry): Object3D[] {\n\t\tconst mat = new MeshLambertMaterial();\n\t\tconst mesh = new Mesh(geometry, mat);\n\n\t\treturn [mesh]; //.children\n\t}\n\n\tasync loader_for_ext() {\n\t\tswitch (this.ext.toLowerCase()) {\n\t\t\tcase 'gltf':\n\t\t\t\treturn this.loader_for_gltf();\n\t\t\tcase 'glb':\n\t\t\t\treturn this.loader_for_glb();\n\t\t\tcase 'drc':\n\t\t\t\treturn this.loader_for_drc();\n\t\t\tcase 'obj':\n\t\t\t\treturn this.loader_for_obj();\n\t\t}\n\t}\n\n\tasync loader_for_gltf() {\n\t\t// 'DDSLoader', 'DRACOLoader', 'GLTFLoader'\n\t\t// const {DDSLoader} = await import(`modules/three/examples/jsm/loaders/DDSLoader`);\n\t\t// const {DRACOLoader} = await import(`modules/three/examples/jsm/loaders/DRACOLoader`);\n\t\tconst {GLTFLoader} = await import(`../../../modules/three/examples/jsm/loaders/GLTFLoader`);\n\t\treturn new GLTFLoader();\n\t}\n\tasync loader_for_glb() {\n\t\tconst {GLTFLoader} = await import(`../../../modules/three/examples/jsm/loaders/GLTFLoader`);\n\t\tconst {DRACOLoader} = await import(`../../../modules/three/examples/jsm/loaders/DRACOLoader`);\n\n\t\tconst loader = new GLTFLoader();\n\t\tconst draco_loader = new DRACOLoader();\n\t\tconst decoder_path = '/three/js/libs/draco/gltf/';\n\t\t// DRACOLoader.setDecoderPath( decoder_path );\n\t\tdraco_loader.setDecoderPath(decoder_path);\n\t\tdraco_loader.setDecoderConfig({type: 'js'});\n\t\tloader.setDRACOLoader(draco_loader);\n\n\t\treturn loader;\n\t}\n\tasync loader_for_drc() {\n\t\t// const {DDSLoader} = await import(`modules/three/examples/jsm/loaders/DDSLoader`);\n\t\tconst {DRACOLoader} = await import(`../../../modules/three/examples/jsm/loaders/DRACOLoader`);\n\t\t// const {GLTFLoader} = await import(`modules/three/examples/jsm/loaders/GLTFLoader`);\n\n\t\t// const loader = new GLTFLoader();\n\t\tconst draco_loader = new DRACOLoader();\n\t\tconst decoder_path = '/three/js/libs/draco/';\n\t\t// DRACOLoader.setDecoderPath( decoder_path );\n\t\tdraco_loader.setDecoderPath(decoder_path);\n\t\tdraco_loader.setDecoderConfig({type: 'js'});\n\t\t// loader.setDRACOLoader(draco_loader);\n\t\t// console.log('loader', loader);\n\t\treturn draco_loader;\n\t}\n\tasync loader_for_obj() {\n\t\tconst {OBJLoader} = await import(`../../../modules/three/examples/jsm/loaders/OBJLoader`);\n\t\treturn new OBJLoader();\n\t}\n\n\t// \tconst ext_lowercase = this.ext.toLowerCase();\n\t// \tlet script_names = SCRIPT_URLS_BY_EXT[ext_lowercase];\n\t// \tif (script_names) {\n\t// \t\tif (!lodash_isArray(script_names)) {\n\t// \t\t\tscript_names = [script_names];\n\t// \t\t}\n\t// \t\tlet imported_modules = {};\n\t// \t\tlet imported_module;\n\t// \t\tfor (let script_name of script_names) {\n\t// \t\t\timported_module = await CoreScriptLoader.load_module_three_loader(script_name);\n\t// \t\t\timported_modules[script_name] = imported_module;\n\t// \t\t}\n\n\t// \t\tconst loader_class_name = THREE_LOADER_BY_EXT[ext_lowercase];\n\t// \t\tconst loader_class = imported_module[loader_class_name];\n\t// \t\tif (loader_class) {\n\t// \t\t\tconst loader = new loader_class();\n\n\t// \t\t\tif (DRACO_EXTENSIONS.includes(ext_lowercase)) {\n\t// \t\t\t\tconst DRACOLoader = imported_modules.DRACOLoader.DRACOLoader;\n\t// \t\t\t\tconst draco_loader = new DRACOLoader();\n\t// \t\t\t\t// const decoder_path = '/three/js/libs/draco/gltf/'\n\t// \t\t\t\t// DRACOLoader.setDecoderPath( decoder_path );\n\t// \t\t\t\t// draco_loader.setDecoderPath( decoder_path );\n\t// \t\t\t\tloader.setDRACOLoader(draco_loader);\n\t// \t\t\t}\n\n\t// \t\t\treturn loader;\n\t// \t\t}\n\t// \t}\n\t// }\n}\n","import lodash_flatten from 'lodash/flatten';\n// import lodash_clone from 'lodash/clone';\n// import lodash_merge from 'lodash/merge';\nimport {TypedSopNode} from './_Base';\nimport {Object3D} from 'three/src/core/Object3D';\n\nimport {CoreLoaderGeometry} from '../../../core/loader/Geometry';\n\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nimport {BaseParamType} from '../../params/_Base';\nimport {BaseNodeType} from '../_Base';\nclass FileSopParamsConfig extends NodeParamsConfig {\n\turl = ParamConfig.STRING('', {\n\t\tdesktop_browse: {file_type: 'geometry'},\n\t\talways_reference_asset: true,\n\t});\n\treload = ParamConfig.BUTTON(null, {\n\t\tcallback: (node: BaseNodeType, param: BaseParamType) => {\n\t\t\tFileSopNode.PARAM_CALLBACK_reload(node as FileSopNode);\n\t\t},\n\t});\n}\nconst ParamsConfig = new FileSopParamsConfig();\n\nexport class FileSopNode extends TypedSopNode<FileSopParamsConfig> {\n\tparams_config = ParamsConfig;\n\tstatic type() {\n\t\treturn 'file';\n\t}\n\n\tinitialize_node() {\n\t\t// this.io.inputs.set_count_to_zero();\n\t}\n\n\t// TODO: no error when trying to load a non existing zip file??\n\tcook() {\n\t\tconst loader = new CoreLoaderGeometry(this.pv.url);\n\t\tloader.load(this._on_load.bind(this), this._on_error.bind(this));\n\t}\n\n\tprivate _on_load(objects: Object3D[]) {\n\t\tconsole.log('objects', objects);\n\t\tobjects = lodash_flatten(objects);\n\t\tthis.set_objects(objects);\n\t}\n\tprivate _on_error(message: string) {\n\t\tthis.states.error.set(`could not load geometry from ${this.pv.url} (${message})`);\n\t}\n\n\t// if I add this again, check if it can also work for desktop\n\t// async _on_open_url() {\n\t// \tconst url = this.pv.url\n\t// \tconst a = document.createElement('a');\n\t// \ta.href = url;\n\t// \ta.setAttribute('target', '_blank');\n\t// \ta.click();\n\t// }\n\n\tstatic PARAM_CALLBACK_reload(node: FileSopNode) {\n\t\tnode.param_callback_reload();\n\t}\n\tprivate param_callback_reload() {\n\t\t// this._previous_param_url = null\n\n\t\t// set the param dirty is preferable, in case this is used to refresh a local asset\n\t\tthis.p.url.set_dirty();\n\t\t// this.set_dirty()\n\t}\n\t// json_data_keys_prefix(){ return this.pv.json_data_keys_prefix }\n\t// json_skip_entries(){ return this.pv.skip_entries }\n\t// json_convert(){ return this.pv.convert }\n\t// json_convert_to_numeric(){ return this.pv.convert_to_numeric }\n}\n","import {TypedSopNode} from './_Base';\nimport {CoreGroup} from '../../../core/geometry/Group';\nimport {CoreObject} from '../../../core/geometry/Object';\nimport {CoreGeometry} from '../../../core/geometry/Geometry';\nimport {Vector3} from 'three/src/math/Vector3';\nimport {Mesh} from 'three/src/objects/Mesh';\n\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nimport {InputCloneMode} from '../../poly/InputCloneMode';\nimport {CorePoint} from '../../../core/geometry/Point';\nimport {ObjectType} from '../../../core/geometry/Constant';\nclass FuseSopParamsConfig extends NodeParamsConfig {\n\tdist = ParamConfig.FLOAT(0.1, {\n\t\trange: [0, 1],\n\t\trange_locked: [true, false],\n\t});\n}\nconst ParamsConfig = new FuseSopParamsConfig();\n\nexport class FuseSopNode extends TypedSopNode<FuseSopParamsConfig> {\n\tparams_config = ParamsConfig;\n\tstatic type() {\n\t\treturn 'fuse';\n\t}\n\n\tstatic displayed_input_names(): string[] {\n\t\treturn ['points to fuse together'];\n\t}\n\n\tinitialize_node() {\n\t\tthis.io.inputs.set_count(1);\n\t\tthis.io.inputs.init_inputs_clonable_state([InputCloneMode.FROM_NODE]);\n\t}\n\n\tcook(input_contents: CoreGroup[]) {\n\t\tconst core_group = input_contents[0];\n\n\t\tconst new_objects = [];\n\t\tlet new_object;\n\t\tfor (let core_object of core_group.core_objects()) {\n\t\t\tnew_object = this._fuse_core_object(core_object);\n\t\t\tif (new_object) {\n\t\t\t\tnew_objects.push(new_object);\n\t\t\t}\n\t\t}\n\n\t\tthis.set_objects(new_objects);\n\t}\n\n\tprivate _fuse_core_object(core_object: CoreObject) {\n\t\tconst object = core_object.object();\n\t\tif (!object) {\n\t\t\treturn;\n\t\t}\n\t\tconst points = core_object.points();\n\n\t\tconst precision = this.pv.dist;\n\t\tconst points_by_position: Dictionary<CorePoint[]> = {};\n\t\tfor (let point of points) {\n\t\t\tconst position = point.position();\n\t\t\tconst rounded_position = new Vector3(\n\t\t\t\tMath.round(position.x / precision),\n\t\t\t\tMath.round(position.y / precision),\n\t\t\t\tMath.round(position.z / precision)\n\t\t\t);\n\t\t\tconst key = rounded_position.toArray().join('-');\n\t\t\tpoints_by_position[key] = points_by_position[key] || [];\n\t\t\tpoints_by_position[key].push(point);\n\t\t}\n\n\t\tconst kept_points: CorePoint[] = [];\n\t\tObject.keys(points_by_position).forEach((key) => {\n\t\t\tkept_points.push(points_by_position[key][0]);\n\t\t});\n\n\t\t(object as Mesh).geometry.dispose();\n\t\tif (kept_points.length > 0) {\n\t\t\t(object as Mesh).geometry = CoreGeometry.geometry_from_points(\n\t\t\t\tkept_points,\n\t\t\t\t(<unknown>object.constructor) as ObjectType\n\t\t\t);\n\t\t\treturn object;\n\t\t} else {\n\t\t\t// if(object.material){ object.material.dispose() }\n\t\t\t// if(object.parent){ object.parent.remove(object) }\n\t\t}\n\t}\n}\n","import {Vector2} from 'three/src/math/Vector2'\nimport {BufferGeometry} from 'three/src/core/BufferGeometry'\nimport {BufferAttribute} from 'three/src/core/BufferAttribute'\nconst THREE = {BufferAttribute, BufferGeometry, Vector2}\nimport lodash_flatten from 'lodash/flatten'\n// import {CoreGeometry} from '../Geometry';\n\nexport class CoreGeometryOperationHexagon {\n\tconstructor(\n\t\tprivate _param_size: THREE.Vector2,\n\t\tprivate _param_hexagon_radius: number,\n\t\tprivate _param_points_only: boolean\n\t) {}\n\n\tprocess(): THREE.BufferGeometry {\n\t\tconst side_length = this._param_hexagon_radius\n\t\tconst half_side_length = side_length * 0.5\n\t\tconst step_size = {\n\t\t\tx: side_length,\n\t\t\ty: Math.cos(Math.PI / 6) * this._param_hexagon_radius,\n\t\t}\n\t\tconst steps_count = {\n\t\t\tx: Math.floor(this._param_size.x / step_size.x),\n\t\t\ty: Math.floor(this._param_size.y / step_size.y),\n\t\t}\n\t\tlet positions = []\n\t\tlet indices = []\n\t\tfor (let y = 0; y < steps_count.y; y++) {\n\t\t\tfor (let x = 0; x < steps_count.x; x++) {\n\t\t\t\tpositions.push([\n\t\t\t\t\t-(this._param_size.x * 0.5) +\n\t\t\t\t\t\tx * step_size.x +\n\t\t\t\t\t\t(y % 2 == 0 ? half_side_length : 0),\n\t\t\t\t\t0,\n\t\t\t\t\t-(this._param_size.y * 0.5) + y * step_size.y,\n\t\t\t\t])\n\n\t\t\t\tif (!this._param_points_only) {\n\t\t\t\t\tif (y >= 1) {\n\t\t\t\t\t\tif (x == 0 || x == steps_count.x - 1) {\n\t\t\t\t\t\t\tif (x == 0) {\n\t\t\t\t\t\t\t\tindices.push([\n\t\t\t\t\t\t\t\t\tx + 1 + (y - 1) * steps_count.x,\n\t\t\t\t\t\t\t\t\tx + (y - 1) * steps_count.x,\n\t\t\t\t\t\t\t\t\tx + y * steps_count.x,\n\t\t\t\t\t\t\t\t])\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tindices.push([\n\t\t\t\t\t\t\t\t\tx + y * steps_count.x,\n\t\t\t\t\t\t\t\t\tx + (y - 1) * steps_count.x,\n\t\t\t\t\t\t\t\t\tx - 1 + y * steps_count.x,\n\t\t\t\t\t\t\t\t])\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tindices.push([\n\t\t\t\t\t\t\t\tx + y * steps_count.x,\n\t\t\t\t\t\t\t\tx + (y - 1) * steps_count.x,\n\t\t\t\t\t\t\t\tx - 1 + y * steps_count.x,\n\t\t\t\t\t\t\t])\n\t\t\t\t\t\t\tindices.push([\n\t\t\t\t\t\t\t\tx + y * steps_count.x,\n\t\t\t\t\t\t\t\tx + 1 + (y - 1) * steps_count.x,\n\t\t\t\t\t\t\t\tx + (y - 1) * steps_count.x,\n\t\t\t\t\t\t\t])\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tpositions = lodash_flatten(positions)\n\n\t\tconst geometry = new THREE.BufferGeometry()\n\t\tgeometry.setAttribute(\n\t\t\t'position',\n\t\t\tnew THREE.BufferAttribute(new Float32Array(positions), 3)\n\t\t)\n\n\t\tif (!this._param_points_only) {\n\t\t\tindices = lodash_flatten(indices)\n\t\t\tgeometry.setIndex(indices)\n\t\t\tgeometry.computeVertexNormals()\n\t\t}\n\n\t\treturn geometry\n\t}\n}\n","import {Vector3} from 'three/src/math/Vector3';\nimport {TypedSopNode} from './_Base';\nimport {CoreTransform} from '../../../core/Transform';\nimport {CoreConstant} from '../../../core/geometry/Constant';\n\nimport {CoreGeometryOperationHexagon} from '../../../core/geometry/operation/Hexagon';\n\nconst DEFAULT_UP = new Vector3(0, 1, 0);\n\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nclass HexagonsSopParamsConfig extends NodeParamsConfig {\n\tsize = ParamConfig.VECTOR2([1, 1]);\n\thexagon_radius = ParamConfig.FLOAT(0.1);\n\tdirection = ParamConfig.VECTOR3([0, 1, 0]);\n\tpoints_only = ParamConfig.BOOLEAN(0);\n\t// no need to have centers, as all points are centers anyway\n\t//this.add_param( ParamType.TOGGLE, 'centers_only', 0, {visible_if: {points_only: 1}})\n}\nconst ParamsConfig = new HexagonsSopParamsConfig();\n\nexport class HexagonsSopNode extends TypedSopNode<HexagonsSopParamsConfig> {\n\tparams_config = ParamsConfig;\n\tstatic type() {\n\t\treturn 'hexagons';\n\t}\n\n\tprivate _core_transform = new CoreTransform();\n\n\tinitialize_node() {}\n\n\tcook() {\n\t\tconst operation = new CoreGeometryOperationHexagon(this.pv.size, this.pv.hexagon_radius, this.pv.points_only);\n\t\tconst geometry = operation.process();\n\n\t\tthis._core_transform.rotate_geometry(geometry, DEFAULT_UP, this.pv.direction);\n\n\t\tif (this.pv.points_only) {\n\t\t\tthis.set_geometry(geometry, CoreConstant.OBJECT_TYPE.POINTS);\n\t\t} else {\n\t\t\tthis.set_geometry(geometry);\n\t\t}\n\t}\n}\n","import {Object3D} from 'three/src/core/Object3D';\nimport {Group} from 'three/src/objects/Group';\nconst THREE = {Group, Object3D};\nimport {TypedSopNode} from './_Base';\nimport {CoreGroup} from '../../../core/geometry/Group';\n// import {CoreGroup} from '../../../Core/Geometry/Group';\n// import {CoreConstant} from '../../../Core/Geometry/Constant'\n\nexport enum HierarchyMode {\n\tADD_PARENT = 'add_parent',\n\tREMOVE_PARENT = 'remove_parent',\n}\nexport const HIERARCHY_MODES: Array<HierarchyMode> = [HierarchyMode.ADD_PARENT, HierarchyMode.REMOVE_PARENT];\n\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nclass HierarchySopParamsConfig extends NodeParamsConfig {\n\tmode = ParamConfig.INTEGER(0, {\n\t\tmenu: {\n\t\t\tentries: HIERARCHY_MODES.map((m, i) => {\n\t\t\t\treturn {name: m, value: i};\n\t\t\t}),\n\t\t},\n\t});\n\tlevels = ParamConfig.INTEGER(1, {range: [0, 5]});\n}\nconst ParamsConfig = new HierarchySopParamsConfig();\n\nexport class HierarchySopNode extends TypedSopNode<HierarchySopParamsConfig> {\n\tparams_config = ParamsConfig;\n\tstatic type() {\n\t\treturn 'hierarchy';\n\t}\n\n\tstatic displayed_input_names(): string[] {\n\t\treturn ['geometry to add or remove parents to/from'];\n\t}\n\n\tinitialize_node() {\n\t\tthis.io.inputs.set_count(1);\n\t}\n\n\tcook(input_contents: CoreGroup[]) {\n\t\tconst core_group = input_contents[0];\n\t\t// const group_wrapper = new CoreGroup(group);\n\n\t\tif (HIERARCHY_MODES[this.pv.mode] == HierarchyMode.ADD_PARENT) {\n\t\t\tconst objects = this._add_parent_to_core_group(core_group);\n\t\t\tthis.set_objects(objects);\n\t\t} else {\n\t\t\tconst objects = this._remove_parent_from_core_group(core_group);\n\t\t\tthis.set_objects(objects);\n\t\t}\n\t}\n\n\tprivate _add_parent_to_core_group(core_group: CoreGroup): THREE.Object3D[] {\n\t\tif (this.pv.levels == 0) {\n\t\t\treturn core_group.objects();\n\t\t} else {\n\t\t\tconst new_objects: Object3D[] = [];\n\t\t\tlet new_object;\n\t\t\tfor (let object of core_group.objects()) {\n\t\t\t\tnew_object = this._add_parent_to_object(object);\n\t\t\t\tif (new_object) {\n\t\t\t\t\tnew_objects.push(new_object);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn new_objects;\n\t\t}\n\t}\n\tprivate _add_parent_to_object(object: THREE.Object3D): THREE.Object3D {\n\t\tlet new_parent = new THREE.Group();\n\n\t\t// while(child = object.children[0]){\n\t\tnew_parent.add(object);\n\t\t// }\n\n\t\tif (this.pv.levels > 0) {\n\t\t\tfor (let i = 0; i < this.pv.levels - 1; i++) {\n\t\t\t\t// for (let i of lodash_range(this.pv.levels - 1)) {\n\t\t\t\tnew_parent = this._add_new_parent(new_parent);\n\t\t\t}\n\t\t}\n\n\t\treturn new_parent;\n\t}\n\n\tprivate _add_new_parent(object: THREE.Object3D): THREE.Group {\n\t\tconst new_parent2 = new THREE.Group();\n\t\tnew_parent2.add(object);\n\t\treturn new_parent2;\n\t}\n\n\tprivate _remove_parent_from_core_group(core_group: CoreGroup): THREE.Object3D[] {\n\t\tif (this.pv.levels == 0) {\n\t\t\treturn core_group.objects();\n\t\t} else {\n\t\t\tconst new_objects: Object3D[] = [];\n\t\t\tfor (let object of core_group.objects()) {\n\t\t\t\tconst new_children = this._remove_parent_from_object(object);\n\t\t\t\tfor (let new_child of new_children) {\n\t\t\t\t\tnew_objects.push(new_child);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn new_objects;\n\t\t}\n\t}\n\n\tprivate _remove_parent_from_object(object: THREE.Object3D): THREE.Object3D[] {\n\t\tlet current_children = object.children;\n\n\t\tfor (let i = 0; i < this.pv.levels - 1; i++) {\n\t\t\tcurrent_children = this._get_children_from_objects(current_children);\n\t\t}\n\n\t\treturn current_children;\n\t}\n\n\tprivate _get_children_from_objects(objects: THREE.Object3D[]): THREE.Object3D[] {\n\t\tlet object;\n\t\tconst children: Object3D[] = [];\n\t\twhile ((object = objects.pop())) {\n\t\t\tif (object.children) {\n\t\t\t\tfor (let child of object.children) {\n\t\t\t\t\tchildren.push(child);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn children;\n\t}\n}\n","import {TypedSopNode} from './_Base';\n\nimport {CoreGroup} from '../../../core/geometry/Group';\nimport {CoreInstancer} from '../../../core/geometry/Instancer';\nimport {CoreMaterial} from '../../../core/geometry/Material';\nimport {InputCloneMode} from '../../poly/InputCloneMode';\nimport {GlobalsGeometryHandler} from '../gl/code/globals/Geometry';\nimport {NodeContext} from '../../poly/NodeContext';\nimport {BufferGeometry} from 'three/src/core/BufferGeometry';\nimport {BaseBuilderMatNodeType} from '../mat/_BaseBuilder';\nimport {BaseMatNodeType} from '../mat/_Base';\nimport {Material} from 'three/src/materials/Material';\nimport {Mesh} from 'three/src/objects/Mesh';\n\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nimport {MaterialsObjNode} from '../obj/Materials';\nimport {ObjectTypeByObject} from '../../../core/geometry/Constant';\nclass InstanceSopParamsConfig extends NodeParamsConfig {\n\tattributes_to_copy = ParamConfig.STRING('instance*');\n\tapply_material = ParamConfig.BOOLEAN(1);\n\tmaterial = ParamConfig.OPERATOR_PATH('', {\n\t\tvisible_if: {apply_material: 1},\n\t\tnode_selection: {\n\t\t\tcontext: NodeContext.MAT,\n\t\t},\n\t\tdependent_on_found_node: false,\n\t});\n}\nconst ParamsConfig = new InstanceSopParamsConfig();\n\nexport class InstanceSopNode extends TypedSopNode<InstanceSopParamsConfig> {\n\tparams_config = ParamsConfig;\n\tstatic type() {\n\t\treturn 'instance';\n\t}\n\n\tprivate _globals_handler: GlobalsGeometryHandler | undefined;\n\tprivate _geometry: BufferGeometry | undefined;\n\n\tstatic displayed_input_names(): string[] {\n\t\treturn ['geometry to be instanciated', 'points to instance to'];\n\t}\n\n\tprivate _on_create_bound = this._on_create.bind(this);\n\tinitialize_node() {\n\t\tsuper.initialize_node();\n\n\t\tthis.lifecycle.add_on_create_hook(this._on_create_bound);\n\n\t\tthis.io.inputs.set_count(2);\n\t\tthis.io.inputs.init_inputs_clonable_state([InputCloneMode.ALWAYS, InputCloneMode.NEVER]);\n\t}\n\n\tasync cook(input_contents: CoreGroup[]) {\n\t\tconst core_group_to_instance = input_contents[0];\n\t\tthis._geometry = undefined;\n\n\t\tconst object_to_instance = core_group_to_instance.objects()[0];\n\t\tif (object_to_instance) {\n\t\t\tconst geometry_to_instance = object_to_instance.geometry;\n\t\t\tif (geometry_to_instance) {\n\t\t\t\tconst core_group = input_contents[1];\n\t\t\t\tthis._create_instance(geometry_to_instance, core_group);\n\t\t\t}\n\t\t}\n\n\t\t// const type = object_to_instance.constructor.name;\n\t\tif (this._geometry) {\n\t\t\tconst type = ObjectTypeByObject(object_to_instance);\n\t\t\tif (type) {\n\t\t\t\tconst object = this.create_object(this._geometry, type);\n\t\t\t\t// object.customDepthMaterial = this._create_depth_material();\n\n\t\t\t\tif (this.pv.apply_material) {\n\t\t\t\t\tawait this._apply_material(object as Mesh);\n\t\t\t\t}\n\n\t\t\t\tthis.set_object(object);\n\t\t\t} else {\n\t\t\t\tthis.cook_controller.end_cook();\n\t\t\t}\n\t\t} else {\n\t\t\tthis.cook_controller.end_cook();\n\t\t}\n\t}\n\n\tasync _apply_material(object: Mesh) {\n\t\tconst found_node = this.p.material.found_node();\n\t\tif (found_node) {\n\t\t\tif (found_node.node_context() == NodeContext.MAT) {\n\t\t\t\tconst material_node = found_node as BaseMatNodeType;\n\t\t\t\tthis._globals_handler = this._globals_handler || new GlobalsGeometryHandler();\n\t\t\t\tconst mat_builder_node = material_node as BaseBuilderMatNodeType;\n\t\t\t\tif (mat_builder_node.assembler_controller) {\n\t\t\t\t\tmat_builder_node.assembler_controller.set_assembler_globals_handler(this._globals_handler);\n\t\t\t\t}\n\n\t\t\t\tconst container = await material_node.request_container();\n\t\t\t\tconst material: Material = container.material();\n\t\t\t\tif (material) {\n\t\t\t\t\tobject.material = material;\n\t\t\t\t\tCoreMaterial.apply_custom_materials(object, material);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis.states.error.set('found node is not a material');\n\t\t\t}\n\t\t} else {\n\t\t\tthis.states.error.set('material node invalid');\n\t\t}\n\t}\n\n\t_create_instance(geometry_to_instance: BufferGeometry, template_core_group: CoreGroup) {\n\t\tthis._geometry = CoreInstancer.create_instance_buffer_geo(\n\t\t\tgeometry_to_instance,\n\t\t\ttemplate_core_group,\n\t\t\tthis.pv.attributes_to_copy\n\t\t);\n\t}\n\n\tprivate _on_create() {\n\t\tconst root = this.scene.root;\n\t\tconst mat_type = 'materials';\n\t\tconst mesh_lambert_builder_type = 'mesh_lambert_builder';\n\t\tconst mat_name = 'MAT';\n\t\tconst mesh_lambert_mat_name = 'mesh_lambert_builder1';\n\t\tlet MAT: MaterialsObjNode | undefined;\n\t\tconst node_with_mat_name = root.node(mat_name);\n\t\tif (node_with_mat_name && node_with_mat_name.type == mat_type) {\n\t\t\tMAT = node_with_mat_name as MaterialsObjNode;\n\t\t} else {\n\t\t\tMAT = root.create_node('materials');\n\t\t\tMAT.set_name(mat_name);\n\t\t}\n\n\t\tconst create_mesh_lambert = (MAT: MaterialsObjNode, mesh_lambert_mat_name: string) => {\n\t\t\tconst mat_node = MAT.create_node(mesh_lambert_builder_type);\n\t\t\tmat_node.set_name(mesh_lambert_mat_name);\n\n\t\t\tconst instance_transform1 = mat_node.create_node('instance_transform');\n\t\t\tlet output1 = mat_node.node('output1');\n\t\t\tif (!output1) {\n\t\t\t\toutput1 = mat_node.create_node('output');\n\t\t\t}\n\t\t\toutput1.set_input('position', instance_transform1, 'position');\n\t\t\toutput1.set_input('normal', instance_transform1, 'normal');\n\n\t\t\treturn mat_node;\n\t\t};\n\t\tconst mesh_lambert_mat = MAT.node(mesh_lambert_mat_name) || create_mesh_lambert(MAT, mesh_lambert_mat_name);\n\n\t\tthis.p.material.set(mesh_lambert_mat.full_path());\n\t}\n}\n","import {Vector3} from 'three/src/math/Vector3';\nconst THREE = {Vector3};\nimport {CoreGroup} from '../../../core/geometry/Group';\nimport {CoreMath} from '../../../core/math/_Module';\nimport {TypedSopNode} from './_Base';\n\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nimport {InputCloneMode} from '../../poly/InputCloneMode';\nclass JitterSopParamsConfig extends NodeParamsConfig {\n\tamount = ParamConfig.FLOAT(1);\n\tseed = ParamConfig.INTEGER(1, {range: [0, 100]});\n}\nconst ParamsConfig = new JitterSopParamsConfig();\n\nexport class JitterSopNode extends TypedSopNode<JitterSopParamsConfig> {\n\tparams_config = ParamsConfig;\n\tstatic type() {\n\t\treturn 'jitter';\n\t}\n\n\tstatic displayed_input_names(): string[] {\n\t\treturn ['geometry to jitter points of'];\n\t}\n\n\tinitialize_node() {\n\t\tthis.io.inputs.set_count(1);\n\t\tthis.io.inputs.init_inputs_clonable_state([InputCloneMode.FROM_NODE]);\n\t}\n\n\tcook(input_contents: CoreGroup[]) {\n\t\tconst core_group = input_contents[0];\n\n\t\tcore_group.points().forEach((point, i) => {\n\t\t\t// TODO: replace by a pseudo random\n\t\t\tconst offset = new THREE.Vector3(\n\t\t\t\t2 * (CoreMath.rand(i * 75 + 764 + this.pv.seed) - 0.5),\n\t\t\t\t2 * (CoreMath.rand(i * 5678 + 3653 + this.pv.seed) - 0.5),\n\t\t\t\t2 * (CoreMath.rand(i * 657 + 48464 + this.pv.seed) - 0.5)\n\t\t\t);\n\t\t\toffset.normalize();\n\t\t\toffset.multiplyScalar(this.pv.amount);\n\n\t\t\tconst new_position = point\n\t\t\t\t.position()\n\t\t\t\t.clone()\n\t\t\t\t.add(offset);\n\t\t\tpoint.set_position(new_position);\n\t\t});\n\n\t\tthis.set_core_group(core_group);\n\t}\n}\n","import {TypedSopNode} from './_Base';\n\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nimport {InputCloneMode} from '../../poly/InputCloneMode';\nimport {CoreGroup} from '../../../core/geometry/Group';\nclass LayerSopParamsConfig extends NodeParamsConfig {\n\tlayer = ParamConfig.INTEGER(0, {\n\t\trange: [0, 31],\n\t\trange_locked: [true, true],\n\t});\n}\nconst ParamsConfig = new LayerSopParamsConfig();\n\nexport class LayerSopNode extends TypedSopNode<LayerSopParamsConfig> {\n\tparams_config = ParamsConfig;\n\tstatic type() {\n\t\treturn 'layer';\n\t}\n\n\tstatic displayed_input_names(): string[] {\n\t\treturn ['objects to change layers of'];\n\t}\n\tinitialize_node() {\n\t\tthis.io.inputs.set_count(1);\n\t\tthis.io.inputs.init_inputs_clonable_state([InputCloneMode.FROM_NODE]);\n\t}\n\n\tcook(input_contents: CoreGroup[]) {\n\t\tconst core_group = input_contents[0];\n\n\t\tfor (let object of core_group.objects()) {\n\t\t\tobject.layers.set(this.pv.layer);\n\t\t}\n\n\t\tthis.set_core_group(core_group);\n\t}\n}\n","import {Float32BufferAttribute} from 'three/src/core/BufferAttribute';\nimport {BufferGeometry} from 'three/src/core/BufferGeometry';\nimport lodash_times from 'lodash/times';\n\nimport {TypedSopNode} from './_Base';\nimport {CoreConstant} from '../../../core/geometry/Constant';\n\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nclass LineSopParamsConfig extends NodeParamsConfig {\n\tlength = ParamConfig.FLOAT(1, {range: [0, 10]});\n\tpoints_count = ParamConfig.INTEGER(1, {\n\t\trange: [2, 100],\n\t\trange_locked: [true, false],\n\t});\n\torigin = ParamConfig.VECTOR3([0, 0, 0]);\n\tdirection = ParamConfig.VECTOR3([0, 1, 0]);\n}\nconst ParamsConfig = new LineSopParamsConfig();\n\nexport class LineSopNode extends TypedSopNode<LineSopParamsConfig> {\n\tparams_config = ParamsConfig;\n\tstatic type() {\n\t\treturn 'line';\n\t}\n\n\tinitialize_node() {}\n\n\tcook() {\n\t\tconst points_count = Math.max(2, this.pv.points_count);\n\n\t\tconst positions: number[] = new Array(points_count * 3);\n\t\tconst indices: number[] = new Array(points_count);\n\n\t\tconst last_pt = this.pv.direction\n\t\t\t.clone()\n\t\t\t.normalize()\n\t\t\t.multiplyScalar(this.pv.length);\n\n\t\tlodash_times(points_count, (i) => {\n\t\t\tconst i_n = i / (points_count - 1);\n\t\t\tconst point = last_pt.clone().multiplyScalar(i_n);\n\t\t\tpoint.add(this.pv.origin);\n\t\t\tpoint.toArray(positions, i * 3);\n\n\t\t\tif (i > 0) {\n\t\t\t\tindices[(i - 1) * 2] = i - 1;\n\t\t\t\tindices[(i - 1) * 2 + 1] = i;\n\t\t\t}\n\t\t});\n\t\tconst geometry = new BufferGeometry();\n\t\tgeometry.setAttribute('position', new Float32BufferAttribute(positions, 3));\n\t\tgeometry.setIndex(indices);\n\t\tthis.set_geometry(geometry, CoreConstant.OBJECT_TYPE.LINE_SEGMENTS);\n\t}\n}\n","import {TypedSopNode} from './_Base';\n// import {BaseNodeMat} from '../Mat/_Base'\n\nimport {CoreMaterial} from '../../../core/geometry/Material';\nimport {GlobalsGeometryHandler} from '../gl/code/globals/Geometry';\n\nimport {InputCloneMode} from '../../poly/InputCloneMode';\nimport {NodeContext} from '../../poly/NodeContext';\nimport {BaseMatNodeType} from '../mat/_Base';\nimport {CoreGroup} from '../../../core/geometry/Group';\nimport {ShaderMaterial} from 'three/src/materials/ShaderMaterial';\nimport {Mesh} from 'three/src/objects/Mesh';\nimport {Material} from 'three/src/materials/Material';\nimport {Object3D} from 'three/src/core/Object3D';\n\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nimport {BaseBuilderMatNodeType} from '../mat/_BaseBuilder';\nclass MaterialSopParamsConfig extends NodeParamsConfig {\n\tgroup = ParamConfig.STRING('');\n\tmaterial = ParamConfig.OPERATOR_PATH('/MAT/mesh_standard1', {\n\t\tnode_selection: {\n\t\t\tcontext: NodeContext.MAT,\n\t\t},\n\t\tdependent_on_found_node: false,\n\t});\n\tapply_to_children = ParamConfig.BOOLEAN(1);\n}\nconst ParamsConfig = new MaterialSopParamsConfig();\n\nexport class MaterialSopNode extends TypedSopNode<MaterialSopParamsConfig> {\n\tparams_config = ParamsConfig;\n\tstatic type() {\n\t\treturn 'material';\n\t}\n\n\t_param_material: BaseMatNodeType | undefined;\n\t_globals_handler: GlobalsGeometryHandler = new GlobalsGeometryHandler();\n\n\tstatic displayed_input_names(): string[] {\n\t\treturn ['objects to assign material to'];\n\t}\n\n\tinitialize_node() {\n\t\tthis.io.inputs.set_count(1);\n\t\tthis.io.inputs.init_inputs_clonable_state([InputCloneMode.FROM_NODE]);\n\t}\n\n\t// TODO: optimize by not fetching the material node everytime\n\t// and maybe have a method in all operator_path params to do that quickly\n\t// TODO: does this apply the material to only 1 node?\n\tasync cook(core_groups: CoreGroup[]) {\n\t\t// let container = input_containers[0];\n\t\t// const group =\tcontainer.group(); // {clone: this.do_clone_inputs()})\n\t\tconst core_group = core_groups[0];\n\n\t\tconst node = this.p.material.found_node();\n\t\tif (node) {\n\t\t\tif (node.node_context() != NodeContext.MAT) {\n\t\t\t\tthis.states.error.set('node is not a material');\n\t\t\t} else {\n\t\t\t\tconst material_node = node as BaseMatNodeType;\n\t\t\t\tconst material = material_node.material;\n\t\t\t\tif (material instanceof ShaderMaterial) {\n\t\t\t\t\tconst material_builder_node = node as BaseBuilderMatNodeType;\n\t\t\t\t\tmaterial_builder_node.assembler_controller.set_assembler_globals_handler(this._globals_handler);\n\t\t\t\t}\n\n\t\t\t\tawait material_node.request_container();\n\t\t\t\tif (material) {\n\t\t\t\t\tfor (let object of core_group.objects_from_group(this.pv.group)) {\n\t\t\t\t\t\tif (this.pv.apply_to_children) {\n\t\t\t\t\t\t\tobject.traverse((grand_child) => {\n\t\t\t\t\t\t\t\tthis.apply_material(grand_child, material);\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthis.apply_material(object, material);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tthis.set_core_group(core_group);\n\t\t\t\t} else {\n\t\t\t\t\tthis.states.error.set(`material invalid. (error: '${material_node.states.error.message}')`);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tthis.states.error.set(`node '${this.pv.material}' not found`);\n\t\t}\n\t}\n\n\tapply_material(object: Object3D, material: Material) {\n\t\tconst object_with_material = object as Mesh;\n\t\t// if (object.material != null) {\n\t\t// \tobject.material.dispose();\n\t\t// }\n\t\t// TODO: do I really need to clone this material?\n\t\t// does it get cloned when a node fetches the container?\n\t\t// I may only need to clone it for the copy SOP\n\t\tobject_with_material.material = material;\n\t\tCoreMaterial.apply_custom_materials(object, material);\n\t}\n}\n","// import lodash_times from 'lodash/times';\n// import lodash_each from 'lodash/each';\n// import lodash_difference from 'lodash/difference';\n// import lodash_keys from 'lodash/keys';\n// import {Object3D} from 'three/src/core/Object3D';\n// import {Group} from 'three/src/objects/Group';\n// import {BufferAttribute} from 'three/src/core/BufferAttribute';\n// const THREE = {BufferAttribute, Group, Object3D};\nimport {TypedSopNode} from './_Base';\n// import {ParamType} from '../../../Engine/Param/_Module';\n\n// import {CoreGroup} from '../../../Core/Geometry/Group';\nimport {CoreGeometry} from '../../../core/geometry/Geometry';\nimport {CoreGroup, Object3DWithGeometry} from '../../../core/geometry/Group';\nimport {Object3D} from 'three/src/core/Object3D';\n// import {CoreConstant} from '../../../Core/Geometry/Constant';\nimport {ObjectType} from '../../../core/geometry/Constant';\nimport {Mesh} from 'three/src/objects/Mesh';\nimport {LineSegments} from 'three/src/objects/LineSegments';\nimport {Points} from 'three/src/objects/Points';\ntype ObjectsByType = {[key in ObjectType]: Object3DWithGeometry[]};\ntype ObjectTypes = Array<ObjectType>;\n\nconst INPUT_NAME = 'geometry to merge';\n\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nclass MergeSopParamsConfig extends NodeParamsConfig {\n\tcompact = ParamConfig.BOOLEAN(1);\n}\nconst ParamsConfig = new MergeSopParamsConfig();\n\nexport class MergeSopNode extends TypedSopNode<MergeSopParamsConfig> {\n\tparams_config = ParamsConfig;\n\tstatic type() {\n\t\treturn 'merge';\n\t}\n\n\tstatic displayed_input_names(): string[] {\n\t\treturn [INPUT_NAME, INPUT_NAME, INPUT_NAME, INPUT_NAME];\n\t}\n\n\tinitialize_node() {\n\t\tthis.io.inputs.set_count(1, 4);\n\n\t\tthis.ui_data.set_width(100);\n\t\t// this.ui_data.set_icon('compress-arrows-alt');\n\t}\n\n\tcook(input_contents: CoreGroup[]) {\n\t\tlet all_objects: Object3DWithGeometry[] = []; //new Group()\n\t\tfor (let input_core_group of input_contents) {\n\t\t\tif (input_core_group) {\n\t\t\t\tconst objects = input_core_group.objects();\n\t\t\t\tfor (let object of objects) {\n\t\t\t\t\tobject.traverse((child) => {\n\t\t\t\t\t\tall_objects.push(child as Object3DWithGeometry);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (this.pv.compact) {\n\t\t\tall_objects = this._make_compact(all_objects);\n\t\t}\n\t\tthis.set_objects(all_objects);\n\t}\n\n\t_make_compact(all_objects: Object3DWithGeometry[]): Object3DWithGeometry[] {\n\t\tconst objects_by_type: ObjectsByType = {\n\t\t\t[ObjectType.MESH]: [],\n\t\t\t[ObjectType.POINTS]: [],\n\t\t\t[ObjectType.LINE_SEGMENTS]: [],\n\t\t};\n\t\tconst merged_objects: Object3DWithGeometry[] = [];\n\n\t\tfor (let object of all_objects) {\n\t\t\tobject.traverse((object3d: Object3D) => {\n\t\t\t\tconst object = object3d as Object3DWithGeometry;\n\t\t\t\tif (object.geometry) {\n\t\t\t\t\t// const type = child.constructor.name;\n\t\t\t\t\tif ((object as Mesh).isMesh) {\n\t\t\t\t\t\tobjects_by_type[ObjectType.MESH].push(object);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif ((object as LineSegments).isLineSegments) {\n\t\t\t\t\t\t\tobjects_by_type[ObjectType.LINE_SEGMENTS].push(object);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif ((object as Points).isPoints) {\n\t\t\t\t\t\t\t\tobjects_by_type[ObjectType.POINTS].push(object);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\tfor (let type of Object.keys(objects_by_type) as ObjectTypes) {\n\t\t\tconst objects = objects_by_type[type];\n\n\t\t\tconst geometries = [];\n\t\t\tfor (let object of objects) {\n\t\t\t\tconst geometry = object.geometry;\n\t\t\t\tgeometry.applyMatrix4(object.matrix);\n\t\t\t\tgeometries.push(geometry);\n\t\t\t}\n\n\t\t\t// TODO: test that this works with geometries with same attributes\n\t\t\tconst merged_geometry = CoreGeometry.merge_geometries(geometries);\n\t\t\tif (merged_geometry) {\n\t\t\t\tconst object = this.create_object(merged_geometry, type);\n\t\t\t\tmerged_objects.push(object);\n\t\t\t}\n\n\t\t\t// objects.forEach( object=> {\n\t\t\t// \tif (object.parent != null) {\n\t\t\t// \t\tobject.parent.remove(object);\n\t\t\t// \t}\n\t\t\t// \tif (object.geometry != null) {\n\t\t\t// \t\tobject.geometry.dispose();\n\t\t\t// \t}\n\t\t\t// \t(object.material != null ? object.material.dispose() : undefined);\n\t\t\t// });\n\t\t}\n\t\treturn merged_objects;\n\t}\n}\n\n// _add_missing_attributes: (geo0, geo1)->\n// \tgeo0_attribute_names = lodash_keys(geo0.attributes)\n// \tgeo1_attribute_names = lodash_keys(geo1.attributes)\n\n// \tattributes_not_in_geo0 = lodash_difference(geo1_attribute_names, geo0_attribute_names)\n// \tattributes_not_in_geo1 = lodash_difference(geo0_attribute_names, geo1_attribute_names)\n\n// \tlodash_each attributes_not_in_geo0, (attribute_not_in_geo0)=>\n// \t\tthis._add_attribute(geo0, attribute_not_in_geo0, geo1.attributes[attribute_not_in_geo0])\n// \tlodash_each attributes_not_in_geo1, (attribute_not_in_geo1)=>\n// \t\tthis._add_attribute(geo1, attribute_not_in_geo1, geo0.attributes[attribute_not_in_geo1])\n\n// _add_attribute: (geo, attrib_name, attribute_template)->\n\n// \titem_size = attribute_template['itemSize']\n// \tnormalized = attribute_template['normalized']\n// \tpoints_count = geo.getAttribute('position').array.length / 3\n\n// \traw_values = []\n// \tlodash_times points_count, (i)->\n// \t\tlodash_times item_size, (j)->\n// \t\t\traw_values.push(0)\n\n// \tvalues = new Float32Array(raw_values)\n// \tgeo.setAttribute( attrib_name, new BufferAttribute( values, item_size, normalized) )\n","import {Vector3} from 'three/src/math/Vector3';\nimport {Vector2} from 'three/src/math/Vector2';\nimport {TypedSopNode} from './_Base';\nimport {CoreGroup} from '../../../core/geometry/Group';\nimport {CorePoint} from '../../../core/geometry/Point';\nimport {CoreMath} from '../../../core/math/_Module';\nimport {InputCloneMode} from '../../poly/InputCloneMode';\nimport {TypeAssert} from '../../poly/Assert';\nimport {BufferAttribute} from 'three/src/core/BufferAttribute';\nimport {SimplexNoise} from '../../../../modules/three/examples/jsm/math/SimplexNoise';\n\nenum Operation {\n\tADD = 'add',\n\tSET = 'set',\n\tMULT = 'mult',\n\tSUBSTRACT = 'substract',\n\tDIVIDE = 'divide',\n}\ntype Operations = Array<Operation>;\nconst Operations: Operations = [Operation.ADD, Operation.SET, Operation.MULT, Operation.SUBSTRACT, Operation.DIVIDE];\n\n// const COMPONENT_OFFSETS = [\n// \tnew Vector3(545, 125454, 2142),\n// \tnew Vector3(425, 25746, 95242),\n// \tnew Vector3(765132, 21, 9245),\n// ]\n\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nclass NoiseSopParamsConfig extends NodeParamsConfig {\n\tamount = ParamConfig.FLOAT(1);\n\tfreq = ParamConfig.VECTOR3([1, 1, 1]);\n\toffset = ParamConfig.VECTOR3([0, 0, 0]);\n\toctaves = ParamConfig.INTEGER(3, {\n\t\trange: [1, 8],\n\t\trange_locked: [true, false],\n\t});\n\tamp_attenuation = ParamConfig.FLOAT(0.5, {range: [0, 1]});\n\tfreq_increase = ParamConfig.FLOAT(2, {range: [0, 10]});\n\tseed = ParamConfig.INTEGER(0, {range: [0, 100]});\n\tseparator = ParamConfig.SEPARATOR();\n\tuse_normals = ParamConfig.BOOLEAN(0);\n\tattrib_name = ParamConfig.STRING('position');\n\toperation = ParamConfig.INTEGER(Operations.indexOf(Operation.ADD), {\n\t\tmenu: {\n\t\t\tentries: Operations.map((operation) => {\n\t\t\t\treturn {\n\t\t\t\t\tname: operation,\n\t\t\t\t\tvalue: Operations.indexOf(operation),\n\t\t\t\t};\n\t\t\t}),\n\t\t},\n\t});\n\tcompute_normals = ParamConfig.BOOLEAN(1);\n}\nconst ParamsConfig = new NoiseSopParamsConfig();\n\nexport class NoiseSopNode extends TypedSopNode<NoiseSopParamsConfig> {\n\tparams_config = ParamsConfig;\n\tstatic type() {\n\t\treturn 'noise';\n\t}\n\n\t// _param_amount: number;\n\t// _param_offset: Vector3;\n\t// _param_freq: Vector3;\n\t// _param_seed: number;\n\t// _param_use_normals: boolean;\n\t// _param_attrib_name: string;\n\t// _param_operation: number;\n\t// _param_compute_normals: boolean;\n\n\tprivate _simplex_by_seed: Map<number, SimplexNoise> = new Map();\n\n\tprivate _rest_core_group_timestamp: number | undefined;\n\tprivate _rest_points: CorePoint[] = [];\n\n\tstatic displayed_input_names(): string[] {\n\t\treturn ['geometry to add noise to', 'rest geometry'];\n\t}\n\tinitialize_node() {\n\t\tthis.io.inputs.set_count(1, 2);\n\t\tthis.io.inputs.init_inputs_clonable_state([InputCloneMode.FROM_NODE, InputCloneMode.NEVER]);\n\t}\n\n\tasync cook(input_contents: CoreGroup[]) {\n\t\tconst core_group = input_contents[0];\n\t\tconst core_group_rest = input_contents[1];\n\n\t\tconst dest_points = core_group.points();\n\t\tif (core_group_rest) {\n\t\t\tif (\n\t\t\t\tthis._rest_core_group_timestamp == null ||\n\t\t\t\tthis._rest_core_group_timestamp != core_group_rest.timestamp()\n\t\t\t) {\n\t\t\t\tthis._rest_points = core_group_rest.points();\n\t\t\t\tthis._rest_core_group_timestamp = core_group_rest.timestamp();\n\t\t\t}\n\t\t}\n\n\t\t// const {SimplexNoise} = await import(`three/examples/jsm/math/SimplexNoise`)\n\t\tconst simplex = this._get_simplex();\n\n\t\tconst use_normals = this.pv.use_normals && core_group.has_attrib('normal');\n\t\tconst target_attrib_size = core_group.attrib_size(this.pv.attrib_name);\n\n\t\tfor (let i = 0; i < dest_points.length; i++) {\n\t\t\tconst dest_point = dest_points[i];\n\t\t\tlet rest_point = core_group_rest ? this._rest_points[i] : dest_point;\n\t\t\tconst current_attrib_value = rest_point.attrib_value(this.pv.attrib_name);\n\t\t\tconst pos = rest_point\n\t\t\t\t.position()\n\t\t\t\t.add(this.pv.offset)\n\t\t\t\t.multiply(this.pv.freq);\n\n\t\t\tlet noise_value = (() => {\n\t\t\t\tif (use_normals) {\n\t\t\t\t\tconst normal = rest_point.attrib_value('normal');\n\t\t\t\t\tconst noise = this.pv.amount * this._fbm(simplex, pos.x, pos.y, pos.z);\n\t\t\t\t\treturn normal.clone().multiplyScalar(noise);\n\t\t\t\t\t//vertex.add(noise_vector)\n\t\t\t\t} else {\n\t\t\t\t\treturn new Vector3(\n\t\t\t\t\t\tthis.pv.amount * this._fbm(simplex, pos.x + 545, pos.y + 125454, pos.z + 2142),\n\t\t\t\t\t\tthis.pv.amount * this._fbm(simplex, pos.x - 425, pos.y - 25746, pos.z + 95242),\n\t\t\t\t\t\tthis.pv.amount * this._fbm(simplex, pos.x + 765132, pos.y + 21, pos.z - 9245)\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t})();\n\n\t\t\tnoise_value = (() => {\n\t\t\t\tswitch (target_attrib_size) {\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\treturn noise_value.x;\n\t\t\t\t\tcase 2:\n\t\t\t\t\t\treturn new Vector2(noise_value.x, noise_value.y);\n\t\t\t\t\tcase 3:\n\t\t\t\t\t\treturn noise_value;\n\t\t\t\t}\n\t\t\t})();\n\n\t\t\tconst new_attrib_value = (() => {\n\t\t\t\tconst operation = Operations[this.pv.operation];\n\t\t\t\tswitch (target_attrib_size) {\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\tswitch (operation) {\n\t\t\t\t\t\t\tcase Operation.ADD:\n\t\t\t\t\t\t\t\treturn current_attrib_value + noise_value;\n\t\t\t\t\t\t\tcase Operation.SET:\n\t\t\t\t\t\t\t\treturn noise_value;\n\t\t\t\t\t\t\tcase Operation.MULT:\n\t\t\t\t\t\t\t\treturn current_attrib_value * noise_value;\n\t\t\t\t\t\t\tcase Operation.DIVIDE:\n\t\t\t\t\t\t\t\treturn current_attrib_value / noise_value;\n\t\t\t\t\t\t\tcase Operation.SUBSTRACT:\n\t\t\t\t\t\t\t\treturn current_attrib_value - noise_value;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tTypeAssert.unreachable(operation);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tswitch (operation) {\n\t\t\t\t\t\t\tcase Operation.ADD:\n\t\t\t\t\t\t\t\treturn current_attrib_value.add(noise_value);\n\t\t\t\t\t\t\tcase Operation.SET:\n\t\t\t\t\t\t\t\treturn noise_value;\n\t\t\t\t\t\t\tcase Operation.MULT:\n\t\t\t\t\t\t\t\treturn current_attrib_value.multiply(noise_value);\n\t\t\t\t\t\t\tcase Operation.DIVIDE:\n\t\t\t\t\t\t\t\treturn current_attrib_value.divide(noise_value);\n\t\t\t\t\t\t\tcase Operation.SUBSTRACT:\n\t\t\t\t\t\t\t\treturn current_attrib_value.sub(noise_value);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tTypeAssert.unreachable(operation);\n\t\t\t\t}\n\t\t\t})();\n\n\t\t\tdest_point.set_attrib_value(this.pv.attrib_name, new_attrib_value);\n\t\t}\n\n\t\tif (!this.io.inputs.input_cloned(0)) {\n\t\t\tfor (let geometry of core_group.geometries()) {\n\t\t\t\t(geometry.getAttribute(this.pv.attrib_name) as BufferAttribute).needsUpdate = true;\n\t\t\t}\n\t\t}\n\n\t\tif (this.pv.compute_normals) {\n\t\t\tcore_group.compute_vertex_normals();\n\t\t}\n\t\tthis.set_core_group(core_group);\n\t}\n\n\tprivate _fbm(simplex: SimplexNoise, x: number, y: number, z: number): number {\n\t\tlet value = 0.0;\n\t\tlet amplitude = 1.0;\n\t\tfor (let i = 0; i < this.pv.octaves; i++) {\n\t\t\tvalue += amplitude * simplex.noise3d(x, y, z);\n\t\t\tx *= this.pv.freq_increase;\n\t\t\ty *= this.pv.freq_increase;\n\t\t\tz *= this.pv.freq_increase;\n\t\t\tamplitude *= this.pv.amp_attenuation;\n\t\t}\n\t\treturn value;\n\t}\n\n\tprivate _get_simplex(): SimplexNoise {\n\t\tconst simplex = this._simplex_by_seed.get(this.pv.seed);\n\t\tif (simplex) {\n\t\t\treturn simplex;\n\t\t} else {\n\t\t\tconst simplex = this._create_simplex();\n\t\t\tthis._simplex_by_seed.set(this.pv.seed, simplex);\n\t\t\treturn simplex;\n\t\t}\n\t}\n\tprivate _create_simplex(): SimplexNoise {\n\t\tconst seed = this.pv.seed;\n\t\tconst random_generator = {\n\t\t\trandom: function() {\n\t\t\t\treturn CoreMath.rand_float(seed);\n\t\t\t},\n\t\t};\n\t\tconst simplex = new SimplexNoise(random_generator);\n\t\t// for (let key of Object.keys(this._simplex_by_seed)) {\n\t\tthis._simplex_by_seed.delete(seed);\n\t\t// }\n\t\treturn simplex;\n\t}\n}\n","// Ported from Stefan Gustavson's java implementation\n// http://staffwww.itn.liu.se/~stegu/simplexnoise/simplexnoise.pdf\n// Read Stefan's excellent paper for details on how this code works.\n//\n// Sean McCullough banksean@gmail.com\n//\n// Added 4D noise\n// Joshua Koo zz85nus@gmail.com\n\n/**\n * You can pass in a random number generator object if you like.\n * It is assumed to have a random() method.\n */\nvar SimplexNoise = function ( r ) {\n\n\tif ( r == undefined ) r = Math;\n\tthis.grad3 = [[ 1, 1, 0 ], [ - 1, 1, 0 ], [ 1, - 1, 0 ], [ - 1, - 1, 0 ],\n\t\t[ 1, 0, 1 ], [ - 1, 0, 1 ], [ 1, 0, - 1 ], [ - 1, 0, - 1 ],\n\t\t[ 0, 1, 1 ], [ 0, - 1, 1 ], [ 0, 1, - 1 ], [ 0, - 1, - 1 ]];\n\n\tthis.grad4 = [[ 0, 1, 1, 1 ], [ 0, 1, 1, - 1 ], [ 0, 1, - 1, 1 ], [ 0, 1, - 1, - 1 ],\n\t     [ 0, - 1, 1, 1 ], [ 0, - 1, 1, - 1 ], [ 0, - 1, - 1, 1 ], [ 0, - 1, - 1, - 1 ],\n\t     [ 1, 0, 1, 1 ], [ 1, 0, 1, - 1 ], [ 1, 0, - 1, 1 ], [ 1, 0, - 1, - 1 ],\n\t     [ - 1, 0, 1, 1 ], [ - 1, 0, 1, - 1 ], [ - 1, 0, - 1, 1 ], [ - 1, 0, - 1, - 1 ],\n\t     [ 1, 1, 0, 1 ], [ 1, 1, 0, - 1 ], [ 1, - 1, 0, 1 ], [ 1, - 1, 0, - 1 ],\n\t     [ - 1, 1, 0, 1 ], [ - 1, 1, 0, - 1 ], [ - 1, - 1, 0, 1 ], [ - 1, - 1, 0, - 1 ],\n\t     [ 1, 1, 1, 0 ], [ 1, 1, - 1, 0 ], [ 1, - 1, 1, 0 ], [ 1, - 1, - 1, 0 ],\n\t     [ - 1, 1, 1, 0 ], [ - 1, 1, - 1, 0 ], [ - 1, - 1, 1, 0 ], [ - 1, - 1, - 1, 0 ]];\n\n\tthis.p = [];\n\tfor ( var i = 0; i < 256; i ++ ) {\n\n\t\tthis.p[ i ] = Math.floor( r.random() * 256 );\n\n\t}\n\t// To remove the need for index wrapping, double the permutation table length\n\tthis.perm = [];\n\tfor ( var i = 0; i < 512; i ++ ) {\n\n\t\tthis.perm[ i ] = this.p[ i & 255 ];\n\n\t}\n\n\t// A lookup table to traverse the simplex around a given point in 4D.\n\t// Details can be found where this table is used, in the 4D noise method.\n\tthis.simplex = [\n\t\t[ 0, 1, 2, 3 ], [ 0, 1, 3, 2 ], [ 0, 0, 0, 0 ], [ 0, 2, 3, 1 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ], [ 1, 2, 3, 0 ],\n\t\t[ 0, 2, 1, 3 ], [ 0, 0, 0, 0 ], [ 0, 3, 1, 2 ], [ 0, 3, 2, 1 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ], [ 1, 3, 2, 0 ],\n\t\t[ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ],\n\t\t[ 1, 2, 0, 3 ], [ 0, 0, 0, 0 ], [ 1, 3, 0, 2 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ], [ 2, 3, 0, 1 ], [ 2, 3, 1, 0 ],\n\t\t[ 1, 0, 2, 3 ], [ 1, 0, 3, 2 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ], [ 2, 0, 3, 1 ], [ 0, 0, 0, 0 ], [ 2, 1, 3, 0 ],\n\t\t[ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ],\n\t\t[ 2, 0, 1, 3 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ], [ 3, 0, 1, 2 ], [ 3, 0, 2, 1 ], [ 0, 0, 0, 0 ], [ 3, 1, 2, 0 ],\n\t\t[ 2, 1, 0, 3 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ], [ 3, 1, 0, 2 ], [ 0, 0, 0, 0 ], [ 3, 2, 0, 1 ], [ 3, 2, 1, 0 ]];\n\n};\n\nSimplexNoise.prototype.dot = function ( g, x, y ) {\n\n\treturn g[ 0 ] * x + g[ 1 ] * y;\n\n};\n\nSimplexNoise.prototype.dot3 = function ( g, x, y, z ) {\n\n\treturn g[ 0 ] * x + g[ 1 ] * y + g[ 2 ] * z;\n\n};\n\nSimplexNoise.prototype.dot4 = function ( g, x, y, z, w ) {\n\n\treturn g[ 0 ] * x + g[ 1 ] * y + g[ 2 ] * z + g[ 3 ] * w;\n\n};\n\nSimplexNoise.prototype.noise = function ( xin, yin ) {\n\n\tvar n0, n1, n2; // Noise contributions from the three corners\n\t// Skew the input space to determine which simplex cell we're in\n\tvar F2 = 0.5 * ( Math.sqrt( 3.0 ) - 1.0 );\n\tvar s = ( xin + yin ) * F2; // Hairy factor for 2D\n\tvar i = Math.floor( xin + s );\n\tvar j = Math.floor( yin + s );\n\tvar G2 = ( 3.0 - Math.sqrt( 3.0 ) ) / 6.0;\n\tvar t = ( i + j ) * G2;\n\tvar X0 = i - t; // Unskew the cell origin back to (x,y) space\n\tvar Y0 = j - t;\n\tvar x0 = xin - X0; // The x,y distances from the cell origin\n\tvar y0 = yin - Y0;\n\t// For the 2D case, the simplex shape is an equilateral triangle.\n\t// Determine which simplex we are in.\n\tvar i1, j1; // Offsets for second (middle) corner of simplex in (i,j) coords\n\tif ( x0 > y0 ) {\n\n\t\ti1 = 1; j1 = 0;\n\n\t\t// lower triangle, XY order: (0,0)->(1,0)->(1,1)\n\n\t}\telse {\n\n\t\ti1 = 0; j1 = 1;\n\n\t} // upper triangle, YX order: (0,0)->(0,1)->(1,1)\n\t// A step of (1,0) in (i,j) means a step of (1-c,-c) in (x,y), and\n\t// a step of (0,1) in (i,j) means a step of (-c,1-c) in (x,y), where\n\t// c = (3-sqrt(3))/6\n\tvar x1 = x0 - i1 + G2; // Offsets for middle corner in (x,y) unskewed coords\n\tvar y1 = y0 - j1 + G2;\n\tvar x2 = x0 - 1.0 + 2.0 * G2; // Offsets for last corner in (x,y) unskewed coords\n\tvar y2 = y0 - 1.0 + 2.0 * G2;\n\t// Work out the hashed gradient indices of the three simplex corners\n\tvar ii = i & 255;\n\tvar jj = j & 255;\n\tvar gi0 = this.perm[ ii + this.perm[ jj ] ] % 12;\n\tvar gi1 = this.perm[ ii + i1 + this.perm[ jj + j1 ] ] % 12;\n\tvar gi2 = this.perm[ ii + 1 + this.perm[ jj + 1 ] ] % 12;\n\t// Calculate the contribution from the three corners\n\tvar t0 = 0.5 - x0 * x0 - y0 * y0;\n\tif ( t0 < 0 ) n0 = 0.0;\n\telse {\n\n\t\tt0 *= t0;\n\t\tn0 = t0 * t0 * this.dot( this.grad3[ gi0 ], x0, y0 ); // (x,y) of grad3 used for 2D gradient\n\n\t}\n\tvar t1 = 0.5 - x1 * x1 - y1 * y1;\n\tif ( t1 < 0 ) n1 = 0.0;\n\telse {\n\n\t\tt1 *= t1;\n\t\tn1 = t1 * t1 * this.dot( this.grad3[ gi1 ], x1, y1 );\n\n\t}\n\tvar t2 = 0.5 - x2 * x2 - y2 * y2;\n\tif ( t2 < 0 ) n2 = 0.0;\n\telse {\n\n\t\tt2 *= t2;\n\t\tn2 = t2 * t2 * this.dot( this.grad3[ gi2 ], x2, y2 );\n\n\t}\n\t// Add contributions from each corner to get the final noise value.\n\t// The result is scaled to return values in the interval [-1,1].\n\treturn 70.0 * ( n0 + n1 + n2 );\n\n};\n\n// 3D simplex noise\nSimplexNoise.prototype.noise3d = function ( xin, yin, zin ) {\n\n\tvar n0, n1, n2, n3; // Noise contributions from the four corners\n\t// Skew the input space to determine which simplex cell we're in\n\tvar F3 = 1.0 / 3.0;\n\tvar s = ( xin + yin + zin ) * F3; // Very nice and simple skew factor for 3D\n\tvar i = Math.floor( xin + s );\n\tvar j = Math.floor( yin + s );\n\tvar k = Math.floor( zin + s );\n\tvar G3 = 1.0 / 6.0; // Very nice and simple unskew factor, too\n\tvar t = ( i + j + k ) * G3;\n\tvar X0 = i - t; // Unskew the cell origin back to (x,y,z) space\n\tvar Y0 = j - t;\n\tvar Z0 = k - t;\n\tvar x0 = xin - X0; // The x,y,z distances from the cell origin\n\tvar y0 = yin - Y0;\n\tvar z0 = zin - Z0;\n\t// For the 3D case, the simplex shape is a slightly irregular tetrahedron.\n\t// Determine which simplex we are in.\n\tvar i1, j1, k1; // Offsets for second corner of simplex in (i,j,k) coords\n\tvar i2, j2, k2; // Offsets for third corner of simplex in (i,j,k) coords\n\tif ( x0 >= y0 ) {\n\n\t\tif ( y0 >= z0 ) {\n\n\t\t\ti1 = 1; j1 = 0; k1 = 0; i2 = 1; j2 = 1; k2 = 0;\n\n\t\t\t// X Y Z order\n\n\t\t} else if ( x0 >= z0 ) {\n\n\t\t\ti1 = 1; j1 = 0; k1 = 0; i2 = 1; j2 = 0; k2 = 1;\n\n\t\t\t// X Z Y order\n\n\t\t} else {\n\n\t\t\ti1 = 0; j1 = 0; k1 = 1; i2 = 1; j2 = 0; k2 = 1;\n\n\t\t} // Z X Y order\n\n\t} else { // x0<y0\n\n\t\tif ( y0 < z0 ) {\n\n\t\t\ti1 = 0; j1 = 0; k1 = 1; i2 = 0; j2 = 1; k2 = 1;\n\n\t\t\t// Z Y X order\n\n\t\t} else if ( x0 < z0 ) {\n\n\t\t\ti1 = 0; j1 = 1; k1 = 0; i2 = 0; j2 = 1; k2 = 1;\n\n\t\t\t// Y Z X order\n\n\t\t} else {\n\n\t\t\ti1 = 0; j1 = 1; k1 = 0; i2 = 1; j2 = 1; k2 = 0;\n\n\t\t} // Y X Z order\n\n\t}\n\t// A step of (1,0,0) in (i,j,k) means a step of (1-c,-c,-c) in (x,y,z),\n\t// a step of (0,1,0) in (i,j,k) means a step of (-c,1-c,-c) in (x,y,z), and\n\t// a step of (0,0,1) in (i,j,k) means a step of (-c,-c,1-c) in (x,y,z), where\n\t// c = 1/6.\n\tvar x1 = x0 - i1 + G3; // Offsets for second corner in (x,y,z) coords\n\tvar y1 = y0 - j1 + G3;\n\tvar z1 = z0 - k1 + G3;\n\tvar x2 = x0 - i2 + 2.0 * G3; // Offsets for third corner in (x,y,z) coords\n\tvar y2 = y0 - j2 + 2.0 * G3;\n\tvar z2 = z0 - k2 + 2.0 * G3;\n\tvar x3 = x0 - 1.0 + 3.0 * G3; // Offsets for last corner in (x,y,z) coords\n\tvar y3 = y0 - 1.0 + 3.0 * G3;\n\tvar z3 = z0 - 1.0 + 3.0 * G3;\n\t// Work out the hashed gradient indices of the four simplex corners\n\tvar ii = i & 255;\n\tvar jj = j & 255;\n\tvar kk = k & 255;\n\tvar gi0 = this.perm[ ii + this.perm[ jj + this.perm[ kk ] ] ] % 12;\n\tvar gi1 = this.perm[ ii + i1 + this.perm[ jj + j1 + this.perm[ kk + k1 ] ] ] % 12;\n\tvar gi2 = this.perm[ ii + i2 + this.perm[ jj + j2 + this.perm[ kk + k2 ] ] ] % 12;\n\tvar gi3 = this.perm[ ii + 1 + this.perm[ jj + 1 + this.perm[ kk + 1 ] ] ] % 12;\n\t// Calculate the contribution from the four corners\n\tvar t0 = 0.6 - x0 * x0 - y0 * y0 - z0 * z0;\n\tif ( t0 < 0 ) n0 = 0.0;\n\telse {\n\n\t\tt0 *= t0;\n\t\tn0 = t0 * t0 * this.dot3( this.grad3[ gi0 ], x0, y0, z0 );\n\n\t}\n\tvar t1 = 0.6 - x1 * x1 - y1 * y1 - z1 * z1;\n\tif ( t1 < 0 ) n1 = 0.0;\n\telse {\n\n\t\tt1 *= t1;\n\t\tn1 = t1 * t1 * this.dot3( this.grad3[ gi1 ], x1, y1, z1 );\n\n\t}\n\tvar t2 = 0.6 - x2 * x2 - y2 * y2 - z2 * z2;\n\tif ( t2 < 0 ) n2 = 0.0;\n\telse {\n\n\t\tt2 *= t2;\n\t\tn2 = t2 * t2 * this.dot3( this.grad3[ gi2 ], x2, y2, z2 );\n\n\t}\n\tvar t3 = 0.6 - x3 * x3 - y3 * y3 - z3 * z3;\n\tif ( t3 < 0 ) n3 = 0.0;\n\telse {\n\n\t\tt3 *= t3;\n\t\tn3 = t3 * t3 * this.dot3( this.grad3[ gi3 ], x3, y3, z3 );\n\n\t}\n\t// Add contributions from each corner to get the final noise value.\n\t// The result is scaled to stay just inside [-1,1]\n\treturn 32.0 * ( n0 + n1 + n2 + n3 );\n\n};\n\n// 4D simplex noise\nSimplexNoise.prototype.noise4d = function ( x, y, z, w ) {\n\n\t// For faster and easier lookups\n\tvar grad4 = this.grad4;\n\tvar simplex = this.simplex;\n\tvar perm = this.perm;\n\n\t// The skewing and unskewing factors are hairy again for the 4D case\n\tvar F4 = ( Math.sqrt( 5.0 ) - 1.0 ) / 4.0;\n\tvar G4 = ( 5.0 - Math.sqrt( 5.0 ) ) / 20.0;\n\tvar n0, n1, n2, n3, n4; // Noise contributions from the five corners\n\t// Skew the (x,y,z,w) space to determine which cell of 24 simplices we're in\n\tvar s = ( x + y + z + w ) * F4; // Factor for 4D skewing\n\tvar i = Math.floor( x + s );\n\tvar j = Math.floor( y + s );\n\tvar k = Math.floor( z + s );\n\tvar l = Math.floor( w + s );\n\tvar t = ( i + j + k + l ) * G4; // Factor for 4D unskewing\n\tvar X0 = i - t; // Unskew the cell origin back to (x,y,z,w) space\n\tvar Y0 = j - t;\n\tvar Z0 = k - t;\n\tvar W0 = l - t;\n\tvar x0 = x - X0; // The x,y,z,w distances from the cell origin\n\tvar y0 = y - Y0;\n\tvar z0 = z - Z0;\n\tvar w0 = w - W0;\n\n\t// For the 4D case, the simplex is a 4D shape I won't even try to describe.\n\t// To find out which of the 24 possible simplices we're in, we need to\n\t// determine the magnitude ordering of x0, y0, z0 and w0.\n\t// The method below is a good way of finding the ordering of x,y,z,w and\n\t// then find the correct traversal order for the simplex were in.\n\t// First, six pair-wise comparisons are performed between each possible pair\n\t// of the four coordinates, and the results are used to add up binary bits\n\t// for an integer index.\n\tvar c1 = ( x0 > y0 ) ? 32 : 0;\n\tvar c2 = ( x0 > z0 ) ? 16 : 0;\n\tvar c3 = ( y0 > z0 ) ? 8 : 0;\n\tvar c4 = ( x0 > w0 ) ? 4 : 0;\n\tvar c5 = ( y0 > w0 ) ? 2 : 0;\n\tvar c6 = ( z0 > w0 ) ? 1 : 0;\n\tvar c = c1 + c2 + c3 + c4 + c5 + c6;\n\tvar i1, j1, k1, l1; // The integer offsets for the second simplex corner\n\tvar i2, j2, k2, l2; // The integer offsets for the third simplex corner\n\tvar i3, j3, k3, l3; // The integer offsets for the fourth simplex corner\n\t// simplex[c] is a 4-vector with the numbers 0, 1, 2 and 3 in some order.\n\t// Many values of c will never occur, since e.g. x>y>z>w makes x<z, y<w and x<w\n\t// impossible. Only the 24 indices which have non-zero entries make any sense.\n\t// We use a thresholding to set the coordinates in turn from the largest magnitude.\n\t// The number 3 in the \"simplex\" array is at the position of the largest coordinate.\n\ti1 = simplex[ c ][ 0 ] >= 3 ? 1 : 0;\n\tj1 = simplex[ c ][ 1 ] >= 3 ? 1 : 0;\n\tk1 = simplex[ c ][ 2 ] >= 3 ? 1 : 0;\n\tl1 = simplex[ c ][ 3 ] >= 3 ? 1 : 0;\n\t// The number 2 in the \"simplex\" array is at the second largest coordinate.\n\ti2 = simplex[ c ][ 0 ] >= 2 ? 1 : 0;\n\tj2 = simplex[ c ][ 1 ] >= 2 ? 1 : 0; k2 = simplex[ c ][ 2 ] >= 2 ? 1 : 0;\n\tl2 = simplex[ c ][ 3 ] >= 2 ? 1 : 0;\n\t// The number 1 in the \"simplex\" array is at the second smallest coordinate.\n\ti3 = simplex[ c ][ 0 ] >= 1 ? 1 : 0;\n\tj3 = simplex[ c ][ 1 ] >= 1 ? 1 : 0;\n\tk3 = simplex[ c ][ 2 ] >= 1 ? 1 : 0;\n\tl3 = simplex[ c ][ 3 ] >= 1 ? 1 : 0;\n\t// The fifth corner has all coordinate offsets = 1, so no need to look that up.\n\tvar x1 = x0 - i1 + G4; // Offsets for second corner in (x,y,z,w) coords\n\tvar y1 = y0 - j1 + G4;\n\tvar z1 = z0 - k1 + G4;\n\tvar w1 = w0 - l1 + G4;\n\tvar x2 = x0 - i2 + 2.0 * G4; // Offsets for third corner in (x,y,z,w) coords\n\tvar y2 = y0 - j2 + 2.0 * G4;\n\tvar z2 = z0 - k2 + 2.0 * G4;\n\tvar w2 = w0 - l2 + 2.0 * G4;\n\tvar x3 = x0 - i3 + 3.0 * G4; // Offsets for fourth corner in (x,y,z,w) coords\n\tvar y3 = y0 - j3 + 3.0 * G4;\n\tvar z3 = z0 - k3 + 3.0 * G4;\n\tvar w3 = w0 - l3 + 3.0 * G4;\n\tvar x4 = x0 - 1.0 + 4.0 * G4; // Offsets for last corner in (x,y,z,w) coords\n\tvar y4 = y0 - 1.0 + 4.0 * G4;\n\tvar z4 = z0 - 1.0 + 4.0 * G4;\n\tvar w4 = w0 - 1.0 + 4.0 * G4;\n\t// Work out the hashed gradient indices of the five simplex corners\n\tvar ii = i & 255;\n\tvar jj = j & 255;\n\tvar kk = k & 255;\n\tvar ll = l & 255;\n\tvar gi0 = perm[ ii + perm[ jj + perm[ kk + perm[ ll ] ] ] ] % 32;\n\tvar gi1 = perm[ ii + i1 + perm[ jj + j1 + perm[ kk + k1 + perm[ ll + l1 ] ] ] ] % 32;\n\tvar gi2 = perm[ ii + i2 + perm[ jj + j2 + perm[ kk + k2 + perm[ ll + l2 ] ] ] ] % 32;\n\tvar gi3 = perm[ ii + i3 + perm[ jj + j3 + perm[ kk + k3 + perm[ ll + l3 ] ] ] ] % 32;\n\tvar gi4 = perm[ ii + 1 + perm[ jj + 1 + perm[ kk + 1 + perm[ ll + 1 ] ] ] ] % 32;\n\t// Calculate the contribution from the five corners\n\tvar t0 = 0.6 - x0 * x0 - y0 * y0 - z0 * z0 - w0 * w0;\n\tif ( t0 < 0 ) n0 = 0.0;\n\telse {\n\n\t\tt0 *= t0;\n\t\tn0 = t0 * t0 * this.dot4( grad4[ gi0 ], x0, y0, z0, w0 );\n\n\t}\n\tvar t1 = 0.6 - x1 * x1 - y1 * y1 - z1 * z1 - w1 * w1;\n\tif ( t1 < 0 ) n1 = 0.0;\n\telse {\n\n\t\tt1 *= t1;\n\t\tn1 = t1 * t1 * this.dot4( grad4[ gi1 ], x1, y1, z1, w1 );\n\n\t}\n\tvar t2 = 0.6 - x2 * x2 - y2 * y2 - z2 * z2 - w2 * w2;\n\tif ( t2 < 0 ) n2 = 0.0;\n\telse {\n\n\t\tt2 *= t2;\n\t\tn2 = t2 * t2 * this.dot4( grad4[ gi2 ], x2, y2, z2, w2 );\n\n\t} var t3 = 0.6 - x3 * x3 - y3 * y3 - z3 * z3 - w3 * w3;\n\tif ( t3 < 0 ) n3 = 0.0;\n\telse {\n\n\t\tt3 *= t3;\n\t\tn3 = t3 * t3 * this.dot4( grad4[ gi3 ], x3, y3, z3, w3 );\n\n\t}\n\tvar t4 = 0.6 - x4 * x4 - y4 * y4 - z4 * z4 - w4 * w4;\n\tif ( t4 < 0 ) n4 = 0.0;\n\telse {\n\n\t\tt4 *= t4;\n\t\tn4 = t4 * t4 * this.dot4( grad4[ gi4 ], x4, y4, z4, w4 );\n\n\t}\n\t// Sum up and scale the result to cover the range [-1,1]\n\treturn 27.0 * ( n0 + n1 + n2 + n3 + n4 );\n\n};\n\nexport { SimplexNoise };\n","// import {Vector3} from 'three/src/math/Vector3';\nimport {TypedSopNode} from './_Base';\nimport {CoreGroup} from '../../../core/geometry/Group';\n// import {CoreGeometry} from '../../../core/geometry/Geometry';\nimport {InputCloneMode} from '../../poly/InputCloneMode';\nimport {CoreObject} from '../../../core/geometry/Object';\nimport {Mesh} from 'three/src/objects/Mesh';\nimport {BufferGeometry} from 'three/src/core/BufferGeometry';\n\n// const DEFAULT_NORMAL = new Vector3(0, 0, 1);\nconst NORMAL_ATTRIB_NAME = 'normal';\n\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nclass NormalsSopParamsConfig extends NodeParamsConfig {\n\tedit = ParamConfig.BOOLEAN(0);\n\tupdate_x = ParamConfig.BOOLEAN(0, {\n\t\tvisible_if: {edit: 1},\n\t});\n\tx = ParamConfig.FLOAT('@N.x', {\n\t\tvisible_if: {update_x: 1, edit: 1},\n\t\texpression: {for_entities: true},\n\t});\n\tupdate_y = ParamConfig.BOOLEAN(0, {\n\t\tvisible_if: {edit: 1},\n\t});\n\ty = ParamConfig.FLOAT('@N.y', {\n\t\tvisible_if: {update_y: 1, edit: 1},\n\t\texpression: {for_entities: true},\n\t});\n\tupdate_z = ParamConfig.BOOLEAN(0, {\n\t\tvisible_if: {edit: 1},\n\t});\n\tz = ParamConfig.FLOAT('@N.z', {\n\t\tvisible_if: {update_z: 1, edit: 1},\n\t\texpression: {for_entities: true},\n\t});\n\n\trecompute = ParamConfig.BOOLEAN(0, {\n\t\tvisible_if: {edit: 0},\n\t});\n\tinvert = ParamConfig.BOOLEAN(0);\n}\nconst ParamsConfig = new NormalsSopParamsConfig();\n\nexport class NormalsSopNode extends TypedSopNode<NormalsSopParamsConfig> {\n\tparams_config = ParamsConfig;\n\tstatic type() {\n\t\treturn 'normals';\n\t}\n\n\tstatic displayed_input_names(): string[] {\n\t\treturn ['geometry to update normals of'];\n\t}\n\tinitialize_node() {\n\t\tthis.io.inputs.set_count(1);\n\t\tthis.io.inputs.init_inputs_clonable_state([InputCloneMode.FROM_NODE]);\n\t}\n\n\tasync cook(input_contents: CoreGroup[]) {\n\t\tconst core_group = input_contents[0];\n\n\t\tif (this.pv.edit) {\n\t\t\tawait this._eval_expressions_for_core_group(core_group);\n\t\t} else {\n\t\t\tcore_group.compute_vertex_normals();\n\t\t}\n\t\tif (this.pv.invert) {\n\t\t\tthis._invert_normals(core_group);\n\t\t}\n\n\t\t// add attr if not present\n\t\t// for(let object of core_group.objects()){\n\t\t// \tlet geometry;\n\t\t// \tif ((geometry = object.geometry) != null) {\n\t\t// \t\tif(!geometry.getAttribute('normal')){\n\t\t// \t\t\tconst position_values = geometry.attributes['position'].array;\n\t\t// \t\t\tconst normal_values = [];\n\t\t// \t\t\tposition_values.forEach(p=> normal_values.push(0));\n\t\t// \t\t\tgeometry.setAttribute('normal', new Float32BufferAttribute(normal_values, 3));\n\t\t// \t\t}\n\t\t// \t}\n\t\t// }\n\n\t\t// if (this.pv.edit) {\n\t\t// \tthis._eval_expressions(core_group);\n\t\t// } else {\n\t\t// \tif(this.pv.recompute){\n\t\t// \t\tcore_group.compute_vertex_normals()\n\t\t// \t}\n\t\t// }\n\n\t\t// for(let object of core_group.objects()){\n\t\t// \tlet geometry;\n\t\t// \tif ((geometry = object.geometry) != null) {\n\n\t\t// \t\tif (this.pv.invert) {\n\t\t// \t\t\tthis._invert_normals(geometry);\n\t\t// \t\t}\n\n\t\t// \t\tif (!this.pv.edit) {\n\t\t// \t\t\tgeometry.computeVertexNormals();\n\t\t// \t\t}\n\t\t// \t}\n\t\t// }\n\n\t\tthis.set_core_group(core_group);\n\t}\n\n\tprivate async _eval_expressions_for_core_group(core_group: CoreGroup) {\n\t\t// const points = core_group.points();\n\n\t\t// const attrib_name = 'normal';\n\t\t// for(let point of points){\n\n\t\t// \tthis.context().set_entity(point);\n\n\t\t// \tthis.param(attrib_name).eval(val=> {\n\t\t// \t\tval.normalize();\n\t\t// \t\tpoint.set_attrib_value(attrib_name, val);\n\t\t// \t});\n\t\t// }\n\t\tconst core_objects = core_group.core_objects();\n\t\tfor (let i = 0; i < core_objects.length; i++) {\n\t\t\tawait this._eval_expressions_for_core_object(core_objects[i]);\n\t\t}\n\t}\n\tprivate async _eval_expressions_for_core_object(core_object: CoreObject) {\n\t\tconst object = core_object.object();\n\t\tconst geometry = (object as Mesh).geometry as BufferGeometry;\n\t\tconst points = core_object.points();\n\n\t\tconst array = geometry.getAttribute(NORMAL_ATTRIB_NAME).array as number[];\n\n\t\t// x\n\t\tif (this.pv.update_x) {\n\t\t\tif (this.p.x.has_expression() && this.p.x.expression_controller) {\n\t\t\t\tawait this.p.x.expression_controller.compute_expression_for_points(points, (point, value) => {\n\t\t\t\t\tarray[point.index * 3 + 0] = value;\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tlet point;\n\t\t\t\tfor (let i = 0; i < points.length; i++) {\n\t\t\t\t\tpoint = points[i];\n\t\t\t\t\tarray[point.index * 3 + 0] = this.pv.x;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// y\n\t\tif (this.pv.update_y) {\n\t\t\tif (this.p.y.has_expression() && this.p.y.expression_controller) {\n\t\t\t\tawait this.p.y.expression_controller.compute_expression_for_points(points, (point, value) => {\n\t\t\t\t\tarray[point.index * 3 + 1] = value;\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tlet point;\n\t\t\t\tfor (let i = 0; i < points.length; i++) {\n\t\t\t\t\tpoint = points[i];\n\t\t\t\t\tarray[point.index * 3 + 1] = this.pv.y;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// z\n\t\tif (this.pv.update_z) {\n\t\t\tif (this.p.z.has_expression() && this.p.z.expression_controller) {\n\t\t\t\tawait this.p.z.expression_controller.compute_expression_for_points(points, (point, value) => {\n\t\t\t\t\tarray[point.index * 3 + 2] = value;\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tlet point;\n\t\t\t\tfor (let i = 0; i < points.length; i++) {\n\t\t\t\t\tpoint = points[i];\n\t\t\t\t\tarray[point.index * 3 + 2] = this.pv.z;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// private _create_init_normal(core_geometry: CoreGeometry) {\n\t// \tif (!core_geometry.has_attrib(NORMAL_ATTRIB_NAME)) {\n\t// \t\tcore_geometry.add_numeric_attrib(NORMAL_ATTRIB_NAME, 3, DEFAULT_NORMAL);\n\t// \t}\n\t// }\n\n\tprivate _invert_normals(core_group: CoreGroup) {\n\t\t// this._create_init_normal();\n\n\t\tfor (let core_object of core_group.core_objects()) {\n\t\t\tconst geometry = core_object.core_geometry()?.geometry();\n\t\t\tif (geometry) {\n\t\t\t\tconst normal_attrib = geometry.attributes[NORMAL_ATTRIB_NAME];\n\t\t\t\tif (normal_attrib) {\n\t\t\t\t\tconst array = normal_attrib.array as number[];\n\t\t\t\t\tfor (let i = 0; i < array.length; i++) {\n\t\t\t\t\t\tarray[i] *= -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// let index_attrib;\n\t\t// if ((index_attrib = geometry.getIndex()) != null) {\n\t\t// \tconst { array } = index_attrib;\n\n\t\t// \tconst faces_count = array.length / 3;\n\t\t// \tfor(let i=0; i<faces_count; i++){\n\t\t// \t\tconst tmp = array[i*3];\n\t\t// \t\tarray[i*3] = array[(i*3)+2];\n\t\t// \t\tarray[(i*3)+2] = tmp;\n\t\t// \t}\n\n\t\t// } else {\n\t\t// \tconst geometry_wrapper = new CoreGeometry(geometry);\n\t\t// \tconst points = geometry_wrapper.points();\n\n\t\t// \tconst attrib_name = 'normal';\n\t\t// \tfor(let point of points){\n\t\t// \t\tconst normal = point.normal();\n\t\t// \t\tnormal.multiplyScalar(-1);\n\t\t// \t\tpoint.set_attrib_value(attrib_name, normal);\n\t\t// \t}\n\t\t// }\n\t}\n}\n","import {TypedSopNode} from './_Base';\n\nimport {NodeParamsConfig} from '../utils/params/ParamsConfig';\nimport {InputCloneMode} from '../../poly/InputCloneMode';\nimport {CoreGroup} from '../../../core/geometry/Group';\nclass NullSopParamsConfig extends NodeParamsConfig {}\nconst ParamsConfig = new NullSopParamsConfig();\n\nexport class NullSopNode extends TypedSopNode<NullSopParamsConfig> {\n\tparams_config = ParamsConfig;\n\tstatic type() {\n\t\treturn 'null';\n\t}\n\n\tinitialize_node() {\n\t\tthis.io.inputs.set_count(0, 1);\n\t\tthis.io.inputs.init_inputs_clonable_state([InputCloneMode.FROM_NODE]);\n\t\tthis.ui_data.set_border_radius(1000);\n\t}\n\n\tcook(input_contents: CoreGroup[]) {\n\t\tconst core_group = input_contents[0];\n\t\tif (core_group) {\n\t\t\tthis.set_core_group(core_group);\n\t\t} else {\n\t\t\tthis.set_objects([]);\n\t\t}\n\t}\n}\n","import {TypedSopNode, BaseSopNodeType} from './_Base';\nimport {NodeContext} from '../../poly/NodeContext';\n// import {CoreWalker} from '../../../Core/Walker';\n\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nimport {CoreGroup} from '../../../core/geometry/Group';\nimport {GeometryContainer} from '../../containers/Geometry';\nclass ObjectMergeSopParamsConfig extends NodeParamsConfig {\n\tgeometry = ParamConfig.OPERATOR_PATH('', {\n\t\tnode_selection: {\n\t\t\tcontext: NodeContext.SOP,\n\t\t},\n\t});\n}\nconst ParamsConfig = new ObjectMergeSopParamsConfig();\n\nexport class ObjectMergeSopNode extends TypedSopNode<ObjectMergeSopParamsConfig> {\n\tparams_config = ParamsConfig;\n\tstatic type() {\n\t\treturn 'object_merge';\n\t}\n\n\t// _param_apply_parent_transform: boolean\n\tinitialize_node() {}\n\n\tasync cook(input_containers: CoreGroup[]) {\n\t\tconst geometry_node = this.p.geometry.found_node();\n\t\tif (geometry_node) {\n\t\t\tif (geometry_node.node_context() == NodeContext.SOP) {\n\t\t\t\tconst container = await geometry_node.request_container();\n\t\t\t\tthis.import_input(geometry_node as BaseSopNodeType, container);\n\t\t\t} else {\n\t\t\t\tthis.states.error.set('found node is not a geometry');\n\t\t\t}\n\t\t} else {\n\t\t\tthis.states.error.set(`node not found at path '${this.pv.geometry}'`);\n\t\t}\n\t}\n\n\timport_input(geometry_node: BaseSopNodeType, container: GeometryContainer) {\n\t\tlet core_group;\n\t\t// I unfortunately need to do a clone here,\n\t\t// because if 2 objectmerge nodes import the same geometry,\n\t\t// they would try to place it under 2 different geo nodes\n\t\t// which is not possible\n\t\tif ((core_group = container.core_content_cloned()) != null) {\n\t\t\t// cannot do that until i know how to make it recook\n\t\t\t// when the obj changes\n\t\t\t// if (this._param_apply_parent_transform){\n\t\t\t// \tconst matrix = geometry_node.parent().object().matrixWorld\n\t\t\t// \tgroup.children.forEach(child=>{\n\t\t\t// \t\tconsole.log(child)\n\t\t\t// \t\tconst geometry = child.geometry\n\t\t\t// \t\tif(geometry){\n\t\t\t// \t\t\tgeometry.applyMatrix(matrix)\n\t\t\t// \t\t}\n\t\t\t// \t})\n\t\t\t// }\n\n\t\t\tthis.set_core_group(core_group);\n\t\t} else {\n\t\t\tthis.states.error.set('invalid target');\n\t\t}\n\t}\n\n\t// geometry_node() {\n\t// \tif ((this._param_geometry != null) && (this._param_geometry !== '')) {\n\t// \t\tCoreWalker.find_node(this, this._param_geometry);\n\t// \t}\n\t// }\n}\n","/// <reference path=\"./types/occlusion.d.ts\" />\n// https://github.com/wwwtyro/geo-ambient-occlusion\nimport geoao from 'geo-ambient-occlusion';\n\nimport {Float32BufferAttribute} from 'three/src/core/BufferAttribute';\nconst THREE = {Float32BufferAttribute};\nimport {TypedSopNode} from './_Base';\n\n// import {CoreGroup} from '../../../Core/Geometry/Group';\nimport {CoreObject} from '../../../core/geometry/Object';\n// import {CoreGeometry} from '../../../Core/Geometry/Geometry'\n// import {CorePoint} from '../../../Core/Geometry/Point'\n\nimport {InputCloneMode} from '../../poly/InputCloneMode';\nimport {CoreGroup} from '../../../core/geometry/Group';\n\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nclass OcclusionSopParamsConfig extends NodeParamsConfig {\n\tattrib_name = ParamConfig.STRING('occlusion');\n\tsamples = ParamConfig.INTEGER(256, {\n\t\trange: [1, 256],\n\t\trange_locked: [true, false],\n\t});\n\tsep = ParamConfig.SEPARATOR();\n\tbuffer_resolution = ParamConfig.INTEGER(512);\n\tbias = ParamConfig.FLOAT(0.01);\n}\nconst ParamsConfig = new OcclusionSopParamsConfig();\n\nexport class OcclusionSopNode extends TypedSopNode<OcclusionSopParamsConfig> {\n\tparams_config = ParamsConfig;\n\tstatic type() {\n\t\treturn 'occlusion';\n\t}\n\n\tinitialize_node() {\n\t\tthis.io.inputs.set_count(1);\n\t\tthis.io.inputs.init_inputs_clonable_state([InputCloneMode.FROM_NODE]);\n\t\t// this.ui_data.set_icon('palette');\n\t}\n\n\tasync cook(input_contents: CoreGroup[]) {\n\t\tconst core_group = input_contents[0];\n\t\tconst core_objects = core_group.core_objects();\n\n\t\tfor (let core_object of core_objects) {\n\t\t\tawait this._process_occlusion_on_object(core_object);\n\t\t}\n\n\t\tthis.set_core_group(core_group);\n\t}\n\n\tprivate async _process_occlusion_on_object(core_object: CoreObject) {\n\t\tconst geometry = core_object.core_geometry()?.geometry();\n\t\tif (!geometry) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst position_array = geometry.attributes.position.array;\n\t\tconst normal_array = geometry.attributes.normal.array;\n\t\tconst index_array = geometry.getIndex()?.array;\n\t\tconst aoSampler = geoao(position_array, {\n\t\t\tcells: index_array,\n\t\t\tnormals: normal_array,\n\t\t\tresolution: this.pv.buffer_resolution,\n\t\t\tbias: this.pv.bias,\n\t\t});\n\n\t\tfor (let i = 0; i < this.pv.samples; i++) {\n\t\t\taoSampler.sample();\n\t\t}\n\t\tconst ao = aoSampler.report();\n\n\t\tgeometry.setAttribute(this.pv.attrib_name, new THREE.Float32BufferAttribute(ao, 1));\n\n\t\taoSampler.dispose();\n\t}\n}\n","import {TextureVariable, TextureVariableData} from './TextureVariable';\nimport {BaseGlNodeType} from '../../_Base';\nimport {PolyScene} from '../../../../scene/PolyScene';\nimport {ShaderName} from '../../../utils/shaders/ShaderName';\n\nexport class TextureAllocation {\n\tprivate _variables: TextureVariable[] | undefined;\n\tprivate _size: number = 0;\n\n\tconstructor(private _shader_name: ShaderName) {}\n\n\tadd_variable(variable: TextureVariable) {\n\t\tthis._variables = this._variables || [];\n\t\tthis._variables.push(variable);\n\t\tvariable.set_position(this._size);\n\t\tvariable.set_allocation(this);\n\t\tthis._size += variable.size;\n\t}\n\n\thas_space_for_variable(variable: TextureVariable): boolean {\n\t\treturn this._size + variable.size <= 4;\n\t}\n\tget shader_name() {\n\t\treturn this._shader_name; //this._variables[0].name()\n\t}\n\tget texture_name(): string {\n\t\treturn `texture_${this._shader_name}`;\n\t}\n\n\tget variables(): TextureVariable[] | undefined {\n\t\treturn this._variables;\n\t}\n\tvariables_for_input_node(root_node: BaseGlNodeType): TextureVariable[] | undefined {\n\t\treturn this._variables?.filter((variable) => variable.graph_node_ids?.has(root_node.graph_node_id) || false);\n\t}\n\tinput_names_for_node(root_node: BaseGlNodeType): string[] | undefined {\n\t\treturn this.variables_for_input_node(root_node)?.map((v) => v.name);\n\t}\n\t// find_variable_with_node(root_node: BaseNodeGl, input_name: string): TextureVariable{\n\t// \treturn this.variables_for_input_node(root_node).filter(v=>v.name() == input_name)[0]\n\t// }\n\t// find_variable_without_node(input_name: string): TextureVariable{\n\t// \treturn this._variables.filter(v=>v.name() == input_name)[0]\n\t// }\n\tvariable(variable_name: string) {\n\t\tif (this._variables) {\n\t\t\tfor (let variable of this._variables) {\n\t\t\t\tif (variable.name == variable_name) {\n\t\t\t\t\treturn variable;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tto_json(scene: PolyScene): TextureVariableData[] | undefined {\n\t\treturn this._variables?.map((v) => v.to_json(scene));\n\t\t// for(let variable of this._variables){\n\t\t// \tdata[variable.name()] = variable.to_json(scene)\n\t\t// }\n\t\t// return data\n\t}\n}\n","import {TextureAllocation} from './TextureAllocation';\nimport {PolyScene} from '../../../../scene/PolyScene';\n\nexport interface TextureVariableData {\n\tname: string;\n\tnodes: string[];\n}\n\nexport class TextureVariable {\n\tprivate _allocation: TextureAllocation | undefined;\n\tprivate _position: number = -1;\n\n\tprivate _graph_node_ids: Map<string, boolean> | undefined;\n\n\tconstructor(private _name: string, private _size: number) {\n\t\tif (!_name) {\n\t\t\tthrow 'TextureVariable requires a name';\n\t\t}\n\t}\n\n\tset_allocation(allocation: TextureAllocation) {\n\t\tthis._allocation = allocation;\n\t}\n\tget allocation() {\n\t\treturn this._allocation;\n\t}\n\n\tget graph_node_ids() {\n\t\treturn this._graph_node_ids;\n\t}\n\tadd_graph_node_id(id: string) {\n\t\tthis._graph_node_ids = this._graph_node_ids || new Map();\n\t\tthis._graph_node_ids.set(id, true);\n\t}\n\tget name() {\n\t\treturn this._name;\n\t}\n\tget size() {\n\t\treturn this._size;\n\t}\n\n\tset_position(position: number) {\n\t\tthis._position = position;\n\t}\n\tget position() {\n\t\treturn this._position;\n\t}\n\tget component(): string {\n\t\treturn 'xyzw'\n\t\t\t.split('')\n\t\t\t.splice(this._position, this._size)\n\t\t\t.join('');\n\t}\n\tto_json(scene: PolyScene): TextureVariableData {\n\t\tconst names: string[] = [];\n\t\tif (this._graph_node_ids) {\n\t\t\tthis._graph_node_ids.forEach((boolean, node_id: string) => {\n\t\t\t\tconst name = scene.graph.node_from_id(node_id).name;\n\t\t\t\tnames.push(name);\n\t\t\t});\n\t\t}\n\n\t\treturn {\n\t\t\tname: this.name,\n\t\t\tnodes: names.sort(),\n\t\t};\n\t}\n}\n","import lodash_flatten from 'lodash/flatten';\nimport lodash_uniq from 'lodash/uniq';\nimport lodash_sortBy from 'lodash/sortBy';\nimport lodash_includes from 'lodash/includes';\nimport {TextureAllocation} from './TextureAllocation';\nimport {BaseGlNodeType} from '../../_Base';\n\n// import {TypedConnection, COMPONENTS_COUNT_BY_TYPE} from '../../../../../Engine/Node/Gl/GlData';\nimport {TextureVariable, TextureVariableData} from './TextureVariable';\nimport {ShaderConfig} from '../configs/ShaderConfig';\nimport {ShaderName, ParticleShaderNames} from '../../../utils/shaders/ShaderName';\nimport {PolyScene} from '../../../../scene/PolyScene';\nimport {ConnectionPointComponentsCountMap} from '../../../utils/connections/ConnectionPointType';\nimport {AttributeGlNode} from '../../Attribute';\nimport {BaseNamedConnectionPointType} from '../../../utils/connections/NamedConnectionPoint';\nimport {GlobalsGlNode} from '../../Globals';\n\nexport type TextureAllocationsControllerData = Dictionary<TextureVariableData[] | undefined>[];\n\nexport class TextureAllocationsController {\n\tprivate _allocations: TextureAllocation[] = [];\n\tprivate _next_allocation_index: number = 0;\n\n\tconstructor() {}\n\tallocate_connections_from_root_nodes(root_nodes: BaseGlNodeType[], leaf_nodes: BaseGlNodeType[]) {\n\t\t// const connections_by_node_id = {}\n\t\tconst variables = [];\n\n\t\t// TODO: let's go through the output node first, in case there is a name conflict, it will have priority\n\t\tfor (let node of root_nodes) {\n\t\t\tconst node_id = node.graph_node_id;\n\t\t\tswitch (node.type) {\n\t\t\t\tcase 'output': {\n\t\t\t\t\tfor (let connection_point of node.io.inputs.named_input_connection_points) {\n\t\t\t\t\t\tconst input = node.io.inputs.named_input(connection_point.name);\n\t\t\t\t\t\tif (input) {\n\t\t\t\t\t\t\t// connections_by_node_id[node_id] = connections_by_node_id[node_id] || []\n\t\t\t\t\t\t\t// connections_by_node_id[node_id].push(named_input)\n\t\t\t\t\t\t\tconst variable = new TextureVariable(\n\t\t\t\t\t\t\t\tconnection_point.name,\n\t\t\t\t\t\t\t\tConnectionPointComponentsCountMap[connection_point.type]\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tvariable.add_graph_node_id(node_id);\n\t\t\t\t\t\t\tvariables.push(variable);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase 'attribute': {\n\t\t\t\t\tconst attrib_node = node as AttributeGlNode;\n\t\t\t\t\tconst named_input: BaseGlNodeType | null = attrib_node.connected_input_node();\n\t\t\t\t\tconst connection_point:\n\t\t\t\t\t\t| BaseNamedConnectionPointType\n\t\t\t\t\t\t| undefined = attrib_node.connected_input_connection_point();\n\t\t\t\t\tif (named_input && connection_point) {\n\t\t\t\t\t\t// connections_by_node_id[node_id] = connections_by_node_id[node_id] || []\n\t\t\t\t\t\t// connections_by_node_id[node_id].push(named_input)\n\t\t\t\t\t\tconst variable = new TextureVariable(\n\t\t\t\t\t\t\tattrib_node.attribute_name,\n\t\t\t\t\t\t\tConnectionPointComponentsCountMap[connection_point.type]\n\t\t\t\t\t\t);\n\t\t\t\t\t\tvariable.add_graph_node_id(node_id);\n\t\t\t\t\t\tvariables.push(variable);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (let node of leaf_nodes) {\n\t\t\tconst node_id = node.graph_node_id;\n\t\t\tswitch (node.type) {\n\t\t\t\tcase 'globals': {\n\t\t\t\t\tconst globals_node = node as GlobalsGlNode;\n\t\t\t\t\tconst output_names_attributes = ['position', 'normal', 'color', 'uv'];\n\t\t\t\t\t// const output_names_not_attributes = ['frame', 'gl_FragCoord', 'gl_PointCoord'];\n\t\t\t\t\tfor (let output_name of globals_node.io.outputs.used_output_names()) {\n\t\t\t\t\t\t// const is_attribute = !lodash_includes(output_names_not_attributes, output_name)\n\n\t\t\t\t\t\t// is_attribute, as opposed to frame, gl_FragCoord and gl_PointCoord which are either uniforms or provided by the renderer\n\t\t\t\t\t\tconst is_attribute = output_names_attributes.includes(output_name);\n\n\t\t\t\t\t\tif (is_attribute) {\n\t\t\t\t\t\t\tconst connection_point = globals_node.io.outputs.named_output_connection_points_by_name(\n\t\t\t\t\t\t\t\toutput_name\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tif (connection_point) {\n\t\t\t\t\t\t\t\tconst gl_type = connection_point.type;\n\t\t\t\t\t\t\t\tconst variable = new TextureVariable(\n\t\t\t\t\t\t\t\t\toutput_name,\n\t\t\t\t\t\t\t\t\tConnectionPointComponentsCountMap[gl_type]\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tvariable.add_graph_node_id(node_id);\n\t\t\t\t\t\t\t\tvariables.push(variable);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase 'attribute': {\n\t\t\t\t\tconst attribute_node = node as AttributeGlNode;\n\t\t\t\t\tconst connection_point = attribute_node.output_connection_point();\n\t\t\t\t\tif (connection_point) {\n\t\t\t\t\t\t// connections_by_node_id[node_id] = connections_by_node_id[node_id] || []\n\t\t\t\t\t\t// connections_by_node_id[node_id].push(named_output)\n\t\t\t\t\t\tconst variable = new TextureVariable(\n\t\t\t\t\t\t\tattribute_node.attribute_name,\n\t\t\t\t\t\t\tConnectionPointComponentsCountMap[connection_point.type]\n\t\t\t\t\t\t);\n\t\t\t\t\t\tvariable.add_graph_node_id(node_id);\n\t\t\t\t\t\tvariables.push(variable);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthis.allocate_variables(variables);\n\t}\n\tallocate_variables(variables: TextureVariable[]) {\n\t\tconst variables_by_size_inverse = lodash_sortBy(variables, (variable) => {\n\t\t\treturn -variable.size;\n\t\t});\n\t\tfor (let variable of variables_by_size_inverse) {\n\t\t\tthis.allocate_variable(variable);\n\t\t}\n\t}\n\tallocate_variable(new_variable: TextureVariable) {\n\t\tlet allocated = this.has_variable(new_variable.name);\n\t\tif (allocated) {\n\t\t\tconst allocated_variable = this.variables().filter((v) => v.name == new_variable.name)[0];\n\t\t\tnew_variable.graph_node_ids?.forEach((boolean, graph_node_id: string) => {\n\t\t\t\tallocated_variable.add_graph_node_id(graph_node_id);\n\t\t\t});\n\t\t} else {\n\t\t\tif (!allocated) {\n\t\t\t\tfor (let allocation of this._allocations) {\n\t\t\t\t\tif (!allocated && allocation.has_space_for_variable(new_variable)) {\n\t\t\t\t\t\tallocation.add_variable(new_variable);\n\t\t\t\t\t\tallocated = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!allocated) {\n\t\t\t\tconst new_allocation = new TextureAllocation(this.next_allocation_name());\n\t\t\t\tthis._allocations.push(new_allocation);\n\t\t\t\tnew_allocation.add_variable(new_variable);\n\t\t\t}\n\t\t}\n\t}\n\n\tnext_allocation_name(): ShaderName {\n\t\tconst name = ParticleShaderNames[this._next_allocation_index];\n\t\tthis._next_allocation_index += 1;\n\t\treturn name;\n\t}\n\n\tshader_names(): ShaderName[] {\n\t\tconst explicit_shader_names = this._allocations.map((a) => a.shader_name);\n\n\t\t// include dependencies if needed\n\t\t// TODO: typescript - do I need those?\n\t\t// if (lodash_includes(explicit_shader_names, 'acceleration')) {\n\t\t// \texplicit_shader_names.push('velocity');\n\t\t// }\n\t\t// if (lodash_includes(explicit_shader_names, 'velocity')) {\n\t\t// \texplicit_shader_names.push('position');\n\t\t// }\n\n\t\treturn lodash_uniq(explicit_shader_names);\n\t}\n\tcreate_shader_configs(): ShaderConfig[] {\n\t\treturn [\n\t\t\t// new ShaderConfig('position', ['position'], []),\n\t\t\t// new ShaderConfig('fragment', ['color', 'alpha'], ['vertex']),\n\t\t];\n\t}\n\tallocation_for_shader_name(shader_name: ShaderName): TextureAllocation {\n\t\treturn this._allocations.filter((a) => a.shader_name == shader_name)[0];\n\t}\n\tinput_names_for_shader_name(root_node: BaseGlNodeType, shader_name: ShaderName) {\n\t\tconst allocation = this.allocation_for_shader_name(shader_name);\n\t\tif (allocation) {\n\t\t\treturn allocation.input_names_for_node(root_node);\n\t\t}\n\t}\n\t// find_variable(root_node: BaseNodeGl, shader_name: ShaderName, input_name: string): TextureVariable{\n\t// \tconst allocation = this.allocation_for_shader_name(shader_name)\n\t// \tif(allocation){\n\t// \t\treturn allocation.find_variable_with_node(root_node, input_name)\n\t// \t}\n\t// }\n\tvariable(variable_name: string): TextureVariable | undefined {\n\t\tfor (let allocation of this._allocations) {\n\t\t\tconst variable = allocation.variable(variable_name);\n\t\t\tif (variable) {\n\t\t\t\treturn variable;\n\t\t\t}\n\t\t}\n\t}\n\tvariables(): TextureVariable[] {\n\t\treturn lodash_flatten(this._allocations.map((a) => a.variables || []));\n\t}\n\thas_variable(name: string): boolean {\n\t\tconst names = this.variables().map((v) => v.name);\n\t\treturn lodash_includes(names, name);\n\t}\n\t// allocation_for_variable(name:string):TextureAllocation{\n\t// \tfor(let allocation of this._allocations){\n\t// \t\tconst variables = allocation.variables()\n\t// \t\tfor(let variable of variables){\n\t// \t\t\tif(variable.name() == name){\n\t// \t\t\t\treturn allocation\n\t// \t\t\t}\n\t// \t\t}\n\t// \t}\n\t// }\n\tto_json(scene: PolyScene): TextureAllocationsControllerData {\n\t\treturn this._allocations.map((allocation: TextureAllocation) => {\n\t\t\tconst data = {\n\t\t\t\t[allocation.texture_name]: allocation.to_json(scene),\n\t\t\t};\n\t\t\treturn data;\n\t\t});\n\t}\n\tprint(scene: PolyScene) {\n\t\tconsole.log(JSON.stringify(this.to_json(scene), [''], 2));\n\t}\n}\n","import {BaseGlShaderAssembler} from '../_Base';\n// import {GlobalsTextureHandler} from '../../Assembler/Globals/Texture';\n\nimport TemplateDefault from '../../templates/particles/Default.glsl';\n// import TemplatePosition from './Template/Particle/Position.glsl'\n// import TemplateVelocity from './Template/Particle/Velocity.glsl'\n// import TemplateAcceleration from './Template/Particle/Acceleration.glsl'\n\n// import {ShaderConfig} from './Config/ShaderConfig';\n// import {VariableConfig} from './Config/VariableConfig';\n// import {ShaderName, LineType} from '../../../../../Engine/Node/Gl/Assembler/Util/CodeBuilder';\nimport {AttributeGlNode} from '../../../Attribute';\nimport {TextureAllocationsController} from '../../utils/TextureAllocationsController';\nimport {ThreeToGl} from '../../../../../../core/ThreeToGl';\nimport {BaseGlNodeType} from '../../../_Base';\nimport {GlobalsGlNode} from '../../../Globals';\nimport {TypedNodeTraverser} from '../../../../utils/shaders/NodeTraverser';\nimport {ShaderName} from '../../../../utils/shaders/ShaderName';\nimport {OutputGlNode} from '../../../Output';\nimport {ParamType} from '../../../../../poly/ParamType';\nimport {TypedNamedConnectionPoint} from '../../../../utils/connections/NamedConnectionPoint';\nimport {ConnectionPointType} from '../../../../utils/connections/ConnectionPointType';\nimport {UniformGLDefinition} from '../../../utils/GLDefinition';\nimport {GlobalsTextureHandler} from '../../globals/Texture';\nimport {ShadersCollectionController} from '../../utils/ShadersCollectionController';\n\nexport class ShaderAssemblerParticles extends BaseGlShaderAssembler {\n\tprivate _texture_allocations_controller: TextureAllocationsController | undefined;\n\n\tget _template_shader() {\n\t\treturn undefined;\n\t}\n\tprotected _template_shader_for_shader_name(shader_name: ShaderName) {\n\t\treturn TemplateDefault;\n\t}\n\t// async get_shaders(){\n\t// \tawait this.update_shaders()\n\t// \treturn this._shaders_by_name\n\t// }\n\n\tasync compile() {\n\t\tawait this.setup_shader_names_and_variables();\n\t\tawait this.update_shaders();\n\t}\n\n\troot_nodes_by_shader_name(shader_name: ShaderName): BaseGlNodeType[] {\n\t\t// return this._root_nodes\n\t\tconst list = [];\n\t\tfor (let node of this._root_nodes) {\n\t\t\tswitch (node.type) {\n\t\t\t\tcase 'output': {\n\t\t\t\t\tlist.push(node);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase 'attribute': {\n\t\t\t\t\t// TODO: typescript - gl - why is there a texture allocation controller in the base assembler?\n\t\t\t\t\tconst attrib_name = (node as AttributeGlNode).attribute_name;\n\t\t\t\t\tconst variable = this._texture_allocations_controller?.variable(attrib_name);\n\t\t\t\t\tif (variable && variable.allocation) {\n\t\t\t\t\t\tconst allocation_shader_name = variable.allocation.shader_name;\n\t\t\t\t\t\tif (allocation_shader_name == shader_name) {\n\t\t\t\t\t\t\tlist.push(node);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn list;\n\t}\n\tleaf_nodes_by_shader_name(shader_name: ShaderName): BaseGlNodeType[] {\n\t\tconst list = [];\n\t\tfor (let node of this._leaf_nodes) {\n\t\t\tswitch (node.type) {\n\t\t\t\tcase 'globals': {\n\t\t\t\t\tlist.push(node);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase 'attribute': {\n\t\t\t\t\t// TODO: typescript - gl - why is there a texture allocation controller in the base assembler? AND especially since there is no way to assign it?\n\t\t\t\t\tconst attrib_name: string = (node as AttributeGlNode).attribute_name;\n\t\t\t\t\tconst variable = this._texture_allocations_controller?.variable(attrib_name);\n\t\t\t\t\tif (variable && variable.allocation) {\n\t\t\t\t\t\tconst allocation_shader_name = variable.allocation.shader_name;\n\t\t\t\t\t\tif (allocation_shader_name == shader_name) {\n\t\t\t\t\t\t\tlist.push(node);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn list;\n\t}\n\tasync setup_shader_names_and_variables() {\n\t\tconst node_traverser = new TypedNodeTraverser<BaseGlNodeType>(this, this._gl_parent_node);\n\t\tthis._leaf_nodes = node_traverser.leaves_from_nodes(this._root_nodes);\n\n\t\tfor (let node of this._root_nodes) {\n\t\t\tawait node.params.eval_all();\n\t\t}\n\t\tfor (let node of this._leaf_nodes) {\n\t\t\tawait node.params.eval_all();\n\t\t}\n\n\t\tconsole.log('root and leaf:', this._root_nodes, this._leaf_nodes);\n\t\tthis._texture_allocations_controller = new TextureAllocationsController();\n\t\tthis._texture_allocations_controller.allocate_connections_from_root_nodes(this._root_nodes, this._leaf_nodes);\n\n\t\t// const globals_handler = new GlobalsTextureHandler()\n\t\t// this.set_assembler_globals_handler(globals_handler)\n\t\tif (this.globals_handler) {\n\t\t\t((<unknown>this.globals_handler) as GlobalsTextureHandler)?.set_texture_allocations_controller(\n\t\t\t\tthis._texture_allocations_controller\n\t\t\t);\n\t\t}\n\n\t\tthis._reset_shader_configs();\n\t}\n\tasync update_shaders() {\n\t\tthis._shaders_by_name = new Map();\n\t\tthis._lines = new Map();\n\t\tconsole.log('this.shader_names', this.shader_names);\n\t\tfor (let shader_name of this.shader_names) {\n\t\t\tconst template = this._template_shader_for_shader_name(shader_name);\n\t\t\tthis._lines.set(shader_name, template.split('\\n'));\n\t\t}\n\t\tif (this._root_nodes.length > 0) {\n\t\t\t// this._output_node.set_assembler(this)\n\t\t\tawait this.build_code_from_nodes(this._root_nodes);\n\n\t\t\tthis._build_lines();\n\t\t}\n\t\t// this._material.uniforms = this.build_uniforms(template_shader)\n\t\tfor (let shader_name of this.shader_names) {\n\t\t\tconst lines = this._lines.get(shader_name);\n\t\t\tif (lines) {\n\t\t\t\tconsole.log(shader_name, lines.join('\\n'));\n\t\t\t\tthis._shaders_by_name.set(shader_name, lines.join('\\n'));\n\t\t\t}\n\t\t}\n\t}\n\n\t//\n\t//\n\t// CHILDREN NODES PARAMS\n\t//\n\t//\n\tadd_output_params(output_child: OutputGlNode) {\n\t\toutput_child.add_param(ParamType.VECTOR3, 'position', [0, 0, 0]);\n\t\toutput_child.add_param(ParamType.VECTOR3, 'velocity', [0, 0, 0]);\n\t\t// output_child.add_param(ParamType.VECTOR3, 'accacceleration', [0, 0, 0]);\n\t}\n\tadd_globals_params(globals_node: GlobalsGlNode) {\n\t\tglobals_node.io.outputs.set_named_output_connection_points([\n\t\t\tnew TypedNamedConnectionPoint('position', ConnectionPointType.VEC3),\n\t\t\tnew TypedNamedConnectionPoint('velocity', ConnectionPointType.VEC3),\n\t\t\t// new TypedNamedConnectionPoint('acceleration', ConnectionPointType.VEC3),\n\t\t\tnew TypedNamedConnectionPoint('time', ConnectionPointType.FLOAT),\n\t\t]);\n\t}\n\tallow_attribute_exports() {\n\t\treturn true;\n\t}\n\n\tget texture_allocations_controller() {\n\t\treturn (this._texture_allocations_controller =\n\t\t\tthis._texture_allocations_controller || new TextureAllocationsController());\n\t}\n\n\t//\n\t//\n\t// CONFIGS\n\t//\n\t//\n\tcreate_shader_configs() {\n\t\treturn this._texture_allocations_controller?.create_shader_configs() || [];\n\t\t// [\n\t\t// \tnew ShaderConfig('position', ['position'], []),\n\t\t// \t// new ShaderConfig('fragment', ['color', 'alpha'], ['vertex']),\n\t\t// ]\n\t}\n\tcreate_variable_configs() {\n\t\treturn [\n\t\t\t// new VariableConfig('position', {\n\t\t\t// \tdefault: 'vec3( position )',\n\t\t\t// \tprefix: 'vec3 transformed = '\n\t\t\t// }),\n\t\t];\n\t}\n\tget shader_names(): ShaderName[] {\n\t\treturn this.texture_allocations_controller.shader_names() || [];\n\t}\n\tinput_names_for_shader_name(root_node: BaseGlNodeType, shader_name: ShaderName) {\n\t\treturn this.texture_allocations_controller.input_names_for_shader_name(root_node, shader_name) || [];\n\t\t// return this.shader_config(shader_name).input_names()\n\t}\n\n\t//\n\t//\n\t// TEMPLATE HOOKS\n\t//\n\t//\n\tprotected insert_define_after(shader_name: ShaderName) {\n\t\treturn '// INSERT DEFINE';\n\t}\n\tprotected insert_body_after(shader_name: ShaderName) {\n\t\treturn '// INSERT BODY';\n\t}\n\tprotected lines_to_remove(shader_name: ShaderName) {\n\t\treturn ['// INSERT DEFINE', '// INSERT BODY'];\n\t}\n\n\t//\n\t//\n\t// TEMPLATE CODE REPLACEMENT\n\t//\n\t//\n\tadd_export_body_line(\n\t\texport_node: BaseGlNodeType,\n\t\tinput_name: string,\n\t\tinput: BaseGlNodeType,\n\t\tvariable_name: string,\n\t\tshaders_collection_controller: ShadersCollectionController\n\t) {\n\t\tif (input) {\n\t\t\tconst var_input = export_node.variable_for_input(input_name);\n\t\t\tconst new_var = ThreeToGl.vector3(var_input);\n\t\t\tif (new_var) {\n\t\t\t\tconst texture_variable = this.texture_allocations_controller.variable(variable_name);\n\n\t\t\t\t// if we are in the texture this variable is allocated to, we write it back\n\t\t\t\tconst shader_name = shaders_collection_controller.current_shader_name;\n\t\t\t\tif (texture_variable && texture_variable.allocation?.shader_name == shader_name) {\n\t\t\t\t\tconst component = texture_variable.component;\n\n\t\t\t\t\tconst line = `gl_FragColor.${component} = ${new_var}`;\n\t\t\t\t\tshaders_collection_controller.add_body_lines(export_node, [line], shader_name);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tset_node_lines_output(output_node: BaseGlNodeType, shaders_collection_controller: ShadersCollectionController) {\n\t\tconst shader_name = shaders_collection_controller.current_shader_name;\n\t\tconst input_names = this.texture_allocations_controller.input_names_for_shader_name(output_node, shader_name);\n\t\tif (input_names) {\n\t\t\tfor (let input_name of input_names) {\n\t\t\t\tconst input = output_node.io.inputs.named_input(input_name);\n\n\t\t\t\tif (input) {\n\t\t\t\t\tconst variable_name = input_name;\n\t\t\t\t\tthis.add_export_body_line(\n\t\t\t\t\t\toutput_node,\n\t\t\t\t\t\tinput_name,\n\t\t\t\t\t\tinput,\n\t\t\t\t\t\tvariable_name,\n\t\t\t\t\t\tshaders_collection_controller\n\t\t\t\t\t);\n\t\t\t\t} else {\n\t\t\t\t\t// position reads the default attribute position\n\t\t\t\t\t// or maybe there is no need?\n\t\t\t\t\t// if(input_name == 'position'){\n\t\t\t\t\t// \tthis.globals_handler().read_attribute(output_node, 'vec3', 'position')\n\t\t\t\t\t// }\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tset_node_lines_attribute(\n\t\tattribute_node: AttributeGlNode,\n\t\tshaders_collection_controller: ShadersCollectionController\n\t) {\n\t\tif (attribute_node.is_importing) {\n\t\t\tconst gl_type = attribute_node.gl_type();\n\t\t\tconst attribute_name = attribute_node.attribute_name;\n\t\t\tconst new_value = this.globals_handler?.read_attribute(\n\t\t\t\tattribute_node,\n\t\t\t\tgl_type,\n\t\t\t\tattribute_name,\n\t\t\t\tshaders_collection_controller\n\t\t\t);\n\t\t\tconst var_name = attribute_node.gl_var_name(attribute_node.output_name);\n\t\t\tconst body_line = `${gl_type} ${var_name} = ${new_value}`;\n\t\t\tshaders_collection_controller.add_body_lines(attribute_node, [body_line]);\n\n\t\t\t// re-export to ensure it is available on next frame\n\t\t\tconst texture_variable = this.texture_allocations_controller.variable(attribute_name);\n\t\t\tconst shader_name = shaders_collection_controller.current_shader_name;\n\t\t\tif (texture_variable && texture_variable.allocation?.shader_name == shader_name) {\n\t\t\t\tconst variable = this.texture_allocations_controller.variable(attribute_name);\n\t\t\t\tif (variable) {\n\t\t\t\t\tconst component = variable.component;\n\t\t\t\t\tconst body_line = `gl_FragColor.${component} = ${var_name}`;\n\t\t\t\t\tshaders_collection_controller.add_body_lines(attribute_node, [body_line]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// this.add_import_body_line(\n\t\t\t// \tattribute_node,\n\t\t\t// \tshader_name,\n\t\t\t// \tAttribute.output_name(),\n\t\t\t// \tattribute_node.attribute_name()\n\t\t\t// \t)\n\t\t}\n\t\tif (attribute_node.is_exporting) {\n\t\t\tconst input = attribute_node.connected_input_node();\n\t\t\tif (input) {\n\t\t\t\tconst variable_name = attribute_node.attribute_name;\n\n\t\t\t\tthis.add_export_body_line(\n\t\t\t\t\tattribute_node,\n\t\t\t\t\tattribute_node.input_name,\n\t\t\t\t\tinput,\n\t\t\t\t\tvariable_name,\n\t\t\t\t\tshaders_collection_controller\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\tset_node_lines_globals(globals_node: GlobalsGlNode, shaders_collection_controller: ShadersCollectionController) {\n\t\tfor (let output_name of globals_node.io.outputs.used_output_names()) {\n\t\t\tswitch (output_name) {\n\t\t\t\tcase 'time':\n\t\t\t\t\tthis._handle_globals_time(globals_node, output_name, shaders_collection_controller);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tthis._handle_globals_default(globals_node, output_name, shaders_collection_controller);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate _handle_globals_time(\n\t\tglobals_node: GlobalsGlNode,\n\t\toutput_name: string,\n\t\tshaders_collection_controller: ShadersCollectionController\n\t) {\n\t\tconst definition = new UniformGLDefinition(globals_node, ConnectionPointType.FLOAT, output_name);\n\t\tshaders_collection_controller.add_definitions(globals_node, [definition]);\n\n\t\tconst var_name = globals_node.gl_var_name(output_name);\n\t\tconst body_line = `float ${var_name} = ${output_name}`;\n\t\tshaders_collection_controller.add_body_lines(globals_node, [body_line]);\n\t\tthis.set_uniforms_time_dependent();\n\t}\n\n\tprivate _handle_globals_default(\n\t\tglobals_node: GlobalsGlNode,\n\t\toutput_name: string,\n\t\tshaders_collection_controller: ShadersCollectionController\n\t) {\n\t\tconst output_connection_point = globals_node.io.outputs.named_output_connection_points_by_name(output_name);\n\t\tif (output_connection_point) {\n\t\t\tconst gl_type = output_connection_point.type;\n\n\t\t\tconst attrib_read = this.globals_handler?.read_attribute(\n\t\t\t\tglobals_node,\n\t\t\t\tgl_type,\n\t\t\t\toutput_name,\n\t\t\t\tshaders_collection_controller\n\t\t\t);\n\t\t\tconst var_name = globals_node.gl_var_name(output_name);\n\t\t\tconst body_line = `${gl_type} ${var_name} = ${attrib_read}`;\n\t\t\tshaders_collection_controller.add_body_lines(globals_node, [body_line]);\n\t\t}\n\t}\n}\n","export default \"#include <common>\\n\\n// INSERT DEFINE\\n\\nvoid main() {\\n\\n\\tvec2 particleUV = (gl_FragCoord.xy / resolution.xy);\\n\\n\\t// INSERT BODY\\n\\n}\"","import {GlobalsBaseController} from './_Base';\nimport {GlobalsGlNode} from '../../Globals';\nimport {BaseGlNodeType} from '../../_Base';\n// import {Definition} from '../../Definition/_Module'\n// import { VariableConfig } from '../Config/VariableConfig';\nimport {TextureAllocationsController} from '../utils/TextureAllocationsController';\nimport {GlobalsGeometryHandler} from './Geometry';\nimport {ShaderName} from '../../../utils/shaders/ShaderName';\nimport {UniformGLDefinition, AttributeGLDefinition, VaryingGLDefinition} from '../../utils/GLDefinition';\nimport {ConnectionPointType} from '../../../utils/connections/ConnectionPointType';\nimport {ShadersCollectionController} from '../utils/ShadersCollectionController';\n\n// import {DefinitionBaseConfig} from '../Config/DefinitionBaseConfig'\n// import {UniformConfig} from '../Config/UniformConfig'\n// import {AttributeConfig} from '../Config/AttributeConfig'\n// import { Attribute } from '../../Attribute';\n\nexport class GlobalsTextureHandler extends GlobalsBaseController {\n\tprivate _texture_allocations_controller: TextureAllocationsController | undefined;\n\n\tstatic UV_ATTRIB = 'particles_sim_uv_attrib';\n\tstatic UV_VARYING = 'particles_sim_uv_varying';\n\tstatic PARTICLE_SIM_UV = 'particleUV';\n\n\tprivate globals_geometry_handler: GlobalsGeometryHandler | undefined;\n\n\tconstructor(private _uv_name: string) {\n\t\tsuper();\n\t}\n\n\tset_texture_allocations_controller(controller: TextureAllocationsController) {\n\t\tthis._texture_allocations_controller = controller;\n\t}\n\n\thandle_globals_node(\n\t\tglobals_node: GlobalsGlNode,\n\t\toutput_name: string,\n\t\tshaders_collection_controller: ShadersCollectionController\n\t\t// definitions_by_shader_name: Map<ShaderName, BaseGLDefinition[]>,\n\t\t// body_lines_by_shader_name: Map<ShaderName, string[]>,\n\t\t// body_lines: string[],\n\t\t// dependencies: ShaderName[],\n\t\t// shader_name: ShaderName\n\t) {\n\t\tif (!this._texture_allocations_controller) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst connection_point = globals_node.io.outputs.named_output_connection_points_by_name(output_name);\n\t\tconst var_name = globals_node.gl_var_name(output_name);\n\n\t\tconst variable = this._texture_allocations_controller.variable(output_name);\n\n\t\tif (variable && connection_point) {\n\t\t\tconst gl_type = connection_point.type;\n\t\t\tconst new_value = this.read_attribute(globals_node, gl_type, output_name, shaders_collection_controller);\n\t\t\tconst body_line = `${gl_type} ${var_name} = ${new_value}`;\n\t\t\tshaders_collection_controller.add_body_lines(globals_node, [body_line]);\n\t\t} else {\n\t\t\tthis.globals_geometry_handler = this.globals_geometry_handler || new GlobalsGeometryHandler();\n\t\t\tthis.globals_geometry_handler.handle_globals_node(\n\t\t\t\tglobals_node,\n\t\t\t\toutput_name,\n\t\t\t\tshaders_collection_controller\n\t\t\t\t// definitions_by_shader_name,\n\t\t\t\t// body_lines_by_shader_name,\n\t\t\t\t// body_lines,\n\t\t\t\t// dependencies,\n\t\t\t\t// shader_name\n\t\t\t);\n\t\t}\n\n\t\t// definitions\n\t\t// const gl_type = named_output.gl_type()\n\t\t// const definition = new Definition.Varying(globals_node, gl_type, var_name)\n\t\t// definitions_by_shader_name[shader_name].push(definition)\n\n\t\t// const new_value = this.read_attribute(globals_node, gl_type, output_name)\n\t\t// const body_line = `${var_name} = ${new_value}`\n\t\t// if(allocation){\n\t\t// \tconst var_name_texture = allocation.texture_name()\n\t\t// \t// add another definition if a texture was allocated by ParticlesSystemGPU\n\t\t// \tconst texture_definition = new Definition.Uniform(globals_node, 'sampler2D', var_name_texture)\n\t\t// \tdefinitions_by_shader_name[shader_name].push(texture_definition)\n\n\t\t// \t// const particles_sim_uv_definition = new Definition.Attribute(globals_node, 'vec2', GlobalsTextureHandler.UV_ATTRIB)\n\t\t// \t// definitions_by_shader_name['vertex'].push(particles_sim_uv_definition)\n\t\t// \t// this.add_particles_sim_uv_attribute(globals_node)\n\n\t\t// \tconst new_value = this.read_attribute(globals_node, gl_type, output_name, shader_name)\n\t\t// \tbody_line = `${var_name} = ${new_value}`\n\n\t\t// } else {\n\t\t// \tbody_line = `${var_name} = vec3(${output_name})`\n\t\t// }\n\n\t\t// const new_body_lines = [\n\t\t// \t// `${var_name} = vec3(${output_name})`,\n\t\t// \t`vec3 ${var_name} = texture2D( ${var_name_texture}, uv ).xyz;`\n\t\t// ]\n\t\t// const body_line = `vec3 ${var_name} = texture2D( ${var_name_texture}, uv ).xyz`\n\n\t\t// for(let dependency of dependencies){\n\t\t// \tdefinitions_by_shader_name[dependency].push(definition)\n\t\t// \tbody_lines_by_shader_name[dependency].push(body_line)\n\t\t// }\n\t\t// if(dependencies.length == 0){\n\t\t// \tbody_lines.push(body_line)\n\t\t// }\n\t}\n\t// variable_config_default(variable_name: string): string {\n\t// \t// const allocation = this._texture_allocations_controller.allocation_for_variable(variable_name)\n\t// \t// if(allocation){\n\t// \t// \treturn `texture2D( texture_${allocation.name()}, ${GlobalsTextureHandler.UV_VARYING} ).xyz`\n\t// \t// } else {\n\t// \t// \tGlobalsGeometryHandler.variable_config_default(variable_name)\n\t// \t// }\n\t// \tthrow 'do I go through here?';\n\t// \treturn this.read_attribute(variable_name);\n\t// }\n\t// variable_config_required_definitions(variable_name:string):DefinitionBaseConfig[]{\n\t// \tconst allocation = this._texture_allocations_controller.allocation_for_variable(variable_name)\n\t// \tif(allocation){\n\t// \t\treturn [\n\t// \t\t\tnew AttributeConfig('vec2', GlobalsTextureHandler.UV_ATTRIB),\n\t// \t\t\tnew UniformConfig('sampler2D', `texture_${allocation.name()}`)\n\t// \t\t]\n\t// \t}\n\t// }\n\n\t// static remap_instance_attribute(name:string):string{\n\t// \tif(name == 'instancePosition'){\n\t// \t\treturn 'position'\n\t// \t}\n\t// \treturn name\n\t// }\n\t// static variable_name_to_instance_attrib(name:string):string{\n\t// \tif(name == 'position'){\n\t// \t\treturn 'instancePosition'\n\t// \t}\n\t// \treturn name\n\t// }\n\n\tread_attribute(\n\t\tnode: BaseGlNodeType,\n\t\tgl_type: ConnectionPointType,\n\t\tattrib_name: string,\n\t\tshaders_collection_controller: ShadersCollectionController\n\t) {\n\t\tif (!this._texture_allocations_controller) {\n\t\t\treturn;\n\t\t}\n\t\t// attrib_name = GlobalsTextureHandler.remap_instance_attribute(attrib_name)\n\n\t\tconst texture_variable = this._texture_allocations_controller.variable(attrib_name);\n\n\t\tif (texture_variable) {\n\t\t\tthis.add_particles_sim_uv_attribute(node, shaders_collection_controller);\n\t\t\t// const texture_variable = allocation.variable(attrib_name)\n\t\t\t// if(!texture_variable){\n\t\t\t// \tconsole.error(`no tex var found for ${attrib_name}`)\n\t\t\t// \tthis._texture_allocations_controller.print(node.scene())\n\t\t\t// }\n\t\t\tconst component = texture_variable.component;\n\t\t\tconst allocation = texture_variable.allocation;\n\t\t\tif (allocation) {\n\t\t\t\t// const definitions_by_shader_name = {}\n\t\t\t\t// definitions_by_shader_name[shader_name] = []\n\t\t\t\tconst var_name_texture = allocation.texture_name;\n\t\t\t\tconst texture_definition = new UniformGLDefinition(\n\t\t\t\t\tnode,\n\t\t\t\t\tConnectionPointType.SAMPLER_2D,\n\t\t\t\t\tvar_name_texture\n\t\t\t\t);\n\t\t\t\t// definitions_by_shader_name[shader_name].push(texture_definition)\n\n\t\t\t\tshaders_collection_controller.add_definitions(node, [texture_definition]);\n\n\t\t\t\t// const particles_sim_uv_definition = new Definition.Attribute(globals_node, 'vec2', 'particles_sim_uv')\n\t\t\t\t// definitions_by_shader_name['vertex'].push(particles_sim_uv_definition)\n\t\t\t\tconst body_line = `texture2D( ${var_name_texture}, ${this._uv_name} ).${component}`;\n\t\t\t\treturn body_line;\n\t\t\t}\n\t\t} else {\n\t\t\treturn GlobalsGeometryHandler.read_attribute(node, gl_type, attrib_name, shaders_collection_controller);\n\t\t}\n\t}\n\n\tadd_particles_sim_uv_attribute(node: BaseGlNodeType, shaders_collection_controller: ShadersCollectionController) {\n\t\t// const shader_names = ['vertex', 'fragment'];\n\t\t// const definitions_by_shader_name:Map<ShaderName, BaseGLDefinition[]> = new Map();\n\t\t// definitions_by_shader_name.set(ShaderName.VERTEX, [])\n\t\t// definitions_by_shader_name.set(ShaderName.FRAGMENT, [])\n\t\t// for (let shader_name of shader_names) {\n\t\t// \tdefinitions_by_shader_name[shader_name] = [];\n\t\t// }\n\n\t\tconst particles_sim_uv_attrib_definition = new AttributeGLDefinition(\n\t\t\tnode,\n\t\t\tConnectionPointType.VEC2,\n\t\t\tGlobalsTextureHandler.UV_ATTRIB\n\t\t);\n\t\tconst particles_sim_uv_varying_definition = new VaryingGLDefinition(\n\t\t\tnode,\n\t\t\tConnectionPointType.VEC2,\n\t\t\tGlobalsTextureHandler.UV_VARYING\n\t\t);\n\n\t\tshaders_collection_controller.add_definitions(\n\t\t\tnode,\n\t\t\t[particles_sim_uv_attrib_definition, particles_sim_uv_varying_definition],\n\t\t\tShaderName.VERTEX\n\t\t);\n\t\tshaders_collection_controller.add_definitions(node, [particles_sim_uv_varying_definition], ShaderName.FRAGMENT);\n\n\t\tshaders_collection_controller.add_body_lines(\n\t\t\tnode,\n\t\t\t[`${GlobalsTextureHandler.UV_VARYING} = ${GlobalsTextureHandler.UV_ATTRIB}`],\n\t\t\tShaderName.VERTEX\n\t\t);\n\t}\n}\n","import lodash_cloneDeep from 'lodash/cloneDeep';\nimport {ShaderMaterial} from 'three/src/materials/ShaderMaterial';\n// import {BaseNodeSop} from '../_Base'\nimport {Object3D} from 'three/src/core/Object3D';\nimport {BaseBuilderMatNodeType} from '../../../mat/_BaseBuilder';\n\n// import computeShaderPosition from 'src/Engine/Node/Gl/Assembler/Template/Particle/Position.glsl'\n// import computeShaderVelocity from 'src/Engine/Node/Gl/Assembler/Template/Particle/Particle.v.glsl'\n// import particleVertexShader from 'src/Engine/Node/Gl/Assembler/Template/Particle/Particle.vert.glsl'\n// import particleFragmentShader from 'src/Engine/Node/Gl/Assembler/Template/Particle/Particle.frag.glsl'\nimport {GlobalsTextureHandler} from '../../../gl/code/globals/Texture';\n\nimport {ParticlesSystemGpuSopNode} from '../../ParticlesSystemGpu';\nimport {CoreMaterial, ShaderMaterialWithCustomMaterials} from '../../../../../core/geometry/Material';\nimport {CoreGroup} from '../../../../../core/geometry/Group';\nimport {Mesh} from 'three/src/objects/Mesh';\nimport {ShaderName} from '../../../utils/shaders/ShaderName';\nimport {TextureAllocationsControllerData} from '../../../gl/code/utils/TextureAllocationsController';\n\nexport class ParticlesSystemGpuRenderController {\n\tprivate _render_material: ShaderMaterial | undefined;\n\tprotected _particles_group_objects: Object3D[] = [];\n\tprivate _shaders_by_name: Map<ShaderName, string> | undefined;\n\tprivate _texture_allocations_json: TextureAllocationsControllerData | undefined;\n\n\tconstructor(private node: ParticlesSystemGpuSopNode) {}\n\n\t// _create_render_params() {\n\t// \tthis.self.within_param_folder(\"setup\", () => {\n\t// \t\tthis.self.add_param(ParamType.OPERATOR_PATH, \"material\", \"\", {\n\t// \t\t\tnode_selection: {\n\t// \t\t\t\tcontext: NodeContext.MAT\n\t// \t\t\t},\n\t// \t\t\tdependent_on_found_node: false\n\t// \t\t});\n\t// \t});\n\t// }\n\tset_shaders_by_name(shaders_by_name: Map<ShaderName, string>) {\n\t\tthis._shaders_by_name = shaders_by_name;\n\t\tthis.reset_render_material();\n\t}\n\n\tassign_render_material() {\n\t\tif (!this._render_material) {\n\t\t\t// throw 'cannot assign non existing material';\n\t\t\treturn;\n\t\t}\n\t\tfor (let object3d of this._particles_group_objects) {\n\t\t\tconst object = object3d as Mesh;\n\t\t\tif (object.geometry) {\n\t\t\t\tobject.material = this._render_material;\n\t\t\t\tCoreMaterial.apply_custom_materials(object, this._render_material as ShaderMaterialWithCustomMaterials);\n\t\t\t\tobject.matrixAutoUpdate = false;\n\t\t\t\tobject.updateMatrix();\n\t\t\t}\n\t\t}\n\t\t// if this material is recomputed on a frame after the frame_start\n\t\t// we need to:\n\t\t// - mark the material as needsUpdate (to ensure it gets recompiled by the renderer)\n\t\t// - update the uniforms (to ensure the material gets the right values, as the uniforms have been reset)\n\t\tthis._render_material.needsUpdate = true;\n\t\tthis.update_render_material_uniforms();\n\t}\n\tupdate_render_material_uniforms() {\n\t\tif (!this._render_material) {\n\t\t\treturn;\n\t\t}\n\t\t// if (!this.self._gpu_compute) {\n\t\t// \treturn;\n\t\t// }\n\n\t\t// for (let shader_name of Object.keys(this._shaders_by_name)) {\n\t\tthis._shaders_by_name?.forEach((string, shader_name) => {\n\t\t\tconst texture = this.node.gpu_controller.getCurrentRenderTarget(shader_name)?.texture;\n\t\t\tif (texture) {\n\t\t\t\tconst uniform_name = `texture_${shader_name}`;\n\t\t\t\tif (this._render_material) {\n\t\t\t\t\tthis._render_material.uniforms[uniform_name].value = texture;\n\t\t\t\t\tCoreMaterial.assign_custom_uniforms(this._render_material, uniform_name, texture);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\t// console.log(this._render_material.vertexShader);\n\t\t// console.log(this._render_material.fragmentShader);\n\t}\n\n\treset_render_material() {\n\t\tthis._render_material = undefined;\n\t\tthis._particles_group_objects = []; //this._particles_core_group.objects()\n\t}\n\tget initialized(): boolean {\n\t\treturn this._render_material != null;\n\t}\n\n\tinit_core_group(core_group: CoreGroup) {\n\t\tfor (let child of core_group.objects()) {\n\t\t\tthis._particles_group_objects.push(child);\n\t\t}\n\t}\n\tasync init_render_material() {\n\t\t// if (this.self.compile_required()) {\n\t\t// \treturn;\n\t\t// }\n\t\tif (this._render_material) {\n\t\t\treturn;\n\t\t}\n\n\t\t// const uniforms_particles = {\n\t\t// \t\"texture_position\": { value: null },\n\t\t// \t// \"debugX\": { value: 0 },\n\t\t// \t// \"textureVelocity\": { value: null },\n\t\t// \t// \"cameraConstant\": { value: 1 }, //( camera ) },\n\t\t// \t// \"density\": { value: 1.0 }\n\t\t// };\n\n\t\t// ShaderMaterial\n\t\tif (this.node.p.material.is_dirty) {\n\t\t\tawait this.node.p.material.compute();\n\t\t}\n\t\tconst mat_node = this.node.p.material.found_node() as BaseBuilderMatNodeType; // TODO: typescript - ensure node selection is safe, as it would currently crash with a non builder mat selected\n\n\t\tif (mat_node) {\n\t\t\tconst new_texture_allocations_json: TextureAllocationsControllerData = this.node.assembler_controller.assembler.texture_allocations_controller.to_json(\n\t\t\t\tthis.node.scene\n\t\t\t);\n\n\t\t\tconst globals_handler = new GlobalsTextureHandler(GlobalsTextureHandler.UV_VARYING);\n\t\t\tglobals_handler.set_texture_allocations_controller(\n\t\t\t\tthis.node.assembler_controller.assembler.texture_allocations_controller\n\t\t\t);\n\t\t\tmat_node.assembler_controller.set_assembler_globals_handler(globals_handler);\n\t\t\tif (\n\t\t\t\t!this._texture_allocations_json ||\n\t\t\t\tJSON.stringify(this._texture_allocations_json) != JSON.stringify(new_texture_allocations_json)\n\t\t\t) {\n\t\t\t\t// we need to set the node to dirty if a recompile is needed\n\t\t\t\t// otherwise it won't cook\n\t\t\t\t// but we also need to check if the texture_allocation has changed,\n\t\t\t\t// otherwise we'll have an infinite loop\n\t\t\t\tthis._texture_allocations_json = lodash_cloneDeep(new_texture_allocations_json);\n\t\t\t\tmat_node.set_dirty();\n\t\t\t}\n\t\t\t// set compilation required in case the texture allocation has changed\n\t\t\t// but not needed as it is done by set_assembler_globals_handler\n\t\t\t//found_node.set_compilation_required() //_and_dirty()\n\t\t\tconst container = await mat_node.request_container();\n\t\t\tthis._render_material = container.material() as ShaderMaterial; //.clone()\n\t\t\t// this._render_material.needsUpdate = true\n\t\t\t// this.self._assembler.texture_allocations_controller().print()\n\t\t\t// throw \"DEBUGGIN...\"\n\t\t} else {\n\t\t\tthis.node.states.error.set('render material not valid');\n\t\t\t// this._render_material = this._render_material || new ShaderMaterial( {\n\t\t\t// \tuniforms: {},\n\t\t\t// \tvertexShader: particleVertexShader,\n\t\t\t// \tfragmentShader: particleFragmentShader\n\t\t\t// } );\n\t\t}\n\n\t\t// add uniforms\n\t\tif (this._render_material) {\n\t\t\tconst uniforms = this._render_material.uniforms;\n\t\t\t// for (let shader_name of Object.keys(this._shaders_by_name)) {\n\t\t\tthis._shaders_by_name?.forEach((shader, shader_name) => {\n\t\t\t\tconst uniform_name = `texture_${shader_name}`;\n\t\t\t\tconst uniform_value = {value: null};\n\t\t\t\tuniforms[uniform_name] = uniform_value;\n\t\t\t\tif (this._render_material) {\n\t\t\t\t\tCoreMaterial.init_custom_material_uniforms(this._render_material, uniform_name, uniform_value);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\t// this._render_material.extensions.drawBuffers = true;\n\t\tthis.assign_render_material();\n\t}\n}\n","/**\n * @author yomboprime https://github.com/yomboprime\n *\n * GPUComputationRenderer, based on SimulationRenderer by zz85\n *\n * The GPUComputationRenderer uses the concept of variables. These variables are RGBA float textures that hold 4 floats\n * for each compute element (texel)\n *\n * Each variable has a fragment shader that defines the computation made to obtain the variable in question.\n * You can use as many variables you need, and make dependencies so you can use textures of other variables in the shader\n * (the sampler uniforms are added automatically) Most of the variables will need themselves as dependency.\n *\n * The renderer has actually two render targets per variable, to make ping-pong. Textures from the current frame are used\n * as inputs to render the textures of the next frame.\n *\n * The render targets of the variables can be used as input textures for your visualization shaders.\n *\n * Variable names should be valid identifiers and should not collide with THREE GLSL used identifiers.\n * a common approach could be to use 'texture' prefixing the variable name; i.e texturePosition, textureVelocity...\n *\n * The size of the computation (sizeX * sizeY) is defined as 'resolution' automatically in the shader. For example:\n * #DEFINE resolution vec2( 1024.0, 1024.0 )\n *\n * -------------\n *\n * Basic use:\n *\n * // Initialization...\n *\n * // Create computation renderer\n * var gpuCompute = new GPUComputationRenderer( 1024, 1024, renderer );\n *\n * // Create initial state float textures\n * var pos0 = gpuCompute.createTexture();\n * var vel0 = gpuCompute.createTexture();\n * // and fill in here the texture data...\n *\n * // Add texture variables\n * var velVar = gpuCompute.addVariable( \"textureVelocity\", fragmentShaderVel, pos0 );\n * var posVar = gpuCompute.addVariable( \"texturePosition\", fragmentShaderPos, vel0 );\n *\n * // Add variable dependencies\n * gpuCompute.setVariableDependencies( velVar, [ velVar, posVar ] );\n * gpuCompute.setVariableDependencies( posVar, [ velVar, posVar ] );\n *\n * // Add custom uniforms\n * velVar.material.uniforms.time = { value: 0.0 };\n *\n * // Check for completeness\n * var error = gpuCompute.init();\n * if ( error !== null ) {\n *\t\tconsole.error( error );\n  * }\n *\n *\n * // In each frame...\n *\n * // Compute!\n * gpuCompute.compute();\n *\n * // Update texture uniforms in your visualization materials with the gpu renderer output\n * myMaterial.uniforms.myTexture.value = gpuCompute.getCurrentRenderTarget( posVar ).texture;\n *\n * // Do your rendering\n * renderer.render( myScene, myCamera );\n *\n * -------------\n *\n * Also, you can use utility functions to create ShaderMaterial and perform computations (rendering between textures)\n * Note that the shaders can have multiple input textures.\n *\n * var myFilter1 = gpuCompute.createShaderMaterial( myFilterFragmentShader1, { theTexture: { value: null } } );\n * var myFilter2 = gpuCompute.createShaderMaterial( myFilterFragmentShader2, { theTexture: { value: null } } );\n *\n * var inputTexture = gpuCompute.createTexture();\n *\n * // Fill in here inputTexture...\n *\n * myFilter1.uniforms.theTexture.value = inputTexture;\n *\n * var myRenderTarget = gpuCompute.createRenderTarget();\n * myFilter2.uniforms.theTexture.value = myRenderTarget.texture;\n *\n * var outputRenderTarget = gpuCompute.createRenderTarget();\n *\n * // Now use the output texture where you want:\n * myMaterial.uniforms.map.value = outputRenderTarget.texture;\n *\n * // And compute each frame, before rendering to screen:\n * gpuCompute.doRenderTarget( myFilter1, myRenderTarget );\n * gpuCompute.doRenderTarget( myFilter2, outputRenderTarget );\n *\n *\n *\n * @param {int} sizeX Computation problem size is always 2d: sizeX * sizeY elements.\n * @param {int} sizeY Computation problem size is always 2d: sizeX * sizeY elements.\n * @param {WebGLRenderer} renderer The renderer\n*/\n\nimport {Camera} from 'three/src/cameras/Camera'\nimport {ClampToEdgeWrapping, FloatType, HalfFloatType, NearestFilter, RGBAFormat} from 'three/src/constants'\nimport {DataTexture} from 'three/src/textures/DataTexture'\nimport {Mesh} from 'three/src/objects/Mesh'\nimport {PlaneBufferGeometry} from 'three/src/geometries/PlaneGeometry'\nimport {Scene} from 'three/src/scenes/Scene'\nimport {ShaderMaterial} from 'three/src/materials/ShaderMaterial'\nimport {WebGLRenderTarget} from 'three/src/renderers/WebGLRenderTarget'\n// const THREE = {Camera, ClampToEdgeWrapping, FloatType, HalfFloatType, NearestFilter, RGBAFormat, DataTexture, mesh, PlaneBufferGeometry, Scene, ShaderMaterial, WebGLRenderTarget}\n\nvar GPUComputationRenderer = function ( sizeX, sizeY, renderer ) {\n\n\tthis.variables = [];\n\n\tthis.currentTextureIndex = 0;\n\n\tvar scene = new Scene();\n\n\tvar camera = new Camera();\n\tcamera.position.z = 1;\n\n\tvar passThruUniforms = {\n\t\tpassThruTexture: { value: null }\n\t};\n\n\tvar passThruShader = createShaderMaterial( getPassThroughFragmentShader(), passThruUniforms );\n\n\tvar mesh = new Mesh( new PlaneBufferGeometry( 2, 2 ), passThruShader );\n\tscene.add( mesh );\n\n\n\tthis.addVariable = function ( variableName, computeFragmentShader, initialValueTexture ) {\n\n\t\tvar material = this.createShaderMaterial( computeFragmentShader );\n\n\t\tvar variable = {\n\t\t\tname: variableName,\n\t\t\tinitialValueTexture: initialValueTexture,\n\t\t\tmaterial: material,\n\t\t\tdependencies: null,\n\t\t\trenderTargets: [],\n\t\t\twrapS: null,\n\t\t\twrapT: null,\n\t\t\tminFilter: NearestFilter,\n\t\t\tmagFilter: NearestFilter\n\t\t};\n\n\t\tthis.variables.push( variable );\n\n\t\treturn variable;\n\n\t};\n\n\tthis.setVariableDependencies = function ( variable, dependencies ) {\n\n\t\tvariable.dependencies = dependencies;\n\n\t};\n\n\tthis.init = function () {\n\n\t\tif ( ! renderer.capabilities.isWebGL2 &&\n\t\t\t ! renderer.extensions.get( \"OES_texture_float\" ) ) {\n\n\t\t\treturn \"No OES_texture_float support for float textures.\";\n\n\t\t}\n\n\t\tif ( renderer.capabilities.maxVertexTextures === 0 ) {\n\n\t\t\treturn \"No support for vertex shader textures.\";\n\n\t\t}\n\n\t\tfor ( var i = 0; i < this.variables.length; i ++ ) {\n\n\t\t\tvar variable = this.variables[ i ];\n\n\t\t\t// Creates rendertargets and initialize them with input texture\n\t\t\tvariable.renderTargets[ 0 ] = this.createRenderTarget( sizeX, sizeY, variable.wrapS, variable.wrapT, variable.minFilter, variable.magFilter );\n\t\t\tvariable.renderTargets[ 1 ] = this.createRenderTarget( sizeX, sizeY, variable.wrapS, variable.wrapT, variable.minFilter, variable.magFilter );\n\t\t\tthis.renderTexture( variable.initialValueTexture, variable.renderTargets[ 0 ] );\n\t\t\tthis.renderTexture( variable.initialValueTexture, variable.renderTargets[ 1 ] );\n\n\t\t\t// Adds dependencies uniforms to the ShaderMaterial\n\t\t\tvar material = variable.material;\n\t\t\tvar uniforms = material.uniforms;\n\t\t\tif ( variable.dependencies !== null ) {\n\n\t\t\t\tfor ( var d = 0; d < variable.dependencies.length; d ++ ) {\n\n\t\t\t\t\tvar depVar = variable.dependencies[ d ];\n\n\t\t\t\t\tif ( depVar.name !== variable.name ) {\n\n\t\t\t\t\t\t// Checks if variable exists\n\t\t\t\t\t\tvar found = false;\n\t\t\t\t\t\tfor ( var j = 0; j < this.variables.length; j ++ ) {\n\n\t\t\t\t\t\t\tif ( depVar.name === this.variables[ j ].name ) {\n\n\t\t\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( ! found ) {\n\n\t\t\t\t\t\t\treturn \"Variable dependency not found. Variable=\" + variable.name + \", dependency=\" + depVar.name;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tuniforms[ depVar.name ] = { value: null };\n\n\t\t\t\t\t// material.fragmentShader = \"\\nuniform sampler2D \" + depVar.name + \";\\n\" + material.fragmentShader;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.currentTextureIndex = 0;\n\n\t\treturn null;\n\n\t};\n\n\tthis.compute = function () {\n\n\t\tvar currentTextureIndex = this.currentTextureIndex;\n\t\tvar nextTextureIndex = this.currentTextureIndex === 0 ? 1 : 0;\n\n\t\tfor ( var i = 0, il = this.variables.length; i < il; i ++ ) {\n\n\t\t\tvar variable = this.variables[ i ];\n\n\t\t\t// Sets texture dependencies uniforms\n\t\t\tif ( variable.dependencies !== null ) {\n\n\t\t\t\tvar uniforms = variable.material.uniforms;\n\t\t\t\tfor ( var d = 0, dl = variable.dependencies.length; d < dl; d ++ ) {\n\n\t\t\t\t\tvar depVar = variable.dependencies[ d ];\n\n\t\t\t\t\tuniforms[ depVar.name ].value = depVar.renderTargets[ currentTextureIndex ].texture;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// Performs the computation for this variable\n\t\t\tthis.doRenderTarget( variable.material, variable.renderTargets[ nextTextureIndex ] );\n\n\t\t}\n\n\t\tthis.currentTextureIndex = nextTextureIndex;\n\n\t};\n\n\tthis.getCurrentRenderTarget = function ( variable ) {\n\n\t\treturn variable.renderTargets[ this.currentTextureIndex ];\n\n\t};\n\n\tthis.getAlternateRenderTarget = function ( variable ) {\n\n\t\treturn variable.renderTargets[ this.currentTextureIndex === 0 ? 1 : 0 ];\n\n\t};\n\n\tfunction addResolutionDefine( materialShader ) {\n\n\t\tmaterialShader.defines.resolution = 'vec2( ' + sizeX.toFixed( 1 ) + ', ' + sizeY.toFixed( 1 ) + \" )\";\n\n\t}\n\tthis.addResolutionDefine = addResolutionDefine;\n\n\n\t// The following functions can be used to compute things manually\n\n\tfunction createShaderMaterial( computeFragmentShader, uniforms ) {\n\n\t\tuniforms = uniforms || {};\n\n\t\tvar material = new ShaderMaterial( {\n\t\t\tuniforms: uniforms,\n\t\t\tvertexShader: getPassThroughVertexShader(),\n\t\t\tfragmentShader: computeFragmentShader\n\t\t} );\n\n\t\taddResolutionDefine( material );\n\n\t\treturn material;\n\n\t}\n\n\tthis.createShaderMaterial = createShaderMaterial;\n\n\tthis.createRenderTarget = function ( sizeXTexture, sizeYTexture, wrapS, wrapT, minFilter, magFilter ) {\n\n\t\tsizeXTexture = sizeXTexture || sizeX;\n\t\tsizeYTexture = sizeYTexture || sizeY;\n\n\t\twrapS = wrapS || ClampToEdgeWrapping;\n\t\twrapT = wrapT || ClampToEdgeWrapping;\n\n\t\tminFilter = minFilter || NearestFilter;\n\t\tmagFilter = magFilter || NearestFilter;\n\n\t\tvar renderTarget = new WebGLRenderTarget( sizeXTexture, sizeYTexture, {\n\t\t\twrapS: wrapS,\n\t\t\twrapT: wrapT,\n\t\t\tminFilter: minFilter,\n\t\t\tmagFilter: magFilter,\n\t\t\tformat: RGBAFormat,\n\t\t\ttype: ( /(iPad|iPhone|iPod)/g.test( navigator.userAgent ) ) ? HalfFloatType : FloatType,\n\t\t\tstencilBuffer: false,\n\t\t\tdepthBuffer: false\n\t\t} );\n\n\t\treturn renderTarget;\n\n\t};\n\n\tthis.createTexture = function () {\n\n\t\tvar data = new Float32Array( sizeX * sizeY * 4 );\n\t\treturn new DataTexture( data, sizeX, sizeY, RGBAFormat, FloatType );\n\n\t};\n\n\tthis.renderTexture = function ( input, output ) {\n\n\t\t// Takes a texture, and render out in rendertarget\n\t\t// input = Texture\n\t\t// output = RenderTarget\n\n\t\tpassThruUniforms.passThruTexture.value = input;\n\n\t\tthis.doRenderTarget( passThruShader, output );\n\n\t\tpassThruUniforms.passThruTexture.value = null;\n\n\t};\n\n\tthis.doRenderTarget = function ( material, output ) {\n\n\t\tvar currentRenderTarget = renderer.getRenderTarget();\n\n\t\tmesh.material = material;\n\t\trenderer.setRenderTarget( output );\n\t\trenderer.render( scene, camera );\n\t\tmesh.material = passThruShader;\n\n\t\trenderer.setRenderTarget( currentRenderTarget );\n\n\t};\n\n\t// Shaders\n\n\tfunction getPassThroughVertexShader() {\n\n\t\treturn\t\"void main()\t{\\n\" +\n\t\t\t\t\"\\n\" +\n\t\t\t\t\"\tgl_Position = vec4( position, 1.0 );\\n\" +\n\t\t\t\t\"\\n\" +\n\t\t\t\t\"}\\n\";\n\n\t}\n\n\tfunction getPassThroughFragmentShader() {\n\n\t\treturn\t\"uniform sampler2D passThruTexture;\\n\" +\n\t\t\t\t\"\\n\" +\n\t\t\t\t\"void main() {\\n\" +\n\t\t\t\t\"\\n\" +\n\t\t\t\t\"\tvec2 uv = gl_FragCoord.xy / resolution.xy;\\n\" +\n\t\t\t\t\"\\n\" +\n\t\t\t\t\"\tgl_FragColor = texture2D( passThruTexture, uv );\\n\" +\n\t\t\t\t\"\\n\" +\n\t\t\t\t\"}\\n\";\n\n\t}\n\n};\n\nexport { GPUComputationRenderer };\n","import {Vector2} from 'three/src/math/Vector2';\n\nimport {MathUtils} from 'three/src/math/MathUtils';\nimport {InstancedBufferAttribute} from 'three/src/core/InstancedBufferAttribute';\nimport {DataTexture} from 'three/src/textures/DataTexture';\nimport {BufferAttribute} from 'three/src/core/BufferAttribute';\n\n// import {BaseNodeSop} from '../_Base'\n\n// import {CoreConstant} from '../../../../../Core/Geometry/Constant'\n\nimport {CoreGroup} from '../../../../../core/geometry/Group';\nimport {CoreMath} from '../../../../../core/math/_Module';\n\n// import computeShaderPosition from 'src/Engine/Node/Gl/Assembler/Template/Particle/Position.glsl'\n// import computeShaderVelocity from 'src/Engine/Node/Gl/Assembler/Template/Particle/Particle.v.glsl'\n// import particleVertexShader from 'src/Engine/Node/Gl/Assembler/Template/Particle/Particle.vert.glsl'\n// import particleFragmentShader from 'src/Engine/Node/Gl/Assembler/Template/Particle/Particle.frag.glsl'\nimport {GlobalsTextureHandler} from '../../../gl/code/globals/Texture';\nimport {GPUComputationRenderer} from './GPUComputationRenderer';\nimport {ParticlesSystemGpuSopNode} from '../../ParticlesSystemGpu';\nimport {WebGLRenderer} from 'three/src/renderers/WebGLRenderer';\nimport {WebGLRenderTarget} from 'three/src/renderers/WebGLRenderTarget';\nimport {ShaderMaterial} from 'three/src/materials/ShaderMaterial';\nimport {Poly} from '../../../../Poly';\nimport {CorePoint} from '../../../../../core/geometry/Point';\nimport {ShaderName} from '../../../utils/shaders/ShaderName';\n\ninterface GPUComputationRendererVariable {\n\tname: string;\n\trenderTargets: WebGLRenderTarget[];\n\tmaterial: ShaderMaterial;\n}\ninterface GPUComputationRenderer {\n\tnew (x: number, y: number, renderer: WebGLRenderer): GPUComputationRenderer;\n\tcompute(): void;\n\tinit(): string | null;\n\taddVariable(name: string, fragment_shader: string, variable: DataTexture): GPUComputationRendererVariable;\n\tsetVariableDependencies(variable: GPUComputationRendererVariable, vars: GPUComputationRendererVariable[]): void;\n\trenderTexture(texture: DataTexture, render_target: WebGLRenderTarget): void;\n\tcreateTexture(): DataTexture;\n\tgetCurrentRenderTarget(variable: GPUComputationRendererVariable): WebGLRenderTarget;\n}\n\nexport class ParticlesSystemGpuComputeController {\n\tprotected _gpu_compute: GPUComputationRenderer | undefined;\n\tprotected _simulation_restart_required: boolean = false;\n\n\tprotected _renderer: WebGLRenderer | undefined;\n\t// private _particles_group: CoreGroup\n\n\tprotected _particles_core_group: CoreGroup | undefined;\n\tprotected _points: CorePoint[] = [];\n\n\tprivate variables_by_name: Map<ShaderName, GPUComputationRendererVariable> = new Map();\n\tprivate _created_textures_by_name: Map<ShaderName, DataTexture> = new Map();\n\tprivate _shaders_by_name: Map<ShaderName, string> | undefined;\n\tprotected _last_simulated_frame: number | undefined;\n\t// private _use_instancing: boolean = false\n\n\t// private _param_auto_textures_size: boolean;\n\t// private _param_max_textures_size: Vector2;\n\t// private _param_textures_sizes: Vector2;\n\tprivate _used_textures_size: Vector2 = new Vector2();\n\n\tconstructor(private node: ParticlesSystemGpuSopNode) {}\n\n\t// protected _create_gpu_compute_params() {\n\t// \tthis.self.within_param_folder('setup', () => {\n\t// \t\tthis.self.add_param(ParamType.INTEGER, 'start_frame', 1, {\n\t// \t\t\trange: [1, 100],\n\t// \t\t});\n\t// \t\tthis.self.add_param(ParamType.TOGGLE, 'auto_textures_size', 1);\n\t// \t\tthis.self.add_param(ParamType.VECTOR2, 'max_textures_size', [1024, 1024], {\n\t// \t\t\tvisible_if: {auto_textures_size: 1},\n\t// \t\t});\n\t// \t\tthis.self.add_param(ParamType.VECTOR2, 'textures_size', [64, 64], {\n\t// \t\t\tvisible_if: {auto_textures_size: 0},\n\t// \t\t});\n\t// \t\tthis.self.add_param(ParamType.BUTTON, 'reset', '', {\n\t// \t\t\tcallback: this._reset_gpu_compute_and_set_dirty.bind(this),\n\t// \t\t});\n\t// \t});\n\t// \t// this.self.add_param(ParamType.BUTTON, 'force_compute', '', {callback: this._force_compute.bind(this)})\n\t// }\n\n\tset_shaders_by_name(shaders_by_name: Map<ShaderName, string>) {\n\t\tthis._shaders_by_name = shaders_by_name;\n\t\tthis.reset_gpu_compute();\n\t}\n\tasync init(core_group: CoreGroup) {\n\t\tthis.init_particle_group_points(core_group);\n\t\tawait this.create_gpu_compute();\n\t}\n\n\tgetCurrentRenderTarget(shader_name: ShaderName) {\n\t\tconst variable = this.variables_by_name.get(shader_name);\n\t\tif (variable) {\n\t\t\treturn this._gpu_compute?.getCurrentRenderTarget(variable);\n\t\t}\n\t}\n\n\tinit_particle_group_points(core_group: CoreGroup) {\n\t\tthis.reset_gpu_compute();\n\n\t\tif (!core_group) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis._particles_core_group = core_group;\n\t\t// this._particles_group_objects = []; //this._particles_core_group.objects()\n\n\t\t// in order to have proper copy on each children, I need to do .push for each\n\t\t// and not just my_array = group.children, as the array would then be empty\n\t\t// after have done .set_group(group)\n\t\t// I may need to rethink the whole\n\t\t// for (let child of this._particles_core_group.objects()) {\n\t\t// \tthis._particles_group_objects.push(child);\n\t\t// }\n\t\t// this._particles_core_group = new CoreGroup(this._particles_group)\n\t\tthis._points = this._get_points() || [];\n\t}\n\n\tcompute_similation_if_required() {\n\t\tconst frame = this.node.scene.frame;\n\t\tconst start_frame: number = this.node.pv.start_frame;\n\t\tif (frame >= start_frame) {\n\t\t\tif (this._last_simulated_frame == null) {\n\t\t\t\tthis._last_simulated_frame = start_frame - 1;\n\t\t\t}\n\t\t\tif (frame > this._last_simulated_frame) {\n\t\t\t\tthis._compute_simulation(frame - this._last_simulated_frame);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate _compute_simulation(count = 1) {\n\t\tif (!this._gpu_compute) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.update_simulation_material_uniforms();\n\n\t\tfor (let i = 0; i < count; i++) {\n\t\t\tthis._gpu_compute.compute();\n\t\t}\n\t\tthis.node.render_controller.update_render_material_uniforms();\n\t\tthis._last_simulated_frame = this.node.scene.frame;\n\n\t\t// this._renderer.render(this._gpu_scene, this._gpu_camera)\n\t}\n\n\tasync create_gpu_compute() {\n\t\tif (this.node.pv.auto_textures_size) {\n\t\t\tconst nearest_power_of_two = CoreMath.nearestPower2(Math.sqrt(this._points.length));\n\t\t\tthis._used_textures_size.x = Math.min(nearest_power_of_two, this.node.pv.max_textures_size.x);\n\t\t\tthis._used_textures_size.y = Math.min(nearest_power_of_two, this.node.pv.max_textures_size.y);\n\t\t} else {\n\t\t\tif (\n\t\t\t\t!(\n\t\t\t\t\tMathUtils.isPowerOfTwo(this.node.pv.textures_size.x) &&\n\t\t\t\t\tMathUtils.isPowerOfTwo(this.node.pv.textures_size.y)\n\t\t\t\t)\n\t\t\t) {\n\t\t\t\tthis.node.states.error.set('texture size must be a power of 2');\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst max_particles_count = this.node.pv.textures_size.x * this.node.pv.textures_size.y;\n\t\t\tif (this._points.length > max_particles_count) {\n\t\t\t\tthis.node.states.error.set(\n\t\t\t\t\t`max particles is set to (${this.node.pv.textures_size.x}x${this.node.pv.textures_size.y}=) ${max_particles_count}`\n\t\t\t\t);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tthis._used_textures_size.copy(this.node.pv.textures_size);\n\t\t}\n\n\t\tthis.node.states.time_dependent.force_time_dependent();\n\t\tthis._init_particles_uvs();\n\t\t// we need to recreate the material if the texture allocation changes\n\t\tthis.node.render_controller.reset_render_material();\n\t\t// await this.node.render_controller.init_render_material();\n\n\t\tconst renderer = await Poly.instance().renderers_controller.wait_for_renderer(); //new WebGLRenderer();\n\t\tif (renderer) {\n\t\t\tthis._renderer = renderer;\n\t\t} else {\n\t\t\tthis.node.states.error.set('no renderer found');\n\t\t}\n\t\t// console.log(this._renderer.extensions, this._renderer.capabilities)\n\t\t// if(!this._renderer.extensions.get( 'WEBGL_draw_buffers' )){\n\t\t// \tthis.self.set_error(\"this operator requires the browser extension WEBGL_draw_buffers\")\n\t\t// \talert(\"no extension found\")\n\t\t// \treturn\n\t\t// }\n\t\t// this._renderer = new WebGLRenderer();\n\t\t// this._gpu_scene = new Scene()\n\t\t// this._gpu_camera = new Camera()\n\t\t// this._renderer.setPixelRatio( window.devicePixelRatio );\n\t\t// this._renderer.setSize( this.node.pv.textures_size.x, this.node.pv.textures_size.y );\n\n\t\tconst compute = new GPUComputationRenderer(\n\t\t\tthis._used_textures_size.x,\n\t\t\tthis._used_textures_size.y,\n\t\t\tthis._renderer\n\t\t);\n\t\tthis._gpu_compute = (<unknown>compute) as GPUComputationRenderer;\n\n\t\tif (!this._gpu_compute) {\n\t\t\tthis.node.states.error.set('failed to create the GPUComputationRenderer');\n\t\t\treturn;\n\t\t}\n\n\t\tthis._last_simulated_frame = undefined;\n\n\t\t// document.body.style = ''\n\t\t// document.body.appendChild( renderer.domElement );\n\n\t\tthis.variables_by_name.forEach((variable, shader_name) => {\n\t\t\tvariable.renderTargets[0].dispose();\n\t\t\tvariable.renderTargets[1].dispose();\n\t\t\tthis.variables_by_name.delete(shader_name);\n\t\t});\n\t\t// for (let shader_name of Object.keys(this._shaders_by_name)) {\n\t\tconst all_variables: GPUComputationRendererVariable[] = [];\n\t\tthis._shaders_by_name?.forEach((shader, shader_name) => {\n\t\t\tif (this._gpu_compute) {\n\t\t\t\tconst variable = this._gpu_compute.addVariable(\n\t\t\t\t\t`texture_${shader_name}`,\n\t\t\t\t\tshader,\n\t\t\t\t\tthis._created_textures_by_name.get(shader_name)!\n\t\t\t\t);\n\t\t\t\tthis.variables_by_name.set(shader_name, variable);\n\t\t\t\tall_variables.push(variable);\n\t\t\t}\n\t\t});\n\n\t\t// this._gpu_compute.setVariableDependencies( this.var_v, [ this.var_P, this.var_v ] );\n\t\t// for (let shader_name of Object.keys(this._shaders_by_name)) {\n\t\tthis.variables_by_name?.forEach((variable, shader_name) => {\n\t\t\tif (this._gpu_compute) {\n\t\t\t\tthis._gpu_compute.setVariableDependencies(\n\t\t\t\t\tvariable,\n\t\t\t\t\tall_variables // currently all depend on all\n\t\t\t\t);\n\t\t\t}\n\t\t});\n\n\t\tthis._create_texture_render_targets();\n\t\tthis._fill_textures();\n\t\tthis.create_simulation_material_uniforms();\n\n\t\tvar error = this._gpu_compute.init();\n\n\t\tif (error !== null) {\n\t\t\tconsole.error(error);\n\t\t\tthis.node.states.error.set(error);\n\t\t}\n\t}\n\n\tprivate create_simulation_material_uniforms() {\n\t\tthis.variables_by_name.forEach((variable, shader_name) => {\n\t\t\tconst uniforms = variable.material.uniforms;\n\t\t\tuniforms['frame'] = {value: this.node.scene.frame};\n\n\t\t\tfor (let param_config of this.node.assembler_controller.assembler.param_configs()) {\n\t\t\t\tuniforms[param_config.uniform_name] = param_config.uniform;\n\t\t\t}\n\t\t});\n\t}\n\tprivate update_simulation_material_uniforms() {\n\t\tthis.variables_by_name.forEach((variable, shader_name) => {\n\t\t\tvariable.material.uniforms['frame'].value = this.node.scene.frame;\n\t\t});\n\t}\n\n\tprivate _init_particles_uvs() {\n\t\t// var uvs = new Float32Array( this.node.pv.textures_size.x * this.node.pv.textures_size.y * 2 );\n\t\tvar uvs = new Float32Array(this._points.length * 2);\n\t\t// const rows_count = Math.ceil(Math.min(\n\t\t// \tthis.node.pv.textures_size.y, (points.length / this.node.pv.textures_size.y)\n\t\t// ))\n\t\t// const columns_count = Math.ceil(Math.min(\n\t\t// \tthis.node.pv.textures_size.x, (points.length / rows_count)\n\t\t// ))\n\t\tlet p = 0;\n\t\tvar cmptr = 0;\n\t\tfor (var j = 0; j < this._used_textures_size.x; j++) {\n\t\t\tfor (var i = 0; i < this._used_textures_size.y; i++) {\n\t\t\t\tuvs[p++] = i / (this._used_textures_size.x - 1);\n\t\t\t\tuvs[p++] = j / (this._used_textures_size.y - 1);\n\n\t\t\t\tcmptr += 2;\n\t\t\t\tif (cmptr >= uvs.length) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tconst uv_attrib_name = GlobalsTextureHandler.UV_ATTRIB;\n\t\tif (this._particles_core_group) {\n\t\t\tfor (let core_geometry of this._particles_core_group.core_geometries()) {\n\t\t\t\t// geometry.setAttribute( 'position', new BufferAttribute( positions, 3 ) );\n\t\t\t\tconst geometry = core_geometry.geometry();\n\t\t\t\tconst attribute_constructor = core_geometry.marked_as_instance()\n\t\t\t\t\t? InstancedBufferAttribute\n\t\t\t\t\t: BufferAttribute;\n\t\t\t\tgeometry.setAttribute(uv_attrib_name, new attribute_constructor(uvs, 2));\n\t\t\t}\n\t\t}\n\t}\n\n\tcreated_textures_by_name() {\n\t\treturn this._created_textures_by_name;\n\t}\n\n\tprivate _fill_textures() {\n\t\tthis._created_textures_by_name.forEach((texture, shader_name) => {\n\t\t\tconst assembler = this.node.assembler_controller.assembler;\n\t\t\tconst texture_allocations_controller = assembler.texture_allocations_controller;\n\n\t\t\tconst texture_allocation = texture_allocations_controller.allocation_for_shader_name(shader_name);\n\t\t\tif (!texture_allocation) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tconst texture_variables = texture_allocation.variables;\n\t\t\tif (!texture_variables) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst array = texture.image.data;\n\n\t\t\tfor (let texture_variable of texture_variables) {\n\t\t\t\tconst texture_position = texture_variable.position;\n\t\t\t\tlet variable_name = texture_variable.name;\n\t\t\t\t// if(this._use_instancing){\n\t\t\t\t// \tvariable_name = GlobalsTextureHandler.variable_name_to_instance_attrib(variable_name)\n\t\t\t\t// }\n\n\t\t\t\tconst first_point = this._points[0];\n\t\t\t\tif (first_point) {\n\t\t\t\t\tconst has_attrib = first_point.has_attrib(variable_name);\n\t\t\t\t\tif (has_attrib) {\n\t\t\t\t\t\tconst attrib_size = first_point.attrib_size(variable_name);\n\t\t\t\t\t\tlet cmptr = texture_position;\n\t\t\t\t\t\tfor (let point of this._points) {\n\t\t\t\t\t\t\tif (attrib_size == 1) {\n\t\t\t\t\t\t\t\tconst val = point.attrib_value(variable_name);\n\t\t\t\t\t\t\t\tarray[cmptr] = val;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tpoint.attrib_value(variable_name).toArray(array, cmptr);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcmptr += 4;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\t// var posArray = texture_P.image.data;\n\t\t// var velArray = texture_v.image.data;\n\n\t\t// let cmptr = 0\n\t\t// for(let point of points){\n\t\t// \tpoint.position().toArray(posArray, cmptr)\n\t\t// \tposArray[ cmptr + 3 ] = 1;\n\t\t// \tcmptr += 4\n\t\t// }\n\t}\n\n\treset_gpu_compute() {\n\t\tthis._gpu_compute = undefined;\n\t\tthis._simulation_restart_required = true;\n\t}\n\tset_restart_not_required() {\n\t\tthis._simulation_restart_required = false;\n\t}\n\treset_gpu_compute_and_set_dirty() {\n\t\tthis.reset_gpu_compute();\n\t\tthis.node.set_dirty();\n\t}\n\treset_particle_groups() {\n\t\t// this._particles_group = null\n\t\t// this._particles_group_objects = [];\n\t\tthis._particles_core_group = undefined;\n\t}\n\tget initialized(): boolean {\n\t\treturn this._particles_core_group != null && this._gpu_compute != null;\n\t}\n\t// private _force_compute(){\n\t// \tthis.self.run_assembler()\n\t// }\n\n\tprivate _create_texture_render_targets() {\n\t\tthis._created_textures_by_name.forEach((texture, shader_name) => {\n\t\t\ttexture.dispose();\n\t\t});\n\n\t\tthis._created_textures_by_name.clear();\n\t\tthis.variables_by_name.forEach((texture_variable, shader_name) => {\n\t\t\tif (this._gpu_compute) {\n\t\t\t\tthis._created_textures_by_name.set(shader_name, this._gpu_compute.createTexture());\n\t\t\t}\n\t\t});\n\t}\n\trestart_simulation_if_required() {\n\t\tif (this._simulation_restart_required) {\n\t\t\tthis._restart_simulation();\n\t\t}\n\t}\n\tprivate _restart_simulation() {\n\t\tthis._last_simulated_frame = undefined;\n\n\t\tthis._create_texture_render_targets();\n\t\tconst points = this._get_points(); // TODO: typescript - not sure that's right\n\t\tif (!points) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis._fill_textures();\n\n\t\t// for (let variable_name of Object.keys(this.variables_by_name)) {\n\t\tthis.variables_by_name.forEach((variable, shader_name) => {\n\t\t\tconst texture = this._created_textures_by_name.get(shader_name);\n\t\t\tif (this._gpu_compute && texture) {\n\t\t\t\tthis._gpu_compute.renderTexture(texture, variable.renderTargets[0]);\n\t\t\t\tthis._gpu_compute.renderTexture(texture, variable.renderTargets[1]);\n\t\t\t}\n\t\t});\n\t}\n\n\t// if we have a mix of marked_as_instance and non marked_as_instance\n\t// we take all geos that are the type that comes first\n\tprivate _get_points() {\n\t\tif (!this._particles_core_group) {\n\t\t\treturn;\n\t\t}\n\n\t\tlet geometries = this._particles_core_group.core_geometries();\n\t\tconst first_geometry = geometries[0];\n\t\tif (first_geometry) {\n\t\t\tconst type = first_geometry.marked_as_instance();\n\t\t\t// this._use_instancing = type\n\t\t\tconst selected_geometries = [];\n\t\t\tfor (let geometry of geometries) {\n\t\t\t\tif (geometry.marked_as_instance() == type) {\n\t\t\t\t\tselected_geometries.push(geometry);\n\t\t\t\t}\n\t\t\t}\n\t\t\tconst points = [];\n\t\t\tfor (let geometry of selected_geometries) {\n\t\t\t\tfor (let point of geometry.points()) {\n\t\t\t\t\tpoints.push(point);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn points;\n\t\t} else {\n\t\t\treturn [];\n\t\t}\n\t}\n}\n","import {TypedSopNode} from './_Base';\n// import {ParamType} from '../../../Engine/Param/_Module'\n\n// import {Lifespan} from './Concerns/ParticlesSystemGPU/Lifespan';\n// import {GPUCompute} from './Concerns/ParticlesSystemGPU/GPUCompute';\n// import {RenderMaterial} from './Concerns/ParticlesSystemGPU/RenderMaterial';\n// import {ParticleShaderBuilder} from './Concerns/ParticlesSystemGPU/ParticleShaderBuilder'\n// import {AssemblerOwner} from '../../../Engine/Node/Gl/Assembler/Owner';\nimport {ShaderAssemblerParticles} from '../gl/code/assemblers/particles/Particles';\nimport {GlobalsTextureHandler} from '../gl/code/globals/Texture';\n\n// SPECS:\n// - simulation shaders should update the particles at any frame, and resimulate accordingly when at later frames\n// - render material should update at any frame, without having to resimulate\n// - changing the input will recompute, when on first frame only (otherwise an animated geo could make it recompute all the time)\n\n// AssemblerOwner(\n// \tRenderMaterial(\n// \tLifespan(\n// \tGPUCompute(\nimport {InputCloneMode} from '../../poly/InputCloneMode';\nimport {BaseNodeType} from '../_Base';\nimport {BaseParamType} from '../../params/_Base';\nimport {NodeContext} from '../../poly/NodeContext';\nimport {CoreGroup} from '../../../core/geometry/Group';\nimport {GlAssemblerController} from '../gl/code/Controller';\nimport {MaterialsObjNode} from '../obj/Materials';\nimport {GlNodeChildrenMap} from '../../poly/registers/Gl';\nimport {BaseGlNodeType} from '../gl/_Base';\nimport {ParticlesSystemGpuRenderController} from './utils/ParticlesSystemGPU/RenderController';\nimport {ParticlesSystemGpuComputeController} from './utils/ParticlesSystemGPU/GPUComputeController';\n\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nimport {ShaderName} from '../utils/shaders/ShaderName';\nimport {GlNodeFinder} from '../gl/code/utils/NodeFinder';\nimport {PointsBuilderMatNode} from '../mat/PointsBuilder';\nimport {ConstantGlNode} from '../gl/Constant';\nclass ParticlesSystemGpuSopParamsConfig extends NodeParamsConfig {\n\t// gpu compute\n\tstart_frame = ParamConfig.FLOAT(1, {range: [1, 100]});\n\tauto_textures_size = ParamConfig.BOOLEAN(1);\n\tmax_textures_size = ParamConfig.VECTOR2([1024, 1024], {visible_if: {auto_textures_size: 1}});\n\ttextures_size = ParamConfig.VECTOR2([64, 64], {visible_if: {auto_textures_size: 0}});\n\treset = ParamConfig.BUTTON(null, {\n\t\tcallback: (node: BaseNodeType, param: BaseParamType) => {\n\t\t\tParticlesSystemGpuSopNode.PARAM_CALLBACK_reset(node as ParticlesSystemGpuSopNode);\n\t\t},\n\t});\n\n\t// render\n\t// this.self.within_param_folder(\"setup\", () => {\n\tmaterial = ParamConfig.OPERATOR_PATH('', {\n\t\tnode_selection: {\n\t\t\tcontext: NodeContext.MAT,\n\t\t},\n\t\tdependent_on_found_node: false,\n\t});\n}\nconst ParamsConfig = new ParticlesSystemGpuSopParamsConfig();\nexport class ParticlesSystemGpuSopNode extends TypedSopNode<ParticlesSystemGpuSopParamsConfig> {\n\tparams_config = ParamsConfig;\n\tstatic type() {\n\t\treturn 'particles_system_gpu';\n\t}\n\tprotected _assembler_controller: GlAssemblerController<ShaderAssemblerParticles> = new GlAssemblerController<\n\t\tShaderAssemblerParticles\n\t>(this, ShaderAssemblerParticles);\n\tget assembler_controller() {\n\t\treturn this._assembler_controller;\n\t}\n\n\tpublic readonly gpu_controller = new ParticlesSystemGpuComputeController(this);\n\tpublic readonly render_controller = new ParticlesSystemGpuRenderController(this);\n\n\tstatic require_webgl2() {\n\t\treturn true;\n\t}\n\tstatic PARAM_CALLBACK_reset(node: ParticlesSystemGpuSopNode) {\n\t\tnode.PARAM_CALLBACK_reset();\n\t}\n\tPARAM_CALLBACK_reset() {\n\t\tthis.gpu_controller.reset_gpu_compute_and_set_dirty();\n\t}\n\n\tstatic displayed_input_names(): string[] {\n\t\treturn ['points to emit particles from'];\n\t}\n\n\tprivate _reset_material_if_dirty_bound = this._reset_material_if_dirty.bind(this);\n\tprotected _children_controller_context = NodeContext.GL;\n\tprivate _on_create_prepare_material_bound = this._on_create_prepare_material.bind(this);\n\tinitialize_node() {\n\t\t// this._init_common_shader_builder(ShaderAssemblerParticles, {\n\t\t// \thas_display_flag: true,\n\t\t// \tupdate_on_dirty: false,\n\t\t// });\n\n\t\tthis.io.inputs.set_count(1);\n\t\t// set to never at the moment\n\t\t// otherwise the input is cloned on every frame inside cook_main()\n\t\tthis.io.inputs.init_inputs_clonable_state([InputCloneMode.NEVER]);\n\n\t\tthis.add_post_dirty_hook('_reset_material_if_dirty', this._reset_material_if_dirty_bound);\n\n\t\tthis.lifecycle.add_on_create_hook(this.assembler_controller.on_create.bind(this.assembler_controller));\n\t\tthis.lifecycle.add_on_create_hook(this._on_create_prepare_material_bound);\n\t\tthis.children_controller?.init();\n\t}\n\n\tcreate_node<K extends keyof GlNodeChildrenMap>(type: K): GlNodeChildrenMap[K] {\n\t\treturn super.create_node(type) as GlNodeChildrenMap[K];\n\t}\n\tchildren() {\n\t\treturn super.children() as BaseGlNodeType[];\n\t}\n\tnodes_by_type<K extends keyof GlNodeChildrenMap>(type: K): GlNodeChildrenMap[K][] {\n\t\treturn super.nodes_by_type(type) as GlNodeChildrenMap[K][];\n\t}\n\n\t// create_params() {\n\t// \t// this._create_gpu_compute_params();\n\t// \t// this._create_render_params();\n\t// \tthis._create_lifespan_params();\n\t// }\n\n\tasync _reset_material_if_dirty() {\n\t\t// if(\n\t\t// \tdirty_trigger.graph_node_id &&\n\t\t// \tthis._render_material_node &&\n\t\t// \tdirty_trigger.graph_node_id() == this._render_material_node.graph_node_id()\n\t\t// ){\n\t\t// \tthis.remove_dirty_state()\n\t\t// } else {\n\t\tif (this.p.material.is_dirty) {\n\t\t\tthis.render_controller.reset_render_material();\n\t\t\tif (!this.is_on_frame_start()) {\n\t\t\t\tawait this.render_controller.init_render_material();\n\t\t\t}\n\t\t}\n\t\t// }\n\t\t// that seems to create an infinite loop\n\t\t// maybe only check if the type of geo has changed?\n\t\t// if(this.input_graph_node(0).is_dirty()){\n\t\t// \tthis.set_compilation_required()\n\t\t// }\n\t}\n\n\tis_on_frame_start(): boolean {\n\t\treturn this.scene.frame == this.pv.start_frame;\n\t}\n\n\tasync cook(input_contents: CoreGroup[]) {\n\t\tthis.gpu_controller.set_restart_not_required();\n\t\tconst core_group = input_contents[0];\n\t\t// this._simulation_restart_required = false;\n\t\t// let set_group_required = false;\n\t\t// let points:CorePoint[] = [];\n\t\tconsole.log('particles cook');\n\t\tawait this.compile_if_required();\n\n\t\tif (this.is_on_frame_start()) {\n\t\t\tthis.gpu_controller.reset_particle_groups();\n\t\t}\n\n\t\tif (!this.gpu_controller.initialized) {\n\t\t\tawait this.gpu_controller.init(core_group);\n\t\t\t// this.gpu_controller.init_particle_group_points(core_group)\n\t\t\t// await this.gpu_controller.create_gpu_compute();\n\t\t}\n\n\t\t// if (!this._gpu_compute) {\n\t\t// \tawait this.gpu_controller.create_gpu_compute(points);\n\t\t// \t// set_group_required = true\n\t\t// }\n\t\tif (!this.render_controller.initialized) {\n\t\t\tthis.render_controller.init_core_group(core_group);\n\t\t\tawait this.render_controller.init_render_material();\n\t\t}\n\n\t\tthis.gpu_controller.restart_simulation_if_required();\n\t\tthis.gpu_controller.compute_similation_if_required();\n\t\t// if (frame >= this.pv.start_frame) {\n\t\t// \tif (this._last_simulated_frame == null) {\n\t\t// \t\tthis._last_simulated_frame = this._param_start_frame - 1;\n\t\t// \t}\n\t\t// \tif (frame > this._last_simulated_frame) {\n\t\t// \t\tthis._compute_simulation(frame - this._last_simulated_frame);\n\t\t// \t}\n\t\t// }\n\n\t\tif (this.is_on_frame_start()) {\n\t\t\tthis.set_core_group(core_group);\n\t\t} else {\n\t\t\tthis.cook_controller.end_cook();\n\t\t}\n\t}\n\tasync compile_if_required() {\n\t\tif (this.assembler_controller.compile_required()) {\n\t\t\tawait this.run_assembler();\n\t\t}\n\t}\n\tasync run_assembler() {\n\t\tconst root_nodes = this._find_root_nodes();\n\t\tconsole.log('root_nodes', root_nodes);\n\t\tif (root_nodes.length > 0) {\n\t\t\tconst globals_handler = new GlobalsTextureHandler(GlobalsTextureHandler.PARTICLE_SIM_UV);\n\t\t\tthis.assembler_controller.set_assembler_globals_handler(globals_handler);\n\t\t\tthis.assembler_controller.assembler.set_root_nodes(root_nodes);\n\n\t\t\tawait this.assembler_controller.assembler.compile();\n\t\t\tawait this.assembler_controller.post_compile();\n\t\t}\n\n\t\tconst shaders_by_name: Map<ShaderName, string> = this.assembler_controller.assembler.shaders_by_name();\n\t\tthis.gpu_controller.set_shaders_by_name(shaders_by_name);\n\t\tthis.render_controller.set_shaders_by_name(shaders_by_name);\n\t\t// if (shaders_by_name) {\n\t\t// \tawait this.eval_params(this._new_params);\n\t\t// \tthis._shaders_by_name = lodash_cloneDeep(shaders_by_name);\n\t\t// } else {\n\t\t// \tconsole.warn('no shaders by name from assembler');\n\t\t// }\n\t\tthis.gpu_controller.reset_gpu_compute();\n\t\tthis.gpu_controller.reset_particle_groups(); // this\n\n\t\tawait this.assembler_controller.assign_uniform_values(); // TODO: needed?\n\t}\n\t// shaders_by_name() {\n\t// \treturn this._shaders_by_name;\n\t// }\n\t// shaders(): string[] {\n\t// \treturn Object.keys(this._shaders_by_name).map((k) => this._shaders_by_name[k]);\n\t// }\n\n\tprivate _find_root_nodes() {\n\t\tconst nodes: BaseGlNodeType[] = GlNodeFinder.find_attribute_export_nodes(this);\n\t\tconst output_nodes = GlNodeFinder.find_output_nodes(this);\n\t\tif (output_nodes.length > 1) {\n\t\t\tthis.states.error.set('only one output node is allowed');\n\t\t\treturn [];\n\t\t}\n\t\tconst output_node = output_nodes[0];\n\t\tif (output_node) {\n\t\t\tnodes.push(output_node);\n\t\t}\n\t\treturn nodes;\n\t}\n\t// set_compilation_required_and_dirty() {\n\t// \tthis.assembler_controller.set_compilation_required_and_dirty();\n\t// }\n\n\tprivate _on_create_prepare_material() {\n\t\t// that's mostly to have the default shader work when creating the node\n\t\t// output.set_input('position', globals, 'position')\n\t\t// or instead we could create the default shader\n\t\tconst root = this.scene.root;\n\t\tconst mat_name = 'MAT';\n\t\tconst particles_mat_name = 'points_particles';\n\t\tconst MAT: MaterialsObjNode = root.nodes_by_type('materials')[0] || this.scene.root.create_node('materials');\n\t\tMAT.set_name(mat_name);\n\n\t\tconst create_points_mat = (MAT: MaterialsObjNode, name: string) => {\n\t\t\tlet points_mat = MAT.node('points_builder1') as PointsBuilderMatNode;\n\t\t\tif (!(points_mat && points_mat.type == PointsBuilderMatNode.type())) {\n\t\t\t\tpoints_mat = MAT.create_node('points_builder');\n\t\t\t}\n\t\t\tpoints_mat.set_name(name);\n\n\t\t\tlet points_mat_constant_point_size = points_mat.node('constant') as ConstantGlNode;\n\t\t\tif (!(points_mat_constant_point_size && points_mat_constant_point_size.type == ConstantGlNode.type())) {\n\t\t\t\tpoints_mat_constant_point_size = points_mat.create_node('constant');\n\t\t\t\tpoints_mat_constant_point_size.set_name('constant_point_size');\n\t\t\t}\n\t\t\tpoints_mat_constant_point_size.p.float.set(4); // to match the default point material\n\t\t\tconst points_mat_output1 = points_mat.node('output1');\n\t\t\tif (points_mat_output1) {\n\t\t\t\tpoints_mat_output1.set_input(\n\t\t\t\t\t'gl_PointSize',\n\t\t\t\t\tpoints_mat_constant_point_size,\n\t\t\t\t\tConstantGlNode.OUTPUT_NAME\n\t\t\t\t);\n\t\t\t}\n\t\t\treturn points_mat;\n\t\t};\n\t\tconst points_mat = MAT.node(particles_mat_name) || create_points_mat(MAT, particles_mat_name);\n\t\tif (points_mat) {\n\t\t\tconst new_path = points_mat.full_path();\n\t\t\tif (this.p.material.raw_input != new_path) {\n\t\t\t\tthis.p.material.set(new_path);\n\t\t\t}\n\t\t}\n\t}\n}\n","import {CoreGeometry} from '../../../core/geometry/Geometry';\nimport {TypedSopNode} from './_Base';\nimport {InputCloneMode} from '../../poly/InputCloneMode';\nimport {CoreGroup} from '../../../core/geometry/Group';\nimport {BufferAttribute} from 'three/src/core/BufferAttribute';\nimport {BufferGeometry} from 'three/src/core/BufferGeometry';\nimport {Mesh} from 'three/src/objects/Mesh';\n\nconst POSITION = 'position';\n\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nclass PeakSopParamsConfig extends NodeParamsConfig {\n\tamount = ParamConfig.FLOAT(1, {range: [-1, 1]});\n}\nconst ParamsConfig = new PeakSopParamsConfig();\n\nexport class PeakSopNode extends TypedSopNode<PeakSopParamsConfig> {\n\tparams_config = ParamsConfig;\n\tstatic type() {\n\t\treturn 'peak';\n\t}\n\n\tinitialize_node() {\n\t\tthis.io.inputs.set_count(1);\n\t\tthis.io.inputs.init_inputs_clonable_state([InputCloneMode.FROM_NODE]);\n\t}\n\n\tcook(input_contents: CoreGroup[]) {\n\t\tconst core_group = input_contents[0];\n\n\t\tlet core_geometry, point;\n\t\tfor (let object of core_group.objects()) {\n\t\t\tobject.traverse((child_object) => {\n\t\t\t\tlet geometry;\n\t\t\t\tif ((geometry = (child_object as Mesh).geometry as BufferGeometry) != null) {\n\t\t\t\t\tcore_geometry = new CoreGeometry(geometry);\n\t\t\t\t\tfor (point of core_geometry.points()) {\n\t\t\t\t\t\tconst normal = point.normal();\n\t\t\t\t\t\tconst position = point.position();\n\t\t\t\t\t\tconst new_position = position.clone().add(normal.multiplyScalar(this.pv.amount));\n\t\t\t\t\t\tpoint.set_position(new_position);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!this.io.inputs.input_cloned(0)) {\n\t\t\t\t\t\tconst attrib = core_geometry.geometry().getAttribute(POSITION) as BufferAttribute;\n\t\t\t\t\t\tattrib.needsUpdate = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\tthis.set_core_group(core_group);\n\t}\n}\n","import {Vector3} from 'three/src/math/Vector3';\nimport {Vector2} from 'three/src/math/Vector2';\nimport {PlaneBufferGeometry} from 'three/src/geometries/PlaneGeometry';\nimport {TypedSopNode} from './_Base';\nimport {CoreTransform} from '../../../core/Transform';\nimport {CoreGroup} from '../../../core/geometry/Group';\nimport {InputCloneMode} from '../../poly/InputCloneMode';\n\nconst DEFAULT_UP = new Vector3(0, 0, 1);\nconst ROTATE_START = new Vector3(0, 0, 1);\nconst ROTATE_END = new Vector3(0, 1, 0);\n\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nclass PlaneSopParamsConfig extends NodeParamsConfig {\n\tsize = ParamConfig.VECTOR2([1, 1]);\n\tuse_segments_count = ParamConfig.BOOLEAN(0);\n\tstep_size = ParamConfig.FLOAT(1, {visible_if: {use_segments_count: 0}});\n\tsegments = ParamConfig.VECTOR2([1, 1], {visible_if: {use_segments_count: 1}});\n\tdirection = ParamConfig.VECTOR3([0, 1, 0]);\n\tcenter = ParamConfig.VECTOR3([0, 0, 0]);\n}\nconst ParamsConfig = new PlaneSopParamsConfig();\n\nexport class PlaneSopNode extends TypedSopNode<PlaneSopParamsConfig> {\n\tparams_config = ParamsConfig;\n\tstatic type() {\n\t\treturn 'plane';\n\t}\n\n\tprivate _core_transform = new CoreTransform();\n\n\tstatic displayed_input_names(): string[] {\n\t\treturn ['geometry to create plane from (optional)'];\n\t}\n\n\tinitialize_node() {\n\t\tthis.io.inputs.set_count(0, 1);\n\t\tthis.io.inputs.init_inputs_clonable_state([InputCloneMode.NEVER]);\n\t}\n\n\tcook(input_contents: CoreGroup[]) {\n\t\tconst core_group = input_contents[0];\n\t\tif (core_group) {\n\t\t\tthis._cook_with_input(core_group);\n\t\t} else {\n\t\t\tthis._cook_without_input();\n\t\t}\n\t}\n\t_cook_without_input() {\n\t\tconst geometry = this._create_plane(this.pv.size);\n\n\t\t// convert to buffer geo, as some render problems can occur otherwise\n\t\t// geometry = BufferGeometryUtils.mergeBufferGeometries([geometry])\n\t\t// console.log(geometry, geometry.isBufferGeometry)\n\t\tthis._core_transform.rotate_geometry(geometry, DEFAULT_UP, this.pv.direction);\n\n\t\tconst matrix = this._core_transform.translation_matrix(this.pv.center);\n\t\tgeometry.applyMatrix4(matrix);\n\n\t\tthis.set_geometry(geometry);\n\t}\n\t_cook_with_input(core_group: CoreGroup) {\n\t\tconst bbox = core_group.bounding_box();\n\t\tconst size = new Vector3();\n\t\tbbox.getSize(size);\n\t\tconst center = new Vector3();\n\t\tbbox.getCenter(center);\n\n\t\t// TODO: rotate the input geo to get the accurate bbox\n\t\tconst size2d = new Vector2(size.x, size.z);\n\t\tconst geometry = this._create_plane(size2d);\n\n\t\tthis._core_transform.rotate_geometry(geometry, ROTATE_START, ROTATE_END);\n\n\t\tconst matrix = this._core_transform.translation_matrix(center);\n\t\tgeometry.applyMatrix4(matrix);\n\n\t\t// const buffer_geometry = CoreGeometry.clone(geometry);\n\t\tthis.set_geometry(geometry);\n\t}\n\n\t_create_plane(size: Vector2) {\n\t\tlet segments_count;\n\t\tsize = size.clone();\n\t\tif (this.pv.use_segments_count) {\n\t\t\tsegments_count = {\n\t\t\t\tx: Math.floor(this.pv.segments.x),\n\t\t\t\ty: Math.floor(this.pv.segments.y),\n\t\t\t};\n\t\t} else {\n\t\t\tsegments_count = {\n\t\t\t\tx: Math.floor(size.x / this.pv.step_size),\n\t\t\t\ty: Math.floor(size.y / this.pv.step_size),\n\t\t\t};\n\t\t\tsize.x = segments_count.x * this.pv.step_size;\n\t\t\tsize.y = segments_count.y * this.pv.step_size;\n\t\t}\n\t\treturn new PlaneBufferGeometry(size.x, size.y, segments_count.x, segments_count.y);\n\t}\n}\n","// import lodash_map from 'lodash/map'\n\nimport {BufferGeometry} from 'three/src/core/BufferGeometry';\n\nimport {TypedSopNode} from './_Base';\nimport {CoreGroup} from '../../../core/geometry/Group';\nimport {CoreObject} from '../../../core/geometry/Object';\nimport {CorePoint} from '../../../core/geometry/Point';\nimport {InputCloneMode} from '../../poly/InputCloneMode';\n\nimport {BufferAttribute} from 'three/src/core/BufferAttribute';\nimport {Mesh} from 'three/src/objects/Mesh';\nimport {BooleanParam} from '../../params/Boolean';\nimport {FloatParam} from '../../params/Float';\n\nconst POSITION_ATTRIB_NAME = 'position';\n\ntype ValueArrayByName = Map<string, number[]>;\ntype ComponentOffset = 0 | 1 | 2;\n\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nclass PointSopParamsConfig extends NodeParamsConfig {\n\tupdate_x = ParamConfig.BOOLEAN(0);\n\tx = ParamConfig.FLOAT('@P.x', {\n\t\tvisible_if: {update_x: 1},\n\t\texpression: {for_entities: true},\n\t});\n\tupdate_y = ParamConfig.BOOLEAN(0);\n\ty = ParamConfig.FLOAT('@P.y', {\n\t\tvisible_if: {update_y: 1},\n\t\texpression: {for_entities: true},\n\t});\n\tupdate_z = ParamConfig.BOOLEAN(0);\n\tz = ParamConfig.FLOAT('@P.z', {\n\t\tvisible_if: {update_z: 1},\n\t\texpression: {for_entities: true},\n\t});\n\tupdate_normals = ParamConfig.BOOLEAN(1);\n}\nconst ParamsConfig = new PointSopParamsConfig();\n\nexport class PointSopNode extends TypedSopNode<PointSopParamsConfig> {\n\tparams_config = ParamsConfig;\n\tstatic type() {\n\t\treturn 'point';\n\t}\n\n\tprivate _x_arrays_by_geometry_uuid: ValueArrayByName = new Map();\n\tprivate _y_arrays_by_geometry_uuid: ValueArrayByName = new Map();\n\tprivate _z_arrays_by_geometry_uuid: ValueArrayByName = new Map();\n\n\tstatic displayed_input_names(): string[] {\n\t\treturn ['points to move'];\n\t}\n\n\tinitialize_node() {\n\t\tthis.io.inputs.set_count(1);\n\t\tthis.io.inputs.init_inputs_clonable_state([InputCloneMode.FROM_NODE]);\n\t\t// this.ui_data.set_icon('dot-circle');\n\t}\n\n\tasync cook(input_contents: CoreGroup[]) {\n\t\tconst core_group = input_contents[0];\n\t\tawait this._eval_expressions_for_core_group(core_group);\n\t}\n\n\t// group.traverse (object)=>\n\t// \tif (geometry = object.geometry)?\n\t// \t\tthis._eval_expressions(geometry)\n\t// \t\tgeometry.computeVertexNormals()\n\n\tasync _eval_expressions_for_core_group(core_group: CoreGroup) {\n\t\tconst core_objects = core_group.core_objects();\n\t\t// this._allocate_arrays(core_objects)\n\n\t\tfor (let i = 0; i < core_objects.length; i++) {\n\t\t\tawait this._eval_expressions_for_core_object(core_objects[i]);\n\t\t}\n\n\t\tif (this.pv.update_normals) {\n\t\t\tcore_group.compute_vertex_normals();\n\t\t}\n\n\t\tconst geometries = core_group.geometries();\n\t\tfor (let geometry of geometries) {\n\t\t\tgeometry.computeBoundingBox();\n\t\t}\n\n\t\t// needs update required for when no cloning\n\t\tif (!this.io.inputs.input_cloned(0)) {\n\t\t\tconst geometries = core_group.geometries();\n\t\t\tfor (let geometry of geometries) {\n\t\t\t\tconst attrib = geometry.getAttribute(POSITION_ATTRIB_NAME) as BufferAttribute;\n\t\t\t\tattrib.needsUpdate = true;\n\t\t\t}\n\t\t}\n\n\t\tthis.set_core_group(core_group);\n\t}\n\tasync _eval_expressions_for_core_object(core_object: CoreObject) {\n\t\tconst object = core_object.object();\n\t\tconst geometry = (object as Mesh).geometry as BufferGeometry;\n\t\tconst points = core_object.points();\n\n\t\tconst array = geometry.getAttribute(POSITION_ATTRIB_NAME).array as number[];\n\n\t\tconst tmp_array_x = await this._update_from_param(\n\t\t\tgeometry,\n\t\t\tarray,\n\t\t\tpoints,\n\t\t\tthis.p.update_x,\n\t\t\tthis.p.x,\n\t\t\tthis.pv.x,\n\t\t\tthis._x_arrays_by_geometry_uuid,\n\t\t\t0\n\t\t);\n\t\tconst tmp_array_y = await this._update_from_param(\n\t\t\tgeometry,\n\t\t\tarray,\n\t\t\tpoints,\n\t\t\tthis.p.update_y,\n\t\t\tthis.p.y,\n\t\t\tthis.pv.y,\n\t\t\tthis._y_arrays_by_geometry_uuid,\n\t\t\t1\n\t\t);\n\t\tconst tmp_array_z = await this._update_from_param(\n\t\t\tgeometry,\n\t\t\tarray,\n\t\t\tpoints,\n\t\t\tthis.p.update_z,\n\t\t\tthis.p.z,\n\t\t\tthis.pv.z,\n\t\t\tthis._z_arrays_by_geometry_uuid,\n\t\t\t2\n\t\t);\n\n\t\tif (tmp_array_x) {\n\t\t\tthis._commit_tmp_values(tmp_array_x, array, 0);\n\t\t}\n\t\tif (tmp_array_y) {\n\t\t\tthis._commit_tmp_values(tmp_array_y, array, 1);\n\t\t}\n\t\tif (tmp_array_z) {\n\t\t\tthis._commit_tmp_values(tmp_array_z, array, 2);\n\t\t}\n\t}\n\n\tprivate async _update_from_param(\n\t\tgeometry: BufferGeometry,\n\t\tarray: number[],\n\t\tpoints: CorePoint[],\n\t\tdo_update_param: BooleanParam,\n\t\tvalue_param: FloatParam,\n\t\tparam_value: number,\n\t\tarrays_by_geometry_uuid: ValueArrayByName,\n\t\toffset: ComponentOffset\n\t) {\n\t\tconst do_update = do_update_param;\n\t\tconst param = value_param;\n\n\t\tlet tmp_array = this._init_array_if_required(geometry, arrays_by_geometry_uuid, points.length, offset);\n\t\tif (do_update.value) {\n\t\t\tif (param.has_expression() && param.expression_controller) {\n\t\t\t\tawait param.expression_controller.compute_expression_for_points(points, (point, value) => {\n\t\t\t\t\ttmp_array[point.index] = value;\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tlet point;\n\t\t\t\tfor (let i = 0; i < points.length; i++) {\n\t\t\t\t\tpoint = points[i];\n\t\t\t\t\ttmp_array[point.index] = param_value;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn tmp_array;\n\t}\n\n\tprivate _init_array_if_required(\n\t\tgeometry: BufferGeometry,\n\t\tarrays_by_geometry_uuid: ValueArrayByName,\n\t\tpoints_count: number,\n\t\toffset: ComponentOffset\n\t) {\n\t\tconst uuid = geometry.uuid;\n\t\tconst current_array = arrays_by_geometry_uuid.get(uuid);\n\t\tif (current_array) {\n\t\t\t// only create new array if we need more point, or as soon as the length is different?\n\t\t\tif (current_array.length < points_count) {\n\t\t\t\tconst new_array = this._array_for_component(geometry, points_count, offset);\n\t\t\t\tarrays_by_geometry_uuid.set(uuid, new_array);\n\t\t\t\treturn new_array;\n\t\t\t} else {\n\t\t\t\treturn current_array;\n\t\t\t}\n\t\t} else {\n\t\t\tconst new_array = this._array_for_component(geometry, points_count, offset);\n\t\t\tarrays_by_geometry_uuid.set(uuid, new_array);\n\t\t\treturn new_array;\n\t\t}\n\t}\n\n\tprivate _array_for_component(geometry: BufferGeometry, points_count: number, offset: ComponentOffset) {\n\t\tconst new_array = new Array<number>(points_count);\n\t\tconst src_array = geometry.getAttribute(POSITION_ATTRIB_NAME).array;\n\t\tfor (let i = 0; i < new_array.length; i++) {\n\t\t\tnew_array[i] = src_array[i * 3 + offset];\n\t\t}\n\t\treturn new_array;\n\t}\n\n\tprivate _commit_tmp_values(tmp_array: number[], target_array: number[], offset: number) {\n\t\tfor (let i = 0; i < tmp_array.length; i++) {\n\t\t\ttarget_array[i * 3 + offset] = tmp_array[i];\n\t\t}\n\t}\n}\n","// import lodash_flatten from 'lodash/flatten'\n// import lodash_map from 'lodash/map'\n\nimport {CoreGeometry} from '../Geometry';\nimport {CorePoint} from '../Point';\nimport {Float32BufferAttribute} from 'three/src/core/BufferAttribute';\nimport {BufferGeometry} from 'three/src/core/BufferGeometry';\n\nexport class CoreGeometryUtilCurve {\n\tstatic accumulated_curve_point_indices(indices: number[]) {\n\t\tlet curve_point_indices: number[] = [];\n\t\tconst accumulated_curve_point_indices = [];\n\t\tlet last_index_added: number | null = null;\n\n\t\t// indices.forEach((index, i) => {\n\t\tlet index: number;\n\t\tfor (let i = 0; i < indices.length; i++) {\n\t\t\tif (i % 2 === 1) {\n\t\t\t\tindex = indices[i];\n\t\t\t\tconst previous_index = indices[i - 1];\n\n\t\t\t\t// if the last added index, from the previous segment\n\t\t\t\t// is the same as the start of the current segment (indices[i-1])\n\t\t\t\t// then this is part of the same curve\n\t\t\t\tif (last_index_added == null || previous_index === last_index_added) {\n\t\t\t\t\t// add the first point\n\t\t\t\t\tif (curve_point_indices.length === 0) {\n\t\t\t\t\t\tcurve_point_indices.push(previous_index);\n\t\t\t\t\t}\n\n\t\t\t\t\tcurve_point_indices.push(index);\n\t\t\t\t\tlast_index_added = index;\n\t\t\t\t} else {\n\t\t\t\t\t// otherwise we create a new curve\n\t\t\t\t\taccumulated_curve_point_indices.push(curve_point_indices);\n\t\t\t\t\t//current_points = lodash_map curve_point_indices, (index)->points[index]\n\t\t\t\t\t//curve_point_indices_groups.push(current_points)\n\t\t\t\t\t//this._create_curve_from_points(current_points)\n\n\t\t\t\t\t// and reset the array\n\t\t\t\t\tcurve_point_indices = [previous_index, index];\n\t\t\t\t\tlast_index_added = index;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// also create with the remaining ones\n\t\taccumulated_curve_point_indices.push(curve_point_indices);\n\n\t\treturn accumulated_curve_point_indices;\n\t}\n\n\tstatic create_line_segment_geometry(\n\t\tpoints: CorePoint[],\n\t\tindices: number[],\n\t\tattrib_names: string[],\n\t\tattrib_sizes_by_name: Dictionary<number>\n\t) {\n\t\t// let new_positions: number[] = []\n\t\tconst new_indices: number[] = [];\n\n\t\tconst new_attribute_values_by_name: Dictionary<number[]> = {};\n\t\tattrib_names.forEach((attrib_name) => {\n\t\t\tnew_attribute_values_by_name[attrib_name] = [];\n\t\t});\n\n\t\tindices.forEach((index, i) => {\n\t\t\tconst point = points[index];\n\t\t\t// const position = point.position();\n\t\t\t// new_positions.push(position.toArray());\n\t\t\tattrib_names.forEach((attrib_name) => {\n\t\t\t\tlet attrib_value = point.attrib_value(attrib_name);\n\t\t\t\tconst attrib_size = attrib_sizes_by_name[attrib_name];\n\t\t\t\tif (attrib_size > 1) {\n\t\t\t\t\tattrib_value = attrib_value.toArray();\n\t\t\t\t} else {\n\t\t\t\t\tattrib_value = [attrib_value];\n\t\t\t\t}\n\t\t\t\tattrib_value.forEach((v: number) => {\n\t\t\t\t\tnew_attribute_values_by_name[attrib_name].push(v);\n\t\t\t\t});\n\t\t\t});\n\n\t\t\tif (i > 0) {\n\t\t\t\tnew_indices.push(i - 1);\n\t\t\t\tnew_indices.push(i);\n\t\t\t}\n\t\t});\n\n\t\t// new_positions = lodash_flatten(new_positions)\n\t\tconst geometry = new BufferGeometry();\n\n\t\tattrib_names.forEach((attrib_name) => {\n\t\t\tconst attrib_size = attrib_sizes_by_name[attrib_name];\n\t\t\tconst values = new_attribute_values_by_name[attrib_name];\n\t\t\tgeometry.setAttribute(attrib_name, new Float32BufferAttribute(values, attrib_size));\n\t\t});\n\n\t\tgeometry.setIndex(new_indices);\n\t\treturn geometry;\n\t}\n\n\tstatic line_segment_to_geometries(geometry: BufferGeometry) {\n\t\tconst geometries: BufferGeometry[] = [];\n\t\tconst core_geometry = new CoreGeometry(geometry);\n\t\tconst attrib_names = core_geometry.attrib_names();\n\t\tconst points = core_geometry.points();\n\t\tconst indices = (geometry.getIndex()?.array as number[]) || [];\n\n\t\tconst accumulated_curve_point_indices = this.accumulated_curve_point_indices(indices);\n\t\tconsole.log(indices, accumulated_curve_point_indices);\n\n\t\tif (accumulated_curve_point_indices.length > 0) {\n\t\t\tconst attribute_sizes_by_name = core_geometry.attrib_sizes();\n\n\t\t\taccumulated_curve_point_indices.forEach((curve_point_indices, i) => {\n\t\t\t\tgeometry = this.create_line_segment_geometry(\n\t\t\t\t\tpoints,\n\t\t\t\t\tcurve_point_indices,\n\t\t\t\t\tattrib_names,\n\t\t\t\t\tattribute_sizes_by_name\n\t\t\t\t);\n\t\t\t\tgeometries.push(geometry);\n\t\t\t});\n\t\t}\n\n\t\treturn geometries;\n\t}\n}\n","import {Float32BufferAttribute} from 'three/src/core/BufferAttribute'\nimport {BufferGeometry} from 'three/src/core/BufferGeometry'\nimport {CoreGeometry} from '../Geometry'\n// import lodash_range from 'lodash/range'\nimport lodash_flatten from 'lodash/flatten'\nimport lodash_intersection from 'lodash/intersection'\nimport lodash_concat from 'lodash/concat'\n\nexport class CoreGeometryOperationSkin {\n\tconstructor(\n\t\tprivate geometry: BufferGeometry,\n\t\tprivate geometry1: BufferGeometry,\n\t\tprivate geometry0: BufferGeometry\n\t) {}\n\n\tprocess() {\n\t\tconst geometry_wrapper0 = new CoreGeometry(this.geometry0)\n\t\tconst geometry_wrapper1 = new CoreGeometry(this.geometry1)\n\t\tconst segments0 = geometry_wrapper0.segments()\n\t\tconst segments1 = geometry_wrapper1.segments()\n\n\t\tif (segments0.length === 0 || segments1.length === 0) {\n\t\t\treturn\n\t\t}\n\t\t// find smallest geo to iterate on its array\n\t\tconst geometries_by_segments_count =\n\t\t\tsegments0.length < segments1.length\n\t\t\t\t? [geometry_wrapper0, geometry_wrapper1]\n\t\t\t\t: [geometry_wrapper1, geometry_wrapper0]\n\n\t\tconst smallest_geometry = geometries_by_segments_count[0]\n\t\tconst largest_geometry = geometries_by_segments_count[1]\n\n\t\tconst smallest_segments = smallest_geometry.segments()\n\t\tconst largest_segments = largest_geometry.segments()\n\n\t\tconst smallest_points = smallest_geometry.points()\n\t\tconst largest_points = largest_geometry.points()\n\t\tconst smallest_points_count = smallest_points.length\n\t\t// const largest_points_count = largest_points.length;\n\t\tconst all_points = lodash_concat(smallest_points, largest_points)\n\n\t\t// const half_faces_count = smallest_segments.length;\n\t\tconst points_indices: number[] = []\n\t\tsmallest_segments.forEach((segment, i) => {\n\t\t\tconst matched_segment = largest_segments[i]\n\t\t\t// face 1\n\t\t\tpoints_indices.push(segment[0])\n\t\t\tpoints_indices.push(segment[1])\n\t\t\tpoints_indices.push(matched_segment[0] + smallest_points_count)\n\t\t\t// face 2\n\t\t\tpoints_indices.push(segment[1])\n\t\t\tpoints_indices.push(matched_segment[1] + smallest_points_count)\n\t\t\tpoints_indices.push(matched_segment[0] + smallest_points_count)\n\t\t})\n\n\t\tconst attributes_in_common = lodash_intersection(\n\t\t\tsmallest_geometry.attrib_names(),\n\t\t\tlargest_geometry.attrib_names()\n\t\t)\n\t\t// const points = all_points //points_indices.map(index=> all_points[index]);\n\t\tattributes_in_common.forEach((attrib_name) => {\n\t\t\tconst attrib_size = smallest_geometry.attrib_size(attrib_name)\n\t\t\tlet attrib_values = all_points.map((point) =>\n\t\t\t\tpoint.attrib_value(attrib_name)\n\t\t\t)\n\t\t\tif (attrib_size > 1) {\n\t\t\t\tattrib_values = lodash_flatten(\n\t\t\t\t\tattrib_values.map((v) => v.toArray())\n\t\t\t\t)\n\t\t\t}\n\t\t\tthis.geometry.setAttribute(\n\t\t\t\tattrib_name,\n\t\t\t\tnew Float32BufferAttribute(attrib_values, attrib_size)\n\t\t\t)\n\t\t})\n\n\t\t// const new_indices = lodash_range(points.length);\n\t\tthis.geometry.setIndex(points_indices)\n\t\tthis.geometry.computeVertexNormals()\n\t}\n}\n","import {TypedSopNode} from './_Base';\nimport {CoreGeometry} from '../../../core/geometry/Geometry';\nimport {CoreTransform} from '../../../core/Transform';\nimport {CoreGeometryUtilCircle} from '../../../core/geometry/util/Circle';\nimport {CoreGeometryUtilCurve} from '../../../core/geometry/util/Curve';\nimport {CoreGeometryOperationSkin} from '../../../core/geometry/operation/Skin';\n\nimport {Vector3} from 'three/src/math/Vector3';\n// import {TubeBufferGeometry} from 'three/src/geometries/TubeGeometry';\nimport {LineSegments} from 'three/src/objects/LineSegments';\n// import {CatmullRomCurve3} from 'three/src/extras/curves/CatmullRomCurve3';\nimport {BufferGeometry} from 'three/src/core/BufferGeometry';\nimport {InputCloneMode} from '../../poly/InputCloneMode';\n\nconst DEFAULT_R = new Vector3(0, 0, 0);\nconst DEFAULT_S = new Vector3(1, 1, 1);\n\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nimport {CoreGroup} from '../../../core/geometry/Group';\nimport {CorePoint} from '../../../core/geometry/Point';\nclass PolywireSopParamsConfig extends NodeParamsConfig {\n\tradius = ParamConfig.FLOAT(1);\n\tsegments_radial = ParamConfig.INTEGER(8, {\n\t\trange: [3, 20],\n\t\trange_locked: [true, false],\n\t});\n\tclosed = ParamConfig.BOOLEAN(0);\n}\nconst ParamsConfig = new PolywireSopParamsConfig();\n\nexport class PolywireSopNode extends TypedSopNode<PolywireSopParamsConfig> {\n\tparams_config = ParamsConfig;\n\tstatic type() {\n\t\treturn 'polywire';\n\t}\n\n\tstatic displayed_input_names(): string[] {\n\t\treturn ['lines to create tubes from'];\n\t}\n\n\tprivate _core_transform = new CoreTransform();\n\n\tinitialize_node() {\n\t\tthis.io.inputs.set_count(1);\n\t\tthis.io.inputs.init_inputs_clonable_state([InputCloneMode.NEVER]);\n\t}\n\n\tprivate _geometries: BufferGeometry[] = [];\n\n\tcook(input_contents: CoreGroup[]) {\n\t\tconst core_group = input_contents[0];\n\n\t\tthis._geometries = [];\n\t\tfor (let object of core_group.objects()) {\n\t\t\tif (object instanceof LineSegments) {\n\t\t\t\tthis._create_tube(object);\n\t\t\t}\n\t\t}\n\n\t\t//if @_param_merge\n\t\t//geometries = lodash_map @_geometries, (object)->object.geometry\n\t\tconst merged_geometry = CoreGeometry.merge_geometries(this._geometries);\n\t\tfor (let geometry of this._geometries) {\n\t\t\tgeometry.dispose();\n\t\t}\n\t\tif (merged_geometry) {\n\t\t\tconst object = this.create_object(merged_geometry);\n\n\t\t\tthis.set_object(object);\n\t\t} else {\n\t\t\tthis.set_objects([]);\n\t\t}\n\t}\n\t//else\n\t//\tthis.set_objects( @_objects )\n\n\t_create_tube(line_segment: LineSegments) {\n\t\tconst geometry = line_segment.geometry as BufferGeometry;\n\t\tconst wrapper = new CoreGeometry(geometry);\n\t\tconst points = wrapper.points();\n\t\tconst indices = geometry.getIndex()?.array as number[];\n\n\t\tconst accumulated_curve_point_indices = CoreGeometryUtilCurve.accumulated_curve_point_indices(indices);\n\n\t\tfor (let curve_point_indices of accumulated_curve_point_indices) {\n\t\t\tconst current_points = curve_point_indices.map((index) => points[index]);\n\t\t\tthis._create_tube_from_points(current_points);\n\t\t}\n\t}\n\n\t_create_tube_from_points(points: CorePoint[]) {\n\t\tif (points.length <= 1) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst positions = points.map((point) => point.attrib_value('position'));\n\n\t\tconst circle_template = CoreGeometryUtilCircle.create(this.pv.radius, this.pv.segments_radial);\n\t\tconst circles: BufferGeometry[] = [];\n\t\tconst scale = 1;\n\t\tfor (let position of positions) {\n\t\t\tconst t = position;\n\t\t\tconst matrix = this._core_transform.matrix(t, DEFAULT_R, DEFAULT_S, scale);\n\n\t\t\tconst new_circle = circle_template.clone();\n\t\t\tnew_circle.applyMatrix4(matrix);\n\t\t\tcircles.push(new_circle);\n\t\t}\n\n\t\tfor (let i = 0; i < circles.length; i++) {\n\t\t\tif (i > 0) {\n\t\t\t\tconst circle = circles[i];\n\t\t\t\tconst prev_circle = circles[i - 1];\n\n\t\t\t\tconst geometry = this._skin(prev_circle, circle);\n\t\t\t\tthis._geometries.push(geometry);\n\t\t\t}\n\t\t}\n\t}\n\n\t//this.set_geometries(circles, Core.Geometry.Constant.OBJECT_TYPE.LINE_SEGMENTS)\n\n\t// curve = new CatmullRomCurve3(positions)\n\t// segments_count = positions.length-1\n\n\t// geometry = new TubeBufferGeometry(\n\t// \tcurve,\n\t// \tsegments_count,\n\t// \t@_param_radius,\n\t// \t@_param_segments_radial,\n\t// \t@_param_closed\n\t// \t)\n\n\t// object = this.create_object(geometry)\n\t// @_objects.push(object)\n\t_skin(geometry1: BufferGeometry, geometry0: BufferGeometry) {\n\t\tconst geometry = new BufferGeometry();\n\n\t\tconst operation = new CoreGeometryOperationSkin(geometry, geometry1, geometry0);\n\t\toperation.process();\n\n\t\treturn geometry;\n\t}\n}\n","import {Vector3} from 'three/src/math/Vector3';\nimport {Raycaster, Intersection} from 'three/src/core/Raycaster';\nimport {Object3D} from 'three/src/core/Object3D';\nimport {MeshBasicMaterial} from 'three/src/materials/MeshBasicMaterial';\nimport {Mesh} from 'three/src/objects/Mesh';\nimport {DoubleSide} from 'three/src/constants';\n\nimport {TypedSopNode} from './_Base';\nimport {CoreGroup} from '../../../core/geometry/Group';\nimport {InputCloneMode} from '../../poly/InputCloneMode';\n\nconst MAT_DOUBLE_SIDED = new MeshBasicMaterial({\n\tside: DoubleSide,\n});\n\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nclass RaySopParamsConfig extends NodeParamsConfig {\n\tuse_normals = ParamConfig.BOOLEAN(1);\n\tdirection = ParamConfig.VECTOR3([0, -1, 0], {\n\t\tvisible_if: {use_normals: 0},\n\t});\n\ttransfer_face_normals = ParamConfig.BOOLEAN(1);\n}\nconst ParamsConfig = new RaySopParamsConfig();\n\nexport class RaySopNode extends TypedSopNode<RaySopParamsConfig> {\n\tparams_config = ParamsConfig;\n\tstatic type() {\n\t\treturn 'ray';\n\t}\n\n\t// _material_by_object_uuid: MaterialByString\n\tprivate _bound_assign_mat = this._assign_double_sided_material_to_object.bind(this); //(Object3D)=>void;\n\tprivate _raycaster = new Raycaster();\n\n\tstatic double_sided_material() {\n\t\treturn MAT_DOUBLE_SIDED;\n\t}\n\n\tstatic displayed_input_names(): string[] {\n\t\treturn ['geometry to move', 'geometry to ray onto'];\n\t}\n\n\tinitialize_node() {\n\t\tthis.io.inputs.set_count(2);\n\t\tthis.io.inputs.init_inputs_clonable_state([\n\t\t\tInputCloneMode.FROM_NODE,\n\t\t\tInputCloneMode.ALWAYS, // to assign double sided mat\n\t\t]);\n\t}\n\n\tcreate_params() {}\n\n\tcook(input_contents: CoreGroup[]) {\n\t\tconst core_group = input_contents[0];\n\t\tconst core_group_collision = input_contents[1];\n\n\t\tthis.ray(core_group, core_group_collision);\n\t}\n\n\tray(core_group: CoreGroup, core_group_collision: CoreGroup) {\n\t\t// this._material_by_object_uuid = {}\n\t\tthis._assign_double_sided_material_to_core_group(core_group_collision);\n\n\t\tlet direction: Vector3, first_intersect: Intersection;\n\t\tfor (let point of core_group.points()) {\n\t\t\tdirection = this.pv.use_normals ? point.normal() : this.pv.direction;\n\t\t\tthis._raycaster.set(point.position(), direction);\n\n\t\t\tfirst_intersect = this._raycaster.intersectObjects(core_group_collision.objects(), true)[0];\n\t\t\tif (first_intersect) {\n\t\t\t\tpoint.set_position(first_intersect.point);\n\t\t\t\tif (this.pv.transfer_face_normals && first_intersect.face) {\n\t\t\t\t\tpoint.set_normal(first_intersect.face.normal);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthis.set_core_group(core_group);\n\t}\n\n\t_assign_double_sided_material_to_core_group(core_group: CoreGroup) {\n\t\tfor (let object of core_group.objects()) {\n\t\t\tobject.traverse(this._bound_assign_mat);\n\t\t}\n\t}\n\t_assign_double_sided_material_to_object(object: Object3D) {\n\t\t// this._material_by_object_uuid[object.uuid] = object.material\n\t\t(object as Mesh).material = RaySopNode.double_sided_material();\n\t}\n\n\t// average_normals(geometry){\n\t// \tconst normals = [];\n\t// \tconst vertex_index_names = ['a', 'b', 'c'];\n\t// \tlodash_each(geometry.faces, face=> {\n\t// \t\treturn lodash_each(vertex_index_names, (vertex_index_name, i)=> {\n\t// \t\t\tconst vertex_index = face[vertex_index_name];\n\t// \t\t\tif (normals[vertex_index] == null) { normals[vertex_index] = []; }\n\t// \t\t\treturn normals[vertex_index].push(face.vertexNormals[i].clone());\n\t// \t\t});\n\t// \t});\n\n\t// \tlodash_each(normals, function(normal_group, i){\n\t// \t\tconst average = new Vector3(\n\t// \t\t\t(lodash_sum(lodash_map(normal_group, 'x')) / normal_group.length),\n\t// \t\t\t(lodash_sum(lodash_map(normal_group, 'y')) / normal_group.length),\n\t// \t\t\t(lodash_sum(lodash_map(normal_group, 'z')) / normal_group.length)\n\t// \t\t);\n\t// \t\treturn normals[i] = average;\n\t// \t});\n\n\t// \treturn normals;\n\t// }\n}\n","import {LineSegments} from 'three/src/objects/LineSegments';\nimport {Float32BufferAttribute} from 'three/src/core/BufferAttribute';\nimport {BufferGeometry} from 'three/src/core/BufferGeometry';\n\nimport {CatmullRomCurve3} from 'three/src/extras/curves/CatmullRomCurve3';\n// import {CubicBezierCurve3} from 'three/src/extras/curves/CubicBezierCurve3';\n// import {LineCurve3} from 'three/src/extras/curves/LineCurve3';\n// import {QuadraticBezierCurve3} from 'three/src/extras/curves/QuadraticBezierCurve3';\nimport {BufferGeometryUtils} from '../../../../modules/three/examples/jsm/utils/BufferGeometryUtils';\n\nimport lodash_flatten from 'lodash/flatten';\nimport lodash_map from 'lodash/map';\nimport {TypedSopNode} from './_Base';\nimport {CoreConstant} from '../../../core/geometry/Constant';\nimport {CoreGeometryUtilCurve} from '../../../core/geometry/util/Curve';\nimport {CoreGeometry} from '../../../core/geometry/Geometry';\n\nexport enum METHOD {\n\tPOINTS_COUNT = 'points_count',\n\tSEGMENT_LENGTH = 'segment_length',\n}\nexport const METHODS = [METHOD.POINTS_COUNT, METHOD.SEGMENT_LENGTH];\n\n// matches threejs curve type in CatmullRomCurve3.js\nexport enum CURVE_TYPE {\n\tCENTRIPETAL = 'centripetal',\n\tCHORDAL = 'chordal',\n\tCATMULLROM = 'catmullrom',\n}\nexport const CURVE_TYPES = [CURVE_TYPE.CENTRIPETAL, CURVE_TYPE.CHORDAL, CURVE_TYPE.CATMULLROM];\n\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nimport {CoreGroup} from '../../../core/geometry/Group';\nimport {CorePoint} from '../../../core/geometry/Point';\nimport {TypeAssert} from '../../poly/Assert';\nclass ResampleSopParamsConfig extends NodeParamsConfig {\n\tmethod = ParamConfig.INTEGER(METHODS.indexOf(METHOD.POINTS_COUNT), {\n\t\tmenu: {\n\t\t\tentries: METHODS.map((name, i) => {\n\t\t\t\treturn {\n\t\t\t\t\tname: name,\n\t\t\t\t\tvalue: i,\n\t\t\t\t};\n\t\t\t}),\n\t\t},\n\t});\n\tcurve_type = ParamConfig.INTEGER(CURVE_TYPES.indexOf(CURVE_TYPE.CATMULLROM), {\n\t\trange: [0, 2],\n\t\trange_locked: [true, true],\n\t\tmenu: {\n\t\t\tentries: CURVE_TYPES.map((name, i) => {\n\t\t\t\treturn {\n\t\t\t\t\tname: name,\n\t\t\t\t\tvalue: i,\n\t\t\t\t};\n\t\t\t}),\n\t\t},\n\t});\n\ttension = ParamConfig.FLOAT(0.01, {\n\t\trange: [0, 1],\n\t\trange_locked: [true, true],\n\t});\n\tpoints_count = ParamConfig.INTEGER(100, {\n\t\tvisible_if: {method: METHODS.indexOf(METHOD.POINTS_COUNT)},\n\t});\n\tsegment_length = ParamConfig.FLOAT(1, {\n\t\tvisible_if: {method: METHODS.indexOf(METHOD.SEGMENT_LENGTH)},\n\t});\n}\nconst ParamsConfig = new ResampleSopParamsConfig();\n\nexport class ResampleSopNode extends TypedSopNode<ResampleSopParamsConfig> {\n\tparams_config = ParamsConfig;\n\tstatic type() {\n\t\treturn 'resample';\n\t}\n\n\t// private _objects: Object3D\n\n\tinitialize_node() {\n\t\tthis.io.inputs.set_count(1);\n\t}\n\n\tcook(input_contents: CoreGroup[]) {\n\t\tconst core_group = input_contents[0];\n\n\t\t// this._objects = [];\n\t\tconst resampled_objects = [];\n\t\tif (this.pv.points_count >= 2) {\n\t\t\tconst core_objects = core_group.core_objects();\n\t\t\tfor (let i = 0; i < core_objects.length; i++) {\n\t\t\t\tconst core_object = core_objects[i];\n\t\t\t\tconst object = core_object.object();\n\t\t\t\tif (object instanceof LineSegments) {\n\t\t\t\t\tconst resampled_object = this._resample(object);\n\t\t\t\t\tresampled_objects.push(resampled_object);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// if (this.pv.merge) {\n\t\t// \tconst geometries = lodash_map(this._objects, object => object.geometry);\n\t\t// \tconst merged_geometry = CoreGeometry.merge_geometries(geometries);\n\t\t// \tlodash_each(geometries, geometry => geometry.dispose());\n\t\t// \tconst object = this.create_object(merged_geometry, CoreConstant.OBJECT_TYPE.LINE_SEGMENTS);\n\t\t// \tthis.set_object( object );\n\t\t// } else {\n\t\tthis.set_objects(resampled_objects);\n\t\t// }\n\t}\n\n\t_resample(line_segment: LineSegments) {\n\t\tconst geometry = line_segment.geometry as BufferGeometry;\n\t\tconst core_geometry = new CoreGeometry(geometry);\n\t\tconst points = core_geometry.points();\n\t\tconst indices = geometry.getIndex()?.array as number[];\n\n\t\tconst accumulated_curve_point_indices = CoreGeometryUtilCurve.accumulated_curve_point_indices(indices);\n\t\t// accumulated_curve_point_indices = [accumulated_curve_point_indices[0]]\n\t\tconst geometries: BufferGeometry[] = [];\n\t\tfor (let i = 0; i < accumulated_curve_point_indices.length; i++) {\n\t\t\tconst curve_point_indices = accumulated_curve_point_indices[i];\n\t\t\tconst current_points = curve_point_indices.map((index) => points[index]);\n\t\t\tconst geometry = this._create_curve_from_points(current_points);\n\t\t\tif (geometry) {\n\t\t\t\tgeometries.push(geometry);\n\t\t\t}\n\t\t}\n\t\tconst merged_geometry = BufferGeometryUtils.mergeBufferGeometries(geometries);\n\t\tconst object = this.create_object(merged_geometry, CoreConstant.OBJECT_TYPE.LINE_SEGMENTS);\n\t\treturn object;\n\t}\n\n\t_create_curve_from_points(points: CorePoint[]) {\n\t\tif (points.length <= 1) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst old_curve_positions = lodash_map(points, (point) => point.attrib_value('position'));\n\t\tconst closed = false;\n\t\tconst curve_type = CURVE_TYPES[this.pv.curve_type];\n\t\tconst tension = this.pv.tension;\n\t\tconst curve = new CatmullRomCurve3(old_curve_positions, closed, curve_type, tension);\n\t\t// const curve = new LineCurve3(old_curve_positions);\n\t\t// const curve = new CubicBezierCurve3(old_curve_positions);\n\t\t// const curve = new QuadraticBezierCurve3(old_curve_positions);\n\n\t\t// TODO: could I detect when a curve has points that are very close\n\t\t// and prevent a curve to go too far\n\t\tconst new_curve_points = this._get_points_from_curve(curve);\n\n\t\tlet positions = [];\n\t\tconst indices = [];\n\n\t\tfor (let i = 0; i < new_curve_points.length; i++) {\n\t\t\tconst point_position = new_curve_points[i];\n\n\t\t\tconst position = point_position.toArray();\n\t\t\tpositions.push(position);\n\n\t\t\tif (i > 0) {\n\t\t\t\tindices.push(i - 1);\n\t\t\t\tindices.push(i);\n\t\t\t}\n\t\t}\n\n\t\tpositions = lodash_flatten(positions);\n\t\tconst geometry = new BufferGeometry();\n\t\tgeometry.setAttribute('position', new Float32BufferAttribute(positions, 3));\n\t\tgeometry.setIndex(indices);\n\n\t\treturn geometry;\n\t\t// const object = this.create_object(geometry, CoreConstant.OBJECT_TYPE.LINE_SEGMENTS);\n\t\t// this._objects.push(object);\n\t}\n\n\t_get_points_from_curve(curve: CatmullRomCurve3) {\n\t\tconst method = METHODS[this.pv.method];\n\t\tswitch (method) {\n\t\t\tcase METHOD.POINTS_COUNT:\n\t\t\t\treturn curve.getSpacedPoints(Math.max(2, this.pv.points_count));\n\t\t\tcase METHOD.SEGMENT_LENGTH:\n\t\t\t\tvar length = curve.getLength();\n\n\t\t\t\tvar points_count = this.pv.segment_length !== 0 ? 1 + length / this.pv.segment_length : 2;\n\n\t\t\t\tpoints_count = Math.max(2, points_count);\n\n\t\t\t\treturn curve.getSpacedPoints(points_count);\n\t\t}\n\t\tTypeAssert.unreachable(method);\n\t}\n}\n","import {BufferGeometry} from 'three/src/core/BufferGeometry';\nimport {BufferAttribute} from 'three/src/core/BufferAttribute';\nconst THREE = {BufferAttribute, BufferGeometry};\nimport lodash_range from 'lodash/range';\nimport lodash_isNumber from 'lodash/isNumber';\nimport lodash_sortBy from 'lodash/sortBy';\nimport {TypedSopNode} from './_Base';\nimport {CoreGroup} from '../../../core/geometry/Group';\nimport {CoreConstant} from '../../../core/geometry/Constant';\nimport {CoreMath} from '../../../core/math/_Module';\nimport {CoreIterator} from '../../../core/Iterator';\n\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nimport {InputCloneMode} from '../../poly/InputCloneMode';\nclass ScatterSopParamsConfig extends NodeParamsConfig {\n\tpoints_count = ParamConfig.INTEGER(100, {\n\t\trange: [0, 100],\n\t\trange_locked: [true, false],\n\t});\n\tseed = ParamConfig.INTEGER(0, {\n\t\trange: [0, 100],\n\t\trange_locked: [false, false],\n\t});\n\ttransfer_attributes = ParamConfig.BOOLEAN(0);\n\tattributes_to_transfer = ParamConfig.STRING('normal', {\n\t\tvisible_if: {transfer_attributes: 1},\n\t});\n\tadd_id_attribute = ParamConfig.BOOLEAN(1);\n}\nconst ParamsConfig = new ScatterSopParamsConfig();\n\nexport class ScatterSopNode extends TypedSopNode<ScatterSopParamsConfig> {\n\tparams_config = ParamsConfig;\n\tstatic type() {\n\t\treturn 'scatter';\n\t}\n\n\t// private _positions: number[];\n\t// private _areas_thresholds: number[];\n\t// private _attrib_values_by_name = {};\n\t// private _area_sum: number;\n\n\tstatic displayed_input_names(): string[] {\n\t\treturn ['geometry to scatter points onto'];\n\t}\n\n\tinitialize_node() {\n\t\tthis.io.inputs.set_count(1);\n\t\tthis.io.inputs.init_inputs_clonable_state([InputCloneMode.NEVER]);\n\t}\n\n\tasync cook(input_contents: CoreGroup[]) {\n\t\t// const objects = input_contents[0] //.group({clone: false})\n\t\tconst core_group = input_contents[0]; //CoreGroup.from_objects(objects)\n\t\tlet faces = core_group.faces();\n\t\t// const areas_by_face_index = []\n\t\tconst areas_thresholds: number[] = [];\n\t\tlet area_sum = 0;\n\t\tconst area_by_face_index: Map<number, number> = new Map();\n\n\t\tfor (let face of faces) {\n\t\t\tconst area = face.area;\n\t\t\tarea_by_face_index.set(face.index, area);\n\t\t}\n\t\tconst sorted_faces = lodash_sortBy(faces, (f) => {\n\t\t\treturn area_by_face_index.get(f.index);\n\t\t});\n\n\t\tlet i = 0;\n\t\tfor (let face of sorted_faces) {\n\t\t\tarea_sum += area_by_face_index.get(face.index) as number;\n\t\t\tareas_thresholds[i] = area_sum;\n\t\t\ti++;\n\t\t}\n\n\t\tconst positions: number[] = [];\n\t\tlet attrib_names: string[] = [];\n\t\tif (this.pv.transfer_attributes) {\n\t\t\tattrib_names = core_group.attrib_names_matching_mask(this.pv.attributes_to_transfer);\n\t\t}\n\n\t\tconst attrib_values_by_name: Map<string, number[]> = new Map();\n\t\tconst attrib_sizes_by_name: Map<string, number> = new Map();\n\t\tfor (let attrib_name of attrib_names) {\n\t\t\tattrib_values_by_name.set(attrib_name, []);\n\t\t\tattrib_sizes_by_name.set(attrib_name, core_group.attrib_size(attrib_name));\n\t\t}\n\n\t\tconst iterator = new CoreIterator();\n\t\t// await iterator.start_with_count(this.pv.points_count, this._add_point.bind(this))\n\t\tawait iterator.start_with_count(this.pv.points_count, (point_index: number) => {\n\t\t\tconst rand = CoreMath.rand_float(this.pv.seed + point_index) * area_sum;\n\n\t\t\tfor (let face_index = 0; face_index < areas_thresholds.length; face_index++) {\n\t\t\t\tconst areas_threshold = areas_thresholds[face_index];\n\n\t\t\t\tif (rand <= areas_threshold) {\n\t\t\t\t\tconst face = sorted_faces[face_index];\n\t\t\t\t\tconst position = face.random_position(rand);\n\t\t\t\t\tposition.toArray(positions, positions.length);\n\n\t\t\t\t\tfor (let attrib_name of attrib_names) {\n\t\t\t\t\t\tconst attrib_value = face.attrib_value_at_position(attrib_name, position);\n\t\t\t\t\t\tif (lodash_isNumber(attrib_value)) {\n\t\t\t\t\t\t\tattrib_values_by_name.get(attrib_name)!.push(attrib_value);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tattrib_value.toArray(\n\t\t\t\t\t\t\t\tattrib_values_by_name.get(attrib_name),\n\t\t\t\t\t\t\t\tattrib_values_by_name.get(attrib_name)!.length\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\t// for(let point_index=0; point_index<this.pv.points_count; point_index++){\n\n\t\t// \tconst rand = CoreMath.rand_float(this.pv.seed+point_index) * area_sum\n\n\t\t// \tfor(let face_index=0; face_index<areas_thresholds.length; face_index++){\n\n\t\t// \t\tconst areas_threshold = areas_thresholds[face_index]\n\n\t\t// \t\tif(rand <= areas_threshold){\n\t\t// \t\t\tconst face = sorted_faces[face_index]\n\t\t// \t\t\tconst position = face.random_position(rand)\n\t\t// \t\t\tposition.toArray(positions, positions.length)\n\n\t\t// \t\t\tfor(let attrib_name of attrib_names){\n\t\t// \t\t\t\tconst attrib_value = face.attrib_value_at_position(attrib_name, position)\n\t\t// \t\t\t\tif (lodash_isNumber(attrib_value)){\n\t\t// \t\t\t\t\tattrib_values_by_name[attrib_name].push(attrib_value)\n\t\t// \t\t\t\t} else {\n\t\t// \t\t\t\t\tattrib_value.toArray(\n\t\t// \t\t\t\t\t\tattrib_values_by_name[attrib_name],\n\t\t// \t\t\t\t\t\tattrib_values_by_name[attrib_name].length\n\t\t// \t\t\t\t\t)\n\t\t// \t\t\t\t}\n\t\t// \t\t\t}\n\n\t\t// \t\t\tbreak;\n\t\t// \t\t}\n\t\t// \t}\n\t\t// }\n\n\t\tconst geometry = new THREE.BufferGeometry();\n\t\tgeometry.setAttribute('position', new THREE.BufferAttribute(new Float32Array(positions), 3));\n\t\tfor (let attrib_name of attrib_names) {\n\t\t\tgeometry.setAttribute(\n\t\t\t\tattrib_name,\n\t\t\t\tnew THREE.BufferAttribute(\n\t\t\t\t\tnew Float32Array(attrib_values_by_name.get(attrib_name)!),\n\t\t\t\t\tattrib_sizes_by_name.get(attrib_name)!\n\t\t\t\t)\n\t\t\t);\n\t\t}\n\n\t\tif (this.pv.add_id_attribute) {\n\t\t\tconst ids = lodash_range(this.pv.points_count);\n\t\t\tgeometry.setAttribute('id', new THREE.BufferAttribute(new Float32Array(ids), 1));\n\t\t}\n\n\t\tthis.set_geometry(geometry, CoreConstant.OBJECT_TYPE.POINTS);\n\t}\n\n\t// private _add_point(point_index: number) {\n\t// \tconst rand = CoreMath.rand_float(this.pv.seed + point_index) * this._area_sum;\n\n\t// \tfor (let face_index = 0; face_index < this._areas_thresholds.length; face_index++) {\n\t// \t\tconst areas_threshold = this._areas_thresholds[face_index];\n\n\t// \t\tif (rand <= areas_threshold) {\n\t// \t\t\tconst face = this._sorted_faces[face_index];\n\t// \t\t\tconst position = face.random_position(rand);\n\t// \t\t\tposition.toArray(positions, positions.length);\n\n\t// \t\t\tfor (let attrib_name of attrib_names) {\n\t// \t\t\t\tconst attrib_value = face.attrib_value_at_position(attrib_name, position);\n\t// \t\t\t\tif (lodash_isNumber(attrib_value)) {\n\t// \t\t\t\t\tthis._attrib_values_by_name[attrib_name].push(attrib_value);\n\t// \t\t\t\t} else {\n\t// \t\t\t\t\tattrib_value.toArray(\n\t// \t\t\t\t\t\tthis._attrib_values_by_name[attrib_name],\n\t// \t\t\t\t\t\tthis._attrib_values_by_name[attrib_name].length\n\t// \t\t\t\t\t);\n\t// \t\t\t\t}\n\t// \t\t\t}\n\n\t// \t\t\tbreak;\n\t// \t\t}\n\t// \t}\n\t// }\n}\n","import {TypedSopNode} from './_Base';\nimport {InputCloneMode} from '../../poly/InputCloneMode';\nimport {CoreGroup} from '../../../core/geometry/Group';\n\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nclass ShadowsSopParamsConfig extends NodeParamsConfig {\n\tcast_shadow = ParamConfig.BOOLEAN(1);\n\treceive_shadow = ParamConfig.BOOLEAN(1);\n\tapply_to_children = ParamConfig.BOOLEAN(0);\n}\nconst ParamsConfig = new ShadowsSopParamsConfig();\n\nexport class ShadowsSopNode extends TypedSopNode<ShadowsSopParamsConfig> {\n\tparams_config = ParamsConfig;\n\tstatic type() {\n\t\treturn 'shadows';\n\t}\n\n\tstatic displayed_input_names(): string[] {\n\t\treturn ['objects to change shadows properties of'];\n\t}\n\n\tinitialize_node() {\n\t\tthis.io.inputs.set_count(1);\n\t\tthis.io.inputs.init_inputs_clonable_state([InputCloneMode.FROM_NODE]);\n\t}\n\n\tasync cook(input_contents: CoreGroup[]) {\n\t\tconst core_group = input_contents[0];\n\n\t\tfor (let object of core_group.objects()) {\n\t\t\tif (this.pv.apply_to_children) {\n\t\t\t\tobject.traverse((child) => {\n\t\t\t\t\tchild.castShadow = this.pv.cast_shadow;\n\t\t\t\t\tchild.receiveShadow = this.pv.receive_shadow;\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tobject.castShadow = this.pv.cast_shadow;\n\t\t\t\tobject.receiveShadow = this.pv.receive_shadow;\n\t\t\t}\n\t\t}\n\n\t\tconsole.log(core_group.objects());\n\t\tthis.set_core_group(core_group);\n\t}\n}\n","import {BufferGeometry} from 'three/src/core/BufferGeometry';\nimport {Mesh} from 'three/src/objects/Mesh';\nimport {LineSegments} from 'three/src/objects/LineSegments';\nimport lodash_sortBy from 'lodash/sortBy';\nimport lodash_reverse from 'lodash/reverse';\nimport lodash_compact from 'lodash/compact';\nimport {TypedSopNode} from './_Base';\n\nimport {CoreGeometryUtilCurve} from '../../../core/geometry/util/Curve';\nimport {CoreGeometryOperationSkin} from '../../../core/geometry/operation/Skin';\nimport {CoreGroup} from '../../../core/geometry/Group';\n\nimport {NodeParamsConfig} from '../utils/params/ParamsConfig';\nclass SkinSopParamsConfig extends NodeParamsConfig {}\nconst ParamsConfig = new SkinSopParamsConfig();\n\nexport class SkinSopNode extends TypedSopNode<SkinSopParamsConfig> {\n\tparams_config = ParamsConfig;\n\tstatic type() {\n\t\treturn 'skin';\n\t}\n\n\tstatic displayed_input_names(): string[] {\n\t\treturn ['lines to create polygons from', 'if used, lines from both inputs will be used'];\n\t}\n\n\tinitialize_node() {\n\t\tthis.io.inputs.set_count(1, 2);\n\t}\n\n\tcook(input_contents: CoreGroup[]) {\n\t\tswitch (lodash_compact(this.io.inputs.inputs()).length) {\n\t\t\tcase 1:\n\t\t\t\treturn this.process_one_input(input_contents);\n\t\t\tcase 2:\n\t\t\t\treturn this.process_two_inputs(input_contents);\n\t\t\tdefault:\n\t\t\t\treturn this.states.error.set('inputs count not valid');\n\t\t}\n\t}\n\n\tprocess_one_input(input_contents: CoreGroup[]) {\n\t\tconst core_group0 = input_contents[0];\n\t\tconst line_segments0 = this._get_line_segments(core_group0);\n\n\t\tconst geometries: BufferGeometry[] = [];\n\t\tif (line_segments0) {\n\t\t\tconst first_line_segment = line_segments0[0] as Mesh;\n\t\t\tif (first_line_segment) {\n\t\t\t\tconst src_geometries = CoreGeometryUtilCurve.line_segment_to_geometries(\n\t\t\t\t\tfirst_line_segment.geometry as BufferGeometry\n\t\t\t\t);\n\t\t\t\tsrc_geometries.forEach((src_geometry, i) => {\n\t\t\t\t\tif (i > 0) {\n\t\t\t\t\t\tconst prev_src_geometry = src_geometries[i - 1];\n\n\t\t\t\t\t\tconst geometry = this._skin(prev_src_geometry, src_geometry);\n\t\t\t\t\t\tgeometries.push(geometry);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\tthis.set_geometries(geometries);\n\t}\n\n\tprocess_two_inputs(input_contents: CoreGroup[]) {\n\t\tconst core_group0 = input_contents[0];\n\t\tconst core_group1 = input_contents[1];\n\t\tconst line_segments0 = this._get_line_segments(core_group0);\n\t\tconst line_segments1 = this._get_line_segments(core_group1);\n\t\tconst line_segments = lodash_reverse(lodash_sortBy([line_segments0, line_segments1], (array) => array.length));\n\t\tconst smallest_array = line_segments[0];\n\t\tconst largest_array = line_segments[1];\n\n\t\tconst geometries: BufferGeometry[] = [];\n\t\tsmallest_array.forEach((line_segment, i) => {\n\t\t\tconst other_line_segment = largest_array[i];\n\n\t\t\tif (line_segment != null && other_line_segment != null) {\n\t\t\t\tconst geo = (line_segment as Mesh).geometry as BufferGeometry;\n\t\t\t\tconst other_geo = (other_line_segment as Mesh).geometry as BufferGeometry;\n\t\t\t\tconst geometry = this._skin(geo, other_geo);\n\t\t\t\tgeometries.push(geometry);\n\t\t\t}\n\t\t});\n\n\t\tthis.set_geometries(geometries);\n\t}\n\n\t_get_line_segments(core_group: CoreGroup) {\n\t\treturn core_group.objects().filter((child) => (child as LineSegments).isLineSegments);\n\t}\n\n\t_skin(geometry1: BufferGeometry, geometry0: BufferGeometry) {\n\t\t// TODO: maybe instead of doing this,\n\t\tconst geometry = new BufferGeometry();\n\n\t\tconst operation = new CoreGeometryOperationSkin(geometry, geometry1, geometry0);\n\t\toperation.process();\n\n\t\treturn geometry;\n\t}\n}\n","import {SphereBufferGeometry} from 'three/src/geometries/SphereGeometry';\nimport {IcosahedronBufferGeometry} from 'three/src/geometries/IcosahedronGeometry';\nimport {TypedSopNode} from './_Base';\n\nenum SphereType {\n\tDEFAULT = 'default',\n\tISOCAHEDRON = 'isocahedron',\n}\ntype SphereTypes = {[key in SphereType]: number};\nconst SPHERE_TYPE: SphereTypes = {\n\tdefault: 0,\n\tisocahedron: 1,\n};\nconst SPHERE_TYPES: Array<SphereType> = [SphereType.DEFAULT, SphereType.ISOCAHEDRON];\n\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nimport {InputCloneMode} from '../../poly/InputCloneMode';\nimport {CoreGroup} from '../../../core/geometry/Group';\nclass SphereSopParamsConfig extends NodeParamsConfig {\n\ttype = ParamConfig.INTEGER(SPHERE_TYPE.default, {\n\t\tmenu: {\n\t\t\tentries: SPHERE_TYPES.map((name) => {\n\t\t\t\treturn {name: name, value: SPHERE_TYPE[name]};\n\t\t\t}),\n\t\t},\n\t});\n\tradius = ParamConfig.FLOAT(1, {visible_if: {type: SPHERE_TYPE.default}});\n\tresolution = ParamConfig.VECTOR2([8, 6], {visible_if: {type: SPHERE_TYPE.default}});\n\topen = ParamConfig.BOOLEAN(0, {visible_if: {type: SPHERE_TYPE.default}});\n\tangle_range_x = ParamConfig.VECTOR2([0, '$PI*2'], {visible_if: {type: SPHERE_TYPE.default, open: true}});\n\tangle_range_y = ParamConfig.VECTOR2([0, '$PI*2'], {visible_if: {type: SPHERE_TYPE.default, open: true}});\n\tdetail = ParamConfig.INTEGER(1, {\n\t\trange: [0, 5],\n\t\trange_locked: [true, false],\n\t\tvisible_if: {type: SPHERE_TYPE.isocahedron},\n\t});\n\tcenter = ParamConfig.VECTOR3([0, 0, 0]);\n}\nconst ParamsConfig = new SphereSopParamsConfig();\n\nexport class SphereSopNode extends TypedSopNode<SphereSopParamsConfig> {\n\tparams_config = ParamsConfig;\n\tstatic type() {\n\t\treturn 'sphere';\n\t}\n\n\tinitialize_node() {\n\t\tthis.io.inputs.set_count(0, 1);\n\t\tthis.io.inputs.init_inputs_clonable_state([InputCloneMode.NEVER]);\n\t}\n\n\tcook(input_contents: CoreGroup[]) {\n\t\tconst core_group = input_contents[0];\n\t\tif (core_group) {\n\t\t\tthis._cook_with_input(core_group);\n\t\t} else {\n\t\t\tthis._cook_without_input();\n\t\t}\n\t}\n\tprivate _cook_without_input() {\n\t\tconst geometry = this._create_required_geometry();\n\t\tgeometry.translate(this.pv.center.x, this.pv.center.y, this.pv.center.z);\n\t\tthis.set_geometry(geometry);\n\t}\n\tprivate _cook_with_input(core_group: CoreGroup) {\n\t\tconst bbox = core_group.bounding_box();\n\t\tconst size = bbox.max.clone().sub(bbox.min);\n\t\tconst center = bbox.max\n\t\t\t.clone()\n\t\t\t.add(bbox.min)\n\t\t\t.multiplyScalar(0.5);\n\n\t\tconst geometry = this._create_required_geometry();\n\t\tgeometry.translate(this.pv.center.x, this.pv.center.y, this.pv.center.z);\n\t\tgeometry.translate(center.x, center.y, center.z);\n\t\tgeometry.scale(size.x, size.y, size.z);\n\t\tthis.set_geometry(geometry);\n\t}\n\n\tprivate _create_required_geometry() {\n\t\tif (this.pv.type == SPHERE_TYPE.default) {\n\t\t\treturn this._create_default_sphere();\n\t\t} else {\n\t\t\treturn this._create_default_isocahedron();\n\t\t}\n\t}\n\n\tprivate _create_default_sphere() {\n\t\tif (this.pv.open) {\n\t\t\treturn new SphereBufferGeometry(\n\t\t\t\tthis.pv.radius,\n\t\t\t\tthis.pv.resolution.x,\n\t\t\t\tthis.pv.resolution.y,\n\t\t\t\tthis.pv.angle_range_x.x,\n\t\t\t\tthis.pv.angle_range_x.y,\n\t\t\t\tthis.pv.angle_range_y.x,\n\t\t\t\tthis.pv.angle_range_y.y\n\t\t\t);\n\t\t} else {\n\t\t\treturn new SphereBufferGeometry(this.pv.radius, this.pv.resolution.x, this.pv.resolution.y);\n\t\t}\n\t}\n\t_create_default_isocahedron() {\n\t\treturn new IcosahedronBufferGeometry(this.pv.radius, this.pv.detail);\n\t}\n}\n","import {TypedSopNode} from './_Base';\n\nconst INPUT_NAME = 'geometry to switch to';\n\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nimport {InputCloneMode} from '../../poly/InputCloneMode';\nclass SwitchSopParamsConfig extends NodeParamsConfig {\n\tinput = ParamConfig.INTEGER(0, {\n\t\trange: [0, 3],\n\t\trange_locked: [true, true],\n\t});\n}\nconst ParamsConfig = new SwitchSopParamsConfig();\n\nexport class SwitchSopNode extends TypedSopNode<SwitchSopParamsConfig> {\n\tparams_config = ParamsConfig;\n\tstatic type() {\n\t\treturn 'switch';\n\t}\n\n\tstatic displayed_input_names(): string[] {\n\t\treturn [INPUT_NAME, INPUT_NAME, INPUT_NAME, INPUT_NAME];\n\t}\n\n\tinitialize_node() {\n\t\tthis.io.inputs.set_count(0, 4);\n\t\tthis.io.inputs.init_inputs_clonable_state([\n\t\t\tInputCloneMode.NEVER,\n\t\t\tInputCloneMode.NEVER,\n\t\t\tInputCloneMode.NEVER,\n\t\t\tInputCloneMode.NEVER,\n\t\t]);\n\t\tthis.ui_data.set_width(100);\n\t\t// this.ui_data.set_icon('code-branch');\n\n\t\tthis.cook_controller.disallow_inputs_evaluation();\n\t}\n\n\tasync cook() {\n\t\tconst input_index = this.pv.input;\n\t\tif (this.io.inputs.has_input(input_index)) {\n\t\t\tconst container = await this.container_controller.request_input_container(input_index);\n\t\t\tthis.set_core_group(container.core_content());\n\t\t} else {\n\t\t\tthis.states.error.set(`no input ${input_index}`);\n\t\t}\n\t}\n}\n","import lodash_range from 'lodash/range';\n\n// import {CoreFont} from '../../../Core/Font'\nimport {TypedSopNode} from './_Base';\nimport {CoreConstant} from '../../../core/geometry/Constant';\n\nimport {TextBufferGeometry} from 'three/src/geometries/TextGeometry';\nimport {BufferGeometry} from 'three/src/core/BufferGeometry';\nimport {ShapeBufferGeometry} from 'three/src/geometries/ShapeGeometry';\nimport {FontLoader} from 'three/src/loaders/FontLoader';\nimport {Font} from 'three/src/extras/core/Font';\nimport {Float32BufferAttribute} from 'three/src/core/BufferAttribute';\nimport {Vector3} from 'three/src/math/Vector3';\nimport {Path} from 'three/src/extras/core/Path';\nimport {Shape} from 'three/src/extras/core/Shape';\n\nimport {BufferGeometryUtils} from '../../../../modules/three/examples/jsm/utils/BufferGeometryUtils';\n\nvar opentype = require('opentype.js');\n\nimport {TTFLoader} from '../../../../modules/three/examples/jsm/loaders/TTFLoader';\nimport {SVGLoader} from '../../../../modules/three/examples/jsm/loaders/SVGLoader';\n\nconst DEFAULT_URL = '/fonts/droid_sans_regular.typeface.json';\n\ndeclare global {\n\tinterface Window {\n\t\topentype: any;\n\t}\n}\n\n// const DEFAULT_PARAMS = {\n// \tsize: 1,\n// \theight: 0.1,\n// \tcurveSegments: 1\n// };\n\nexport enum TEXT_TYPE {\n\tMESH = 'mesh',\n\tFLAT = 'flat',\n\tLINE = 'line',\n\tSTROKE = 'stroke',\n}\nexport const TEXT_TYPES: Array<TEXT_TYPE> = [TEXT_TYPE.MESH, TEXT_TYPE.FLAT, TEXT_TYPE.LINE, TEXT_TYPE.STROKE];\n\ninterface FontByUrl {\n\t[propName: string]: Font;\n}\n\nconst GENERATION_ERROR_MESSAGE = `failed to generate geometry. Try to remove some characters`;\n\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nclass TextSopParamsConfig extends NodeParamsConfig {\n\tfont = ParamConfig.STRING('');\n\ttext = ParamConfig.STRING('polygonjs', {multiline: true});\n\ttype = ParamConfig.INTEGER(0, {\n\t\tmenu: {\n\t\t\tentries: TEXT_TYPES.map((type, i) => {\n\t\t\t\treturn {\n\t\t\t\t\tname: type,\n\t\t\t\t\tvalue: i,\n\t\t\t\t};\n\t\t\t}),\n\t\t},\n\t});\n\tsize = ParamConfig.FLOAT(1, {\n\t\trange: [0, 1],\n\t\trange_locked: [true, false],\n\t});\n\textrude = ParamConfig.FLOAT(0.1, {\n\t\tvisible_if: {\n\t\t\ttype: TEXT_TYPES.indexOf(TEXT_TYPE.MESH),\n\t\t},\n\t});\n\tsegments = ParamConfig.INTEGER(1, {\n\t\trange: [1, 20],\n\t\trange_locked: [true, false],\n\t\tvisible_if: {\n\t\t\ttype: TEXT_TYPES.indexOf(TEXT_TYPE.MESH),\n\t\t},\n\t});\n\tstroke_width = ParamConfig.FLOAT(0.02, {\n\t\tvisible_if: {\n\t\t\ttype: TEXT_TYPES.indexOf(TEXT_TYPE.STROKE),\n\t\t},\n\t});\n}\n\nconst ParamsConfig = new TextSopParamsConfig();\n\nexport class TextSopNode extends TypedSopNode<TextSopParamsConfig> {\n\tparams_config = ParamsConfig;\n\tstatic type() {\n\t\treturn 'text';\n\t}\n\t// static required_three_imports() {\n\t// \treturn ['loaders/TTFLoader', 'loaders/SVGLoader'];\n\t// }\n\n\tprivate _font_loader: FontLoader = new FontLoader();\n\tprivate _ttf_loader: TTFLoader | undefined;\n\tprivate _svg_loader: typeof SVGLoader | undefined;\n\tprivate _loaded_fonts: FontByUrl = {};\n\n\tinitialize_node() {}\n\n\tasync cook() {\n\t\ttry {\n\t\t\tthis._loaded_fonts[this.pv.font] = this._loaded_fonts[this.pv.font] || (await this._load_url(this.pv.font));\n\t\t} catch (err) {\n\t\t\tthis.states.error.set(`count not load font (${this.pv.font})`);\n\t\t\treturn;\n\t\t}\n\t\tconst font = this._loaded_fonts[this.pv.font];\n\t\tif (font) {\n\t\t\tswitch (TEXT_TYPES[this.pv.type]) {\n\t\t\t\tcase TEXT_TYPE.MESH:\n\t\t\t\t\treturn this._create_geometry_from_type_mesh(font);\n\t\t\t\tcase TEXT_TYPE.FLAT:\n\t\t\t\t\treturn this._create_geometry_from_type_flat(font);\n\t\t\t\tcase TEXT_TYPE.LINE:\n\t\t\t\t\treturn this._create_geometry_from_type_line(font);\n\t\t\t\tcase TEXT_TYPE.STROKE:\n\t\t\t\t\treturn this._create_geometry_from_type_stroke(font);\n\t\t\t\tdefault:\n\t\t\t\t\tconsole.warn('type is not valid');\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate _create_geometry_from_type_mesh(font: Font) {\n\t\tconst text = this.displayed_text();\n\n\t\tconst parameters = {\n\t\t\tfont: font,\n\t\t\tsize: this.pv.size,\n\t\t\theight: this.pv.extrude,\n\t\t\tcurveSegments: this.pv.segments,\n\t\t};\n\n\t\ttry {\n\t\t\tconst geometry = new TextBufferGeometry(text, parameters);\n\t\t\tif (!geometry.index) {\n\t\t\t\tconst position_array = geometry.getAttribute('position').array;\n\t\t\t\tgeometry.setIndex(lodash_range(position_array.length / 3));\n\t\t\t}\n\t\t\tthis.set_geometry(geometry);\n\t\t} catch (err) {\n\t\t\tthis.states.error.set(GENERATION_ERROR_MESSAGE);\n\t\t}\n\t}\n\n\tprivate _create_geometry_from_type_flat(font: Font) {\n\t\tconst shapes = this._get_shapes(font);\n\t\tif (shapes) {\n\t\t\tvar geometry = new ShapeBufferGeometry(shapes);\n\t\t\tthis.set_geometry(geometry);\n\t\t}\n\t}\n\tprivate _create_geometry_from_type_line(font: Font) {\n\t\tconst shapes = this.shapes_from_font(font);\n\t\tif (shapes) {\n\t\t\tconst positions = [];\n\t\t\tconst indices = [];\n\t\t\tlet current_index = 0;\n\n\t\t\tfor (let i = 0; i < shapes.length; i++) {\n\t\t\t\tconst shape = shapes[i];\n\t\t\t\tconst points = shape.getPoints();\n\t\t\t\tfor (let j = 0; j < points.length; j++) {\n\t\t\t\t\tconst point = points[j];\n\t\t\t\t\tpositions.push(point.x);\n\t\t\t\t\tpositions.push(point.y);\n\t\t\t\t\tpositions.push(0);\n\t\t\t\t\tindices.push(current_index);\n\t\t\t\t\tif (j > 0 && j < points.length - 1) {\n\t\t\t\t\t\tindices.push(current_index);\n\t\t\t\t\t}\n\t\t\t\t\tcurrent_index += 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tconst geometry = new BufferGeometry();\n\t\t\tgeometry.setAttribute('position', new Float32BufferAttribute(positions, 3));\n\t\t\tgeometry.setIndex(indices);\n\t\t\tthis.set_geometry(geometry, CoreConstant.OBJECT_TYPE.LINE_SEGMENTS);\n\t\t}\n\t}\n\tprivate async _create_geometry_from_type_stroke(font: Font) {\n\t\tconst shapes = this.shapes_from_font(font);\n\t\tif (shapes) {\n\t\t\t// const color = new Color( 0xffffff );\n\t\t\tthis._svg_loader = this._svg_loader || (await this._load_svg_loader());\n\t\t\t// TODO: typescript: correct definition for last 3 optional args\n\t\t\tvar style = this._svg_loader.getStrokeStyle(this.pv.stroke_width, 'white', 'miter', 'butt', 4);\n\t\t\tconst geometries = [];\n\n\t\t\t// const positions = [];\n\t\t\t// const indices = [];\n\t\t\t// let current_index = 0;\n\n\t\t\tfor (let i = 0; i < shapes.length; i++) {\n\t\t\t\tconst shape = shapes[i];\n\t\t\t\tconst points = shape.getPoints();\n\t\t\t\t// TODO: typescript: correct definition for points, arcDivisions, and minDistance\n\t\t\t\tconst arcDivisions = 12;\n\t\t\t\tconst minDistance = 0.001;\n\t\t\t\tconst geometry = this._svg_loader.pointsToStroke(\n\t\t\t\t\t(<unknown>points) as Vector3[],\n\t\t\t\t\tstyle,\n\t\t\t\t\tarcDivisions,\n\t\t\t\t\tminDistance\n\t\t\t\t);\n\t\t\t\tgeometries.push(geometry);\n\t\t\t}\n\t\t\tconst merged_geometry = BufferGeometryUtils.mergeBufferGeometries(geometries);\n\t\t\tthis.set_geometry(merged_geometry); //, CoreConstant.OBJECT_TYPE.LINE_SEGMENTS);\n\t\t}\n\t}\n\n\tprivate shapes_from_font(font: Font) {\n\t\tconst shapes = this._get_shapes(font);\n\t\tif (shapes) {\n\t\t\tconst holeShapes: Path[] = [];\n\t\t\tfor (let i = 0; i < shapes.length; i++) {\n\t\t\t\tconst shape = shapes[i];\n\t\t\t\tif (shape.holes && shape.holes.length > 0) {\n\t\t\t\t\tfor (let j = 0; j < shape.holes.length; j++) {\n\t\t\t\t\t\tconst hole = shape.holes[j];\n\t\t\t\t\t\tholeShapes.push(hole);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tshapes.push.apply(shapes, holeShapes as Shape[]);\n\t\t\treturn shapes;\n\t\t}\n\t}\n\n\tprivate _get_shapes(font: Font) {\n\t\tconst text = this.displayed_text();\n\t\ttry {\n\t\t\tconst shapes = font.generateShapes(text, this.pv.size);\n\t\t\treturn shapes;\n\t\t} catch (err) {\n\t\t\tthis.states.error.set(GENERATION_ERROR_MESSAGE);\n\t\t}\n\t}\n\n\tprivate displayed_text(): string {\n\t\treturn this.pv.text || '';\n\t}\n\n\t// _create_shape(font){\n\t// \tconst shapes = font.generateShapes( this.displayed_text(), 100 );\n\t// \tvar geometry = new ShapeBufferGeometry( shapes );\n\t// \treturn geometry\n\t// \t// geometry.computeBoundingBox();\n\t// \t// xMid = - 0.5 * ( geometry.boundingBox.max.x - geometry.boundingBox.min.x );\n\t// \t// geometry.translate( xMid, 0, 0 );\n\t// \t// make shape ( N.B. edge view not visible )\n\t// \t// text = new Mesh( geometry, matLite );\n\t// \t// text.position.z = - 150;\n\t// }\n\n\tprivate _load_url(url: string) {\n\t\tif (url === '') {\n\t\t\turl = DEFAULT_URL;\n\t\t}\n\t\tconst elements1 = url.split('?')[0];\n\t\tconst elements2 = elements1.split('.');\n\t\tconst ext = elements2[elements2.length - 1];\n\t\turl = `${url}?${Date.now()}`;\n\t\tswitch (ext) {\n\t\t\tcase 'ttf': {\n\t\t\t\treturn this._load_ttf(url);\n\t\t\t}\n\t\t\tcase 'json': {\n\t\t\t\treturn this._load_json(url);\n\t\t\t}\n\t\t\tdefault: {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate _load_ttf(url: string): Promise<Font> {\n\t\treturn new Promise(async (resolve, reject) => {\n\t\t\tthis._ttf_loader = this._ttf_loader || (await this._load_ttf_loader());\n\t\t\twindow.opentype = opentype;\n\t\t\tthis._ttf_loader.load(\n\t\t\t\turl,\n\t\t\t\t(fnt: object) => {\n\t\t\t\t\tconst parsed = this._font_loader.parse(fnt);\n\t\t\t\t\t// make sure not to delete opentype from window, as it may be required by other nodes\n\t\t\t\t\t// delete window.opentype;\n\t\t\t\t\tresolve(parsed);\n\t\t\t\t},\n\t\t\t\tundefined,\n\t\t\t\t() => {\n\t\t\t\t\treject();\n\t\t\t\t}\n\t\t\t);\n\t\t});\n\t}\n\tprivate _load_json(url: string): Promise<Font> {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tthis._font_loader.load(\n\t\t\t\turl,\n\t\t\t\t(font) => {\n\t\t\t\t\tresolve(font);\n\t\t\t\t},\n\t\t\t\tundefined,\n\t\t\t\t() => {\n\t\t\t\t\treject();\n\t\t\t\t}\n\t\t\t);\n\t\t});\n\t}\n\n\t// private _default_font_parameters(options){\n\t// \tif (options == null) { options = {}; }\n\t// \tconst default_options = lodash_clone(DEFAULT_PARAMS);\n\t// \tif (options['font'] == null) { options['font'] = this.font(); }\n\n\t// \tfor(let key of Object.keys(options)){\n\t// \t\tdefault_options[key] = options[key];\n\t// \t}\n\n\t// \treturn default_options;\n\t// }\n\tprivate async _load_ttf_loader(): Promise<TTFLoader> {\n\t\tconst {TTFLoader} = await import(`../../../../modules/three/examples/jsm/loaders/TTFLoader`);\n\t\tconst loader_constructor = (<unknown>TTFLoader) as typeof TTFLoader;\n\t\treturn new loader_constructor();\n\t}\n\tprivate async _load_svg_loader(): Promise<typeof SVGLoader> {\n\t\tconst {SVGLoader} = await import(`../../../../modules/three/examples/jsm/loaders/SVGLoader`);\n\t\treturn (<unknown>SVGLoader) as typeof SVGLoader;\n\t}\n}\n","import {TorusBufferGeometry} from 'three/src/geometries/TorusGeometry';\nimport {TypedSopNode} from './_Base';\n\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nclass TorusSopParamsConfig extends NodeParamsConfig {\n\tradius = ParamConfig.FLOAT(1, {range: [0, 1]});\n\tradius_tube = ParamConfig.FLOAT(1, {range: [0, 1]});\n\tsegments_radial = ParamConfig.INTEGER(20, {\n\t\trange: [1, 50],\n\t\trange_locked: [true, false],\n\t});\n\tsegments_tube = ParamConfig.INTEGER(12, {\n\t\trange: [1, 50],\n\t\trange_locked: [true, false],\n\t});\n}\nconst ParamsConfig = new TorusSopParamsConfig();\n\nexport class TorusSopNode extends TypedSopNode<TorusSopParamsConfig> {\n\tparams_config = ParamsConfig;\n\tstatic type() {\n\t\treturn 'torus';\n\t}\n\tinitialize_node() {}\n\n\tcook() {\n\t\tconst radius = this.pv.radius;\n\t\tconst radius_tube = this.pv.radius_tube;\n\t\tconst segments_radial = this.pv.segments_radial;\n\t\tconst segments_tube = this.pv.segments_tube;\n\t\t//radius : Float, tube : Float, radialSegments : Integer, tubularSegments : Integer, arc : Float\n\n\t\tconst geometry = new TorusBufferGeometry(radius, radius_tube, segments_radial, segments_tube);\n\t\tthis.set_geometry(geometry);\n\t}\n}\n","import {TorusKnotBufferGeometry} from 'three/src/geometries/TorusKnotGeometry';\nconst THREE = {TorusKnotBufferGeometry};\nimport {TypedSopNode} from './_Base';\n\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nclass TorusKnotSopParamsConfig extends NodeParamsConfig {\n\tradius = ParamConfig.FLOAT(1);\n\tradius_tube = ParamConfig.FLOAT(1);\n\tsegments_radial = ParamConfig.INTEGER(64, {range: [1, 128]});\n\tsegments_tube = ParamConfig.INTEGER(8, {range: [1, 32]});\n\tp = ParamConfig.INTEGER(2, {range: [1, 10]});\n\tq = ParamConfig.INTEGER(3, {range: [1, 10]});\n}\nconst ParamsConfig = new TorusKnotSopParamsConfig();\n\nexport class TorusKnotSopNode extends TypedSopNode<TorusKnotSopParamsConfig> {\n\tparams_config = ParamsConfig;\n\tstatic type() {\n\t\treturn 'torus_knot';\n\t}\n\tinitialize_node() {}\n\n\tcook() {\n\t\tconst radius = this.pv.radius;\n\t\tconst radius_tube = this.pv.radius_tube;\n\t\tconst segments_radial = this.pv.segments_radial;\n\t\tconst segments_tube = this.pv.segments_tube;\n\t\tconst p = this.pv.p;\n\t\tconst q = this.pv.q;\n\n\t\tconst geometry = new THREE.TorusKnotBufferGeometry(radius, radius_tube, segments_radial, segments_tube, p, q);\n\t\tthis.set_geometry(geometry);\n\t}\n}\n","import {TypedSopNode} from './_Base';\n// import {GroupParamController} from './utils/GroupParamController';\n\nimport {CoreGroup} from '../../../core/geometry/Group';\nimport {CoreTransform} from '../../../core/Transform';\n// import {ParamType} from '../../poly/ParamType';\nimport {InputCloneMode} from '../../poly/InputCloneMode';\n\n// const DEFAULT_PARAMS = {\n// \tPIVOT: [0, 0, 0] as [number, number, number],\n// };\n\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nclass TransformSopParamConfig extends NodeParamsConfig {\n\tgroup = ParamConfig.STRING('');\n\n\t// transform\n\tt = ParamConfig.VECTOR3([0, 0, 0]);\n\tr = ParamConfig.VECTOR3([0, 0, 0]);\n\ts = ParamConfig.VECTOR3([1, 1, 1]);\n\tscale = ParamConfig.FLOAT(1);\n\tlook_at = ParamConfig.OPERATOR_PATH('');\n\tup = ParamConfig.VECTOR3([0, 1, 0]);\n\tpivot = ParamConfig.VECTOR3([0, 0, 0]);\n}\nconst ParamsConfig = new TransformSopParamConfig();\n\nexport class TransformSopNode extends TypedSopNode<TransformSopParamConfig> {\n\tparams_config = ParamsConfig;\n\tstatic type() {\n\t\treturn 'transform';\n\t}\n\t// allow_eval_key_check() {\n\t// \treturn true;\n\t// }\n\n\tstatic displayed_input_names(): string[] {\n\t\treturn ['geometry to transform'];\n\t}\n\n\t// constructor(scene: PolyScene) {\n\t// \tsuper(scene);\n\tinitialize_node() {\n\t\tthis.io.inputs.set_count(1);\n\t\tthis.io.inputs.init_inputs_clonable_state([InputCloneMode.FROM_NODE]);\n\t}\n\n\tprivate _core_transform = new CoreTransform();\n\tcook(input_contents: CoreGroup[]) {\n\t\tconst objects = input_contents[0].objects();\n\t\tconst matrix = this._core_transform.matrix(this.pv.t, this.pv.r, this.pv.s, this.pv.scale);\n\n\t\tif (this.pv.group === '') {\n\t\t\tfor (let object of objects) {\n\t\t\t\tlet geometry;\n\t\t\t\tif ((geometry = object.geometry) != null) {\n\t\t\t\t\tgeometry.translate(-this.pv.pivot.x, -this.pv.pivot.y, -this.pv.pivot.z);\n\t\t\t\t\tgeometry.applyMatrix4(matrix);\n\t\t\t\t\tgeometry.translate(this.pv.pivot.x, this.pv.pivot.y, this.pv.pivot.z);\n\t\t\t\t} else {\n\t\t\t\t\tobject.applyMatrix4(matrix);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tconst core_group = CoreGroup.from_objects(objects);\n\t\t\tconst points = core_group.points_from_group(this.pv.group);\n\t\t\tfor (let point of points) {\n\t\t\t\tconst position = point.position().sub(this.pv.pivot);\n\t\t\t\tposition.applyMatrix4(matrix);\n\t\t\t\tpoint.set_position(position.add(this.pv.pivot));\n\t\t\t}\n\t\t}\n\n\t\tthis.set_objects(objects);\n\t}\n}\n","import {TypedSopNode} from './_Base';\n\nimport {Vector3} from 'three/src/math/Vector3';\nimport {CylinderBufferGeometry} from 'three/src/geometries/CylinderGeometry';\nimport {CoreTransform} from '../../../core/Transform';\n\nconst DEFAULT_UP = new Vector3(0, 1, 0);\n\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nclass TubeSopParamsConfig extends NodeParamsConfig {\n\tradius = ParamConfig.FLOAT(1, {range: [0, 1]});\n\theight = ParamConfig.FLOAT(1, {range: [0, 1]});\n\tsegments_radial = ParamConfig.INTEGER(12, {range: [3, 20], range_locked: [true, false]});\n\tsegments_height = ParamConfig.INTEGER(1, {range: [1, 20], range_locked: [true, false]});\n\tcap = ParamConfig.BOOLEAN(1);\n\tcenter = ParamConfig.VECTOR3([0, 0, 0]);\n\tdirection = ParamConfig.VECTOR3([0, 0, 1]);\n}\nconst ParamsConfig = new TubeSopParamsConfig();\n\nexport class TubeSopNode extends TypedSopNode<TubeSopParamsConfig> {\n\tparams_config = ParamsConfig;\n\tstatic type() {\n\t\treturn 'tube';\n\t}\n\n\tprivate _core_transform = new CoreTransform();\n\n\tcook() {\n\t\tconst geometry = new CylinderBufferGeometry(\n\t\t\tthis.pv.radius,\n\t\t\tthis.pv.radius,\n\t\t\tthis.pv.height,\n\t\t\tthis.pv.segments_radial,\n\t\t\tthis.pv.segments_height,\n\t\t\t!this.pv.cap\n\t\t);\n\n\t\tthis._core_transform.rotate_geometry(geometry, DEFAULT_UP, this.pv.direction);\n\t\tgeometry.translate(this.pv.center.x, this.pv.center.y, this.pv.center.z);\n\n\t\tthis.set_geometry(geometry);\n\t}\n}\n","import {Object3D} from 'three/src/core/Object3D';\n\nenum EVENT {\n\tCHANGE = 'change',\n\tMOVEEND = 'moveend',\n}\n\ntype CameraControllerCallback = (target: Object3D) => void;\n\nexport class CameraController {\n\tprivate _update_always: boolean = true;\n\tprivate _listener: any;\n\tprivate _target: Object3D | undefined;\n\tprivate _listener_added: boolean = false;\n\n\tconstructor(private _callback: CameraControllerCallback) {\n\t\tthis._listener = this._execute_callback.bind(this);\n\t}\n\n\tremove_target() {\n\t\tthis.set_target(undefined);\n\t}\n\tset_target(target: Object3D | undefined) {\n\t\tif (!target) {\n\t\t\tthis._remove_camera_event();\n\t\t}\n\n\t\tconst old_target = this._target;\n\t\tthis._target = target;\n\n\t\tif (this._target != null) {\n\t\t\tthis._execute_callback();\n\t\t}\n\n\t\tif (\n\t\t\t(this._target != null ? this._target.uuid : undefined) !==\n\t\t\t(old_target != null ? old_target.uuid : undefined)\n\t\t) {\n\t\t\tthis._add_camera_event();\n\t\t}\n\t}\n\n\tset_update_always(new_update_always: boolean) {\n\t\tthis._remove_camera_event();\n\n\t\tthis._update_always = new_update_always;\n\n\t\tthis._add_camera_event();\n\t}\n\n\tprivate _current_event_name() {\n\t\tif (this._update_always) {\n\t\t\treturn EVENT.CHANGE;\n\t\t} else {\n\t\t\treturn EVENT.MOVEEND;\n\t\t}\n\t}\n\n\tprivate _add_camera_event() {\n\t\tif (this._listener_added) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (this._target != null) {\n\t\t\tthis._target.addEventListener(this._current_event_name(), this._listener);\n\t\t\tthis._listener_added = true;\n\t\t}\n\t}\n\n\tprivate _remove_camera_event() {\n\t\tif (this._listener_added !== true) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (this._target != null) {\n\t\t\tthis._target.removeEventListener(this._current_event_name(), this._listener);\n\t\t\tthis._listener_added = false;\n\t\t}\n\t}\n\n\tprivate _execute_callback() {\n\t\tif (this._target != null) {\n\t\t\tthis._callback(this._target);\n\t\t}\n\t}\n}\n","import {Camera} from 'three/src/cameras/Camera';\nimport {Object3D} from 'three/src/core/Object3D';\nimport {Matrix4} from 'three/src/math/Matrix4';\nimport {Vector3} from 'three/src/math/Vector3';\nimport {TypedSopNode} from './_Base';\nimport {CoreGroup} from '../../../core/geometry/Group';\nimport {CameraController} from '../../../core/CameraController';\nimport {BaseCameraObjNodeType} from '../obj/_BaseCamera';\n\n// const MODE = [];\nconst UV_NAME = 'uv';\n\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nimport {InputCloneMode} from '../../poly/InputCloneMode';\nimport {NodeContext} from '../../poly/NodeContext';\nimport {BaseObjNodeType} from '../obj/_Base';\nclass UvProjectSopParamsConfig extends NodeParamsConfig {\n\tcamera = ParamConfig.OPERATOR_PATH('/perspective_camera1', {\n\t\tnode_selection: {\n\t\t\tcontext: NodeContext.OBJ,\n\t\t},\n\t});\n\t// force_aspect = ParamConfig.BOOLEAN(0)\n\t// aspect = ParamConfig.FLOAT(1, {\n\t// \trange: [0, 2],\n\t// \tvisible_if: {force_aspect: 1},\n\t// })\n}\nconst ParamsConfig = new UvProjectSopParamsConfig();\n\nexport class UvProjectSopNode extends TypedSopNode<UvProjectSopParamsConfig> {\n\tparams_config = ParamsConfig;\n\tstatic type() {\n\t\treturn 'uv_project';\n\t}\n\n\tprivate _camera_controller: CameraController = new CameraController(this._update_uvs_from_camera.bind(this));\n\t// private _param_camera: string\n\tprivate _processed_core_group: CoreGroup | undefined;\n\t// private _camera_node: BaseCameraObjNodeType | undefined;\n\tprivate _camera_object: Camera | undefined;\n\n\tinitialize_node() {\n\t\tthis.io.inputs.set_count(1);\n\t\tthis.io.inputs.init_inputs_clonable_state([InputCloneMode.FROM_NODE]);\n\t}\n\n\tcook(core_groups: CoreGroup[]) {\n\t\tthis._processed_core_group = core_groups[0];\n\n\t\tconst camera_node = this.p.camera.found_node();\n\t\tif (camera_node != null) {\n\t\t\tthis._camera_object = (camera_node as BaseCameraObjNodeType).object;\n\t\t\tthis._camera_controller.set_target(this._camera_object);\n\t\t\t// this._add_camera_event()\n\t\t} else {\n\t\t\tthis._camera_object = undefined;\n\t\t\t//this._remove_camera_event()\n\t\t\tthis._camera_controller.remove_target();\n\t\t}\n\n\t\tthis.set_core_group(this._processed_core_group);\n\t}\n\n\t_update_uvs_from_camera(look_at_target: Object3D) {\n\t\t// let old_aspect;\n\t\t// if (this.pv.force_aspect) {\n\t\t// \told_aspect = this._camera_object.aspect;\n\t\t// \tthis._camera_node.setup_for_aspect_ratio(this.pv.aspect);\n\t\t// }\n\n\t\tif (this._processed_core_group && this.parent) {\n\t\t\tconst points = this._processed_core_group.points();\n\t\t\tconst obj_world_matrix = (this.parent as BaseObjNodeType).object.matrixWorld;\n\t\t\tpoints.forEach((point) => {\n\t\t\t\tconst position = point.position();\n\t\t\t\tconst uvw = this._vector_in_camera_space(position, obj_world_matrix);\n\t\t\t\tif (uvw) {\n\t\t\t\t\tconst uv = {\n\t\t\t\t\t\tx: 1 - (uvw[0] * 0.5 + 0.5),\n\t\t\t\t\t\ty: uvw[1] * 0.5 + 0.5,\n\t\t\t\t\t};\n\t\t\t\t\tpoint.set_attrib_value(UV_NAME, uv);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t// if (this.pv.force_aspect) {\n\t\t\t// \tthis._camera_node.setup_for_aspect_ratio(old_aspect);\n\t\t\t// }\n\t\t}\n\t}\n\n\tprivate _vector_in_camera_space(vector: Vector3, obj_world_matrix: Matrix4) {\n\t\tif (this._camera_object) {\n\t\t\tvector.applyMatrix4(obj_world_matrix);\n\t\t\treturn vector.project(this._camera_object).toArray();\n\t\t}\n\t}\n}\n","import {CATEGORY_SOP} from './Category';\n\nimport {AddSopNode} from '../../nodes/sop/Add';\nimport {AnimationCopySopNode} from '../../nodes/sop/AnimationCopy';\nimport {AnimationMixerSopNode} from '../../nodes/sop/AnimationMixer';\nimport {AttribAddMultSopNode} from '../../nodes/sop/AttribAddMult';\nimport {AttribCopySopNode} from '../../nodes/sop/AttribCopy';\nimport {AttribCreateSopNode} from '../../nodes/sop/AttribCreate';\nimport {AttribDeleteSopNode} from '../../nodes/sop/AttribDelete';\nimport {AttribNormalizeSopNode} from '../../nodes/sop/AttribNormalize';\nimport {AttribPromoteSopNode} from '../../nodes/sop/AttribPromote';\nimport {AttribRemapSopNode} from '../../nodes/sop/AttribRemap';\nimport {AttribRenameSopNode} from '../../nodes/sop/AttribRename';\nimport {AttribTransferSopNode} from '../../nodes/sop/AttribTransfer';\nimport {BboxScatterSopNode} from '../../nodes/sop/BboxScatter';\nimport {BlendSopNode} from '../../nodes/sop/Blend';\nimport {BoxSopNode} from '../../nodes/sop/Box';\nimport {CacheSopNode} from '../../nodes/sop/Cache';\nimport {CircleSopNode} from '../../nodes/sop/Circle';\nimport {CodeSopNode} from '../../nodes/sop/Code';\nimport {ColorSopNode} from '../../nodes/sop/Color';\nimport {ConeSopNode} from '../../nodes/sop/Cone';\nimport {CopySopNode} from '../../nodes/sop/Copy';\nimport {DataSopNode} from '../../nodes/sop/Data';\nimport {DataUrlSopNode} from '../../nodes/sop/DataUrl';\nimport {DelaySopNode} from '../../nodes/sop/Delay';\nimport {DeleteSopNode} from '../../nodes/sop/Delete';\nimport {FaceSopNode} from '../../nodes/sop/Face';\nimport {FileSopNode} from '../../nodes/sop/File';\nimport {FuseSopNode} from '../../nodes/sop/Fuse';\nimport {HexagonsSopNode} from '../../nodes/sop/Hexagons';\nimport {HierarchySopNode} from '../../nodes/sop/Hierarchy';\n// TODO: heightmap\nimport {InstanceSopNode} from '../../nodes/sop/Instance';\nimport {JitterSopNode} from '../../nodes/sop/Jitter';\nimport {LayerSopNode} from '../../nodes/sop/Layer';\nimport {LineSopNode} from '../../nodes/sop/Line';\nimport {MaterialSopNode} from '../../nodes/sop/Material';\nimport {MergeSopNode} from '../../nodes/sop/Merge';\nimport {NoiseSopNode} from '../../nodes/sop/Noise';\nimport {NormalsSopNode} from '../../nodes/sop/Normals';\nimport {NullSopNode} from '../../nodes/sop/Null';\nimport {ObjectMergeSopNode} from '../../nodes/sop/ObjectMerge';\nimport {OcclusionSopNode} from '../../nodes/sop/Occlusion';\nimport {ParticlesSystemGpuSopNode} from '../../nodes/sop/ParticlesSystemGpu';\nimport {PeakSopNode} from '../../nodes/sop/Peak';\nimport {PlaneSopNode} from '../../nodes/sop/Plane';\nimport {PointSopNode} from '../../nodes/sop/Point';\nimport {PolywireSopNode} from '../../nodes/sop/Polywire';\nimport {RaySopNode} from '../../nodes/sop/Ray';\nimport {ResampleSopNode} from '../../nodes/sop/Resample';\nimport {ScatterSopNode} from '../../nodes/sop/Scatter';\nimport {ShadowsSopNode} from '../../nodes/sop/Shadows';\nimport {SkinSopNode} from '../../nodes/sop/Skin';\nimport {SphereSopNode} from '../../nodes/sop/Sphere';\nimport {SwitchSopNode} from '../../nodes/sop/Switch';\nimport {TextSopNode} from '../../nodes/sop/Text';\nimport {TorusSopNode} from '../../nodes/sop/Torus';\nimport {TorusKnotSopNode} from '../../nodes/sop/TorusKnot';\nimport {TransformSopNode} from '../../nodes/sop/Transform';\nimport {TubeSopNode} from '../../nodes/sop/Tube';\nimport {UvProjectSopNode} from '../../nodes/sop/UvProject';\n\nexport interface GeoNodeChildrenMap {\n\tadd: AddSopNode;\n\tanimation_copy: AnimationCopySopNode;\n\tanimation_mixer: AnimationMixerSopNode;\n\tattrib_add_mult: AttribAddMultSopNode;\n\tattrib_copy: AttribCopySopNode;\n\tattrib_create: AttribCreateSopNode;\n\tattrib_delete: AttribDeleteSopNode;\n\tattrib_normalize: AttribNormalizeSopNode;\n\tattrib_promote: AttribPromoteSopNode;\n\tattrib_remap: AttribRemapSopNode;\n\tattrib_rename: AttribRenameSopNode;\n\tattrib_transfer: AttribTransferSopNode;\n\tbbox_scatter: BboxScatterSopNode;\n\tblend: BlendSopNode;\n\tbox: BoxSopNode;\n\tcache: CacheSopNode;\n\tcircle: CircleSopNode;\n\tcode: CodeSopNode;\n\tcolor: ColorSopNode;\n\tcopy: CopySopNode;\n\tdata: DataSopNode;\n\tdata_url: DataUrlSopNode;\n\tdelay: DelaySopNode;\n\tdelete: DeleteSopNode;\n\tface: FaceSopNode;\n\tfile: FileSopNode;\n\tfuse: FuseSopNode;\n\thexagons: HexagonsSopNode;\n\thierarchy: HierarchySopNode;\n\tinstance: InstanceSopNode;\n\tjitter: JitterSopNode;\n\tlayer: LayerSopNode;\n\tline: LineSopNode;\n\tmaterial: MaterialSopNode;\n\tmerge: MergeSopNode;\n\tnoise: NoiseSopNode;\n\tnormals: NormalsSopNode;\n\tnull: NullSopNode;\n\tobject_merge: ObjectMergeSopNode;\n\tocclusion: OcclusionSopNode;\n\tparticles_system_gpu: ParticlesSystemGpuSopNode;\n\tpeak: PeakSopNode;\n\tplane: PlaneSopNode;\n\tpoint: PointSopNode;\n\tpolywire: PolywireSopNode;\n\tray: RaySopNode;\n\tresample: ResampleSopNode;\n\tscatter: ScatterSopNode;\n\tshadows: ShadowsSopNode;\n\tskin: SkinSopNode;\n\tsphere: SphereSopNode;\n\tswitch: SwitchSopNode;\n\ttext: TextSopNode;\n\ttorus: TorusSopNode;\n\ttorus_knot: TorusKnotSopNode;\n\ttransform: TransformSopNode;\n\ttube: TubeSopNode;\n\tuv_project: UvProjectSopNode;\n}\n\nimport {Poly} from '../../Poly';\nexport class SopRegister {\n\tstatic run(poly: Poly) {\n\t\tpoly.register_node(AddSopNode, CATEGORY_SOP.INPUT);\n\t\tpoly.register_node(AnimationCopySopNode, CATEGORY_SOP.ANIMATION);\n\t\tpoly.register_node(AnimationMixerSopNode, CATEGORY_SOP.ANIMATION);\n\t\tpoly.register_node(AttribAddMultSopNode, CATEGORY_SOP.ATTRIBUTE);\n\t\tpoly.register_node(AttribCopySopNode, CATEGORY_SOP.ATTRIBUTE);\n\t\tpoly.register_node(AttribCreateSopNode, CATEGORY_SOP.ATTRIBUTE);\n\t\tpoly.register_node(AttribDeleteSopNode, CATEGORY_SOP.ATTRIBUTE);\n\t\tpoly.register_node(AttribNormalizeSopNode, CATEGORY_SOP.ATTRIBUTE);\n\t\tpoly.register_node(AttribPromoteSopNode, CATEGORY_SOP.ATTRIBUTE);\n\t\tpoly.register_node(AttribRemapSopNode, CATEGORY_SOP.ATTRIBUTE);\n\t\tpoly.register_node(AttribRenameSopNode, CATEGORY_SOP.ATTRIBUTE);\n\t\tpoly.register_node(AttribTransferSopNode, CATEGORY_SOP.ATTRIBUTE);\n\t\tpoly.register_node(BboxScatterSopNode, CATEGORY_SOP.MODIFIER);\n\t\tpoly.register_node(BlendSopNode, CATEGORY_SOP.MODIFIER);\n\t\tpoly.register_node(BoxSopNode, CATEGORY_SOP.PRIMITIVES);\n\t\tpoly.register_node(CacheSopNode, CATEGORY_SOP.MISC);\n\t\tpoly.register_node(CodeSopNode, CATEGORY_SOP.ADVANCED);\n\t\tpoly.register_node(CircleSopNode, CATEGORY_SOP.PRIMITIVES);\n\t\tpoly.register_node(ColorSopNode, CATEGORY_SOP.MODIFIER);\n\t\tpoly.register_node(ConeSopNode, CATEGORY_SOP.PRIMITIVES);\n\t\tpoly.register_node(CopySopNode, CATEGORY_SOP.MODIFIER);\n\t\tpoly.register_node(DataSopNode, CATEGORY_SOP.INPUT);\n\t\tpoly.register_node(DataUrlSopNode, CATEGORY_SOP.INPUT);\n\t\tpoly.register_node(DelaySopNode, CATEGORY_SOP.MISC);\n\t\tpoly.register_node(DeleteSopNode, CATEGORY_SOP.MODIFIER);\n\t\tpoly.register_node(FaceSopNode, CATEGORY_SOP.MODIFIER);\n\t\tpoly.register_node(FileSopNode, CATEGORY_SOP.INPUT);\n\t\tpoly.register_node(FuseSopNode, CATEGORY_SOP.MODIFIER);\n\t\tpoly.register_node(HexagonsSopNode, CATEGORY_SOP.PRIMITIVES);\n\t\tpoly.register_node(HierarchySopNode, CATEGORY_SOP.MISC);\n\t\tpoly.register_node(InstanceSopNode, CATEGORY_SOP.RENDER);\n\t\tpoly.register_node(JitterSopNode, CATEGORY_SOP.MODIFIER);\n\t\tpoly.register_node(LayerSopNode, CATEGORY_SOP.MODIFIER);\n\t\tpoly.register_node(LineSopNode, CATEGORY_SOP.PRIMITIVES);\n\t\tpoly.register_node(MaterialSopNode, CATEGORY_SOP.RENDER);\n\t\tpoly.register_node(MergeSopNode, CATEGORY_SOP.MISC);\n\t\tpoly.register_node(NoiseSopNode, CATEGORY_SOP.MISC);\n\t\tpoly.register_node(NormalsSopNode, CATEGORY_SOP.MODIFIER);\n\t\tpoly.register_node(NullSopNode, CATEGORY_SOP.MODIFIER);\n\t\tpoly.register_node(ObjectMergeSopNode, CATEGORY_SOP.INPUT);\n\t\tpoly.register_node(OcclusionSopNode, CATEGORY_SOP.RENDER);\n\t\tpoly.register_node(ParticlesSystemGpuSopNode, CATEGORY_SOP.DYNAMICS);\n\t\tpoly.register_node(PeakSopNode, CATEGORY_SOP.MODIFIER);\n\t\tpoly.register_node(PlaneSopNode, CATEGORY_SOP.PRIMITIVES);\n\t\tpoly.register_node(PointSopNode, CATEGORY_SOP.MODIFIER);\n\t\tpoly.register_node(PolywireSopNode, CATEGORY_SOP.MODIFIER);\n\t\tpoly.register_node(RaySopNode, CATEGORY_SOP.MODIFIER);\n\t\tpoly.register_node(ResampleSopNode, CATEGORY_SOP.MODIFIER);\n\t\tpoly.register_node(ScatterSopNode, CATEGORY_SOP.MODIFIER);\n\t\tpoly.register_node(SkinSopNode, CATEGORY_SOP.MODIFIER);\n\t\tpoly.register_node(ShadowsSopNode, CATEGORY_SOP.MODIFIER);\n\t\tpoly.register_node(SphereSopNode, CATEGORY_SOP.PRIMITIVES);\n\t\tpoly.register_node(SwitchSopNode, CATEGORY_SOP.MISC);\n\t\tpoly.register_node(TextSopNode, CATEGORY_SOP.PRIMITIVES);\n\t\tpoly.register_node(TorusSopNode, CATEGORY_SOP.PRIMITIVES);\n\t\tpoly.register_node(TorusKnotSopNode, CATEGORY_SOP.PRIMITIVES);\n\t\tpoly.register_node(TransformSopNode, CATEGORY_SOP.MODIFIER);\n\t\tpoly.register_node(TubeSopNode, CATEGORY_SOP.PRIMITIVES);\n\t\tpoly.register_node(UvProjectSopNode, CATEGORY_SOP.MODIFIER);\n\t}\n}\n"],"sourceRoot":""}