{"version":3,"sources":["webpack://POLY/./src/modules/three/examples/jsm/loaders/SVGLoader.js"],"names":["tempV2_1","tempV2_2","tempV2_3","tempV2_4","tempV2_5","tempV2_6","tempV2_7","lastPointL","lastPointR","point0L","point0R","currentPointL","currentPointR","nextPointL","nextPointR","innerPoint","outerPoint","SVGLoader","manager","call","this","defaultDPI","defaultUnit","prototype","Object","assign","create","constructor","load","url","onLoad","onProgress","onError","scope","loader","setPath","path","setRequestHeader","requestHeader","setWithCredentials","withCredentials","text","parse","e","console","error","itemError","parseArcCommand","rx","ry","x_axis_rotation","large_arc_flag","sweep_flag","start","end","Math","PI","abs","dx2","x","dy2","y","x1p","cos","sin","y1p","rxs","rys","x1ps","y1ps","cr","s","sqrt","dq","pq","q","max","cxp","cyp","cx","cy","theta","svgAngle","delta","currentPath","absellipse","lineTo","ux","uy","vx","vy","dot","len","ang","acos","min","parseStyle","node","style","stylesheetStyles","hasAttribute","classSelectors","getAttribute","split","filter","Boolean","map","i","trim","length","stylesheets","addStyle","svgName","jsName","adjustFunction","undefined","v","startsWith","warn","clamp","parseFloatWithUnits","positive","getReflection","a","b","parseFloats","string","array","number","indexOf","lastIndexOf","splice","units","unitConversion","theUnit","String","n","u","endsWith","substring","scale","parseFloat","getTransformScaleX","m","te","elements","getTransformScaleY","paths","transformStack","tempTransform0","tempTransform1","tempTransform2","tempTransform3","tempV2","tempV3","currentTransform","xml","DOMParser","parseFromString","parseNode","nodeType","transform","nodeName","tx","ty","translate","transformsTexts","tIndex","transformText","openParPos","closeParPos","transformType","substr","identity","angle","rotate","multiplyMatrices","scaleX","scaleY","set","tan","premultiply","parseNodeTransform","copy","push","getNodeTransform","traverseChildNodes","sheet","cssRules","stylesheet","type","selectorList","selectorText","j","parseCSSStylesheet","point","control","firstPoint","isFirstPoint","doSetFirstPoint","commands","match","l","command","charAt","data","jl","numbers","moveTo","bezierCurveTo","quadraticCurveTo","clone","autoClose","curves","currentPoint","parsePathNode","w","h","parseRectNode","iterator","index","regex","replace","parsePolygonNode","parsePolylineNode","r","subpath","absarc","subPaths","parseCircleNode","parseEllipseNode","x1","y1","x2","y2","parseLineNode","usedNodeId","href","baseVal","usedNode","viewportElement","getElementById","fill","color","setStyle","transfVec2","v2","applyMatrix3","isRotated","isTransformRotated","curve","isLineCurve","v1","isCubicBezierCurve","v0","v3","isQuadraticBezierCurve","isEllipseCurve","aX","aY","xRadius","yRadius","transformPath","userData","nodes","childNodes","pop","documentElement","fillOpacity","strokeOpacity","strokeWidth","strokeLineJoin","strokeLineCap","strokeMiterLimit","getStrokeStyle","width","lineJoin","lineCap","miterLimit","strokeColor","pointsToStroke","points","arcDivisions","minDistance","vertices","normals","uvs","pointsToStrokeWithBuffers","geometry","setAttribute","vertexOffset","numPoints","dupPoints","distanceTo","newPoints","removeDuplicatedPoints","nextPoint","innerSideModified","joinIsOnLeftSide","isMiter","isClosed","equals","previousPoint","strokeWidth2","deltaU","u0","initialJoinIsOnLeftSide","numVertices","currentCoordinate","currentCoordinateUV","getNormal","multiplyScalar","sub","add","iPoint","normal1","u1","subVectors","normalize","miterSide","setLength","negate","miterLength2","segmentLengthPrev","divideScalar","segmentLengthNext","makeSegmentTriangles","makeSegmentWithBevelJoin","createSegmentTrianglesWithMiddleSection","makeCircularSector","miterFraction","addVertex","addCapGeometry","lastOuter","lastInner","toArray","p1","p2","result","position","center","il","rotateAround","addVectors","vl"],"mappings":"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","file":"11.ce1820de068d0ec6e338.js","sourcesContent":["import {BufferGeometry} from 'three/src/core/BufferGeometry';\nimport {FileLoader} from 'three/src/loaders/FileLoader';\nimport {Float32BufferAttribute} from 'three/src/core/BufferAttribute';\nimport {Loader} from 'three/src/loaders/Loader';\nimport {Matrix3} from 'three/src/math/Matrix3';\nimport {Path} from 'three/src/extras/core/Path';\nimport {ShapePath} from 'three/src/extras/core/ShapePath';\nimport {Vector2} from 'three/src/math/Vector2';\nimport {Vector3} from 'three/src/math/Vector3';\n\nvar SVGLoader = function ( manager ) {\n\n\tLoader.call( this, manager );\n\n\t// Default dots per inch\n\tthis.defaultDPI = 90;\n\n\t// Accepted units: 'mm', 'cm', 'in', 'pt', 'pc', 'px'\n\tthis.defaultUnit = \"px\";\n\n};\n\nSVGLoader.prototype = Object.assign( Object.create( Loader.prototype ), {\n\n\tconstructor: SVGLoader,\n\n\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\tvar scope = this;\n\n\t\tvar loader = new FileLoader( scope.manager );\n\t\tloader.setPath( scope.path );\n\t\tloader.setRequestHeader( scope.requestHeader );\n\t\tloader.setWithCredentials( scope.withCredentials );\n\t\tloader.load( url, function ( text ) {\n\n\t\t\ttry {\n\n\t\t\t\tonLoad( scope.parse( text ) );\n\n\t\t\t} catch ( e ) {\n\n\t\t\t\tif ( onError ) {\n\n\t\t\t\t\tonError( e );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.error( e );\n\n\t\t\t\t}\n\n\t\t\t\tscope.manager.itemError( url );\n\n\t\t\t}\n\n\t\t}, onProgress, onError );\n\n\t},\n\n\tparse: function ( text ) {\n\n\t\tvar scope = this;\n\n\t\tfunction parseNode( node, style ) {\n\n\t\t\tif ( node.nodeType !== 1 ) return;\n\n\t\t\tvar transform = getNodeTransform( node );\n\n\t\t\tvar traverseChildNodes = true;\n\n\t\t\tvar path = null;\n\n\t\t\tswitch ( node.nodeName ) {\n\n\t\t\t\tcase 'svg':\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'style':\n\t\t\t\t\tparseCSSStylesheet( node );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'g':\n\t\t\t\t\tstyle = parseStyle( node, style );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'path':\n\t\t\t\t\tstyle = parseStyle( node, style );\n\t\t\t\t\tif ( node.hasAttribute( 'd' ) ) path = parsePathNode( node );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'rect':\n\t\t\t\t\tstyle = parseStyle( node, style );\n\t\t\t\t\tpath = parseRectNode( node );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'polygon':\n\t\t\t\t\tstyle = parseStyle( node, style );\n\t\t\t\t\tpath = parsePolygonNode( node );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'polyline':\n\t\t\t\t\tstyle = parseStyle( node, style );\n\t\t\t\t\tpath = parsePolylineNode( node );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'circle':\n\t\t\t\t\tstyle = parseStyle( node, style );\n\t\t\t\t\tpath = parseCircleNode( node );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'ellipse':\n\t\t\t\t\tstyle = parseStyle( node, style );\n\t\t\t\t\tpath = parseEllipseNode( node );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'line':\n\t\t\t\t\tstyle = parseStyle( node, style );\n\t\t\t\t\tpath = parseLineNode( node );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'defs':\n\t\t\t\t\ttraverseChildNodes = false;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'use':\n\t\t\t\t\tstyle = parseStyle( node, style );\n\t\t\t\t\tvar usedNodeId = node.href.baseVal.substring( 1 );\n\t\t\t\t\tvar usedNode = node.viewportElement.getElementById( usedNodeId );\n\t\t\t\t\tif ( usedNode ) {\n\n\t\t\t\t\t\tparseNode( usedNode, style );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tconsole.warn( \"SVGLoader: 'use node' references non-existent node id: \" + usedNodeId );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\t// console.log( node );\n\n\t\t\t}\n\n\t\t\tif ( path ) {\n\n\t\t\t\tif ( style.fill !== undefined && style.fill !== 'none' ) {\n\n\t\t\t\t\tpath.color.setStyle( style.fill );\n\n\t\t\t\t}\n\n\t\t\t\ttransformPath( path, currentTransform );\n\n\t\t\t\tpaths.push( path );\n\n\t\t\t\tpath.userData = { node: node, style: style };\n\n\t\t\t}\n\n\t\t\tif ( traverseChildNodes ) {\n\n\t\t\t\tvar nodes = node.childNodes;\n\n\t\t\t\tfor ( var i = 0; i < nodes.length; i ++ ) {\n\n\t\t\t\t\tparseNode( nodes[ i ], style );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( transform ) {\n\n\t\t\t\ttransformStack.pop();\n\n\t\t\t\tif ( transformStack.length > 0 ) {\n\n\t\t\t\t\tcurrentTransform.copy( transformStack[ transformStack.length - 1 ] );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tcurrentTransform.identity();\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction parsePathNode( node ) {\n\n\t\t\tvar path = new ShapePath();\n\n\t\t\tvar point = new Vector2();\n\t\t\tvar control = new Vector2();\n\n\t\t\tvar firstPoint = new Vector2();\n\t\t\tvar isFirstPoint = true;\n\t\t\tvar doSetFirstPoint = false;\n\n\t\t\tvar d = node.getAttribute( 'd' );\n\n\t\t\t// console.log( d );\n\n\t\t\tvar commands = d.match( /[a-df-z][^a-df-z]*/ig );\n\n\t\t\tfor ( var i = 0, l = commands.length; i < l; i ++ ) {\n\n\t\t\t\tvar command = commands[ i ];\n\n\t\t\t\tvar type = command.charAt( 0 );\n\t\t\t\tvar data = command.substr( 1 ).trim();\n\n\t\t\t\tif ( isFirstPoint === true ) {\n\n\t\t\t\t\tdoSetFirstPoint = true;\n\t\t\t\t\tisFirstPoint = false;\n\n\t\t\t\t}\n\n\t\t\t\tswitch ( type ) {\n\n\t\t\t\t\tcase 'M':\n\t\t\t\t\t\tvar numbers = parseFloats( data );\n\t\t\t\t\t\tfor ( var j = 0, jl = numbers.length; j < jl; j += 2 ) {\n\n\t\t\t\t\t\t\tpoint.x = numbers[ j + 0 ];\n\t\t\t\t\t\t\tpoint.y = numbers[ j + 1 ];\n\t\t\t\t\t\t\tcontrol.x = point.x;\n\t\t\t\t\t\t\tcontrol.y = point.y;\n\n\t\t\t\t\t\t\tif ( j === 0 ) {\n\n\t\t\t\t\t\t\t\tpath.moveTo( point.x, point.y );\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tpath.lineTo( point.x, point.y );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'H':\n\t\t\t\t\t\tvar numbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( var j = 0, jl = numbers.length; j < jl; j ++ ) {\n\n\t\t\t\t\t\t\tpoint.x = numbers[ j ];\n\t\t\t\t\t\t\tcontrol.x = point.x;\n\t\t\t\t\t\t\tcontrol.y = point.y;\n\t\t\t\t\t\t\tpath.lineTo( point.x, point.y );\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'V':\n\t\t\t\t\t\tvar numbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( var j = 0, jl = numbers.length; j < jl; j ++ ) {\n\n\t\t\t\t\t\t\tpoint.y = numbers[ j ];\n\t\t\t\t\t\t\tcontrol.x = point.x;\n\t\t\t\t\t\t\tcontrol.y = point.y;\n\t\t\t\t\t\t\tpath.lineTo( point.x, point.y );\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'L':\n\t\t\t\t\t\tvar numbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( var j = 0, jl = numbers.length; j < jl; j += 2 ) {\n\n\t\t\t\t\t\t\tpoint.x = numbers[ j + 0 ];\n\t\t\t\t\t\t\tpoint.y = numbers[ j + 1 ];\n\t\t\t\t\t\t\tcontrol.x = point.x;\n\t\t\t\t\t\t\tcontrol.y = point.y;\n\t\t\t\t\t\t\tpath.lineTo( point.x, point.y );\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'C':\n\t\t\t\t\t\tvar numbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( var j = 0, jl = numbers.length; j < jl; j += 6 ) {\n\n\t\t\t\t\t\t\tpath.bezierCurveTo(\n\t\t\t\t\t\t\t\tnumbers[ j + 0 ],\n\t\t\t\t\t\t\t\tnumbers[ j + 1 ],\n\t\t\t\t\t\t\t\tnumbers[ j + 2 ],\n\t\t\t\t\t\t\t\tnumbers[ j + 3 ],\n\t\t\t\t\t\t\t\tnumbers[ j + 4 ],\n\t\t\t\t\t\t\t\tnumbers[ j + 5 ]\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tcontrol.x = numbers[ j + 2 ];\n\t\t\t\t\t\t\tcontrol.y = numbers[ j + 3 ];\n\t\t\t\t\t\t\tpoint.x = numbers[ j + 4 ];\n\t\t\t\t\t\t\tpoint.y = numbers[ j + 5 ];\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'S':\n\t\t\t\t\t\tvar numbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( var j = 0, jl = numbers.length; j < jl; j += 4 ) {\n\n\t\t\t\t\t\t\tpath.bezierCurveTo(\n\t\t\t\t\t\t\t\tgetReflection( point.x, control.x ),\n\t\t\t\t\t\t\t\tgetReflection( point.y, control.y ),\n\t\t\t\t\t\t\t\tnumbers[ j + 0 ],\n\t\t\t\t\t\t\t\tnumbers[ j + 1 ],\n\t\t\t\t\t\t\t\tnumbers[ j + 2 ],\n\t\t\t\t\t\t\t\tnumbers[ j + 3 ]\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tcontrol.x = numbers[ j + 0 ];\n\t\t\t\t\t\t\tcontrol.y = numbers[ j + 1 ];\n\t\t\t\t\t\t\tpoint.x = numbers[ j + 2 ];\n\t\t\t\t\t\t\tpoint.y = numbers[ j + 3 ];\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'Q':\n\t\t\t\t\t\tvar numbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( var j = 0, jl = numbers.length; j < jl; j += 4 ) {\n\n\t\t\t\t\t\t\tpath.quadraticCurveTo(\n\t\t\t\t\t\t\t\tnumbers[ j + 0 ],\n\t\t\t\t\t\t\t\tnumbers[ j + 1 ],\n\t\t\t\t\t\t\t\tnumbers[ j + 2 ],\n\t\t\t\t\t\t\t\tnumbers[ j + 3 ]\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tcontrol.x = numbers[ j + 0 ];\n\t\t\t\t\t\t\tcontrol.y = numbers[ j + 1 ];\n\t\t\t\t\t\t\tpoint.x = numbers[ j + 2 ];\n\t\t\t\t\t\t\tpoint.y = numbers[ j + 3 ];\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'T':\n\t\t\t\t\t\tvar numbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( var j = 0, jl = numbers.length; j < jl; j += 2 ) {\n\n\t\t\t\t\t\t\tvar rx = getReflection( point.x, control.x );\n\t\t\t\t\t\t\tvar ry = getReflection( point.y, control.y );\n\t\t\t\t\t\t\tpath.quadraticCurveTo(\n\t\t\t\t\t\t\t\trx,\n\t\t\t\t\t\t\t\try,\n\t\t\t\t\t\t\t\tnumbers[ j + 0 ],\n\t\t\t\t\t\t\t\tnumbers[ j + 1 ]\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tcontrol.x = rx;\n\t\t\t\t\t\t\tcontrol.y = ry;\n\t\t\t\t\t\t\tpoint.x = numbers[ j + 0 ];\n\t\t\t\t\t\t\tpoint.y = numbers[ j + 1 ];\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'A':\n\t\t\t\t\t\tvar numbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( var j = 0, jl = numbers.length; j < jl; j += 7 ) {\n\n\t\t\t\t\t\t\t// skip command if start point == end point\n\t\t\t\t\t\t\tif ( numbers[ j + 5 ] == point.x && numbers[ j + 6 ] == point.y ) continue;\n\n\t\t\t\t\t\t\tvar start = point.clone();\n\t\t\t\t\t\t\tpoint.x = numbers[ j + 5 ];\n\t\t\t\t\t\t\tpoint.y = numbers[ j + 6 ];\n\t\t\t\t\t\t\tcontrol.x = point.x;\n\t\t\t\t\t\t\tcontrol.y = point.y;\n\t\t\t\t\t\t\tparseArcCommand(\n\t\t\t\t\t\t\t\tpath, numbers[ j ], numbers[ j + 1 ], numbers[ j + 2 ], numbers[ j + 3 ], numbers[ j + 4 ], start, point\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'm':\n\t\t\t\t\t\tvar numbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( var j = 0, jl = numbers.length; j < jl; j += 2 ) {\n\n\t\t\t\t\t\t\tpoint.x += numbers[ j + 0 ];\n\t\t\t\t\t\t\tpoint.y += numbers[ j + 1 ];\n\t\t\t\t\t\t\tcontrol.x = point.x;\n\t\t\t\t\t\t\tcontrol.y = point.y;\n\n\t\t\t\t\t\t\tif ( j === 0 ) {\n\n\t\t\t\t\t\t\t\tpath.moveTo( point.x, point.y );\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tpath.lineTo( point.x, point.y );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'h':\n\t\t\t\t\t\tvar numbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( var j = 0, jl = numbers.length; j < jl; j ++ ) {\n\n\t\t\t\t\t\t\tpoint.x += numbers[ j ];\n\t\t\t\t\t\t\tcontrol.x = point.x;\n\t\t\t\t\t\t\tcontrol.y = point.y;\n\t\t\t\t\t\t\tpath.lineTo( point.x, point.y );\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'v':\n\t\t\t\t\t\tvar numbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( var j = 0, jl = numbers.length; j < jl; j ++ ) {\n\n\t\t\t\t\t\t\tpoint.y += numbers[ j ];\n\t\t\t\t\t\t\tcontrol.x = point.x;\n\t\t\t\t\t\t\tcontrol.y = point.y;\n\t\t\t\t\t\t\tpath.lineTo( point.x, point.y );\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'l':\n\t\t\t\t\t\tvar numbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( var j = 0, jl = numbers.length; j < jl; j += 2 ) {\n\n\t\t\t\t\t\t\tpoint.x += numbers[ j + 0 ];\n\t\t\t\t\t\t\tpoint.y += numbers[ j + 1 ];\n\t\t\t\t\t\t\tcontrol.x = point.x;\n\t\t\t\t\t\t\tcontrol.y = point.y;\n\t\t\t\t\t\t\tpath.lineTo( point.x, point.y );\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'c':\n\t\t\t\t\t\tvar numbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( var j = 0, jl = numbers.length; j < jl; j += 6 ) {\n\n\t\t\t\t\t\t\tpath.bezierCurveTo(\n\t\t\t\t\t\t\t\tpoint.x + numbers[ j + 0 ],\n\t\t\t\t\t\t\t\tpoint.y + numbers[ j + 1 ],\n\t\t\t\t\t\t\t\tpoint.x + numbers[ j + 2 ],\n\t\t\t\t\t\t\t\tpoint.y + numbers[ j + 3 ],\n\t\t\t\t\t\t\t\tpoint.x + numbers[ j + 4 ],\n\t\t\t\t\t\t\t\tpoint.y + numbers[ j + 5 ]\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tcontrol.x = point.x + numbers[ j + 2 ];\n\t\t\t\t\t\t\tcontrol.y = point.y + numbers[ j + 3 ];\n\t\t\t\t\t\t\tpoint.x += numbers[ j + 4 ];\n\t\t\t\t\t\t\tpoint.y += numbers[ j + 5 ];\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 's':\n\t\t\t\t\t\tvar numbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( var j = 0, jl = numbers.length; j < jl; j += 4 ) {\n\n\t\t\t\t\t\t\tpath.bezierCurveTo(\n\t\t\t\t\t\t\t\tgetReflection( point.x, control.x ),\n\t\t\t\t\t\t\t\tgetReflection( point.y, control.y ),\n\t\t\t\t\t\t\t\tpoint.x + numbers[ j + 0 ],\n\t\t\t\t\t\t\t\tpoint.y + numbers[ j + 1 ],\n\t\t\t\t\t\t\t\tpoint.x + numbers[ j + 2 ],\n\t\t\t\t\t\t\t\tpoint.y + numbers[ j + 3 ]\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tcontrol.x = point.x + numbers[ j + 0 ];\n\t\t\t\t\t\t\tcontrol.y = point.y + numbers[ j + 1 ];\n\t\t\t\t\t\t\tpoint.x += numbers[ j + 2 ];\n\t\t\t\t\t\t\tpoint.y += numbers[ j + 3 ];\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'q':\n\t\t\t\t\t\tvar numbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( var j = 0, jl = numbers.length; j < jl; j += 4 ) {\n\n\t\t\t\t\t\t\tpath.quadraticCurveTo(\n\t\t\t\t\t\t\t\tpoint.x + numbers[ j + 0 ],\n\t\t\t\t\t\t\t\tpoint.y + numbers[ j + 1 ],\n\t\t\t\t\t\t\t\tpoint.x + numbers[ j + 2 ],\n\t\t\t\t\t\t\t\tpoint.y + numbers[ j + 3 ]\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tcontrol.x = point.x + numbers[ j + 0 ];\n\t\t\t\t\t\t\tcontrol.y = point.y + numbers[ j + 1 ];\n\t\t\t\t\t\t\tpoint.x += numbers[ j + 2 ];\n\t\t\t\t\t\t\tpoint.y += numbers[ j + 3 ];\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 't':\n\t\t\t\t\t\tvar numbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( var j = 0, jl = numbers.length; j < jl; j += 2 ) {\n\n\t\t\t\t\t\t\tvar rx = getReflection( point.x, control.x );\n\t\t\t\t\t\t\tvar ry = getReflection( point.y, control.y );\n\t\t\t\t\t\t\tpath.quadraticCurveTo(\n\t\t\t\t\t\t\t\trx,\n\t\t\t\t\t\t\t\try,\n\t\t\t\t\t\t\t\tpoint.x + numbers[ j + 0 ],\n\t\t\t\t\t\t\t\tpoint.y + numbers[ j + 1 ]\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tcontrol.x = rx;\n\t\t\t\t\t\t\tcontrol.y = ry;\n\t\t\t\t\t\t\tpoint.x = point.x + numbers[ j + 0 ];\n\t\t\t\t\t\t\tpoint.y = point.y + numbers[ j + 1 ];\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'a':\n\t\t\t\t\t\tvar numbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( var j = 0, jl = numbers.length; j < jl; j += 7 ) {\n\n\t\t\t\t\t\t\t// skip command if no displacement\n\t\t\t\t\t\t\tif ( numbers[ j + 5 ] == 0 && numbers[ j + 6 ] == 0 ) continue;\n\n\t\t\t\t\t\t\tvar start = point.clone();\n\t\t\t\t\t\t\tpoint.x += numbers[ j + 5 ];\n\t\t\t\t\t\t\tpoint.y += numbers[ j + 6 ];\n\t\t\t\t\t\t\tcontrol.x = point.x;\n\t\t\t\t\t\t\tcontrol.y = point.y;\n\t\t\t\t\t\t\tparseArcCommand(\n\t\t\t\t\t\t\t\tpath, numbers[ j ], numbers[ j + 1 ], numbers[ j + 2 ], numbers[ j + 3 ], numbers[ j + 4 ], start, point\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'Z':\n\t\t\t\t\tcase 'z':\n\t\t\t\t\t\tpath.currentPath.autoClose = true;\n\n\t\t\t\t\t\tif ( path.currentPath.curves.length > 0 ) {\n\n\t\t\t\t\t\t\t// Reset point to beginning of Path\n\t\t\t\t\t\t\tpoint.copy( firstPoint );\n\t\t\t\t\t\t\tpath.currentPath.currentPoint.copy( point );\n\t\t\t\t\t\t\tisFirstPoint = true;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.warn( command );\n\n\t\t\t\t}\n\n\t\t\t\t// console.log( type, parseFloats( data ), parseFloats( data ).length  )\n\n\t\t\t\tdoSetFirstPoint = false;\n\n\t\t\t}\n\n\t\t\treturn path;\n\n\t\t}\n\n\t\tfunction parseCSSStylesheet( node ) {\n\n\t\t\tif ( ! node.sheet || ! node.sheet.cssRules || ! node.sheet.cssRules.length ) return;\n\n\t\t\tfor ( var i = 0; i < node.sheet.cssRules.length; i ++ ) {\n\n\t\t\t\tvar stylesheet = node.sheet.cssRules[ i ];\n\n\t\t\t\tif ( stylesheet.type !== 1 ) continue;\n\n\t\t\t\tvar selectorList = stylesheet.selectorText\n\t\t\t\t\t.split( /,/gm )\n\t\t\t\t\t.filter( Boolean )\n\t\t\t\t\t.map( i => i.trim() );\n\n\t\t\t\tfor ( var j = 0; j < selectorList.length; j ++ ) {\n\n\t\t\t\t\tstylesheets[ selectorList[ j ] ] = Object.assign(\n\t\t\t\t\t\tstylesheets[ selectorList[ j ] ] || {},\n\t\t\t\t\t\tstylesheet.style\n\t\t\t\t\t);\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t/**\n\t\t * https://www.w3.org/TR/SVG/implnote.html#ArcImplementationNotes\n\t\t * https://mortoray.com/2017/02/16/rendering-an-svg-elliptical-arc-as-bezier-curves/ Appendix: Endpoint to center arc conversion\n\t\t * From\n\t\t * rx ry x-axis-rotation large-arc-flag sweep-flag x y\n\t\t * To\n\t\t * aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation\n\t\t */\n\n\t\tfunction parseArcCommand( path, rx, ry, x_axis_rotation, large_arc_flag, sweep_flag, start, end ) {\n\n\t\t\tif ( rx == 0 || ry == 0 ) {\n\n\t\t\t\t// draw a line if either of the radii == 0\n\t\t\t\tpath.lineTo( end.x, end.y );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tx_axis_rotation = x_axis_rotation * Math.PI / 180;\n\n\t\t\t// Ensure radii are positive\n\t\t\trx = Math.abs( rx );\n\t\t\try = Math.abs( ry );\n\n\t\t\t// Compute (x1', y1')\n\t\t\tvar dx2 = ( start.x - end.x ) / 2.0;\n\t\t\tvar dy2 = ( start.y - end.y ) / 2.0;\n\t\t\tvar x1p = Math.cos( x_axis_rotation ) * dx2 + Math.sin( x_axis_rotation ) * dy2;\n\t\t\tvar y1p = - Math.sin( x_axis_rotation ) * dx2 + Math.cos( x_axis_rotation ) * dy2;\n\n\t\t\t// Compute (cx', cy')\n\t\t\tvar rxs = rx * rx;\n\t\t\tvar rys = ry * ry;\n\t\t\tvar x1ps = x1p * x1p;\n\t\t\tvar y1ps = y1p * y1p;\n\n\t\t\t// Ensure radii are large enough\n\t\t\tvar cr = x1ps / rxs + y1ps / rys;\n\n\t\t\tif ( cr > 1 ) {\n\n\t\t\t\t// scale up rx,ry equally so cr == 1\n\t\t\t\tvar s = Math.sqrt( cr );\n\t\t\t\trx = s * rx;\n\t\t\t\try = s * ry;\n\t\t\t\trxs = rx * rx;\n\t\t\t\trys = ry * ry;\n\n\t\t\t}\n\n\t\t\tvar dq = ( rxs * y1ps + rys * x1ps );\n\t\t\tvar pq = ( rxs * rys - dq ) / dq;\n\t\t\tvar q = Math.sqrt( Math.max( 0, pq ) );\n\t\t\tif ( large_arc_flag === sweep_flag ) q = - q;\n\t\t\tvar cxp = q * rx * y1p / ry;\n\t\t\tvar cyp = - q * ry * x1p / rx;\n\n\t\t\t// Step 3: Compute (cx, cy) from (cx', cy')\n\t\t\tvar cx = Math.cos( x_axis_rotation ) * cxp - Math.sin( x_axis_rotation ) * cyp + ( start.x + end.x ) / 2;\n\t\t\tvar cy = Math.sin( x_axis_rotation ) * cxp + Math.cos( x_axis_rotation ) * cyp + ( start.y + end.y ) / 2;\n\n\t\t\t// Step 4: Compute 1 and \n\t\t\tvar theta = svgAngle( 1, 0, ( x1p - cxp ) / rx, ( y1p - cyp ) / ry );\n\t\t\tvar delta = svgAngle( ( x1p - cxp ) / rx, ( y1p - cyp ) / ry, ( - x1p - cxp ) / rx, ( - y1p - cyp ) / ry ) % ( Math.PI * 2 );\n\n\t\t\tpath.currentPath.absellipse( cx, cy, rx, ry, theta, theta + delta, sweep_flag === 0, x_axis_rotation );\n\n\t\t}\n\n\t\tfunction svgAngle( ux, uy, vx, vy ) {\n\n\t\t\tvar dot = ux * vx + uy * vy;\n\t\t\tvar len = Math.sqrt( ux * ux + uy * uy ) * Math.sqrt( vx * vx + vy * vy );\n\t\t\tvar ang = Math.acos( Math.max( - 1, Math.min( 1, dot / len ) ) ); // floating point precision, slightly over values appear\n\t\t\tif ( ( ux * vy - uy * vx ) < 0 ) ang = - ang;\n\t\t\treturn ang;\n\n\t\t}\n\n\t\t/*\n\t\t* According to https://www.w3.org/TR/SVG/shapes.html#RectElementRXAttribute\n\t\t* rounded corner should be rendered to elliptical arc, but bezier curve does the job well enough\n\t\t*/\n\t\tfunction parseRectNode( node ) {\n\n\t\t\tvar x = parseFloatWithUnits( node.getAttribute( 'x' ) || 0 );\n\t\t\tvar y = parseFloatWithUnits( node.getAttribute( 'y' ) || 0 );\n\t\t\tvar rx = parseFloatWithUnits( node.getAttribute( 'rx' ) || 0 );\n\t\t\tvar ry = parseFloatWithUnits( node.getAttribute( 'ry' ) || 0 );\n\t\t\tvar w = parseFloatWithUnits( node.getAttribute( 'width' ) );\n\t\t\tvar h = parseFloatWithUnits( node.getAttribute( 'height' ) );\n\n\t\t\tvar path = new ShapePath();\n\t\t\tpath.moveTo( x + 2 * rx, y );\n\t\t\tpath.lineTo( x + w - 2 * rx, y );\n\t\t\tif ( rx !== 0 || ry !== 0 ) path.bezierCurveTo( x + w, y, x + w, y, x + w, y + 2 * ry );\n\t\t\tpath.lineTo( x + w, y + h - 2 * ry );\n\t\t\tif ( rx !== 0 || ry !== 0 ) path.bezierCurveTo( x + w, y + h, x + w, y + h, x + w - 2 * rx, y + h );\n\t\t\tpath.lineTo( x + 2 * rx, y + h );\n\n\t\t\tif ( rx !== 0 || ry !== 0 ) {\n\n\t\t\t\tpath.bezierCurveTo( x, y + h, x, y + h, x, y + h - 2 * ry );\n\n\t\t\t}\n\n\t\t\tpath.lineTo( x, y + 2 * ry );\n\n\t\t\tif ( rx !== 0 || ry !== 0 ) {\n\n\t\t\t\tpath.bezierCurveTo( x, y, x, y, x + 2 * rx, y );\n\n\t\t\t}\n\n\t\t\treturn path;\n\n\t\t}\n\n\t\tfunction parsePolygonNode( node ) {\n\n\t\t\tfunction iterator( match, a, b ) {\n\n\t\t\t\tvar x = parseFloatWithUnits( a );\n\t\t\t\tvar y = parseFloatWithUnits( b );\n\n\t\t\t\tif ( index === 0 ) {\n\n\t\t\t\t\tpath.moveTo( x, y );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tpath.lineTo( x, y );\n\n\t\t\t\t}\n\n\t\t\t\tindex ++;\n\n\t\t\t}\n\n\t\t\tvar regex = /(-?[\\d\\.?]+)[,|\\s](-?[\\d\\.?]+)/g;\n\n\t\t\tvar path = new ShapePath();\n\n\t\t\tvar index = 0;\n\n\t\t\tnode.getAttribute( 'points' ).replace( regex, iterator );\n\n\t\t\tpath.currentPath.autoClose = true;\n\n\t\t\treturn path;\n\n\t\t}\n\n\t\tfunction parsePolylineNode( node ) {\n\n\t\t\tfunction iterator( match, a, b ) {\n\n\t\t\t\tvar x = parseFloatWithUnits( a );\n\t\t\t\tvar y = parseFloatWithUnits( b );\n\n\t\t\t\tif ( index === 0 ) {\n\n\t\t\t\t\tpath.moveTo( x, y );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tpath.lineTo( x, y );\n\n\t\t\t\t}\n\n\t\t\t\tindex ++;\n\n\t\t\t}\n\n\t\t\tvar regex = /(-?[\\d\\.?]+)[,|\\s](-?[\\d\\.?]+)/g;\n\n\t\t\tvar path = new ShapePath();\n\n\t\t\tvar index = 0;\n\n\t\t\tnode.getAttribute( 'points' ).replace( regex, iterator );\n\n\t\t\tpath.currentPath.autoClose = false;\n\n\t\t\treturn path;\n\n\t\t}\n\n\t\tfunction parseCircleNode( node ) {\n\n\t\t\tvar x = parseFloatWithUnits( node.getAttribute( 'cx' ) );\n\t\t\tvar y = parseFloatWithUnits( node.getAttribute( 'cy' ) );\n\t\t\tvar r = parseFloatWithUnits( node.getAttribute( 'r' ) );\n\n\t\t\tvar subpath = new Path();\n\t\t\tsubpath.absarc( x, y, r, 0, Math.PI * 2 );\n\n\t\t\tvar path = new ShapePath();\n\t\t\tpath.subPaths.push( subpath );\n\n\t\t\treturn path;\n\n\t\t}\n\n\t\tfunction parseEllipseNode( node ) {\n\n\t\t\tvar x = parseFloatWithUnits( node.getAttribute( 'cx' ) );\n\t\t\tvar y = parseFloatWithUnits( node.getAttribute( 'cy' ) );\n\t\t\tvar rx = parseFloatWithUnits( node.getAttribute( 'rx' ) );\n\t\t\tvar ry = parseFloatWithUnits( node.getAttribute( 'ry' ) );\n\n\t\t\tvar subpath = new Path();\n\t\t\tsubpath.absellipse( x, y, rx, ry, 0, Math.PI * 2 );\n\n\t\t\tvar path = new ShapePath();\n\t\t\tpath.subPaths.push( subpath );\n\n\t\t\treturn path;\n\n\t\t}\n\n\t\tfunction parseLineNode( node ) {\n\n\t\t\tvar x1 = parseFloatWithUnits( node.getAttribute( 'x1' ) );\n\t\t\tvar y1 = parseFloatWithUnits( node.getAttribute( 'y1' ) );\n\t\t\tvar x2 = parseFloatWithUnits( node.getAttribute( 'x2' ) );\n\t\t\tvar y2 = parseFloatWithUnits( node.getAttribute( 'y2' ) );\n\n\t\t\tvar path = new ShapePath();\n\t\t\tpath.moveTo( x1, y1 );\n\t\t\tpath.lineTo( x2, y2 );\n\t\t\tpath.currentPath.autoClose = false;\n\n\t\t\treturn path;\n\n\t\t}\n\n\t\t//\n\n\t\tfunction parseStyle( node, style ) {\n\n\t\t\tstyle = Object.assign( {}, style ); // clone style\n\n\t\t\tvar stylesheetStyles = {};\n\n\t\t\tif ( node.hasAttribute( 'class' ) ) {\n\n\t\t\t\tvar classSelectors = node.getAttribute( 'class' )\n\t\t\t\t\t.split( /\\s/ )\n\t\t\t\t\t.filter( Boolean )\n\t\t\t\t\t.map( i => i.trim() );\n\n\t\t\t\tfor ( var i = 0; i < classSelectors.length; i ++ ) {\n\n\t\t\t\t\tstylesheetStyles = Object.assign( stylesheetStyles, stylesheets[ '.' + classSelectors[ i ] ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( node.hasAttribute( 'id' ) ) {\n\n\t\t\t\tstylesheetStyles = Object.assign( stylesheetStyles, stylesheets[ '#' + node.getAttribute( 'id' ) ] );\n\n\t\t\t}\n\n\t\t\tfunction addStyle( svgName, jsName, adjustFunction ) {\n\n\t\t\t\tif ( adjustFunction === undefined ) adjustFunction = function copy( v ) {\n\n\t\t\t\t\tif ( v.startsWith( 'url' ) ) console.warn( \"SVGLoader: url access in attributes is not implemented.\" );\n\n\t\t\t\t\treturn v;\n\n\t\t\t\t};\n\n\t\t\t\tif ( node.hasAttribute( svgName ) ) style[ jsName ] = adjustFunction( node.getAttribute( svgName ) );\n\t\t\t\tif ( stylesheetStyles[ svgName ] ) style[ jsName ] = adjustFunction( stylesheetStyles[ svgName ] );\n\t\t\t\tif ( node.style && node.style[ svgName ] !== '' ) style[ jsName ] = adjustFunction( node.style[ svgName ] );\n\n\t\t\t}\n\n\t\t\tfunction clamp( v ) {\n\n\t\t\t\treturn Math.max( 0, Math.min( 1, parseFloatWithUnits( v ) ) );\n\n\t\t\t}\n\n\t\t\tfunction positive( v ) {\n\n\t\t\t\treturn Math.max( 0, parseFloatWithUnits( v ) );\n\n\t\t\t}\n\n\t\t\taddStyle( 'fill', 'fill' );\n\t\t\taddStyle( 'fill-opacity', 'fillOpacity', clamp );\n\t\t\taddStyle( 'opacity', 'opacity', clamp );\n\t\t\taddStyle( 'stroke', 'stroke' );\n\t\t\taddStyle( 'stroke-opacity', 'strokeOpacity', clamp );\n\t\t\taddStyle( 'stroke-width', 'strokeWidth', positive );\n\t\t\taddStyle( 'stroke-linejoin', 'strokeLineJoin' );\n\t\t\taddStyle( 'stroke-linecap', 'strokeLineCap' );\n\t\t\taddStyle( 'stroke-miterlimit', 'strokeMiterLimit', positive );\n\t\t\taddStyle( 'visibility', 'visibility' );\n\n\t\t\treturn style;\n\n\t\t}\n\n\t\t// http://www.w3.org/TR/SVG11/implnote.html#PathElementImplementationNotes\n\n\t\tfunction getReflection( a, b ) {\n\n\t\t\treturn a - ( b - a );\n\n\t\t}\n\n\t\tfunction parseFloats( string ) {\n\n\t\t\tvar array = string.split( /[\\s,]+|(?=\\s?[+\\-])/ );\n\n\t\t\tfor ( var i = 0; i < array.length; i ++ ) {\n\n\t\t\t\tvar number = array[ i ];\n\n\t\t\t\t// Handle values like 48.6037.7.8\n\t\t\t\t// TODO Find a regex for this\n\n\t\t\t\tif ( number.indexOf( '.' ) !== number.lastIndexOf( '.' ) ) {\n\n\t\t\t\t\tvar split = number.split( '.' );\n\n\t\t\t\t\tfor ( var s = 2; s < split.length; s ++ ) {\n\n\t\t\t\t\t\tarray.splice( i + s - 1, 0, '0.' + split[ s ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tarray[ i ] = parseFloatWithUnits( number );\n\n\t\t\t}\n\n\t\t\treturn array;\n\n\n\t\t}\n\n\t\t// Units\n\n\t\tvar units = [ 'mm', 'cm', 'in', 'pt', 'pc', 'px' ];\n\n\t\t// Conversion: [ fromUnit ][ toUnit ] (-1 means dpi dependent)\n\t\tvar unitConversion = {\n\n\t\t\t\"mm\": {\n\t\t\t\t\"mm\": 1,\n\t\t\t\t\"cm\": 0.1,\n\t\t\t\t\"in\": 1 / 25.4,\n\t\t\t\t\"pt\": 72 / 25.4,\n\t\t\t\t\"pc\": 6 / 25.4,\n\t\t\t\t\"px\": - 1\n\t\t\t},\n\t\t\t\"cm\": {\n\t\t\t\t\"mm\": 10,\n\t\t\t\t\"cm\": 1,\n\t\t\t\t\"in\": 1 / 2.54,\n\t\t\t\t\"pt\": 72 / 2.54,\n\t\t\t\t\"pc\": 6 / 2.54,\n\t\t\t\t\"px\": - 1\n\t\t\t},\n\t\t\t\"in\": {\n\t\t\t\t\"mm\": 25.4,\n\t\t\t\t\"cm\": 2.54,\n\t\t\t\t\"in\": 1,\n\t\t\t\t\"pt\": 72,\n\t\t\t\t\"pc\": 6,\n\t\t\t\t\"px\": - 1\n\t\t\t},\n\t\t\t\"pt\": {\n\t\t\t\t\"mm\": 25.4 / 72,\n\t\t\t\t\"cm\": 2.54 / 72,\n\t\t\t\t\"in\": 1 / 72,\n\t\t\t\t\"pt\": 1,\n\t\t\t\t\"pc\": 6 / 72,\n\t\t\t\t\"px\": - 1\n\t\t\t},\n\t\t\t\"pc\": {\n\t\t\t\t\"mm\": 25.4 / 6,\n\t\t\t\t\"cm\": 2.54 / 6,\n\t\t\t\t\"in\": 1 / 6,\n\t\t\t\t\"pt\": 72 / 6,\n\t\t\t\t\"pc\": 1,\n\t\t\t\t\"px\": - 1\n\t\t\t},\n\t\t\t\"px\": {\n\t\t\t\t\"px\": 1\n\t\t\t}\n\n\t\t};\n\n\t\tfunction parseFloatWithUnits( string ) {\n\n\t\t\tvar theUnit = \"px\";\n\n\t\t\tif ( typeof string === 'string' || string instanceof String ) {\n\n\t\t\t\tfor ( var i = 0, n = units.length; i < n; i ++ ) {\n\n\t\t\t\t\tvar u = units[ i ];\n\n\t\t\t\t\tif ( string.endsWith( u ) ) {\n\n\t\t\t\t\t\ttheUnit = u;\n\t\t\t\t\t\tstring = string.substring( 0, string.length - u.length );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tvar scale = undefined;\n\n\t\t\tif ( theUnit === \"px\" && scope.defaultUnit !== \"px\" ) {\n\n\t\t\t\t// Conversion scale from  pixels to inches, then to default units\n\n\t\t\t\tscale = unitConversion[ \"in\" ][ scope.defaultUnit ] / scope.defaultDPI;\n\n\t\t\t} else {\n\n\t\t\t\tscale = unitConversion[ theUnit ][ scope.defaultUnit ];\n\n\t\t\t\tif ( scale < 0 ) {\n\n\t\t\t\t\t// Conversion scale to pixels\n\n\t\t\t\t\tscale = unitConversion[ theUnit ][ \"in\" ] * scope.defaultDPI;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn scale * parseFloat( string );\n\n\t\t}\n\n\t\t// Transforms\n\n\t\tfunction getNodeTransform( node ) {\n\n\t\t\tif ( ! ( node.hasAttribute( 'transform' ) || ( node.nodeName === 'use' && ( node.hasAttribute( 'x' ) || node.hasAttribute( 'y' ) ) ) ) ) {\n\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tvar transform = parseNodeTransform( node );\n\n\t\t\tif ( transformStack.length > 0 ) {\n\n\t\t\t\ttransform.premultiply( transformStack[ transformStack.length - 1 ] );\n\n\t\t\t}\n\n\t\t\tcurrentTransform.copy( transform );\n\t\t\ttransformStack.push( transform );\n\n\t\t\treturn transform;\n\n\t\t}\n\n\t\tfunction parseNodeTransform( node ) {\n\n\t\t\tvar transform = new Matrix3();\n\t\t\tvar currentTransform = tempTransform0;\n\n\t\t\tif ( node.nodeName === 'use' && ( node.hasAttribute( 'x' ) || node.hasAttribute( 'y' ) ) ) {\n\n\t\t\t\tvar tx = parseFloatWithUnits( node.getAttribute( 'x' ) );\n\t\t\t\tvar ty = parseFloatWithUnits( node.getAttribute( 'y' ) );\n\n\t\t\t\ttransform.translate( tx, ty );\n\n\t\t\t}\n\n\t\t\tif ( node.hasAttribute( 'transform' ) ) {\n\n\t\t\t\tvar transformsTexts = node.getAttribute( 'transform' ).split( ')' );\n\n\t\t\t\tfor ( var tIndex = transformsTexts.length - 1; tIndex >= 0; tIndex -- ) {\n\n\t\t\t\t\tvar transformText = transformsTexts[ tIndex ].trim();\n\n\t\t\t\t\tif ( transformText === '' ) continue;\n\n\t\t\t\t\tvar openParPos = transformText.indexOf( '(' );\n\t\t\t\t\tvar closeParPos = transformText.length;\n\n\t\t\t\t\tif ( openParPos > 0 && openParPos < closeParPos ) {\n\n\t\t\t\t\t\tvar transformType = transformText.substr( 0, openParPos );\n\n\t\t\t\t\t\tvar array = parseFloats( transformText.substr( openParPos + 1, closeParPos - openParPos - 1 ) );\n\n\t\t\t\t\t\tcurrentTransform.identity();\n\n\t\t\t\t\t\tswitch ( transformType ) {\n\n\t\t\t\t\t\t\tcase \"translate\":\n\n\t\t\t\t\t\t\t\tif ( array.length >= 1 ) {\n\n\t\t\t\t\t\t\t\t\tvar tx = array[ 0 ];\n\t\t\t\t\t\t\t\t\tvar ty = tx;\n\n\t\t\t\t\t\t\t\t\tif ( array.length >= 2 ) {\n\n\t\t\t\t\t\t\t\t\t\tty = array[ 1 ];\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tcurrentTransform.translate( tx, ty );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase \"rotate\":\n\n\t\t\t\t\t\t\t\tif ( array.length >= 1 ) {\n\n\t\t\t\t\t\t\t\t\tvar angle = 0;\n\t\t\t\t\t\t\t\t\tvar cx = 0;\n\t\t\t\t\t\t\t\t\tvar cy = 0;\n\n\t\t\t\t\t\t\t\t\t// Angle\n\t\t\t\t\t\t\t\t\tangle = - array[ 0 ] * Math.PI / 180;\n\n\t\t\t\t\t\t\t\t\tif ( array.length >= 3 ) {\n\n\t\t\t\t\t\t\t\t\t\t// Center x, y\n\t\t\t\t\t\t\t\t\t\tcx = array[ 1 ];\n\t\t\t\t\t\t\t\t\t\tcy = array[ 2 ];\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// Rotate around center (cx, cy)\n\t\t\t\t\t\t\t\t\ttempTransform1.identity().translate( - cx, - cy );\n\t\t\t\t\t\t\t\t\ttempTransform2.identity().rotate( angle );\n\t\t\t\t\t\t\t\t\ttempTransform3.multiplyMatrices( tempTransform2, tempTransform1 );\n\t\t\t\t\t\t\t\t\ttempTransform1.identity().translate( cx, cy );\n\t\t\t\t\t\t\t\t\tcurrentTransform.multiplyMatrices( tempTransform1, tempTransform3 );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase \"scale\":\n\n\t\t\t\t\t\t\t\tif ( array.length >= 1 ) {\n\n\t\t\t\t\t\t\t\t\tvar scaleX = array[ 0 ];\n\t\t\t\t\t\t\t\t\tvar scaleY = scaleX;\n\n\t\t\t\t\t\t\t\t\tif ( array.length >= 2 ) {\n\n\t\t\t\t\t\t\t\t\t\tscaleY = array[ 1 ];\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tcurrentTransform.scale( scaleX, scaleY );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase \"skewX\":\n\n\t\t\t\t\t\t\t\tif ( array.length === 1 ) {\n\n\t\t\t\t\t\t\t\t\tcurrentTransform.set(\n\t\t\t\t\t\t\t\t\t\t1, Math.tan( array[ 0 ] * Math.PI / 180 ), 0,\n\t\t\t\t\t\t\t\t\t\t0, 1, 0,\n\t\t\t\t\t\t\t\t\t\t0, 0, 1\n\t\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase \"skewY\":\n\n\t\t\t\t\t\t\t\tif ( array.length === 1 ) {\n\n\t\t\t\t\t\t\t\t\tcurrentTransform.set(\n\t\t\t\t\t\t\t\t\t\t1, 0, 0,\n\t\t\t\t\t\t\t\t\t\tMath.tan( array[ 0 ] * Math.PI / 180 ), 1, 0,\n\t\t\t\t\t\t\t\t\t\t0, 0, 1\n\t\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase \"matrix\":\n\n\t\t\t\t\t\t\t\tif ( array.length === 6 ) {\n\n\t\t\t\t\t\t\t\t\tcurrentTransform.set(\n\t\t\t\t\t\t\t\t\t\tarray[ 0 ], array[ 2 ], array[ 4 ],\n\t\t\t\t\t\t\t\t\t\tarray[ 1 ], array[ 3 ], array[ 5 ],\n\t\t\t\t\t\t\t\t\t\t0, 0, 1\n\t\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttransform.premultiply( currentTransform );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn transform;\n\n\t\t}\n\n\t\tfunction transformPath( path, m ) {\n\n\t\t\tfunction transfVec2( v2 ) {\n\n\t\t\t\ttempV3.set( v2.x, v2.y, 1 ).applyMatrix3( m );\n\n\t\t\t\tv2.set( tempV3.x, tempV3.y );\n\n\t\t\t}\n\n\t\t\tvar isRotated = isTransformRotated( m );\n\n\t\t\tvar subPaths = path.subPaths;\n\n\t\t\tfor ( var i = 0, n = subPaths.length; i < n; i ++ ) {\n\n\t\t\t\tvar subPath = subPaths[ i ];\n\t\t\t\tvar curves = subPath.curves;\n\n\t\t\t\tfor ( var j = 0; j < curves.length; j ++ ) {\n\n\t\t\t\t\tvar curve = curves[ j ];\n\n\t\t\t\t\tif ( curve.isLineCurve ) {\n\n\t\t\t\t\t\ttransfVec2( curve.v1 );\n\t\t\t\t\t\ttransfVec2( curve.v2 );\n\n\t\t\t\t\t} else if ( curve.isCubicBezierCurve ) {\n\n\t\t\t\t\t\ttransfVec2( curve.v0 );\n\t\t\t\t\t\ttransfVec2( curve.v1 );\n\t\t\t\t\t\ttransfVec2( curve.v2 );\n\t\t\t\t\t\ttransfVec2( curve.v3 );\n\n\t\t\t\t\t} else if ( curve.isQuadraticBezierCurve ) {\n\n\t\t\t\t\t\ttransfVec2( curve.v0 );\n\t\t\t\t\t\ttransfVec2( curve.v1 );\n\t\t\t\t\t\ttransfVec2( curve.v2 );\n\n\t\t\t\t\t} else if ( curve.isEllipseCurve ) {\n\n\t\t\t\t\t\tif ( isRotated ) {\n\n\t\t\t\t\t\t\tconsole.warn( \"SVGLoader: Elliptic arc or ellipse rotation or skewing is not implemented.\" );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\ttempV2.set( curve.aX, curve.aY );\n\t\t\t\t\t\ttransfVec2( tempV2 );\n\t\t\t\t\t\tcurve.aX = tempV2.x;\n\t\t\t\t\t\tcurve.aY = tempV2.y;\n\n\t\t\t\t\t\tcurve.xRadius *= getTransformScaleX( m );\n\t\t\t\t\t\tcurve.yRadius *= getTransformScaleY( m );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction isTransformRotated( m ) {\n\n\t\t\treturn m.elements[ 1 ] !== 0 || m.elements[ 3 ] !== 0;\n\n\t\t}\n\n\t\tfunction getTransformScaleX( m ) {\n\n\t\t\tvar te = m.elements;\n\t\t\treturn Math.sqrt( te[ 0 ] * te[ 0 ] + te[ 1 ] * te[ 1 ] );\n\n\t\t}\n\n\t\tfunction getTransformScaleY( m ) {\n\n\t\t\tvar te = m.elements;\n\t\t\treturn Math.sqrt( te[ 3 ] * te[ 3 ] + te[ 4 ] * te[ 4 ] );\n\n\t\t}\n\n\t\t//\n\n\t\tvar paths = [];\n\t\tvar stylesheets = {};\n\n\t\tvar transformStack = [];\n\n\t\tvar tempTransform0 = new Matrix3();\n\t\tvar tempTransform1 = new Matrix3();\n\t\tvar tempTransform2 = new Matrix3();\n\t\tvar tempTransform3 = new Matrix3();\n\t\tvar tempV2 = new Vector2();\n\t\tvar tempV3 = new Vector3();\n\n\t\tvar currentTransform = new Matrix3();\n\n\t\tvar xml = new DOMParser().parseFromString( text, 'image/svg+xml' ); // application/xml\n\n\t\tparseNode( xml.documentElement, {\n\t\t\tfill: '#000',\n\t\t\tfillOpacity: 1,\n\t\t\tstrokeOpacity: 1,\n\t\t\tstrokeWidth: 1,\n\t\t\tstrokeLineJoin: 'miter',\n\t\t\tstrokeLineCap: 'butt',\n\t\t\tstrokeMiterLimit: 4\n\t\t} );\n\n\t\tvar data = { paths: paths, xml: xml.documentElement };\n\n\t\t// console.log( paths );\n\t\treturn data;\n\n\t}\n\n} );\n\nSVGLoader.getStrokeStyle = function ( width, color, lineJoin, lineCap, miterLimit ) {\n\n\t// Param width: Stroke width\n\t// Param color: As returned by THREE.Color.getStyle()\n\t// Param lineJoin: One of \"round\", \"bevel\", \"miter\" or \"miter-limit\"\n\t// Param lineCap: One of \"round\", \"square\" or \"butt\"\n\t// Param miterLimit: Maximum join length, in multiples of the \"width\" parameter (join is truncated if it exceeds that distance)\n\t// Returns style object\n\n\twidth = width !== undefined ? width : 1;\n\tcolor = color !== undefined ? color : '#000';\n\tlineJoin = lineJoin !== undefined ? lineJoin : 'miter';\n\tlineCap = lineCap !== undefined ? lineCap : 'butt';\n\tmiterLimit = miterLimit !== undefined ? miterLimit : 4;\n\n\treturn {\n\t\tstrokeColor: color,\n\t\tstrokeWidth: width,\n\t\tstrokeLineJoin: lineJoin,\n\t\tstrokeLineCap: lineCap,\n\t\tstrokeMiterLimit: miterLimit\n\t};\n\n};\n\nSVGLoader.pointsToStroke = function ( points, style, arcDivisions, minDistance ) {\n\n\t// Generates a stroke with some witdh around the given path.\n\t// The path can be open or closed (last point equals to first point)\n\t// Param points: Array of Vector2D (the path). Minimum 2 points.\n\t// Param style: Object with SVG properties as returned by SVGLoader.getStrokeStyle(), or SVGLoader.parse() in the path.userData.style object\n\t// Params arcDivisions: Arc divisions for round joins and endcaps. (Optional)\n\t// Param minDistance: Points closer to this distance will be merged. (Optional)\n\t// Returns BufferGeometry with stroke triangles (In plane z = 0). UV coordinates are generated ('u' along path. 'v' across it, from left to right)\n\n\tvar vertices = [];\n\tvar normals = [];\n\tvar uvs = [];\n\n\tif ( SVGLoader.pointsToStrokeWithBuffers( points, style, arcDivisions, minDistance, vertices, normals, uvs ) === 0 ) {\n\n\t\treturn null;\n\n\t}\n\n\tvar geometry = new BufferGeometry();\n\tgeometry.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\tgeometry.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\n\tgeometry.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\n\treturn geometry;\n\n};\n\nSVGLoader.pointsToStrokeWithBuffers = function () {\n\n\tvar tempV2_1 = new Vector2();\n\tvar tempV2_2 = new Vector2();\n\tvar tempV2_3 = new Vector2();\n\tvar tempV2_4 = new Vector2();\n\tvar tempV2_5 = new Vector2();\n\tvar tempV2_6 = new Vector2();\n\tvar tempV2_7 = new Vector2();\n\tvar lastPointL = new Vector2();\n\tvar lastPointR = new Vector2();\n\tvar point0L = new Vector2();\n\tvar point0R = new Vector2();\n\tvar currentPointL = new Vector2();\n\tvar currentPointR = new Vector2();\n\tvar nextPointL = new Vector2();\n\tvar nextPointR = new Vector2();\n\tvar innerPoint = new Vector2();\n\tvar outerPoint = new Vector2();\n\n\treturn function ( points, style, arcDivisions, minDistance, vertices, normals, uvs, vertexOffset ) {\n\n\t\t// This function can be called to update existing arrays or buffers.\n\t\t// Accepts same parameters as pointsToStroke, plus the buffers and optional offset.\n\t\t// Param vertexOffset: Offset vertices to start writing in the buffers (3 elements/vertex for vertices and normals, and 2 elements/vertex for uvs)\n\t\t// Returns number of written vertices / normals / uvs pairs\n\t\t// if 'vertices' parameter is undefined no triangles will be generated, but the returned vertices count will still be valid (useful to preallocate the buffers)\n\t\t// 'normals' and 'uvs' buffers are optional\n\n\t\tarcDivisions = arcDivisions !== undefined ? arcDivisions : 12;\n\t\tminDistance = minDistance !== undefined ? minDistance : 0.001;\n\t\tvertexOffset = vertexOffset !== undefined ? vertexOffset : 0;\n\n\t\t// First ensure there are no duplicated points\n\t\tpoints = removeDuplicatedPoints( points );\n\n\t\tvar numPoints = points.length;\n\n\t\tif ( numPoints < 2 ) return 0;\n\n\t\tvar isClosed = points[ 0 ].equals( points[ numPoints - 1 ] );\n\n\t\tvar currentPoint;\n\t\tvar previousPoint = points[ 0 ];\n\t\tvar nextPoint;\n\n\t\tvar strokeWidth2 = style.strokeWidth / 2;\n\n\t\tvar deltaU = 1 / ( numPoints - 1 );\n\t\tvar u0 = 0;\n\n\t\tvar innerSideModified;\n\t\tvar joinIsOnLeftSide;\n\t\tvar isMiter;\n\t\tvar initialJoinIsOnLeftSide = false;\n\n\t\tvar numVertices = 0;\n\t\tvar currentCoordinate = vertexOffset * 3;\n\t\tvar currentCoordinateUV = vertexOffset * 2;\n\n\t\t// Get initial left and right stroke points\n\t\tgetNormal( points[ 0 ], points[ 1 ], tempV2_1 ).multiplyScalar( strokeWidth2 );\n\t\tlastPointL.copy( points[ 0 ] ).sub( tempV2_1 );\n\t\tlastPointR.copy( points[ 0 ] ).add( tempV2_1 );\n\t\tpoint0L.copy( lastPointL );\n\t\tpoint0R.copy( lastPointR );\n\n\t\tfor ( var iPoint = 1; iPoint < numPoints; iPoint ++ ) {\n\n\t\t\tcurrentPoint = points[ iPoint ];\n\n\t\t\t// Get next point\n\t\t\tif ( iPoint === numPoints - 1 ) {\n\n\t\t\t\tif ( isClosed ) {\n\n\t\t\t\t\t// Skip duplicated initial point\n\t\t\t\t\tnextPoint = points[ 1 ];\n\n\t\t\t\t} else nextPoint = undefined;\n\n\t\t\t} else {\n\n\t\t\t\tnextPoint = points[ iPoint + 1 ];\n\n\t\t\t}\n\n\t\t\t// Normal of previous segment in tempV2_1\n\t\t\tvar normal1 = tempV2_1;\n\t\t\tgetNormal( previousPoint, currentPoint, normal1 );\n\n\t\t\ttempV2_3.copy( normal1 ).multiplyScalar( strokeWidth2 );\n\t\t\tcurrentPointL.copy( currentPoint ).sub( tempV2_3 );\n\t\t\tcurrentPointR.copy( currentPoint ).add( tempV2_3 );\n\n\t\t\tvar u1 = u0 + deltaU;\n\n\t\t\tinnerSideModified = false;\n\n\t\t\tif ( nextPoint !== undefined ) {\n\n\t\t\t\t// Normal of next segment in tempV2_2\n\t\t\t\tgetNormal( currentPoint, nextPoint, tempV2_2 );\n\n\t\t\t\ttempV2_3.copy( tempV2_2 ).multiplyScalar( strokeWidth2 );\n\t\t\t\tnextPointL.copy( currentPoint ).sub( tempV2_3 );\n\t\t\t\tnextPointR.copy( currentPoint ).add( tempV2_3 );\n\n\t\t\t\tjoinIsOnLeftSide = true;\n\t\t\t\ttempV2_3.subVectors( nextPoint, previousPoint );\n\t\t\t\tif ( normal1.dot( tempV2_3 ) < 0 ) {\n\n\t\t\t\t\tjoinIsOnLeftSide = false;\n\n\t\t\t\t}\n\n\t\t\t\tif ( iPoint === 1 ) initialJoinIsOnLeftSide = joinIsOnLeftSide;\n\n\t\t\t\ttempV2_3.subVectors( nextPoint, currentPoint );\n\t\t\t\ttempV2_3.normalize();\n\t\t\t\tvar dot = Math.abs( normal1.dot( tempV2_3 ) );\n\n\t\t\t\t// If path is straight, don't create join\n\t\t\t\tif ( dot !== 0 ) {\n\n\t\t\t\t\t// Compute inner and outer segment intersections\n\t\t\t\t\tvar miterSide = strokeWidth2 / dot;\n\t\t\t\t\ttempV2_3.multiplyScalar( - miterSide );\n\t\t\t\t\ttempV2_4.subVectors( currentPoint, previousPoint );\n\t\t\t\t\ttempV2_5.copy( tempV2_4 ).setLength( miterSide ).add( tempV2_3 );\n\t\t\t\t\tinnerPoint.copy( tempV2_5 ).negate();\n\t\t\t\t\tvar miterLength2 = tempV2_5.length();\n\t\t\t\t\tvar segmentLengthPrev = tempV2_4.length();\n\t\t\t\t\ttempV2_4.divideScalar( segmentLengthPrev );\n\t\t\t\t\ttempV2_6.subVectors( nextPoint, currentPoint );\n\t\t\t\t\tvar segmentLengthNext = tempV2_6.length();\n\t\t\t\t\ttempV2_6.divideScalar( segmentLengthNext );\n\t\t\t\t\t// Check that previous and next segments doesn't overlap with the innerPoint of intersection\n\t\t\t\t\tif ( tempV2_4.dot( innerPoint ) < segmentLengthPrev && tempV2_6.dot( innerPoint ) < segmentLengthNext ) {\n\n\t\t\t\t\t\tinnerSideModified = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t\touterPoint.copy( tempV2_5 ).add( currentPoint );\n\t\t\t\t\tinnerPoint.add( currentPoint );\n\n\t\t\t\t\tisMiter = false;\n\n\t\t\t\t\tif ( innerSideModified ) {\n\n\t\t\t\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\t\t\t\tnextPointR.copy( innerPoint );\n\t\t\t\t\t\t\tcurrentPointR.copy( innerPoint );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tnextPointL.copy( innerPoint );\n\t\t\t\t\t\t\tcurrentPointL.copy( innerPoint );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// The segment triangles are generated here if there was overlapping\n\n\t\t\t\t\t\tmakeSegmentTriangles();\n\n\t\t\t\t\t}\n\n\t\t\t\t\tswitch ( style.strokeLineJoin ) {\n\n\t\t\t\t\t\tcase 'bevel':\n\n\t\t\t\t\t\t\tmakeSegmentWithBevelJoin( joinIsOnLeftSide, innerSideModified, u1 );\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'round':\n\n\t\t\t\t\t\t\t// Segment triangles\n\n\t\t\t\t\t\t\tcreateSegmentTrianglesWithMiddleSection( joinIsOnLeftSide, innerSideModified );\n\n\t\t\t\t\t\t\t// Join triangles\n\n\t\t\t\t\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\t\t\t\t\tmakeCircularSector( currentPoint, currentPointL, nextPointL, u1, 0 );\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tmakeCircularSector( currentPoint, nextPointR, currentPointR, u1, 1 );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'miter':\n\t\t\t\t\t\tcase 'miter-clip':\n\t\t\t\t\t\tdefault:\n\n\t\t\t\t\t\t\tvar miterFraction = ( strokeWidth2 * style.strokeMiterLimit ) / miterLength2;\n\n\t\t\t\t\t\t\tif ( miterFraction < 1 ) {\n\n\t\t\t\t\t\t\t\t// The join miter length exceeds the miter limit\n\n\t\t\t\t\t\t\t\tif ( style.strokeLineJoin !== 'miter-clip' ) {\n\n\t\t\t\t\t\t\t\t\tmakeSegmentWithBevelJoin( joinIsOnLeftSide, innerSideModified, u1 );\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t// Segment triangles\n\n\t\t\t\t\t\t\t\t\tcreateSegmentTrianglesWithMiddleSection( joinIsOnLeftSide, innerSideModified );\n\n\t\t\t\t\t\t\t\t\t// Miter-clip join triangles\n\n\t\t\t\t\t\t\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\t\t\t\t\t\t\ttempV2_6.subVectors( outerPoint, currentPointL ).multiplyScalar( miterFraction ).add( currentPointL );\n\t\t\t\t\t\t\t\t\t\ttempV2_7.subVectors( outerPoint, nextPointL ).multiplyScalar( miterFraction ).add( nextPointL );\n\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPointL, u1, 0 );\n\t\t\t\t\t\t\t\t\t\taddVertex( tempV2_6, u1, 0 );\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\t\t\t\t\t\t\t\t\t\taddVertex( tempV2_6, u1, 0 );\n\t\t\t\t\t\t\t\t\t\taddVertex( tempV2_7, u1, 0 );\n\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\t\t\t\t\t\t\t\t\t\taddVertex( tempV2_7, u1, 0 );\n\t\t\t\t\t\t\t\t\t\taddVertex( nextPointL, u1, 0 );\n\n\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\ttempV2_6.subVectors( outerPoint, currentPointR ).multiplyScalar( miterFraction ).add( currentPointR );\n\t\t\t\t\t\t\t\t\t\ttempV2_7.subVectors( outerPoint, nextPointR ).multiplyScalar( miterFraction ).add( nextPointR );\n\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPointR, u1, 1 );\n\t\t\t\t\t\t\t\t\t\taddVertex( tempV2_6, u1, 1 );\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\t\t\t\t\t\t\t\t\t\taddVertex( tempV2_6, u1, 1 );\n\t\t\t\t\t\t\t\t\t\taddVertex( tempV2_7, u1, 1 );\n\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\t\t\t\t\t\t\t\t\t\taddVertex( tempV2_7, u1, 1 );\n\t\t\t\t\t\t\t\t\t\taddVertex( nextPointR, u1, 1 );\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t// Miter join segment triangles\n\n\t\t\t\t\t\t\t\tif ( innerSideModified ) {\n\n\t\t\t\t\t\t\t\t\t// Optimized segment + join triangles\n\n\t\t\t\t\t\t\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\t\t\t\t\t\t\taddVertex( lastPointR, u0, 1 );\n\t\t\t\t\t\t\t\t\t\taddVertex( lastPointL, u0, 0 );\n\t\t\t\t\t\t\t\t\t\taddVertex( outerPoint, u1, 0 );\n\n\t\t\t\t\t\t\t\t\t\taddVertex( lastPointR, u0, 1 );\n\t\t\t\t\t\t\t\t\t\taddVertex( outerPoint, u1, 0 );\n\t\t\t\t\t\t\t\t\t\taddVertex( innerPoint, u1, 1 );\n\n\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\taddVertex( lastPointR, u0, 1 );\n\t\t\t\t\t\t\t\t\t\taddVertex( lastPointL, u0, 0 );\n\t\t\t\t\t\t\t\t\t\taddVertex( outerPoint, u1, 1 );\n\n\t\t\t\t\t\t\t\t\t\taddVertex( lastPointL, u0, 0 );\n\t\t\t\t\t\t\t\t\t\taddVertex( innerPoint, u1, 0 );\n\t\t\t\t\t\t\t\t\t\taddVertex( outerPoint, u1, 1 );\n\n\t\t\t\t\t\t\t\t\t}\n\n\n\t\t\t\t\t\t\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\t\t\t\t\t\t\tnextPointL.copy( outerPoint );\n\n\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\tnextPointR.copy( outerPoint );\n\n\t\t\t\t\t\t\t\t\t}\n\n\n\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t// Add extra miter join triangles\n\n\t\t\t\t\t\t\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPointL, u1, 0 );\n\t\t\t\t\t\t\t\t\t\taddVertex( outerPoint, u1, 0 );\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\t\t\t\t\t\t\t\t\t\taddVertex( outerPoint, u1, 0 );\n\t\t\t\t\t\t\t\t\t\taddVertex( nextPointL, u1, 0 );\n\n\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPointR, u1, 1 );\n\t\t\t\t\t\t\t\t\t\taddVertex( outerPoint, u1, 1 );\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\t\t\t\t\t\t\t\t\t\taddVertex( outerPoint, u1, 1 );\n\t\t\t\t\t\t\t\t\t\taddVertex( nextPointR, u1, 1 );\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tisMiter = true;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// The segment triangles are generated here when two consecutive points are collinear\n\n\t\t\t\t\tmakeSegmentTriangles();\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// The segment triangles are generated here if it is the ending segment\n\n\t\t\t\tmakeSegmentTriangles();\n\n\t\t\t}\n\n\t\t\tif ( ! isClosed && iPoint === numPoints - 1 ) {\n\n\t\t\t\t// Start line endcap\n\t\t\t\taddCapGeometry( points[ 0 ], point0L, point0R, joinIsOnLeftSide, true, u0 );\n\n\t\t\t}\n\n\t\t\t// Increment loop variables\n\n\t\t\tu0 = u1;\n\n\t\t\tpreviousPoint = currentPoint;\n\n\t\t\tlastPointL.copy( nextPointL );\n\t\t\tlastPointR.copy( nextPointR );\n\n\t\t}\n\n\t\tif ( ! isClosed ) {\n\n\t\t\t// Ending line endcap\n\t\t\taddCapGeometry( currentPoint, currentPointL, currentPointR, joinIsOnLeftSide, false, u1 );\n\n\t\t} else if ( innerSideModified && vertices ) {\n\n\t\t\t// Modify path first segment vertices to adjust to the segments inner and outer intersections\n\n\t\t\tvar lastOuter = outerPoint;\n\t\t\tvar lastInner = innerPoint;\n\n\t\t\tif ( initialJoinIsOnLeftSide !== joinIsOnLeftSide ) {\n\n\t\t\t\tlastOuter = innerPoint;\n\t\t\t\tlastInner = outerPoint;\n\n\t\t\t}\n\n\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\tif ( isMiter || initialJoinIsOnLeftSide ) {\n\n\t\t\t\t\tlastInner.toArray( vertices, 0 * 3 );\n\t\t\t\t\tlastInner.toArray( vertices, 3 * 3 );\n\n\t\t\t\t\tif ( isMiter ) {\n\n\t\t\t\t\t\tlastOuter.toArray( vertices, 1 * 3 );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tif ( isMiter || ! initialJoinIsOnLeftSide ) {\n\n\t\t\t\t\tlastInner.toArray( vertices, 1 * 3 );\n\t\t\t\t\tlastInner.toArray( vertices, 3 * 3 );\n\n\t\t\t\t\tif ( isMiter ) {\n\n\t\t\t\t\t\tlastOuter.toArray( vertices, 0 * 3 );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn numVertices;\n\n\t\t// -- End of algorithm\n\n\t\t// -- Functions\n\n\t\tfunction getNormal( p1, p2, result ) {\n\n\t\t\tresult.subVectors( p2, p1 );\n\t\t\treturn result.set( - result.y, result.x ).normalize();\n\n\t\t}\n\n\t\tfunction addVertex( position, u, v ) {\n\n\t\t\tif ( vertices ) {\n\n\t\t\t\tvertices[ currentCoordinate ] = position.x;\n\t\t\t\tvertices[ currentCoordinate + 1 ] = position.y;\n\t\t\t\tvertices[ currentCoordinate + 2 ] = 0;\n\n\t\t\t\tif ( normals ) {\n\n\t\t\t\t\tnormals[ currentCoordinate ] = 0;\n\t\t\t\t\tnormals[ currentCoordinate + 1 ] = 0;\n\t\t\t\t\tnormals[ currentCoordinate + 2 ] = 1;\n\n\t\t\t\t}\n\n\t\t\t\tcurrentCoordinate += 3;\n\n\t\t\t\tif ( uvs ) {\n\n\t\t\t\t\tuvs[ currentCoordinateUV ] = u;\n\t\t\t\t\tuvs[ currentCoordinateUV + 1 ] = v;\n\n\t\t\t\t\tcurrentCoordinateUV += 2;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tnumVertices += 3;\n\n\t\t}\n\n\t\tfunction makeCircularSector( center, p1, p2, u, v ) {\n\n\t\t\t// param p1, p2: Points in the circle arc.\n\t\t\t// p1 and p2 are in clockwise direction.\n\n\t\t\ttempV2_1.copy( p1 ).sub( center ).normalize();\n\t\t\ttempV2_2.copy( p2 ).sub( center ).normalize();\n\n\t\t\tvar angle = Math.PI;\n\t\t\tvar dot = tempV2_1.dot( tempV2_2 );\n\t\t\tif ( Math.abs( dot ) < 1 ) angle = Math.abs( Math.acos( dot ) );\n\n\t\t\tangle /= arcDivisions;\n\n\t\t\ttempV2_3.copy( p1 );\n\n\t\t\tfor ( var i = 0, il = arcDivisions - 1; i < il; i ++ ) {\n\n\t\t\t\ttempV2_4.copy( tempV2_3 ).rotateAround( center, angle );\n\n\t\t\t\taddVertex( tempV2_3, u, v );\n\t\t\t\taddVertex( tempV2_4, u, v );\n\t\t\t\taddVertex( center, u, 0.5 );\n\n\t\t\t\ttempV2_3.copy( tempV2_4 );\n\n\t\t\t}\n\n\t\t\taddVertex( tempV2_4, u, v );\n\t\t\taddVertex( p2, u, v );\n\t\t\taddVertex( center, u, 0.5 );\n\n\t\t}\n\n\t\tfunction makeSegmentTriangles() {\n\n\t\t\taddVertex( lastPointR, u0, 1 );\n\t\t\taddVertex( lastPointL, u0, 0 );\n\t\t\taddVertex( currentPointL, u1, 0 );\n\n\t\t\taddVertex( lastPointR, u0, 1 );\n\t\t\taddVertex( currentPointL, u1, 1 );\n\t\t\taddVertex( currentPointR, u1, 0 );\n\n\t\t}\n\n\t\tfunction makeSegmentWithBevelJoin( joinIsOnLeftSide, innerSideModified, u ) {\n\n\t\t\tif ( innerSideModified ) {\n\n\t\t\t\t// Optimized segment + bevel triangles\n\n\t\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\t\t// Path segments triangles\n\n\t\t\t\t\taddVertex( lastPointR, u0, 1 );\n\t\t\t\t\taddVertex( lastPointL, u0, 0 );\n\t\t\t\t\taddVertex( currentPointL, u1, 0 );\n\n\t\t\t\t\taddVertex( lastPointR, u0, 1 );\n\t\t\t\t\taddVertex( currentPointL, u1, 0 );\n\t\t\t\t\taddVertex( innerPoint, u1, 1 );\n\n\t\t\t\t\t// Bevel join triangle\n\n\t\t\t\t\taddVertex( currentPointL, u, 0 );\n\t\t\t\t\taddVertex( nextPointL, u, 0 );\n\t\t\t\t\taddVertex( innerPoint, u, 0.5 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// Path segments triangles\n\n\t\t\t\t\taddVertex( lastPointR, u0, 1 );\n\t\t\t\t\taddVertex( lastPointL, u0, 0 );\n\t\t\t\t\taddVertex( currentPointR, u1, 1 );\n\n\t\t\t\t\taddVertex( lastPointL, u0, 0 );\n\t\t\t\t\taddVertex( innerPoint, u1, 0 );\n\t\t\t\t\taddVertex( currentPointR, u1, 1 );\n\n\t\t\t\t\t// Bevel join triangle\n\n\t\t\t\t\taddVertex( currentPointR, u, 1 );\n\t\t\t\t\taddVertex( nextPointR, u, 0 );\n\t\t\t\t\taddVertex( innerPoint, u, 0.5 );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// Bevel join triangle. The segment triangles are done in the main loop\n\n\t\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\t\taddVertex( currentPointL, u, 0 );\n\t\t\t\t\taddVertex( nextPointL, u, 0 );\n\t\t\t\t\taddVertex( currentPoint, u, 0.5 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\taddVertex( currentPointR, u, 1 );\n\t\t\t\t\taddVertex( nextPointR, u, 0 );\n\t\t\t\t\taddVertex( currentPoint, u, 0.5 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction createSegmentTrianglesWithMiddleSection( joinIsOnLeftSide, innerSideModified ) {\n\n\t\t\tif ( innerSideModified ) {\n\n\t\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\t\taddVertex( lastPointR, u0, 1 );\n\t\t\t\t\taddVertex( lastPointL, u0, 0 );\n\t\t\t\t\taddVertex( currentPointL, u1, 0 );\n\n\t\t\t\t\taddVertex( lastPointR, u0, 1 );\n\t\t\t\t\taddVertex( currentPointL, u1, 0 );\n\t\t\t\t\taddVertex( innerPoint, u1, 1 );\n\n\t\t\t\t\taddVertex( currentPointL, u0, 0 );\n\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\t\t\t\t\taddVertex( innerPoint, u1, 1 );\n\n\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\t\t\t\t\taddVertex( nextPointL, u0, 0 );\n\t\t\t\t\taddVertex( innerPoint, u1, 1 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\taddVertex( lastPointR, u0, 1 );\n\t\t\t\t\taddVertex( lastPointL, u0, 0 );\n\t\t\t\t\taddVertex( currentPointR, u1, 1 );\n\n\t\t\t\t\taddVertex( lastPointL, u0, 0 );\n\t\t\t\t\taddVertex( innerPoint, u1, 0 );\n\t\t\t\t\taddVertex( currentPointR, u1, 1 );\n\n\t\t\t\t\taddVertex( currentPointR, u0, 1 );\n\t\t\t\t\taddVertex( innerPoint, u1, 0 );\n\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\n\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\t\t\t\t\taddVertex( innerPoint, u1, 0 );\n\t\t\t\t\taddVertex( nextPointR, u0, 1 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction addCapGeometry( center, p1, p2, joinIsOnLeftSide, start, u ) {\n\n\t\t\t// param center: End point of the path\n\t\t\t// param p1, p2: Left and right cap points\n\n\t\t\tswitch ( style.strokeLineCap ) {\n\n\t\t\t\tcase 'round':\n\n\t\t\t\t\tif ( start ) {\n\n\t\t\t\t\t\tmakeCircularSector( center, p2, p1, u, 0.5 );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tmakeCircularSector( center, p1, p2, u, 0.5 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'square':\n\n\t\t\t\t\tif ( start ) {\n\n\t\t\t\t\t\ttempV2_1.subVectors( p1, center );\n\t\t\t\t\t\ttempV2_2.set( tempV2_1.y, - tempV2_1.x );\n\n\t\t\t\t\t\ttempV2_3.addVectors( tempV2_1, tempV2_2 ).add( center );\n\t\t\t\t\t\ttempV2_4.subVectors( tempV2_2, tempV2_1 ).add( center );\n\n\t\t\t\t\t\t// Modify already existing vertices\n\t\t\t\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\t\t\t\ttempV2_3.toArray( vertices, 1 * 3 );\n\t\t\t\t\t\t\ttempV2_4.toArray( vertices, 0 * 3 );\n\t\t\t\t\t\t\ttempV2_4.toArray( vertices, 3 * 3 );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\ttempV2_3.toArray( vertices, 1 * 3 );\n\t\t\t\t\t\t\ttempV2_3.toArray( vertices, 3 * 3 );\n\t\t\t\t\t\t\ttempV2_4.toArray( vertices, 0 * 3 );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\ttempV2_1.subVectors( p2, center );\n\t\t\t\t\t\ttempV2_2.set( tempV2_1.y, - tempV2_1.x );\n\n\t\t\t\t\t\ttempV2_3.addVectors( tempV2_1, tempV2_2 ).add( center );\n\t\t\t\t\t\ttempV2_4.subVectors( tempV2_2, tempV2_1 ).add( center );\n\n\t\t\t\t\t\tvar vl = vertices.length;\n\n\t\t\t\t\t\t// Modify already existing vertices\n\t\t\t\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\t\t\t\ttempV2_3.toArray( vertices, vl - 1 * 3 );\n\t\t\t\t\t\t\ttempV2_4.toArray( vertices, vl - 2 * 3 );\n\t\t\t\t\t\t\ttempV2_4.toArray( vertices, vl - 4 * 3 );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\ttempV2_3.toArray( vertices, vl - 2 * 3 );\n\t\t\t\t\t\t\ttempV2_4.toArray( vertices, vl - 1 * 3 );\n\t\t\t\t\t\t\ttempV2_4.toArray( vertices, vl - 4 * 3 );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'butt':\n\t\t\t\tdefault:\n\n\t\t\t\t\t// Nothing to do here\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction removeDuplicatedPoints( points ) {\n\n\t\t\t// Creates a new array if necessary with duplicated points removed.\n\t\t\t// This does not remove duplicated initial and ending points of a closed path.\n\n\t\t\tvar dupPoints = false;\n\t\t\tfor ( var i = 1, n = points.length - 1; i < n; i ++ ) {\n\n\t\t\t\tif ( points[ i ].distanceTo( points[ i + 1 ] ) < minDistance ) {\n\n\t\t\t\t\tdupPoints = true;\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( ! dupPoints ) return points;\n\n\t\t\tvar newPoints = [];\n\t\t\tnewPoints.push( points[ 0 ] );\n\n\t\t\tfor ( var i = 1, n = points.length - 1; i < n; i ++ ) {\n\n\t\t\t\tif ( points[ i ].distanceTo( points[ i + 1 ] ) >= minDistance ) {\n\n\t\t\t\t\tnewPoints.push( points[ i ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tnewPoints.push( points[ points.length - 1 ] );\n\n\t\t\treturn newPoints;\n\n\t\t}\n\n\t};\n\n}();\n\nexport { SVGLoader };\n"],"sourceRoot":""}