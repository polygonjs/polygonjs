{"version":3,"sources":["webpack://POLY/./modules/three/examples/jsm/loaders/PLYLoader.js"],"names":["PLYLoader","manager","call","this","propertyNameMapping","prototype","Object","assign","create","constructor","load","url","onLoad","onProgress","onError","scope","loader","setPath","path","setResponseType","text","parse","e","console","error","itemError","setPropertyNameMapping","mapping","data","parseHeader","headerText","headerLength","result","exec","length","currentElement","lineType","lineValues","propertValues","property","header","comments","elements","lines","split","i","line","trim","shift","join","format","version","push","undefined","name","count","parseInt","properties","type","countType","itemType","log","parseASCIINumber","n","parseFloat","parseASCIIElement","values","element","list","j","parseASCII","buffer","indices","vertices","normals","uvs","faceVertexUvs","colors","body","currentElementCount","handleElement","postProcess","geometry","setIndex","setAttribute","toNonIndexed","computeBoundingSphere","elementName","x","y","z","nx","ny","nz","s","t","red","green","blue","vertex_indices","vertex_index","texcoord","binaryRead","dataview","at","little_endian","getInt8","getUint8","getInt16","getUint16","getInt32","getUint32","getFloat32","getFloat64","binaryReadElement","read","ArrayBuffer","decodeText","Uint8Array","DataView","loc","parseBinary"],"mappings":"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","file":"9.bundle.js","sourcesContent":["import {BufferGeometry} from 'three/src/core/BufferGeometry';\nimport {FileLoader} from 'three/src/loaders/FileLoader';\nimport {Float32BufferAttribute} from 'three/src/core/BufferAttribute';\nimport {Loader} from 'three/src/loaders/Loader';\nimport {LoaderUtils} from 'three/src/loaders/LoaderUtils';\n/**\n * @author Wei Meng / http://about.me/menway\n *\n * Description: A THREE loader for PLY ASCII files (known as the Polygon\n * File Format or the Stanford Triangle Format).\n *\n * Limitations: ASCII decoding assumes file is UTF-8.\n *\n * Usage:\n *\tvar loader = new PLYLoader();\n *\tloader.load('./models/ply/ascii/dolphins.ply', function (geometry) {\n *\n *\t\tscene.add( new THREE.Mesh( geometry ) );\n *\n *\t} );\n *\n * If the PLY file uses non standard property names, they can be mapped while\n * loading. For example, the following maps the properties\n * “diffuse_(red|green|blue)” in the file to standard color names.\n *\n * loader.setPropertyNameMapping( {\n *\tdiffuse_red: 'red',\n *\tdiffuse_green: 'green',\n *\tdiffuse_blue: 'blue'\n * } );\n *\n */\n\n\n\nvar PLYLoader = function ( manager ) {\n\n\tLoader.call( this, manager );\n\n\tthis.propertyNameMapping = {};\n\n};\n\nPLYLoader.prototype = Object.assign( Object.create( Loader.prototype ), {\n\n\tconstructor: PLYLoader,\n\n\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\tvar scope = this;\n\n\t\tvar loader = new FileLoader( this.manager );\n\t\tloader.setPath( this.path );\n\t\tloader.setResponseType( 'arraybuffer' );\n\t\tloader.load( url, function ( text ) {\n\n\t\t\ttry {\n\n\t\t\t\tonLoad( scope.parse( text ) );\n\n\t\t\t} catch ( e ) {\n\n\t\t\t\tif ( onError ) {\n\n\t\t\t\t\tonError( e );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.error( e );\n\n\t\t\t\t}\n\n\t\t\t\tscope.manager.itemError( url );\n\n\t\t\t}\n\n\t\t}, onProgress, onError );\n\n\t},\n\n\tsetPropertyNameMapping: function ( mapping ) {\n\n\t\tthis.propertyNameMapping = mapping;\n\n\t},\n\n\tparse: function ( data ) {\n\n\t\tfunction parseHeader( data ) {\n\n\t\t\tvar patternHeader = /ply([\\s\\S]*)end_header\\r?\\n/;\n\t\t\tvar headerText = '';\n\t\t\tvar headerLength = 0;\n\t\t\tvar result = patternHeader.exec( data );\n\n\t\t\tif ( result !== null ) {\n\n\t\t\t\theaderText = result[ 1 ];\n\t\t\t\theaderLength = result[ 0 ].length;\n\n\t\t\t}\n\n\t\t\tvar header = {\n\t\t\t\tcomments: [],\n\t\t\t\telements: [],\n\t\t\t\theaderLength: headerLength\n\t\t\t};\n\n\t\t\tvar lines = headerText.split( '\\n' );\n\t\t\tvar currentElement;\n\t\t\tvar lineType, lineValues;\n\n\t\t\tfunction make_ply_element_property( propertValues, propertyNameMapping ) {\n\n\t\t\t\tvar property = { type: propertValues[ 0 ] };\n\n\t\t\t\tif ( property.type === 'list' ) {\n\n\t\t\t\t\tproperty.name = propertValues[ 3 ];\n\t\t\t\t\tproperty.countType = propertValues[ 1 ];\n\t\t\t\t\tproperty.itemType = propertValues[ 2 ];\n\n\t\t\t\t} else {\n\n\t\t\t\t\tproperty.name = propertValues[ 1 ];\n\n\t\t\t\t}\n\n\t\t\t\tif ( property.name in propertyNameMapping ) {\n\n\t\t\t\t\tproperty.name = propertyNameMapping[ property.name ];\n\n\t\t\t\t}\n\n\t\t\t\treturn property;\n\n\t\t\t}\n\n\t\t\tfor ( var i = 0; i < lines.length; i ++ ) {\n\n\t\t\t\tvar line = lines[ i ];\n\t\t\t\tline = line.trim();\n\n\t\t\t\tif ( line === '' ) continue;\n\n\t\t\t\tlineValues = line.split( /\\s+/ );\n\t\t\t\tlineType = lineValues.shift();\n\t\t\t\tline = lineValues.join( ' ' );\n\n\t\t\t\tswitch ( lineType ) {\n\n\t\t\t\t\tcase 'format':\n\n\t\t\t\t\t\theader.format = lineValues[ 0 ];\n\t\t\t\t\t\theader.version = lineValues[ 1 ];\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'comment':\n\n\t\t\t\t\t\theader.comments.push( line );\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'element':\n\n\t\t\t\t\t\tif ( currentElement !== undefined ) {\n\n\t\t\t\t\t\t\theader.elements.push( currentElement );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcurrentElement = {};\n\t\t\t\t\t\tcurrentElement.name = lineValues[ 0 ];\n\t\t\t\t\t\tcurrentElement.count = parseInt( lineValues[ 1 ] );\n\t\t\t\t\t\tcurrentElement.properties = [];\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'property':\n\n\t\t\t\t\t\tcurrentElement.properties.push( make_ply_element_property( lineValues, scope.propertyNameMapping ) );\n\n\t\t\t\t\t\tbreak;\n\n\n\t\t\t\t\tdefault:\n\n\t\t\t\t\t\tconsole.log( 'unhandled', lineType, lineValues );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( currentElement !== undefined ) {\n\n\t\t\t\theader.elements.push( currentElement );\n\n\t\t\t}\n\n\t\t\treturn header;\n\n\t\t}\n\n\t\tfunction parseASCIINumber( n, type ) {\n\n\t\t\tswitch ( type ) {\n\n\t\t\t\tcase 'char': case 'uchar': case 'short': case 'ushort': case 'int': case 'uint':\n\t\t\t\tcase 'int8': case 'uint8': case 'int16': case 'uint16': case 'int32': case 'uint32':\n\n\t\t\t\t\treturn parseInt( n );\n\n\t\t\t\tcase 'float': case 'double': case 'float32': case 'float64':\n\n\t\t\t\t\treturn parseFloat( n );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction parseASCIIElement( properties, line ) {\n\n\t\t\tvar values = line.split( /\\s+/ );\n\n\t\t\tvar element = {};\n\n\t\t\tfor ( var i = 0; i < properties.length; i ++ ) {\n\n\t\t\t\tif ( properties[ i ].type === 'list' ) {\n\n\t\t\t\t\tvar list = [];\n\t\t\t\t\tvar n = parseASCIINumber( values.shift(), properties[ i ].countType );\n\n\t\t\t\t\tfor ( var j = 0; j < n; j ++ ) {\n\n\t\t\t\t\t\tlist.push( parseASCIINumber( values.shift(), properties[ i ].itemType ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t\telement[ properties[ i ].name ] = list;\n\n\t\t\t\t} else {\n\n\t\t\t\t\telement[ properties[ i ].name ] = parseASCIINumber( values.shift(), properties[ i ].type );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn element;\n\n\t\t}\n\n\t\tfunction parseASCII( data, header ) {\n\n\t\t\t// PLY ascii format specification, as per http://en.wikipedia.org/wiki/PLY_(file_format)\n\n\t\t\tvar buffer = {\n\t\t\t\tindices: [],\n\t\t\t\tvertices: [],\n\t\t\t\tnormals: [],\n\t\t\t\tuvs: [],\n\t\t\t\tfaceVertexUvs: [],\n\t\t\t\tcolors: []\n\t\t\t};\n\n\t\t\tvar result;\n\n\t\t\tvar patternBody = /end_header\\s([\\s\\S]*)$/;\n\t\t\tvar body = '';\n\t\t\tif ( ( result = patternBody.exec( data ) ) !== null ) {\n\n\t\t\t\tbody = result[ 1 ];\n\n\t\t\t}\n\n\t\t\tvar lines = body.split( '\\n' );\n\t\t\tvar currentElement = 0;\n\t\t\tvar currentElementCount = 0;\n\n\t\t\tfor ( var i = 0; i < lines.length; i ++ ) {\n\n\t\t\t\tvar line = lines[ i ];\n\t\t\t\tline = line.trim();\n\t\t\t\tif ( line === '' ) {\n\n\t\t\t\t\tcontinue;\n\n\t\t\t\t}\n\n\t\t\t\tif ( currentElementCount >= header.elements[ currentElement ].count ) {\n\n\t\t\t\t\tcurrentElement ++;\n\t\t\t\t\tcurrentElementCount = 0;\n\n\t\t\t\t}\n\n\t\t\t\tvar element = parseASCIIElement( header.elements[ currentElement ].properties, line );\n\n\t\t\t\thandleElement( buffer, header.elements[ currentElement ].name, element );\n\n\t\t\t\tcurrentElementCount ++;\n\n\t\t\t}\n\n\t\t\treturn postProcess( buffer );\n\n\t\t}\n\n\t\tfunction postProcess( buffer ) {\n\n\t\t\tvar geometry = new BufferGeometry();\n\n\t\t\t// mandatory buffer data\n\n\t\t\tif ( buffer.indices.length > 0 ) {\n\n\t\t\t\tgeometry.setIndex( buffer.indices );\n\n\t\t\t}\n\n\t\t\tgeometry.setAttribute( 'position', new Float32BufferAttribute( buffer.vertices, 3 ) );\n\n\t\t\t// optional buffer data\n\n\t\t\tif ( buffer.normals.length > 0 ) {\n\n\t\t\t\tgeometry.setAttribute( 'normal', new Float32BufferAttribute( buffer.normals, 3 ) );\n\n\t\t\t}\n\n\t\t\tif ( buffer.uvs.length > 0 ) {\n\n\t\t\t\tgeometry.setAttribute( 'uv', new Float32BufferAttribute( buffer.uvs, 2 ) );\n\n\t\t\t}\n\n\t\t\tif ( buffer.colors.length > 0 ) {\n\n\t\t\t\tgeometry.setAttribute( 'color', new Float32BufferAttribute( buffer.colors, 3 ) );\n\n\t\t\t}\n\n\t\t\tif ( buffer.faceVertexUvs.length > 0 ) {\n\n\t\t\t\tgeometry = geometry.toNonIndexed();\n\t\t\t\tgeometry.setAttribute( 'uv', new Float32BufferAttribute( buffer.faceVertexUvs, 2 ) );\n\n\t\t\t}\n\n\t\t\tgeometry.computeBoundingSphere();\n\n\t\t\treturn geometry;\n\n\t\t}\n\n\t\tfunction handleElement( buffer, elementName, element ) {\n\n\t\t\tif ( elementName === 'vertex' ) {\n\n\t\t\t\tbuffer.vertices.push( element.x, element.y, element.z );\n\n\t\t\t\tif ( 'nx' in element && 'ny' in element && 'nz' in element ) {\n\n\t\t\t\t\tbuffer.normals.push( element.nx, element.ny, element.nz );\n\n\t\t\t\t}\n\n\t\t\t\tif ( 's' in element && 't' in element ) {\n\n\t\t\t\t\tbuffer.uvs.push( element.s, element.t );\n\n\t\t\t\t}\n\n\t\t\t\tif ( 'red' in element && 'green' in element && 'blue' in element ) {\n\n\t\t\t\t\tbuffer.colors.push( element.red / 255.0, element.green / 255.0, element.blue / 255.0 );\n\n\t\t\t\t}\n\n\t\t\t} else if ( elementName === 'face' ) {\n\n\t\t\t\tvar vertex_indices = element.vertex_indices || element.vertex_index; // issue #9338\n\t\t\t\tvar texcoord = element.texcoord;\n\n\t\t\t\tif ( vertex_indices.length === 3 ) {\n\n\t\t\t\t\tbuffer.indices.push( vertex_indices[ 0 ], vertex_indices[ 1 ], vertex_indices[ 2 ] );\n\n\t\t\t\t\tif ( texcoord && texcoord.length === 6 ) {\n\n\t\t\t\t\t\tbuffer.faceVertexUvs.push( texcoord[ 0 ], texcoord[ 1 ] );\n\t\t\t\t\t\tbuffer.faceVertexUvs.push( texcoord[ 2 ], texcoord[ 3 ] );\n\t\t\t\t\t\tbuffer.faceVertexUvs.push( texcoord[ 4 ], texcoord[ 5 ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( vertex_indices.length === 4 ) {\n\n\t\t\t\t\tbuffer.indices.push( vertex_indices[ 0 ], vertex_indices[ 1 ], vertex_indices[ 3 ] );\n\t\t\t\t\tbuffer.indices.push( vertex_indices[ 1 ], vertex_indices[ 2 ], vertex_indices[ 3 ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction binaryRead( dataview, at, type, little_endian ) {\n\n\t\t\tswitch ( type ) {\n\n\t\t\t\t// corespondences for non-specific length types here match rply:\n\t\t\t\tcase 'int8':\t\tcase 'char':\t return [ dataview.getInt8( at ), 1 ];\n\t\t\t\tcase 'uint8':\t\tcase 'uchar':\t return [ dataview.getUint8( at ), 1 ];\n\t\t\t\tcase 'int16':\t\tcase 'short':\t return [ dataview.getInt16( at, little_endian ), 2 ];\n\t\t\t\tcase 'uint16':\tcase 'ushort': return [ dataview.getUint16( at, little_endian ), 2 ];\n\t\t\t\tcase 'int32':\t\tcase 'int':\t\t return [ dataview.getInt32( at, little_endian ), 4 ];\n\t\t\t\tcase 'uint32':\tcase 'uint':\t return [ dataview.getUint32( at, little_endian ), 4 ];\n\t\t\t\tcase 'float32': case 'float':\t return [ dataview.getFloat32( at, little_endian ), 4 ];\n\t\t\t\tcase 'float64': case 'double': return [ dataview.getFloat64( at, little_endian ), 8 ];\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction binaryReadElement( dataview, at, properties, little_endian ) {\n\n\t\t\tvar element = {};\n\t\t\tvar result, read = 0;\n\n\t\t\tfor ( var i = 0; i < properties.length; i ++ ) {\n\n\t\t\t\tif ( properties[ i ].type === 'list' ) {\n\n\t\t\t\t\tvar list = [];\n\n\t\t\t\t\tresult = binaryRead( dataview, at + read, properties[ i ].countType, little_endian );\n\t\t\t\t\tvar n = result[ 0 ];\n\t\t\t\t\tread += result[ 1 ];\n\n\t\t\t\t\tfor ( var j = 0; j < n; j ++ ) {\n\n\t\t\t\t\t\tresult = binaryRead( dataview, at + read, properties[ i ].itemType, little_endian );\n\t\t\t\t\t\tlist.push( result[ 0 ] );\n\t\t\t\t\t\tread += result[ 1 ];\n\n\t\t\t\t\t}\n\n\t\t\t\t\telement[ properties[ i ].name ] = list;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tresult = binaryRead( dataview, at + read, properties[ i ].type, little_endian );\n\t\t\t\t\telement[ properties[ i ].name ] = result[ 0 ];\n\t\t\t\t\tread += result[ 1 ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn [ element, read ];\n\n\t\t}\n\n\t\tfunction parseBinary( data, header ) {\n\n\t\t\tvar buffer = {\n\t\t\t\tindices: [],\n\t\t\t\tvertices: [],\n\t\t\t\tnormals: [],\n\t\t\t\tuvs: [],\n\t\t\t\tfaceVertexUvs: [],\n\t\t\t\tcolors: []\n\t\t\t};\n\n\t\t\tvar little_endian = ( header.format === 'binary_little_endian' );\n\t\t\tvar body = new DataView( data, header.headerLength );\n\t\t\tvar result, loc = 0;\n\n\t\t\tfor ( var currentElement = 0; currentElement < header.elements.length; currentElement ++ ) {\n\n\t\t\t\tfor ( var currentElementCount = 0; currentElementCount < header.elements[ currentElement ].count; currentElementCount ++ ) {\n\n\t\t\t\t\tresult = binaryReadElement( body, loc, header.elements[ currentElement ].properties, little_endian );\n\t\t\t\t\tloc += result[ 1 ];\n\t\t\t\t\tvar element = result[ 0 ];\n\n\t\t\t\t\thandleElement( buffer, header.elements[ currentElement ].name, element );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn postProcess( buffer );\n\n\t\t}\n\n\t\t//\n\n\t\tvar geometry;\n\t\tvar scope = this;\n\n\t\tif ( data instanceof ArrayBuffer ) {\n\n\t\t\tvar text = LoaderUtils.decodeText( new Uint8Array( data ) );\n\t\t\tvar header = parseHeader( text );\n\n\t\t\tgeometry = header.format === 'ascii' ? parseASCII( text, header ) : parseBinary( data, header );\n\n\t\t} else {\n\n\t\t\tgeometry = parseASCII( data, parseHeader( data ) );\n\n\t\t}\n\n\t\treturn geometry;\n\n\t}\n\n} );\n\nexport { PLYLoader };\n"],"sourceRoot":""}